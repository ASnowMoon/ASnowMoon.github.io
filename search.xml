<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux I/O调优</title>
      <link href="/2024/10/19/Linux_IO%E8%B0%83%E4%BC%98/"/>
      <url>/2024/10/19/Linux_IO%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="应用层I-O操作"><a href="#应用层I-O操作" class="headerlink" title="应用层I/O操作"></a>应用层I/O操作</h2><p>是否利用标准库缓存</p><h3 id="非缓冲I-O"><a href="#非缓冲I-O" class="headerlink" title="非缓冲I/O"></a>非缓冲I/O</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;0123456789\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd, ret;</span><br><span class="line">    fd = open(<span class="string">&quot;./test.txt&quot;</span>, O_RDWR|O_CREAT|O_APPEND);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">       perror(<span class="string">&quot;ret&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># build</span></span><br><span class="line">gcc -o file file.c</span><br></pre></td></tr></table></figure><p>系统调用提供，如：open, read, write, close等</p><h3 id="缓冲I-O"><a href="#缓冲I-O" class="headerlink" title="缓冲I/O"></a>缓冲I/O</h3><p>c语言标准输入输出库提供，如：fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs等</p><p><strong>是否利用内核里的页缓存</strong><br>open(2) O_DIRECT</p><ul><li>直接I/O</li></ul><p>跳过操作系统的文件缓存，直接跟文件系统交互来访问文件</p><ul><li>接I/O</li></ul><p>需要经过操作系统的文件缓存</p><p><strong>阻塞自身运行</strong><br>open(2) O_NONBLOCK</p><ul><li><p>阻塞I/O</p></li><li><p>非阻塞I/O</p></li></ul><p><strong> 连续IO和随机IO</strong></p><ul><li>连续IO</li></ul><p>read-&gt;read-&gt;read<br>write-&gt;write-&gt;write</p><ul><li>随机IO</li></ul><p>lseek-&gt;read<br>lseek-&gt;write</p><h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>文件缓存</p><p>inode缓存</p><p>dentry缓存</p><p>I/O内核架构</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/Storage%20Stack.webp" alt="Storage Stack"></p><h3 id="通用块设备层"><a href="#通用块设备层" class="headerlink" title="通用块设备层"></a>通用块设备层</h3><p>通用块设备层，包括块设备 I/O 队列和 I/O 调度器。它会对文件系统的 I/O 请求进行排队，再通过重新排序和请求合并，然后才要发送给下一级的设备层。</p><p><strong>I/O队列</strong></p><p>对文件系统的 I/O 请求进行排队，再通过【重新排序】和【请求合并】，然后把请求发送到块设备驱动层。</p><p><strong>调度</strong> </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. I/O调度指对I/O请求进行排序的过程。Linux 内核支持四种 I/O 调度算法，分别是 NONE、NOOP、CFQ 以及 DeadLine。</span><br><span class="line"></span><br><span class="line">2. 查看和修改某个块设备的IO调度器：</span><br><span class="line">$ cat /sys/block/sda/queue/scheduler </span><br><span class="line">noop deadline [cfq] </span><br><span class="line"></span><br><span class="line">NONE</span><br><span class="line">完全不使用任何 I/O 调度器，常用在虚拟机中。</span><br><span class="line"></span><br><span class="line">NOOP（电梯式调度程序）</span><br><span class="line">它实际上是一个先入先出的队列，只做一些最基本的请求合并（类似电梯算法），常用于闪存、SSD等存储。 NOOP倾向饿死读而利于写！</span><br><span class="line"></span><br><span class="line">CFQ（完全公平排队I/O调度器）</span><br><span class="line">CFQ是现在很多发行版的默认 I/O 调度器，它为【每个进程】维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求。 类似于进程 CPU 调度，CFQ 还支持进程 I/O 的优先级调度。 CFQ试图均匀地分布对I/O带宽的访问,避免进程被饿死并实现较低的延迟。</span><br><span class="line"></span><br><span class="line">DeadLine（截止时间调度程序）</span><br><span class="line">DeadLine 调度算法，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量。DeadLine 调度算法，多用在 I/O 压力比较重的场景，比如数据库等。</span><br></pre></td></tr></table></figure><h3 id="块设备驱动层"><a href="#块设备驱动层" class="headerlink" title="块设备驱动层"></a>块设备驱动层</h3><p>负责最终物理设备的I/O操作</p><p>HDD</p><p><a href="https://blog.csdn.net/qyxls/article/details/117322123">/blog.csdn.net/qyxls/article/details/117322123</a></p><p>寻道时间</p><p>旋转时间</p><p>数据传输时间</p><p>SSD</p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p><strong>磁盘用量、剩余等</strong></p><p>相关工具</p><p>df -h</p><p><strong>inode节点用量、剩余等</strong></p><p>inode节点空间不足，但是磁盘空间充足，可能是过多小文件造成的！</p><p>相关工具</p><p>df -i</p><p>测试： # mount -t tmpfs -o size=1G tmpfs /tftpboot/minio</p><p><strong>使用率：磁盘处理I/O的时间占比</strong></p><p>相关工具</p><p>iostat -d -x -p sda（%util）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">【指标解释】</span><br><span class="line">r/s:设备每秒完成的读请求数(合并后)；</span><br><span class="line">w/s:设备每秒完成的写请求数(合并后)；</span><br><span class="line">rkB/s:每秒从磁盘读取的数据量；</span><br><span class="line">wkB/s:每秒向磁盘写入的数据量；</span><br><span class="line">rrqm/s:每秒排队到设备上的合并的读请求数；</span><br><span class="line">wrqm/s:每秒排队到设备上的合并的写请求数；</span><br><span class="line">r_await:读请求处理完成等待时间，包括队列中等待时间和设备实际处理所花的时间，单位是毫秒</span><br><span class="line">w_await:写请求处理完成等待时间，包括队列中等待时间和设备实际处理所花的时间，单位是毫秒</span><br><span class="line">aqu-sz:平均请求队列长度</span><br><span class="line">rareq-sz:读请求的平均数据量大小（单位是KB）</span><br><span class="line">wareq-sz：写请求的平均数据量大小（单位是KB）</span><br><span class="line">svctm：处理I/O请求所需的平均时间（单位是毫秒），该指标不准，后续会移除。</span><br><span class="line">%util：磁盘处理I/O的时间百分比</span><br><span class="line"></span><br><span class="line">【几个重要的指标】</span><br><span class="line">磁盘 I/O 使用率 --&gt; %util</span><br><span class="line">每秒I/O读请求数 --&gt; r/s</span><br><span class="line">每秒I/O写请求数　--&gt; w/s </span><br><span class="line">每秒I/O读请求大小　--&gt; rkB/s</span><br><span class="line">每秒I/O写请求大小　--&gt; wkB/s</span><br><span class="line">读响应时间 --&gt; r_await</span><br><span class="line">写响应时间 --&gt; w_await</span><br></pre></td></tr></table></figure><ul><li>局限</li></ul><p>对于RAID和SSD，该指标不能反映其真实性能</p><p><strong>每秒的I/O请求数（读、写）</strong></p><p>iostat -d -x -p sda （r/s, w/s）</p><p>dstat -r </p><p><strong>每秒的I/O请求大小（读、写）</strong></p><p>iostat -d -x -p sda（rkB/s, wkB/s）</p><p>dstat -d</p><p><strong>响应时间：I/O 请求从发出到收到响应的间隔时间（读、写）</strong></p><p>相关工具</p><p>iostat -d -x -p sda（r_await，w_await）</p><p><strong>进程I/O大小或者I/O延迟</strong></p><p>相关工具</p><p>pidstat -d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kB_rd/s：该进程每秒从磁盘读取的数据大小</span><br><span class="line"></span><br><span class="line">kB_wr/s：该进程每秒写入磁盘的数据大小</span><br><span class="line"></span><br><span class="line">kB_ccwr/s：每秒取消的写请求数据大小，当任务截断一些脏页缓存时可能会发生这种情况</span><br><span class="line"></span><br><span class="line">iodelay：块 I/O 延迟，包括等待同步块 I/O 完成时间和换入块 I/O 的时间，单位是时钟周期。</span><br></pre></td></tr></table></figure><p>iotop<br>IO：进程在等待I/O上花费的时间占比(%)；</p><p>biotop<br>AVGms：进程平均I/O时间，单位是ms</p><p><strong>进程每次IO操作的IO延迟</strong></p><p>相关工具</p><p>biosnoop-bpfcc -Q<br>LAT(ms)：磁盘I/O的延迟，包括请求提交给设备到请求完成的时间</p><p>实践</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">１、file.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    char *p = &quot;123456789\n&quot;;</span><br><span class="line">    char file[128];</span><br><span class="line">    sprintf(file, &quot;test-%d.log&quot;, pid);</span><br><span class="line">    int fd, ret;</span><br><span class="line">    fd = open(file, O_RDWR|O_CREAT|O_APPEND);</span><br><span class="line">    if(fd == -1) &#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = write(fd, p, strlen(p));</span><br><span class="line">    if(ret == -1) &#123;</span><br><span class="line">       perror(&quot;ret&quot;);</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    sleep(1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">２、test.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    ./file</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h3><p>相关工具</p><p>查看整体：<br>cat /proc/meminfo | grep “^Cached”</p><p>单个文件：<br>pcstat /tftpboot/test</p><p>释放文件缓存：<br>echo 1 &gt; /proc/sys/vm/drop_caches</p><h3 id="dentry和inode缓存"><a href="#dentry和inode缓存" class="headerlink" title="dentry和inode缓存"></a>dentry和inode缓存</h3><p><strong>dentry缓存</strong><br>（dcache）</p><p>相关工具</p><p>cat /proc/slabinfo | grep -E ‘^#|dentry’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name：slab object对象的名称</span><br><span class="line">active_objs：被申请走（正在被使用）的对象个数。</span><br><span class="line">num_objs：总对象（slab object）个数。</span><br><span class="line">objsize：每个对象（slab object）大小，以字节为单位。</span><br><span class="line">objperslab：表示一个slab中包含多少个对象（slab object）。</span><br><span class="line">pagesperslab : 一个slab占用几个page内存页。</span><br><span class="line">active_slabs：活动slab个数。</span><br><span class="line">num_slabs：总slab个数。</span><br></pre></td></tr></table></figure><p><strong>inode缓存</strong><br>（icache）</p><p>相关工具</p><p>cat /proc/slabinfo | grep -E ‘^#|inode’</p><p>释放：echo 2 &gt; /proc/sys/vm/drop_caches<br>前后对比查看：cat /proc/meminfo | grep SReclaimable</p><h1 id="工具汇总"><a href="#工具汇总" class="headerlink" title="工具汇总"></a>工具汇总</h1><h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h2><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c：显示cpu指标</span><br><span class="line">-d：显示磁盘使用情况</span><br><span class="line">-k: 以KB为单位显示</span><br><span class="line">-m：以MB为单位显示</span><br><span class="line">-x：显示详细信息</span><br><span class="line">-p：显示某个磁盘或者分区的使用情况</span><br></pre></td></tr></table></figure><h2 id="dstat"><a href="#dstat" class="headerlink" title="dstat"></a>dstat</h2><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-m: 显示内存使用情况</span><br><span class="line">-c：显示cpu使用情况</span><br><span class="line">-n: 显示网络状况</span><br><span class="line">-l：显示系统负载情况</span><br><span class="line">-r：显示I/O请求读写请求数</span><br><span class="line">-d: 磁盘读写情况</span><br><span class="line">-y：显示中断和上下文切换次数等</span><br><span class="line">--socket：显示套接字(tcp,udp等)的个数</span><br><span class="line">--top-io: 显示消耗I/O最大的进程</span><br><span class="line">--top-cpu: 显示消耗cpu最大的进程</span><br><span class="line">--top-cputime: 显示使用cpu时间最大的进程(ms)</span><br><span class="line">--top-latency:  显示总延迟最大的进程(ms)</span><br><span class="line">--top-mem: 显示使用内存最大的进程</span><br></pre></td></tr></table></figure><h2 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h2><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-d：统计进程的I/O大小及I/O延迟</span><br></pre></td></tr></table></figure><h2 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写大小总数。</span><br><span class="line"></span><br><span class="line">- TID/PID：线程ID/进程ID；</span><br><span class="line">- PRIO：I/O 优先级；</span><br><span class="line">- USER：用户名；</span><br><span class="line">- DISK READ：每秒读磁盘的大小；</span><br><span class="line">- DISK WRITE：每秒写磁盘的大小；</span><br><span class="line">- SWAPIN：进程在SWAPIN上花费的时间占比；</span><br><span class="line">- IO：进程在等待I/O上花费的时间占比；</span><br></pre></td></tr></table></figure><p>用法</p><p>不加任何参数显示所有【线程】的I/O使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写大小总数。</span><br><span class="line"></span><br><span class="line">- TID/PID：线程ID/进程ID；</span><br><span class="line">- PRIO：I/O 优先级；</span><br><span class="line">- USER：用户名；</span><br><span class="line">- DISK READ：每秒读磁盘的大小；</span><br><span class="line">- DISK WRITE：每秒写磁盘的大小；</span><br><span class="line">- SWAPIN：进程在SWAPIN上花费的时间占比；</span><br><span class="line">- IO：进程在等待I/O上花费的时间占比；</span><br></pre></td></tr></table></figure><h2 id="ionice"><a href="#ionice" class="headerlink" title="ionice"></a>ionice</h2><p>用法</p><p>ionice对进程的IO调度class and priority 的设置只有当调度算法是CFQ时才是有效的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c &#123;class&#125; ：指定调度策略</span><br><span class="line">&#123;class&#125;表示调度策略，其中0 for none, 1 for real time, 2 for best-effort, 3 for idle</span><br><span class="line">-n &#123;classdata&#125;：指定IO优先级别</span><br><span class="line">classdata表示IO优先级级别，对于best effort和real time，classdata可以设置为0~7，0的优先级最高</span><br><span class="line">-p &#123;pid&#125;：指定要查看或设置的进程号或者线程号</span><br></pre></td></tr></table></figure><h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><p>用法</p><p>追踪进程的I/O系统调用</p><h2 id="filetop"><a href="#filetop" class="headerlink" title="filetop"></a>filetop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filetop实时追踪文件的读写情况。</span><br><span class="line">TID：线程ID</span><br><span class="line">COMM：线程命令行</span><br><span class="line">READS：读取次数</span><br><span class="line">WRITES：写入次数</span><br><span class="line">R_Kb：读取字节数</span><br><span class="line"></span><br><span class="line">W_Kb：写入字节数</span><br><span class="line">T：文件类型</span><br><span class="line">FILE：文件名称</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-a：包含非常规文件，例如：sockets, FIFOs等</span><br><span class="line">-C：不清屏</span><br><span class="line">-r: 最多打印多少行，默认为20</span><br><span class="line">-s &#123;all,reads,writes,rbytes,wbytes&#125;：按指标排序，默认为rbytes</span><br><span class="line">-p &#123;pid&#125;：只追踪&#123;pid&#125;这个进程的文件读写情况</span><br><span class="line">每隔５秒打印一次，共打印１０次</span><br><span class="line">filetop 5 10</span><br></pre></td></tr></table></figure><h2 id="biotop"><a href="#biotop" class="headerlink" title="biotop"></a>biotop</h2><p><a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu---binary">github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu—-binary</a></p><p>用法</p><p><a href="https://github.com/iovisor/bcc/blob/master/tools/biotop_example.txt">github.com/iovisor/bcc/blob/master/tools/biotop_example.txt</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I/O：读或者写的I/O次数</span><br><span class="line"></span><br><span class="line">Kbytes：读或者写的字节数</span><br><span class="line"></span><br><span class="line">AVGms：平均I/O时间，单位是ms （统计的是当前时间周期的数据）</span><br><span class="line"></span><br><span class="line">追踪进程I/O并按I/O吞吐量大小排序，默认每１秒统计一次</span><br><span class="line">-C：不清屏</span><br><span class="line">设置为每5秒打印一次，共打印10次：</span><br><span class="line">biotop 5 10</span><br></pre></td></tr></table></figure><h2 id="biosnoop"><a href="#biosnoop" class="headerlink" title="biosnoop"></a>biosnoop</h2><p>用法</p><p><a href="https://github.com/iovisor/bcc/blob/master/tools/biosnoop_example.txt">github.com/iovisor/bcc/blob/master/tools/biosnoop_example.txt</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LAT(ms)：磁盘I/O的延迟，包括请求提交给设备到请求完成的时间统计。</span><br><span class="line">追踪并打印进程访问I/O时的内核事件</span><br><span class="line">-Q：include OS queued time</span><br><span class="line">-d &#123;DISK&#125;：Trace this disk only</span><br></pre></td></tr></table></figure><h2 id="biolatency"><a href="#biolatency" class="headerlink" title="biolatency"></a>biolatency</h2><p>用法</p><p><a href="https://github.com/iovisor/bcc/blob/master/tools/biolatency_example.txt">github.com/iovisor/bcc/blob/master/tools/biolatency_example.txt</a></p><p>直方图的方式统计系统IO延迟（单位：us）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">直方图的方式统计系统IO延迟（单位：us）</span><br><span class="line">-T: 在输出里包含时间戳</span><br><span class="line">-Q: include OS queued time in I/O time</span><br><span class="line">-m: 按照ms统计系统IO延迟</span><br><span class="line">-D: 分开打印各个磁盘的直方图</span><br><span class="line">输出带时间戳，每秒输出一次，共输出５次：</span><br><span class="line">biolatency -T 1 5</span><br></pre></td></tr></table></figure><h2 id="blktrace"><a href="#blktrace" class="headerlink" title="blktrace"></a>blktrace</h2><p>用法</p><p><a href="https://www.cnblogs.com/codelogs/p/16060775.html">www.cnblogs.com/codelogs/p/16060775.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">第一个字段：主、次设备号;</span><br><span class="line">第二个字段：cpu号;</span><br><span class="line">第三个字段：序列号;</span><br><span class="line">第四个字段：时间戳;</span><br><span class="line">第五个字段：本次I/O对应的进程 ID;</span><br><span class="line">第六个字段：Event，这个字段非常重要，反映了 I/O 进行到了哪一步;</span><br><span class="line">第七个字段：R 表示 Read， W 是 Write，S表示sync;</span><br><span class="line">第八个字段：223490+56，表示的是起始 block number 和 number of blocks，即我们常说的Offset 和 Size;</span><br><span class="line">第九个字段：进程名字;</span><br><span class="line"></span><br><span class="line">第六个字段Event:</span><br><span class="line">A:IO被重新映射到不同的设备；</span><br><span class="line">Q:将要被 request 代码处理（即将生成 I/O 请求）；</span><br><span class="line">G: I/O 请求（request）生成，为 I/O 分配一个 request 结构体；</span><br><span class="line">P:插入I/O请求</span><br><span class="line">U:准备向磁盘驱动发送该 I/O</span><br><span class="line">D:IO发给driver去处理</span><br><span class="line">C:IO处理完毕</span><br><span class="line"></span><br><span class="line">采集：</span><br><span class="line">blktrace -d /dev/vda1</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">blkparse -i vda1</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">blktrace -d /dev/vda1 -o - | blkparse -i -</span><br></pre></td></tr></table></figure><p>fio</p><p>IO性能基准测试</p><h1 id="调优实践"><a href="#调优实践" class="headerlink" title="调优实践"></a>调优实践</h1><h2 id="实践一、linux应用遇到I-O性能问题，如何一步一步进行调试？"><a href="#实践一、linux应用遇到I-O性能问题，如何一步一步进行调试？" class="headerlink" title="实践一、linux应用遇到I/O性能问题，如何一步一步进行调试？"></a>实践一、linux应用遇到I/O性能问题，如何一步一步进行调试？</h2><p>分析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查看系统总体I/O使用情况：</span><br><span class="line">iostat -d -x -p sda 1</span><br><span class="line">top验证</span><br><span class="line">查看所有进程的I/O使用情况，找到可疑的进程：</span><br><span class="line">pidstat -d 1</span><br><span class="line">追踪可疑进程（子进程）的系统调用情况：</span><br><span class="line">strace -f -p &#123;pid&#125;</span><br><span class="line">show出可疑进程的子进程树：</span><br><span class="line">pstree &#123;pid&#125;</span><br></pre></td></tr></table></figure><p>环境搭建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">１、file.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfd\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> file[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;test-%d.log&quot;</span>, pid);</span><br><span class="line">    <span class="type">int</span> fd, ret;</span><br><span class="line">    fd = open(file, O_RDWR|O_CREAT|O_APPEND);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">       perror(<span class="string">&quot;ret&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc -o file file.c</span><br><span class="line"></span><br><span class="line">２、exfile</span><br><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ./file</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="实践二、如何针对linux应用程序的I-O访问行为，具体分析每一步的时间开销？"><a href="#实践二、如何针对linux应用程序的I-O访问行为，具体分析每一步的时间开销？" class="headerlink" title="实践二、如何针对linux应用程序的I/O访问行为，具体分析每一步的时间开销？"></a>实践二、如何针对linux应用程序的I/O访问行为，具体分析每一步的时间开销？</h2><p>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1、file.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    char *p = &quot;0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfd\n&quot;;</span><br><span class="line">    char file[128];</span><br><span class="line">    sprintf(file, &quot;test-%d.log&quot;, pid);</span><br><span class="line">    int fd, ret;</span><br><span class="line">    fd = open(file, O_RDWR|O_CREAT|O_APPEND);</span><br><span class="line">    if(fd == -1) &#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = write(fd, p, strlen(p));</span><br><span class="line">    if(ret == -1) &#123;</span><br><span class="line">       perror(&quot;ret&quot;);</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    ret = write(fd, p, strlen(p));</span><br><span class="line">    if(ret == -1) &#123;</span><br><span class="line">       perror(&quot;ret&quot;);</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、exfile</span><br><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    ./file</span><br><span class="line">    sleep 1</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>分析过程</strong></p><p>查看进程实时读写情况：<br>biosnoop</p><p>blktrace -d /dev/vda1 -o - | blkparse -i -</p><p>Q-&gt;G：生成 I/O 请求所消耗的时间； G-&gt;P：I/O 请求进入 I/O Scheduler 所消耗的时间； P-&gt;D: I/O 请求在 I/O Scheduler 中等待的时间； D-&gt;C：I/O 请求在 Driver 和硬件上所消耗的时间，可以作为硬件性能的指标； Q-&gt;C：整个 I/O 请求所消耗的时间(Q-&gt;G + G-&gt;P + P-&gt;D + D-&gt;C = Q2C)，相当于 iostat 的 await。</p><p>io操作时间戳</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/62dc972cf346fb4e907818ea" alt="img"></p><h2 id="实践三、rm-删掉的文件还能找回来吗？能，不过得分情况！"><a href="#实践三、rm-删掉的文件还能找回来吗？能，不过得分情况！" class="headerlink" title="实践三、rm 删掉的文件还能找回来吗？能，不过得分情况！"></a>实践三、rm 删掉的文件还能找回来吗？能，不过得分情况！</h2><p>实践过程</p><ul><li>创建文件：/app/test.c</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vi /app/test.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">    printf(&quot;pid %d\n&quot;, getpid());</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;debug\n&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删掉文件<br>$ rm /app/test.c</li></ul><ul><li>恢复过程１</li></ul><p>找到正在打开/app/file.c这个文件的进程id(20904)以及该文件在上述进程里的文件描述符(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof | grep /app/test.c filekeep  <span class="number">20904</span>                   root    <span class="number">3</span>r      REG                <span class="number">8</span>,<span class="number">5</span>        <span class="number">449</span>   <span class="number">20731531</span> /app/file.c (deleted)</span><br></pre></td></tr></table></figure><ul><li>恢复过程２</li></ul><p>恢复文件： $ cat /proc/20904/fd/3  &gt; /app/test1.c 即可修复被误删除的文件。</p><ul><li>前提条件：filekeep</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">filekeep.c</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = NULL;</span><br><span class="line"> </span><br><span class="line">   fp = fopen(&quot;/app/test.c&quot;, &quot;r&quot;);</span><br><span class="line">   sleep(600);</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实践总结</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">１、struct dentry</span><br><span class="line">&#123;</span><br><span class="line">  //..</span><br><span class="line">  struct inode *d_inode;//相关联的索引节点</span><br><span class="line">　struct qstr d_name;//目录项名称</span><br><span class="line">　struct dentry *d_parent;//父目录</span><br><span class="line">  //..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">２、struct inode</span><br><span class="line">&#123;</span><br><span class="line">　//...</span><br><span class="line">  unsigned long i_ino;//节点号</span><br><span class="line">  atomic_t i_count;//引用计数</span><br><span class="line">  unsigned int i_nlink;//硬链接数 　</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">３、struct file</span><br><span class="line">&#123;</span><br><span class="line">  //...</span><br><span class="line">  atomic_t f_count;//引用计数</span><br><span class="line">  struct path f_path;//包含目录项 </span><br><span class="line">  struct inode *f_inode;//i节点</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件对象（struct file）是已打开的文件在内存中的表示</span><br><span class="line">由于多个进程可以打开和操作同一个文件，所以同一个文件也可能存在多个文件对象</span><br><span class="line">虽然一个文件对应的文件对象不是唯一的，但是对应的索引节点（struct inode）和目录项（struct dentry）对象是唯一的</span><br><span class="line">rm命令底层调用了unlinkat()函数</span><br><span class="line">unlinkat()：如果该文件对象是对文件的最后一个引用且没有进程正在打开这个文件，才会真正的删除文件；</span><br><span class="line">否则，文件内容会依然保存在内存里，这样的文件就可以被恢复。</span><br></pre></td></tr></table></figure><h2 id="调优方法"><a href="#调优方法" class="headerlink" title="调优方法"></a>调优方法</h2><h3 id="应用程序优化"><a href="#应用程序优化" class="headerlink" title="应用程序优化"></a>应用程序优化</h3><p>追加写替代随机写</p><p>充分利用缓存（包括系统缓存和标准库缓存），降低实际 I/O 的次数</p><p>可以在应用程序内部构建自己的缓存，或者用 Redis/memcached 这类外部缓存系统</p><p>在需要同步写的场景中，尽量将写请求合并，而不是让每个请求都同步写入磁盘，即可以用 fsync() 取代 O_SYNC</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">wfile.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfd\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fd, len;</span><br><span class="line">    fd = open(<span class="string">&quot;./test.txt&quot;</span>, O_RDWR|O_CREAT|O_APPEND<span class="comment">/*|O_SYNC*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    i++;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h4><p>当文件在open()时指定了O_SYNC选项，则意味着每个write()调用后面都隐含地跟着一个fsync()调用。</p><p>在使用 CFQ 调度器时，使用ionice调整进程的I/O调度优先级</p><p>在使用 CFQ 调度器时，可以用 ionice 来调整进程的 I/O 调度优先级，特别是提高核心应用的 I/O 优先级。 ionice 支持三个优先级类：Idle、Best-effort 和 Realtime。 其中， Best-effort 和 Realtime 还分别支持 0-7 的级别，数值越小，则表示优先级别越高。</p><h3 id="文件系统优化"><a href="#文件系统优化" class="headerlink" title="文件系统优化"></a>文件系统优化</h3><ul><li>优化文件系统的缓存</li></ul><p>比如，你可以优化 pdflush 脏页的刷新频率（比如设置 dirty_expire_centisecs 和 dirty_writeback_centisecs）以及脏页的限额（比如调整 dirty_background_ratio 和 dirty_ratio 等）。 备注：以上配置都在/proc/sys/vm/目录下。</p><ul><li>优化内核回收目录项缓存和索引节点缓存的倾向</li></ul><p>可以优化内核回收目录项缓存和索引节点缓存的倾向，即调整 vfs_cache_pressure（/proc/sys/vm/vfs_cache_pressure，默认值 100），数值越大，就表示越倾向于回收目录项缓存和索引节点缓存占用的内存。</p><ul><li>使用tmpfs，获得更好的I/O性能</li></ul><p>磁盘文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、建表</span><br><span class="line">spark-sql&gt;</span><br><span class="line">CREATE table diskfile</span><br><span class="line">USING csv</span><br><span class="line">OPTIONS (</span><br><span class="line">  header true,</span><br><span class="line">  path &quot;/app/tools/test-tool/data/test.csv&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">２、查询</span><br><span class="line">spark-sql&gt; </span><br><span class="line">select * from diskfile where name=&quot;name23453&quot;;</span><br></pre></td></tr></table></figure><p>tmpfs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、创建tmpfs</span><br><span class="line">mkdir -p  /tftpboot/tmp</span><br><span class="line">mount -t tmpfs -o size=1G tmpfs /tftpboot/tmp</span><br><span class="line">２、复制csv文件到tmpfs文件系统目录</span><br><span class="line">３、建表</span><br><span class="line">spark-sql&gt;</span><br><span class="line">CREATE table tmpfile</span><br><span class="line">USING csv</span><br><span class="line">OPTIONS (</span><br><span class="line">  header true,</span><br><span class="line">  path &quot;/tftpboot/tmp/test.csv&quot;</span><br><span class="line">);</span><br><span class="line">4、查询</span><br><span class="line">spark-sql&gt; </span><br><span class="line">select * from tmpfile where name=&quot;name23453&quot;;</span><br></pre></td></tr></table></figure><h3 id="磁盘优化"><a href="#磁盘优化" class="headerlink" title="磁盘优化"></a>磁盘优化</h3><ul><li>SSD替代HDD</li></ul><p>针对磁盘和应用程序 I/O 模式的特征，我们可以选择最适合的 I/O 调度算法</p><p>在顺序读比较多的场景中，我们可以增大磁盘的预读数据</p><p>你可以通过下面的proc文件，调整 /dev/sda 设备的预读大小： $ cat /sys/block/sda/queue/read_ahead_kb 128 默认大小是 128，单位为 KB。</p><p>可以优化内核块设备 I/O 的选项</p><p>比如，可以调整磁盘队列的长度 /sys/block/sda/queue/nr_requests。 适当增大队列长度，可以提升磁盘的吞吐量。</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの嵌入式笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 嵌入式Linux </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——网络调优</title>
      <link href="/2024/09/06/Linux_%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/"/>
      <url>/2024/09/06/Linux_%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-网络调优"><a href="#Linux-网络调优" class="headerlink" title="Linux 网络调优"></a>Linux 网络调优</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h3><ul><li>应用层</li></ul><p>负责应用程序沟通，常见协议：http/ftp/tftp/snmp/smtp/telnet等，可自定义</p><ul><li>传输层</li></ul><p>提供端到端的通信服务，常见协议：tcp和udp协议</p><ul><li>网络层</li></ul><p>负责数据的分片、寻址和路由，常见协议：ip协议</p><ul><li>数据链路层</li></ul><p>负责硬件设备之间的数据帧的传送和识别，例如帧同步、冲突检测等，常见协议：ethernet协议</p><ul><li>物理层</li></ul><p>透明的传输比特流，常见硬件厂商：<br>- broadcom（博通）<br>- realtek（瑞昱）<br>- intel</p><h4 id="实践一、linux-c实现聊天功能及wireshark抓包分析"><a href="#实践一、linux-c实现聊天功能及wireshark抓包分析" class="headerlink" title="实践一、linux c实现聊天功能及wireshark抓包分析"></a>实践一、linux c实现聊天功能及wireshark抓包分析</h4><p>案例代码在这里 -&gt; </p><p><a href="https://github.com/simple-tec/linux-driver/tree/main/app/tcp">https://github.com/simple-tec/linux-driver/tree/main/app/tcp</a></p><h3 id="linux网络设备驱动"><a href="#linux网络设备驱动" class="headerlink" title="linux网络设备驱动"></a>linux网络设备驱动</h3><p>(以dm9000芯片为例)</p><p>硬件datasheet在这里 -&gt; </p><p><a href="http://www.davicom.com.tw/pddocs/DM9000A-DS-F01-030311.pdf">http://www.davicom.com.tw/pddocs/DM9000A-DS-F01-030311.pdf</a></p><h4 id="最大传输单元mtu"><a href="#最大传输单元mtu" class="headerlink" title="最大传输单元mtu"></a>最大传输单元mtu</h4><p>mtu范围：【68, 1500】</p><p>ip报头最小：20 Bytes</p><p>tcp头部最小：20 Bytes</p><p>最大mss = 1500-20-20=1460</p><p>最大报文段长度（MSS）是TCP协议的一个选项，用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度（不包括文段头）。 MSS = MTU - TCP头部大小 - IP头部大小 其中，TCP 头部和 IP 头部的大小是固定的，分别为 20 字节和 20 字节。</p><p>mtu限制了数据链接层上可以传输的数据包的大小，也因此限制了上层（IP层）的数据包大小</p><p>mtu和IP分片的关系</p><p>当要求发送的IP数据包比数据链路层的MTU大时，必把该数据包分割成多个IP数据包才能发送。</p><h4 id="linux网卡驱动发送和接收"><a href="#linux网卡驱动发送和接收" class="headerlink" title="linux网卡驱动发送和接收"></a>linux网卡驱动发送和接收</h4><p>参考代码(linux 4.9.229)：drivers/net/ethernet/davicom/dm9000.c</p><p>网卡驱动整体框架</p><ul><li>数据帧发送</li></ul><p>1、dm9000_start_xmit() </p><p>2、 dm9000_interrupt()</p><p>３、dm9000_tx_done</p><ul><li>数据帧接收</li></ul><p>1、 dm9000_interrupt()</p><p>2、dm9000_rx()</p><p>3、netif_rx()</p><ul><li>软中断NET_TX, NET_RX处理</li></ul><p>参考代码(linux 4.9.229)：net/core/dev.c</p><p>网络底半部发送：net_tx_action()</p><p>网络底半部接收：net_rx_action()</p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="最大传输单元mtu-1"><a href="#最大传输单元mtu-1" class="headerlink" title="最大传输单元mtu"></a>最大传输单元mtu</h3><p>相关工具</p><p>查看：<br>ifconfig eth0 | grep mtu</p><p>修改（临时）：<br>ifconfig eth0 mtu 1450</p><p>实践：IP数据包（包含IP头）超过MTU大小，会发生什么情形？</p><p>操作步骤</p><p>【假设】eth0接口的mtu为1500！ 命令１： ping -I eth0 -s 147２ -M do 192.168.0.101 命令２： ping -I eth0 -s 1473 -M do 192.168.0.101</p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>链路的最大传输速度，单位b/s（比特/s），属于基础设施。</p><p>相关工具</p><p>ethtool eth0 | grep Speed</p><h3 id="PPS"><a href="#PPS" class="headerlink" title="PPS"></a>PPS</h3><p>Packet Per Second，表示以网络包为单位的传输速率</p><p>相关工具</p><p>sar -n DEV</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>单位时间内传输的数据量，单位b/s或者B/s</p><p>相关工具</p><p>sar -n DEV</p><p>rxpck/s 和 txpck/s 分别是接收和发送的 PPS; rxkB/s 和 txkB/s 分别是接收和发送的吞吐量； rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数； %ifutil 是网络接口的使用率，即半双工模式下为 (rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s, txkB/s)/Bandwidth；</p><h3 id="往返延时（RTT）"><a href="#往返延时（RTT）" class="headerlink" title="往返延时（RTT）"></a>往返延时（RTT）</h3><p>RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</p><p>相关工具</p><p>【ICMP】ping -c4 8.8.8.8</p><p>ping命令的输出中的最后一行： rtt min/avg/max/mdev = 58.325/71.634/94.710/14.502 ms mdev全称Mean Deviation，译为平均方差 mdev越大，表示网络越不稳定。</p><p>【TCP】hping3 -c 3 -S -p 80 httpbin.org</p><h3 id="TCP相关性能工具"><a href="#TCP相关性能工具" class="headerlink" title="TCP相关性能工具"></a>TCP相关性能工具</h3><p>tcp半连接队列的大小</p><p>相关工具</p><p>max(64, net.ipv4.tcp_max_syn_backlog)</p><p>tcp全连接队列的大小</p><p>相关工具</p><p>min(backlog, net.core.somaxconn)</p><p>tcp/udp吞吐量</p><p>相关工具</p><p>【tcp】<br>server端：iperf -s -p 10000<br>client端：iperf -c 192.168.0.100 -p 10000</p><p>【udp】<br>server端：iperf -s -p 10000<br>client端：iperf -u -c 192.168.0.100 -p 10000</p><p>tcp缓冲区大小</p><p>相关工具或配置</p><p>tcp发送缓冲区大小：<br>查看：<br>cat /proc/sys/net/ipv4/tcp_wmem<br>该文件包含3个整数值，分别是：min，default，max<br>更改：<br>sysctl -w net.ipv4.tcp_wmem=”XXXX XXXX XXXX”</p><p>tcp接收缓冲区大小：<br>查看：<br>cat /proc/sys/net/ipv4/tcp_rmem<br>该文件包含3个整数值，分别是：min，default，max<br>更改：<br>sysctl -w net.ipv4.tcp_rmem=”XXXX XXXX XXXX”</p><p>socket连接数</p><p>相关工具</p><p>查看tcp状态为SYN_REC的sockets：<br>netstat -n -p -t | grep SYN_REC</p><p>查看tcp状态为SYN_REC的sockets：<br>ss -n -p -t | grep SYN_REC</p><h3 id="UDP相关性能工具"><a href="#UDP相关性能工具" class="headerlink" title="UDP相关性能工具"></a>UDP相关性能工具</h3><p>udp缓冲区大小</p><p>相关工具或配置</p><p>udp缓冲区大小：<br>查看：<br>cat /proc/sys/net/ipv4/udp_mem<br>该文件包含3个整数值，分别是：min，default，max</p><p>套接字缓冲区大小</p><p>单个套接字缓冲区大小</p><p>相关工具或配置</p><p>setsockopt(,,,SO_SNDBUF,,,)配置</p><p>在调用connect或listen之前通过setsockopt设置。</p><p>setsockopt(,,,SO_RCVBUF,,,)配置</p><p>在调用connect或listen之前通过setsockopt设置。</p><p>内核全局的套接字缓冲区大小</p><p>相关工具或配置</p><p>套接字接收缓冲区大小：<br>查看：<br>cat /proc/sys/net/core/rmem_max<br>修改：<br>sysctl -w net.core.rmem_max=212993</p><p>套接字发送缓冲区大小：<br>查看：<br>cat /proc/sys/net/core/wmem_max<br>修改：<br>sysctl -w net.core.wmem_max=212993</p><h3 id="工具汇总"><a href="#工具汇总" class="headerlink" title="工具汇总"></a>工具汇总</h3><h4 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h4><p>用法</p><p>过滤器</p><p>捕获过滤器：用于决定捕获什么数据</p><p>显示过滤器：在捕获的结果中进行详细查找</p><p>详细语法：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/631179d61e0853188ea104c4" alt="img"></p><p>比较运算：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/63117bd11e0853188ea10c9f" alt="img"></p><p>逻辑运算：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/63117bde1efad41efc4ca3a8" alt="img"></p><p>例子</p><p>frame.cap_len &gt; 100<br>【备注】cap_len长度包括【以太网头＋ip头＋tcp头＋应用数据】的总长度</p><p>ip.len &gt;= 100<br>【备注】ip.len是ip层以上的（包含ip头）数据的总长度</p><p>tcp.len &gt;= 60<br>【备注】tcp.len即tcp segment len，指的是tcp所承载的应用数据的长度（不包含tcp头部）</p><p>udp.length &gt; 100<br>【备注】udp.length是udp报头和udp载荷数据的总大小</p><p>对多个条件进行过滤：<br>ip.addr==172.16.10.2 and tcp.flag.fin</p><p>按字节位置的内容进行过滤（十六机制）：<br>tcp[0:2]==ac3a（匹配源端口号44090）<br>【备注】tcp[n,m] ：n是起始位置偏移，m是从指定位置的区域长度</p><p>按比特位置的内容进行过滤：<br>tcp[13]&amp;2<br>【备注】用“&amp;2”符号指出要取这个字节中第2位即SYN位置的值</p><p>tcp.segment_data contains 49:27:6d:20:64:61:74:61<br>【备注】49:27:6d:20:64:61:74:61是16进制的内容序列</p><p>Flow Graph</p><p>1, 在选择一个包后，单击右键并选择 “Follow” -&gt; “TCP Stream”； 2，关闭弹出来的对话框，回到 Wireshark 主窗口。这时候，你会发现 Wireshark 已经自动帮你设置了一个过滤表达式，例如：tcp.stream eq 24。 从这里，你可以看到这个 TCP 连接从三次握手开始的每个请求和响应情况。 3，为了更加直观，你可以继续点击菜单栏里的 Statics -&gt; Flow Graph，选中 “Limit to display filter” 并设置 Flow type 为 “TCP Flows”。就可以看到更直观的通信细节。</p><h4 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h4><p>用法</p><p>-i eth0：指定网络接口</p><p>-nn：不解析ip地址和端口号的名称</p><p>-c {count}：指定要抓取的数据包的个数</p><p>-w {file}：抓包并保存到文件，比如：file.pcap</p><p>[expression] tcpdump的过滤表达式和wireshark是类似的</p><p>tcpdump的过滤表达式</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/63119746079129647b69c738" alt="img"></p><p>输出格式：时间戳　协议　源IP地址：源端口 &gt; 目的IP地址：目的端口　网络包详细信息</p><p>例子：tcpdump -i eth0 icmp and host 192.168.0.102 -nn </p><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>用法</p><p>-a: 显示所有的socket连接（包括listening和non-listening连接）</p><p>-l: 只显示listening状态的socket连接</p><p>-n: 表示显示数字地址和端口(而不是名字)</p><p>-p: 表示显示进程信息</p><p>-t: 只显示tcp连接（若不指定-l，则默认仅显示non-listening连接）</p><p>-u: 只显示udp连接（若不指定-l，则默认仅显示non-listening连接）</p><p>-x: 只显示unix连接</p><p>-i: 显示所有网络接口的状态</p><p>-s：汇总了 ip、icmp、udp、tcp 等各种协议的收发统计信息</p><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><p> Forwarding: 1 //开启转发    8641328 total packets received //总收包数    73 with invalid addresses // 有着错误地址的封包数    0 forwarded //转发包数    0 incoming packets discarded //接收丢包数    8598954 incoming packets delivered //接收的数据包数    5161967 requests sent out //发出的数据包数    160 dropped because of missing route //找不到路由而导致的丢包数    1 fragments dropped after timeout　//超时导致的丢包数    274 reassemblies required　//需要重组的封包数    117 packets reassembled ok//重组成功的封包数    1 packet reassemblies failed　//重组失败的封包数</p><p>-e：显示额外的信息，比如socket path等</p><p>-r：显示内核的路由表，等同于route -e</p><p>Recv-Q 和 Send-Q的解释</p><p>注意，在不同套接字状态下，它们的含义不同： 1、当套接字处于Established状态（Established）时，Recv-Q 表示OS持有的、尚未交付给应用程序的数据的字节数；而 Send-Q 表示已经发送给对端应用，但对端应用尚未ack的字节数。 2、当套接字处于监听状态（Listening）时，Recv-Q 表示当前全连接队列的长度。而 Send-Q 表示全连接队列的最大长度，其值为min(backlog, somaxconn)。 注意，Listening状态时，Recv-Q的最大值为Send-Q+1，即：min(backlog, somaxconn)+1。 之所以加1，是因为OS内核在判断队列是否已满时，用的是&gt;（应该用&gt;=），这导致当已创建成功的连接数量正好等于min(backlog, somaxconn)时，还会再多创建一个tcp连接，最终结果就是：min(backlog, somaxconn)+1。</p><p>场景</p><p>１、列出所有的tcp端口（包含listen和非listen状态）：<br>$ netstat -ta<br>列出处于Listen状态的tcp端口：<br>$ netstat -tl<br>注意：netstat -t会列出处于no-listen状态的tcp连接</p><p>２、显示各个协议的统计信息：<br>$ netstat -s</p><p>３、显示tcp的统计信息<br>$ netstat -st</p><p>４、初步检测你的系统有没有受到DDOS攻击：<br>$ netstat -n -p|grep SYN_REC | wc -l </p><h4 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h4><p>用法</p><p>-a: 显示所有的sockets（包括LISTEN和非LISTEN）</p><p>-l: 只显示LISTEN状态的sockets</p><p>-n：不解析服务名字，显示数字和端口</p><p>-p：显示进程信息</p><p>-t：只显示tcp连接</p><p>-u：只显示udp连接</p><p>-x：只显示unix连接</p><p>-s：连接信息汇总</p><h4 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h4><p>用法</p><p>-f [kmKM] ：分别表示以Kbits, Mbits, KBytes, MBytes显示报告</p><p>-s：以server模式启动</p><p>-c：以client模式启动</p><p>-p：指定端口号</p><p>-u：使用udp协议</p><p>-t {sec}：表示测试多久，一般指定在client端（因为client为封包发送方）</p><p>-m：在结果中打印tcp mss的值</p><p>-N：禁止Nagle算法</p><p>场景</p><p>测试tcp的吞吐量：<br>server端：iperf -s -p 10000<br>client端：iperf -c 192.168.0.100 -p 10000</p><p>测试udp的吞吐量：<br>server端：iperf -s -p 10000 -u<br>client端：iperf -c 192.168.0.100 -p 10000 -u</p><h4 id="ab"><a href="#ab" class="headerlink" title="ab"></a>ab</h4><p>用法</p><p>-c: 并发数</p><p>-n: 总请求数</p><p>-s: 设置每个请求的超时时间</p><p>-r: 套接字接收错误时仍然继续执行</p><p>注意</p><p>测试高并发，需要提前修改进程能打开的最大文件描述符的大小：<br>$ ulimit -n 10240</p><p>场景</p><p>测试某个服务的性能：<br>$ ab -c 100 -n 10000 <a href="http://httpbin.org/ip">http://httpbin.org/ip</a></p><p>Failed requests:　//失败的请求数； Non-2xx responses://非2xx回应的请求数； Requests per second://每秒完成的请求数； Time per request【１】:每个请求的平均处理时间； Time per request【２】:引入并发因素后，每个请求的平均处理时间； Transfer rate: //每秒数据传输量，表示网络吞吐； 备注： 某些情况下Time per request【２】乘以concurrency，约等于Time per request【１】，希望这样有助于你理解这两者的区别。</p><h4 id="hping3"><a href="#hping3" class="headerlink" title="hping3"></a>hping3</h4><p>用法</p><p>模式选择，默认tcp</p><p>—rawip：RAWIP模式</p><p>—icmp：ICMP模式</p><p>—udp：UDP模式</p><p>—scan：SCAN模式，指定扫描对应的端口</p><p>—listen：监听模式</p><p>-S：表示设置TCP协议的SYN（同步序列号）</p><p>-p {port}: 设置端口号</p><p>-c {count}：发送的总封包数</p><p>-i {interval}：u100表示每隔100微秒发送一个网络帧</p><p>-i 1：表示每隔1秒发送一个网络帧； -i u100：表示每隔100微妙发送一个网络帧；</p><p>-a {hostname}：源地址欺骗</p><p>—rand-source：随机化源IP</p><p>—flood：尽量快的发包，无需再指定-i</p><p>场景</p><p>１、端口扫描<br>扫描一个端口：<br>$ hping3 192.168.0.1 —scan 80 -S<br>扫描多个端口：<br>$ hping3 192.168.0.1 —scan 80,8080 -S</p><p>２、模拟DDOS攻击<br>SYN ddos攻击：<br>$ hping3 -S -p 80 -i u10 192.168.0.1<br>flood＋随机源地址SYN攻击：<br>$ hping3 -S -p 80 192.168.0.1 —flood —rand-source</p><p>3、伪造源IP地址<br>伪装源地址为10.0.0.1给192.168.0.1的80端口发送syn包：<br>$ hping3 -S -p 80 -a 10.0.0.1 -S 192.168.0.1</p><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>用法</p><p>-n：不会进行名称解析</p><p>-s {packetsize}：指定要发送的封包大小。<br>【注意】{packetsize}+8+20应该小于等于mtu，否则会执行分片策略</p><p>-M {pmtudisc_opt}：选择Path MTU发现策略，可选值如下：<br>- do：禁止分片<br>- want：package太大时执行分片<br>- dont：不设置DF flag</p><p>例子：<br>ping 192.168.0.101 -c 1</p><h4 id="nethogs"><a href="#nethogs" class="headerlink" title="nethogs"></a>nethogs</h4><p>用法</p><p>排序显示每个进程所使用的网络带宽，例如：<br>nethogs -d 2 -s</p><p>-d {seconds}：指定刷新频率</p><p>-s：按照网络发送量排序　</p><p>交互参数：<br>m：切换byte, kb, mb等<br>r: 按照接收排序<br>s：按照发送量排序</p><h4 id="iftop"><a href="#iftop" class="headerlink" title="iftop"></a>iftop</h4><p>用法</p><p>界面参数说明： =&gt;代表发送数据 &lt;=代表接收数据 TX：发送流量（过去 2s 10s 40s ） RX：接收流量（过去 2s 10s 40s ） TOTAL：总流量 Cumm：运行iftop到目前时间的字节总量 peak：过去40s的流量峰值 rates：分别表示过去 2s 10s 40s 的平均流量 备注：流量的单位是Bytes/s，也就是传输速度。</p><p>-i ${dev}：设定监测的网卡</p><p>-B：以bytes为单位显示流量(默认是bits)</p><p>-n：不使用host信息、而是使用ip地址和端口的方式来显示</p><p>常用组合：<br>iftop -i eth0 -B -n</p><h2 id="调优实践"><a href="#调优实践" class="headerlink" title="调优实践"></a>调优实践</h2><h3 id="实践一、ping不通服务器，该从哪些方面去调试？"><a href="#实践一、ping不通服务器，该从哪些方面去调试？" class="headerlink" title="实践一、ping不通服务器，该从哪些方面去调试？"></a>实践一、ping不通服务器，该从哪些方面去调试？</h3><p>分析过程</p><p>【物理层】查看网线接口灯的状态是否正常。</p><p>绿灯是链路指示灯,黄灯是信号指示灯。 １、黄灯闪动,绿灯长亮 表示链路正常,正在通信中； ２、黄灯不亮,绿灯长亮 表示链接正常,不过目前没有数据通信； ３、黄灯不亮,绿灯闪动 表示链路不稳定，存在比如线头接触不良等问题</p><p>【数据链路层】ifconfig查看相应的网络接口是否存在RX errors或者TX errors<br>$ watch -d ifconfig eth0</p><p>【arp层】查看本地的arp缓存中关于目标ip的mac地址是否正确？<br>$ arp -e</p><p>【网络层】执行route查看针对目标IP的出口设备是否正常？有时docker bridge就创建它自己的172打头的路由规则，导致路由出错</p><p>【本机的软件防火墙】通过iptables -L查看是否有针对目标服务器地址的可疑规则</p><p>【第三方防火墙】和服务器机器是否直连，中间有没有通过其他设备，该设备有无防火墙规则设定？</p><p>【Tcp层】通过nmap -sS -v 172.21.84.140或则nmap -sT -v 172.21.84.140扫描服务器开关机状态和存活端口号</p><h3 id="实践二、对端socket发出了RST报文，导致连接异常关闭，该怎么分析？"><a href="#实践二、对端socket发出了RST报文，导致连接异常关闭，该怎么分析？" class="headerlink" title="实践二、对端socket发出了RST报文，导致连接异常关闭，该怎么分析？"></a>实践二、对端socket发出了RST报文，导致连接异常关闭，该怎么分析？</h3><p>分析过程</p><p>通过wireshark或tcpdump分析tcp通信过程</p><p>RST是发生在３次握手过程中吗？是否在向一个未监听的端口发送<br>SYN封包？</p><p>客户端和服务端程序有任何一方发生了异常退出吗？</p><p>是否在已关闭的socket上收到了数据呢？</p><p>客户端和服务端程序有任何一方发生了提前close退出吗？</p><p>案例代码</p><p>在已经关闭的socket上收到了数据，底层协议栈会发RST</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8887</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> listen_fd, real_fd;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">listen_addr</span>, <span class="title">client_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);  </span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(listen_fd == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;socket failed   &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bzero(&amp;listen_addr,<span class="keyword">sizeof</span>(listen_addr));  </span><br><span class="line">    listen_addr.sin_family = AF_INET;  </span><br><span class="line">    listen_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    listen_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    bind(listen_fd,(<span class="keyword">struct</span> sockaddr *)&amp;listen_addr, len);  </span><br><span class="line">    listen(listen_fd, WAIT_COUNT);  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        real_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);  </span><br><span class="line">        <span class="keyword">if</span>(real_fd == <span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            perror(<span class="string">&quot;accpet fail  &quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            close(listen_fd);  </span><br><span class="line">            <span class="type">char</span> pcContent[<span class="number">4096</span>];</span><br><span class="line">            read(real_fd,pcContent,<span class="number">4096</span>);</span><br><span class="line">            close(real_fd);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);              </span><br><span class="line">        &#125;  </span><br><span class="line">        close(real_fd);  </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8887</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> send_sk;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">s_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(s_addr);  </span><br><span class="line">    send_sk = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(send_sk == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;socket failed  &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bzero(&amp;s_addr, <span class="keyword">sizeof</span>(s_addr));  </span><br><span class="line">    s_addr.sin_family = AF_INET;  </span><br><span class="line">    s_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    s_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    <span class="keyword">if</span>(connect(send_sk,(<span class="keyword">struct</span> sockaddr*)&amp;s_addr,len) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;connect fail  &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">char</span> pcContent[<span class="number">4096</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// first send</span></span><br><span class="line">    write(send_sk,pcContent,<span class="number">4096</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// second send</span></span><br><span class="line">    write(send_sk,pcContent,<span class="number">4096</span>);</span><br><span class="line">    close(send_sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wireshark截图</p><p><img src="C:\Users\ZHY\AppData\Roaming\Typora\typora-user-images\image-20241019212806209.png" alt="image-20241019212806209"></p><p>接收方应用程序未接收完接收缓冲区的数据、就提前close退出，底层协议栈会发RST</p><p>Server.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8887</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> listen_fd, real_fd;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">listen_addr</span>, <span class="title">client_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);  </span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(listen_fd == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;socket failed   &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bzero(&amp;listen_addr,<span class="keyword">sizeof</span>(listen_addr));  </span><br><span class="line">    listen_addr.sin_family = AF_INET;  </span><br><span class="line">    listen_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    listen_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    bind(listen_fd,(<span class="keyword">struct</span> sockaddr *)&amp;listen_addr, len);  </span><br><span class="line">    listen(listen_fd, WAIT_COUNT);  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        real_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);  </span><br><span class="line">        <span class="keyword">if</span>(real_fd == <span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            perror(<span class="string">&quot;accpet fail  &quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            close(listen_fd);  </span><br><span class="line">            <span class="type">char</span> pcContent[<span class="number">4096</span>];</span><br><span class="line">            read(real_fd,pcContent,<span class="number">4096</span>);</span><br><span class="line">            close(real_fd);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);              </span><br><span class="line">        &#125;  </span><br><span class="line">        close(real_fd);  </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8887</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> send_sk;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">s_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(s_addr);  </span><br><span class="line">    send_sk = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(send_sk == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;socket failed  &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bzero(&amp;s_addr, <span class="keyword">sizeof</span>(s_addr));  </span><br><span class="line">    s_addr.sin_family = AF_INET;  </span><br><span class="line">    s_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    s_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    <span class="keyword">if</span>(connect(send_sk,(<span class="keyword">struct</span> sockaddr*)&amp;s_addr,len) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;connect fail  &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">char</span> pcContent[<span class="number">5000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(send_sk,pcContent,<span class="number">5000</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    close(send_sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20241019213237649.webp" alt="image-20241019213237649"></p><h3 id="实践三、压测nginx服务时网络延迟居高不下，该如何解决？"><a href="#实践三、压测nginx服务时网络延迟居高不下，该如何解决？" class="headerlink" title="实践三、压测nginx服务时网络延迟居高不下，该如何解决？"></a>实践三、压测nginx服务时网络延迟居高不下，该如何解决？</h3><p>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. nginx打开nagle算法</span><br><span class="line">vi /etc/nginx/nginx.conf</span><br><span class="line">http &#123;</span><br><span class="line">  ...  </span><br><span class="line">  tcp_nodelay off;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 客户端使用ab工具并发压测：</span><br><span class="line">$  ab -c 100 -n 10000 -k http://172.21.84.207:8081/</span><br><span class="line">结果：</span><br><span class="line">Requests per second:    2259.76 [#/sec] (mean)</span><br><span class="line">Time per request:       44.253 [ms] (mean)</span><br><span class="line"></span><br><span class="line">3. nginx关闭nagle算法</span><br><span class="line">vi /etc/nginx/nginx.conf</span><br><span class="line">http &#123;</span><br><span class="line">  ...  </span><br><span class="line">  tcp_nodelay on;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. 再测压测</span><br><span class="line">$  ab -c 100 -n 10000 -k http://172.21.84.207:8081/</span><br><span class="line">结果：</span><br><span class="line">Requests per second:    20316.37 [#/sec] (mean)</span><br><span class="line">Time per request:       4.922 [ms] (mean)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【附】本例使用的完整的nginx.conf文件如下：</span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8081;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">           root  /var/www/html;             #html访问路径</span><br><span class="line">           index index.html index2.htm;     #html文件名称</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析过程</p><p><a href="https://shimo.im/docs/nPixnamNKxQiG7dQ/ 《Nagle算法和tcp延迟确认-public》，可复制链接后用石墨文档 App 打开">Nagle算法和tcp延迟确认</a></p><p>调优方法</p><p>数据链路层</p><p>网卡驱动优化</p><p>NAPI：中断+轮询</p><p>为网卡中断配置cpu亲和性（smp_affinity），将这些中断处理程序调度到不同的 CPU 上执行</p><p>DPDK</p><p>跳过逻辑复杂的linux网络协议栈，直接由用户态进程用轮询的方式，来处理网络请求</p><p>传输层</p><h4 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h4><p>tcp TIME_WAIT优化</p><p>增大处于 TIME_WAIT 状态的连接数量： net.ipv4.tcp_max_tw_buckets </p><p>tcp_max_tw_buckets控制kernel中最多存在的TIME_WAIT数量。</p><p>减小 net.ipv4.tcp_fin_timeout，让处于FIN状态的tcp连接尽早释放</p><p>开启端口复用 net.ipv4.tcp_tw_reuse，这样被 TIME_WAIT 状态占用的端口，能很快被用于新的连接</p><p>增加可用端口号或者文件数</p><p>增大本地端口的范围 net.ipv4.ip_local_port_range ，这样就可以支持更多连接，提高服务并发能力</p><p>linux里，一切皆是文件，socket连接也是，可增加最大文件描述符的数量（ulimit -n 10240）</p><p>SYN相关优化</p><p>增大 TCP 半连接的最大数量：net.ipv4.tcp_max_syn_backlog </p><p>减少 SYN_RECV 状态的连接重传 SYN+ACK 包的次数 ：net.ipv4.tcp_synack_retries。</p><p>其他优化</p><p>tcp nagle算法</p><p>启用时可提高小封包场景下的网络利用率，但同时也增加了网络延迟</p><p>tcp延迟确认</p><p>提高某些场景下的网络利用率</p><h4 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h4><p>增大UDP的缓冲区大小</p><p>跟前面 TCP 部分提到的一样，增大本地端口号的范围</p><p>根据 MTU 大小，调整 UDP 数据包的大小，减少或者避免分片的发生</p><p>配置套接字缓冲区大小<br>参考出处：<br> linux-4.9.229/Documentation/sysctl/net.txt</p><p>net.core.optmem_max：每个套接字允许的最大辅助缓冲区大小</p><p>net.core.rmem_max：最大接收套接字缓冲区大小(以字节为单位)</p><p>net.core.wmem_max：最大发送套接字缓冲区大小(以字节为单位)</p><p>应用程序</p><p>使用epoll取代select和poll</p><p>尽量使用连接池，比如postgres和redis编程都支持连接池方式，可避免每次请求的时候都要建立3次握手</p><p>为socket配置较大的套接字的缓冲区SO_SNDBUF和SO_RCVBUF</p><p>使用缓存技术，缓存一部分实时性没那么高的数据，减少不必要的网络访问</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの嵌入式笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 嵌入式Linux </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux调试原理及方法2——内存占用调优</title>
      <link href="/2024/06/01/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-Linux-Memory%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98-Processing/"/>
      <url>/2024/06/01/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-Linux-Memory%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98-Processing/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-调试系列文章"><a href="#Linux-调试系列文章" class="headerlink" title="Linux 调试系列文章"></a>Linux 调试系列文章</h1><p>[[Linux CPU 占用调优]]<br>[[Linux Memory占用调优(Processing)]]</p><h1 id="调试工具总览"><a href="#调试工具总览" class="headerlink" title="调试工具总览"></a>调试工具总览</h1><p>Brendan D. Gregg 维护了一份Linux性能调优工具的蓝图<a href="http://www.brendangregg.com/linuxperf.html">Linux Performance Tools</a>，针对Linux系统的各个组件都有相应的分析工具，一目了然。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/202406012053732.webp" alt="image.png"></p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="linux内核内存管理"><a href="#linux内核内存管理" class="headerlink" title="linux内核内存管理"></a>linux内核内存管理</h2><ul><li><p>【批发】linux内核基于伙伴算法管理物理内存页</p></li><li><p>【零售】linux内核基于slab管理内存</p></li><li><p>linux内核所用物理内存大小统计</p></li></ul><h2 id="linux进程内存管理"><a href="#linux进程内存管理" class="headerlink" title="linux进程内存管理"></a>linux进程内存管理</h2><p>malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()</p><p>对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。</p><p>对大块内存（大于 128K），则直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去</p><p>各自的<strong>优缺点</strong>：</p><ul><li><p>brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率；不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片</p></li><li><p>mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大</p></li></ul><p>整体来说，Linux 使用<strong>伙伴系统</strong>来管理内存分配。前面我们提到过，这些内存在 MMU 中以页为单位进行管理，伙伴系统也一样，以页为单位来管理内存，并且会通过相邻页的合并，减少内存碎片化（比如 brk 方式造成的内存碎片）</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><blockquote><ul><li>进程独享虚拟地址空间（32位）  ０～３Ｇ</li><li>进程内分段管理内存空间<blockquote><p>代码段<br>数据段<br>heap<br>malloc()<br>stack<br>文件映射，匿名映射 mmap()</p></blockquote></li></ul></blockquote><p>进程内存按照用途分类</p><p><img src="http://cdn.processon.com/62c842730e3e740a4750ac02?e=1657294979&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:QcniUfzyckg6p1p7BtzFkoetjOY=" alt=""></p><h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><h4 id="进程所用物理内存大小统计"><a href="#进程所用物理内存大小统计" class="headerlink" title="进程所用物理内存大小统计"></a>进程所用物理内存大小统计</h4><ul><li>PSS<blockquote><p>一个进程所使用的内存可通过PSS和RSS来衡量。 计算进程的Pss: $ cat /proc/1/smaps | grep Pss | awk ‘{total+=$2}; END {print total}’<br>把一个共享库占用的内存，分摊到使用了这个共享库的各个进程头上</p></blockquote></li><li>RSS(不合理)<blockquote><p>把共享库占用的内存直接加到每个进程头上</p></blockquote></li><li>USS<blockquote><p>进程独自占用的物理内存（不包含共享库占用的内存）</p><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>在用户空间，malloc 通过 brk() 分配的内存，在释放时并不立即归还系统，而是缓存起来重复利用。在内核空间，Linux 通过 slab 分配器来管理小内存，可以把 slab 看成构建在<strong>伙伴系统上的一个缓存</strong>，主要作用就是分配并释放内核中的小对象</p></blockquote></li></ul><p>系统也不会任由某个进程用完所有内存。在发现内存紧张时，系统就会通过一系列机制来回收内存：</p><ul><li><p>回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面</p></li><li><p>回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中（会用到交换分区）</p></li><li><p>杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程</p></li></ul><p>OOM是内核的一种保护机制。它监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：</p><ul><li><p>进程消耗的内存越大，oom_score 就越大</p></li><li><p>进程运行占用的 CPU 越多，oom_score 就越小</p></li></ul><p>可以手动设置进程的oom_adj来调整oom_score。oom_adj的范围是[-17, 15]，数值越大，进程越容易被OOM杀死；反之，越不容易被OOM杀死</p><h3 id="回收时机"><a href="#回收时机" class="headerlink" title="回收时机"></a>回收时机</h3><ul><li>内存紧缺回收(alloc_pages的时候)</li><li>周期性内存回收：linux内存回收总结：<a href="https://cfn2lv4v46.feishu.cn/docx/P914dlXpro6CHnxErshcFuaNnYg">从swapd触发到回收3部曲</a></li><li>手动回收<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/vm/drop_caches   # &quot;clean&quot; page cache</span><br><span class="line">echo 2 &gt; /proc/sys/vm/drop_caches # shrink slab(dentry &amp; inode)</span><br><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure></li></ul><h3 id="回收方式"><a href="#回收方式" class="headerlink" title="回收方式"></a>回收方式</h3><ul><li>页回写 直接释放物理页面</li><li>页交换 回写到swap分区，然后释放物理页面</li><li>OOM Killer （较为暴力，应尽量避免）</li></ul><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="系统内存使用量"><a href="#系统内存使用量" class="headerlink" title="系统内存使用量"></a>系统内存使用量</h3><p>buffer, cache, used</p><h4 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/proc/meminfo</span><br><span class="line"></span><br><span class="line">free</span><br><span class="line"></span><br><span class="line">sar -r 1</span><br><span class="line"></span><br><span class="line">vmstat </span><br></pre></td></tr></table></figure><p><strong>系统内存余量</strong><br>free, available</p><p>available等于“空闲内存减去所有zones的lowmem reserve和high watermark，再加上page cache和slab中可以回收的部分“</p><h3 id="进程虚拟内存"><a href="#进程虚拟内存" class="headerlink" title="进程虚拟内存"></a>进程虚拟内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/proc/{id}/maps</p><p>pmap -p 1</p><p>进程内存使用量</p><h4 id="相关工具-1"><a href="#相关工具-1" class="headerlink" title="相关工具"></a>相关工具</h4><p>ps -aux</p><p>top</p><p>RES：常驻内存大小<br>RES=RSan+RSfd+RSsh</p><p>RSan：常驻匿名内存大小</p><p>RSfd：常驻文件映射内存大小</p><p>RSsh：常驻被锁定内存大小</p><p>SHR：共享内存大小</p><p>/proc/{pid}/status</p><p>smem -k -s rss| more</p><h3 id="缓存与缓冲区命中率"><a href="#缓存与缓冲区命中率" class="headerlink" title="缓存与缓冲区命中率"></a>缓存与缓冲区命中率</h3><p>缓存命中率，是指直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。</p><h4 id="相关工具-2"><a href="#相关工具-2" class="headerlink" title="相关工具"></a>相关工具</h4><p>cachestat/cachestat-bpfcc（系统整体）</p><p>HITS ，表示page cache命中的次数； MISSES ，表示page caceh未命中的次数； DIRTIES， Number of dirty pages added to the page cache； BUFFERS_MB，表示 Buffers 的大小，以 MB 为单位； CACHED_MB，表示 Cache 的大小，以 MB 为单位； HITRATIO，表示 page cache 命中率；</p><p>cachetop/cachetop-bpfcc（进程）</p><p>pcstat （进程&amp;文件）</p><h3 id="swap分区使用量"><a href="#swap分区使用量" class="headerlink" title="swap分区使用量"></a>swap分区使用量</h3><p>swap分区的作用是在系统物理内存不足时,将一部分物理内存中的数据交换到swap分区（磁盘上），从而把这部分物理内存释放出来给需要的程序来使用。 一、哪部分内存会被交换到swap分区？ １、匿名页(AnonPages)； ２、Shmem(基于tmpfs实现)虽然未统计在AnonPages里，但它们背后没有硬盘文件，所以也是需要交换区的。 二、从进程角度看，以下的函数或者机制分配的内存在物理内存不足时会被交换到swap分区，包括： - stack - malloc() - brk()/sbrk()  - mmap(PRIVATE, ANON) - POSIX shm* - mmap(SHARED, ANON) - tmpfs</p><h4 id="相关工具-3"><a href="#相关工具-3" class="headerlink" title="相关工具"></a>相关工具</h4><p>free（系统整体）</p><p>sar -S 1（系统整体）</p><p>smem -k（进程）</p><p>计算所有进程的swap总的大小： $ smem | awk ‘{if(NR&gt;1) total+=$(NF-3)}; END{printf total}’</p><h3 id="内存泄露情况"><a href="#内存泄露情况" class="headerlink" title="内存泄露情况"></a>内存泄露情况</h3><h4 id="相关工具-4"><a href="#相关工具-4" class="headerlink" title="相关工具"></a>相关工具</h4><p>memleak -a -p {pid}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">leak.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">128</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">64</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺页异常（主、次）"><a href="#缺页异常（主、次）" class="headerlink" title="缺页异常（主、次）"></a>缺页异常（主、次）</h3><p>缺页异常：cpu拿到虚拟地址，让MMU进行地址转换的时候，MMU找不到虚拟地址的页表映射关系。 主缺页：需要从磁盘加载 memory page； 次缺页：不需要从磁盘加载 memory page；</p><h4 id="相关工具-5"><a href="#相关工具-5" class="headerlink" title="相关工具"></a>相关工具</h4><p>进程自启动以来发生的缺页事件的总和：<br>ps -eo min_flt,maj_flt,cmd | more</p><p>进程每秒缺页错误次数：<br>pidstat -r</p><h2 id="工具汇总"><a href="#工具汇总" class="headerlink" title="工具汇总"></a>工具汇总</h2><h3 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意不同版本的free输出可能会有所不同</span></span><br><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        8169348      263524     6875352         668     1030472     7611064</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><ul><li>第一列，total 是总内存大小；</li><li>第二列，used 是已使用内存的大小，包含了共享内存；</li><li>第三列，free 是未使用内存的大小；</li><li>第四列，shared 是共享内存的大小；</li><li>第五列，buff/cache 是缓存和缓冲区的大小；</li><li>最后一列，available 是新进程可用内存的大小</li></ul><p><strong>注意</strong>：available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中</p><h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><p>可以查看每个进程的内存使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按下M切换到内存排序</span></span><br><span class="line">$ top</span><br><span class="line">...</span><br><span class="line">KiB Mem :  8169348 total,  6871440 free,   267096 used,  1030812 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  7607492 avail Mem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">  430 root      19  -1  122360  35588  23748 S   0.0  0.4   0:32.17 systemd-journal</span><br><span class="line"> 1075 root      20   0  771860  22744  11368 S   0.0  0.3   0:38.89 snapd</span><br><span class="line"> 1048 root      20   0  170904  17292   9488 S   0.0  0.2   0:00.24 networkd-dispat</span><br><span class="line">    1 root      20   0   78020   9156   6644 S   0.0  0.1   0:22.92 systemd</span><br><span class="line">12376 azure     20   0   76632   7456   6420 S   0.0  0.1   0:00.01 systemd</span><br><span class="line">12374 root      20   0  107984   7312   6304 S   0.0  0.1   0:00.00 sshd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>主要的几个信息：</p><ul><li>VIRT 是<strong>进程虚拟内存</strong>的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内</li><li>RES 是<strong>常驻内存</strong>的大小，也就是进程<strong>实际使用的物理内存</strong>大小，但<strong>不包括 Swap 和共享内存</strong></li><li>SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等</li><li>%MEM 是进程使用物理内存占系统总内存的百分比</li></ul><p><strong>注意</strong>：</p><ul><li>虚拟内存通常并不会全部分配物理内存。从上面的输出，你可以发现每个进程的虚拟内存都比常驻内存大得多</li><li>共享内存 SHR 并不一定是共享的，比方说，<strong>程序的代码段、非共享的动态链接库</strong>，也都算在 SHR 里。SHR 也包括了<strong>进程间真正共享的内存</strong>。所以在计算多个进程的内存使用时，不要把所有进程的 SHR 直接相加得出结果</li></ul><h3 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h3><p>用法： sar -r -S 1</p><p>-r: 表示显示内存使用情况</p><p>kbcommit，表示当前系统负载需要的内存。它实际上是为了保证系统内存不溢出（不超出），对需要内存的估计值。 %commit，就是这个值相对总内存的百分比，因为commit统计的是RAM+swap，所以%commit可能会大于100%</p><p>-S: 表示显示Swap使用情况</p><p>kbswpcad：其实就是swap文件的file cache。 kbswpcad = SwapCached(来自/proc/meminfo)</p><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-f: 显示系统启动到今创建的所有的进程数</span><br><span class="line"></span><br><span class="line">-S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）。默认单位为K（1024 bytes）</span><br><span class="line"></span><br><span class="line">-a: 显示活跃和非活跃内存</span><br><span class="line"></span><br><span class="line">-s：内存使用详情</span><br><span class="line"></span><br><span class="line">-m: 显示slab详情</span><br><span class="line"></span><br><span class="line">-d：磁盘读写的详情</span><br><span class="line"></span><br><span class="line">-p：显示指定磁盘分区统计信息</span><br></pre></td></tr></table></figure><h3 id="cachestat-cachestat-bpfcc"><a href="#cachestat-cachestat-bpfcc" class="headerlink" title="cachestat/cachestat-bpfcc"></a>cachestat/cachestat-bpfcc</h3><p>安装方法： $ sudo apt-key adv —keyserver keyserver.ubuntu.com —recv-keys 4052245BD4284CDD $ echo “deb <a href="https://repo.iovisor.org/apt/xenial">https://repo.iovisor.org/apt/xenial</a> xenial main” | sudo tee /etc/apt/sources.list.d/iovisor.list $ sudo apt-get update $ sudo apt-get install -y bcc-tools libbcc-examples linux-headers-$(uname -r) $ export PATH=$PATH:/usr/share/bcc/tools</p><p>用法</p><p>HITS ，表示page cache命中的次数； MISSES ，表示page caceh未命中的次数； DIRTIES， Number of dirty pages added to the page cache； BUFFERS_MB，表示 Buffers 的大小，以 MB 为单位； CACHED_MB，表示 Cache 的大小，以 MB 为单位； HITRATIO，表示 page cache 命中率；</p><p>提供了整个系统的 page cache 的读写命中情况</p><p>cachetop/cachetop-bpfcc</p><p>用法</p><p>提供了每个进程的 page cache 的读写命中情况</p><h3 id="pcstat"><a href="#pcstat" class="headerlink" title="pcstat"></a>pcstat</h3><p>安装方法： $ export GOPATH=~/go $ go get github.com/tobert/pcstat $ cp -rfa $GOPATH/bin/pcstat /bin</p><p>用法</p><p>查看文件的缓存大小以及缓存比例：<br>$ pcstat /tftpboot/hello</p><p>查看进程打开的所有文件的缓存大小以及缓存比例：<br>$ pcstat -pid {pid}</p><h3 id="hcache"><a href="#hcache" class="headerlink" title="hcache"></a>hcache</h3><p>go version &gt; 1.12 【安装】 git clone <a href="https://github.com/silenceshell/hcache.git">https://github.com/silenceshell/hcache.git</a> cd hcache make build sudo cp hcache /usr/local/bin/ </p><p>用法</p><p>输出系统中前10大使用缓存最多的文件：<br>hcache —top 10 </p><p>只显示基本名字：<br>hcache —top 10 -basename</p><h3 id="memleak"><a href="#memleak" class="headerlink" title="memleak"></a>memleak</h3><p>memleak跟踪内存申请和释放请求。 【实现原理】 在跟踪某个进程时，memleak会追踪libc中的分配函数，具体来说包括：malloc、calloc、realloc、valloc、memalign、pvalloc、aligned d_alloc和free； 当跟踪所有进程时，memleak追踪包括kmalloc/kfree、kmem_cache_alloc/kmem_cache_free，以及get_free_pages/free_pages所分配的页面。</p><p>用法</p><p>-a: 表示显示每个内存分配请求的大小以及地址</p><p>-p {pid}：指定要检测的进程</p><p>-c {command}：运行指定的命令并只跟踪其分配，这会跟踪libc分配器。</p><p>-z ｛MIN_SIZE｝：只捕获大于等于MIN_SIZE字节的内存泄露</p><p>-Z {MAX_SIZE}：只捕获小于等于MAX_SIZE字节的内存泄露</p><p>INTERVAL：每隔INTERVAL秒打印未释放的申请及其调用堆栈的摘要。缺省值为5秒。</p><p>每隔１秒打印一次进程31826的内存泄露统计：<br>memleak -a -p 31826 1</p><p>限制</p><p>当追踪的进程快速申请和释放内存时，memleak可能会带来很大的开销</p><p>此工具仅适用于Linux 4.6+</p><h3 id="smem"><a href="#smem" class="headerlink" title="smem"></a>smem</h3><p>用法</p><p>统计物理内存用量，支持的维度：process, user, mapping, systemwide</p><p>-k：显示单位后缀</p><p>-p：用百分比显示</p><p>-u：显示用户占用内存信息swap/rss/uss/pss大小</p><p>-w：显示系统内存用量，包括内核空间和用户空间</p><p>-m：统计mapping所用的物理内存</p><p>$ smem -m -k  Map  PIDs   AVGPSS      PSS  /lib/x86_64-linux-gnu/libc-2.27.so         173    29.0K     5.1M  第一列(Map)： 表示被共享的文件名字； 第二列(PIDs)： 表示上述文件被几个进程共享； 第三列(AVGPSS)： 各个进程平均分摊的内存，AVGPSS＝PSS/PIDs 第四列(PSS)： 文件加载后，占用的物理内存；</p><p>-s {swap/pss/uss/rss}：按照进程对swap/rss/pss/uss的使用量排序</p><h2 id="调优实践"><a href="#调优实践" class="headerlink" title="调优实践"></a>调优实践</h2><h3 id="实践一：linux-c语言开发遇到的最常见的内存问题，该如何定位解决？"><a href="#实践一：linux-c语言开发遇到的最常见的内存问题，该如何定位解决？" class="headerlink" title="实践一：linux c语言开发遇到的最常见的内存问题，该如何定位解决？"></a>实践一：linux c语言开发遇到的最常见的内存问题，该如何定位解决？</h3><p><strong>分析过程</strong></p><p>查看系统总体内存用量，确定大致问题：<br>vmstat -S K 1</p><p>对使用物理内存最多的20个进程进行监控（间隔１ｓ），确定进程是否存在内存异常：<br>watch -n 1 -d “smem -s rss |tail -n 20”</p><p>如果进程使用内存持续增加，进行内存泄露监控：<br>memleak -a -p {pid} 1</p><p>对其他内存使用量较高的进程代码进行review，主要关注如下部分：<br>- malloc<br>- brk()/sbrk()<br>- mmap()<br>- shmem等</p><p>进行代码层面的性能优化</p><p><strong>环境搭建</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">main.c</span><br><span class="line"><span class="comment">// 斐波那契数列（Fibonacci sequence）</span></span><br><span class="line"><span class="comment">// 1、1、2、3、5、8、13、21、34</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_SIZE 256000</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">fibo</span><span class="params">(<span class="type">int</span> *n0, <span class="type">int</span> *n1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *v = (<span class="type">int</span> *) <span class="built_in">malloc</span>(MALLOC_SIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, MALLOC_SIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *v = *n0 + *n1;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n0 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *v = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">2</span>; n &gt; <span class="number">0</span>; n++) &#123;</span><br><span class="line">        v = fibo(&amp;n0, &amp;n1);</span><br><span class="line">        n0 = n1;</span><br><span class="line">        n1 = *v;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dth =&gt; %lld\n&quot;</span>, n, *v);</span><br><span class="line">        <span class="comment">//free(v)</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    do_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实践二：spark处理200w笔数据，有时候需要几秒，有时候需要几十秒，原因何在？"><a href="#实践二：spark处理200w笔数据，有时候需要几秒，有时候需要几十秒，原因何在？" class="headerlink" title="实践二：spark处理200w笔数据，有时候需要几秒，有时候需要几十秒，原因何在？"></a>实践二：spark处理200w笔数据，有时候需要几秒，有时候需要几十秒，原因何在？</h3><p>分析过程</p><p>检查程序执行过程中有没有涉及到文件的操作？<br>lsof -p 28161| grep test.csv</p><p>查看文件的缓存命中情况<br>pcstat /app/tools/test-tool/data/test.csv</p><p>记录测试结果</p><p>清除文件缓存<br>echo 1 &gt; /proc/sys/vm/drop_caches</p><p>查看缓存命中情况</p><p>记录测试结果</p><p>结论：由于文件缓存的作用，性能提升了10倍左右！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spark-sql&gt; </span><br><span class="line">CREATE table csv</span><br><span class="line">USING csv</span><br><span class="line">OPTIONS (</span><br><span class="line"> header true,</span><br><span class="line">  path &quot;/app/tools/test-tool/data/test.csv&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">spark-sql&gt;</span><br><span class="line">select * from csv where name=&#x27;nam9876&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在另一个terminal执行：</span><br><span class="line"># echo 1 &gt; /proc/sys/vm/drop_caches </span><br></pre></td></tr></table></figure><h3 id="调优方法"><a href="#调优方法" class="headerlink" title="调优方法"></a>调优方法</h3><p>应用层面</p><p>尽量使用缓存或者缓冲区来缓存数据</p><p>fluent-bit; flume; spark等</p><p>考虑使用tmpfs替代磁盘目录<br>mount -t tmpfs -o size=1G tmpfs /tftpboot/spark</p><p>系统层面</p><p>减少swap使用，比如减少swappiness大小</p><p>限制进程内存资源</p><p>使用HugePage（大页内存，4k-&gt;2M, 1G等），提高TLB的命中率</p><p>通过 /proc/pid/oom_adj ，调整核心应用的 oom_score<br>范围 【-17，+15】，值越大越被容易杀死</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの嵌入式笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Memory </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 性能调优1——CPU</title>
      <link href="/2024/04/20/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-Linux-CPU-%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98/"/>
      <url>/2024/04/20/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-Linux-CPU-%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：最近的工作中涉及到了太多Linux相关调试方法与原理性的问题，但是前期工作太忙一直没来得及好好学习，仔细钻研，最近项目算是告一段落，因此希望能借此机会精进一下技术并好好总结一些方法与原理</p></blockquote><h1 id="CPU相关性能调试基本原理"><a href="#CPU相关性能调试基本原理" class="headerlink" title="CPU相关性能调试基本原理"></a>CPU相关性能调试基本原理</h1><p>在Linux系统中，影响性能的指标主要为CPU、内存、IO、网络，每个模块都有其特定的调试方式和工具。与CPU相关的主要调试方向为进程和线程、软硬件的中断、和上下文的切换情况。</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程是资源拥有的基本单位，线程是调度的基本单位。进程与线程在内核中使用的结构体都为task_struct，二者间区别主要是进程的pid=tgid，线程的pid！=tgid。</p><p>进程状态：</p><ol><li>TASK_RUNNING 并不是说进程正在运行，而是表示进程在时刻准备运行的状态</li><li>TASK_INTERRUPTIBLE 因等待事件（比如IO事件）而进入睡眠</li><li>TASK_UNINTERRUPTIBLE 因等待事件（比如IO事件）而进入睡眠，不可以被信号唤醒</li></ol><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><h4 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h4><p>普通调度策略</p><blockquote><p>SCHED_NORMAL：普通进程<br>SCHED_BATCH：后台进程<br>SCHED_IDLE：空闲进程</p></blockquote><p>实时调度策略</p><blockquote><p>SCHED_FIFO：高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，先到先得<br>SCHED_RR：高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，轮换着来<br>SCHED_DEADLIN7E</p></blockquote><h4 id="调度优先级"><a href="#调度优先级" class="headerlink" title="调度优先级"></a>调度优先级</h4><p>实时进程：0 ~ 99</p><p>普通进程：100 ~ 139</p><h4 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h4><p>Fair</p><blockquote><p>常用的策略为：SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE</p></blockquote><p>完全公平算法 — CFS</p><blockquote><p>CFS对应的调度策略：SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE。 CFS 会为每一个进程安排一个虚拟运行时间 vruntime。如果一个进程在运行，随着时间的增加，进程的 vruntime 将不断增大。没有得到执行的进程 vruntime 不变。 显然，那些 vruntime 少的，原来受到了不公平的对待，需要给它补上，所以会优先运行这样的进程。 你可能会说，不还有优先级呢？如何给优先级高的进程多分时间呢？按比例！</p></blockquote><p>Real_Time</p><blockquote><p>常用的策略为：SCHED<em>FIFO 和 SCHED</em>RR</p></blockquote><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>硬件中断的处理目前都算比较快，所以目前的调试都不会特别关注硬件中断的过程，主要关注的是软件中断的过程，因为会占用比较大量的时间</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><h3 id="CPU上下文"><a href="#CPU上下文" class="headerlink" title="CPU上下文"></a>CPU上下文</h3><p>包括CPU寄存器和程序计数器</p><blockquote><p>CPU寄存器：是 CPU 内置的容量小、但速度极快的内存<br>程序计数器：是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置(PC指针)</p></blockquote><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/98ac9df2593a193d6a7f1767cd68eb5f.webp.webp" alt="img"></p><ul><li>CPU上下文切换：是先把前一个任务的 CPU 上下文（也就是<strong>CPU 寄存器和程序计数器</strong>）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务</li><li>这些这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来</li></ul><p>根据任务的不同，CPU的上下文切换分为进程上下文切换、线程上下文切换和中断下文切换</p><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</li></ul><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/4d3f622f272c49132ecb9760310ce1a7.webp.webp" alt="img"></p><p>从进程用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成，系统调用的过程中会发生<strong>两次CPU上下文切换</strong>。CPU里原来用户态指令的执行位置需要先保存起来，然后更新为内核态执行的指令位置，最后跳转到内核态运行内核任务。在系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。</p><p><strong>注意</strong>：</p><ol><li><p>系统调用的过程中，不会涉及到虚拟内存等进程态的资源，不会切换进程，系统调用过程和进程上下文切换不一样，整个过程都是同一个进程</p></li><li><p>系统调用称为特权模式切换，不是上下文切换</p></li></ol><p>进程上下文切换和系统调用的区别：</p><p>进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的<strong>虚拟内存、栈</strong>等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/395666667d77e718da63261be478a96b.webp.webp" alt="img"></p><p><strong>保存上下文和恢复上下文的过程需要内核在CPU上运行才能完成</strong>（上下文切换过程是CPU密集型），每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。</p><p>在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在<strong>寄存器、内核栈以及虚拟内存</strong>等资源的保存和恢复上，进而大大缩短了真正运行进程的时间，从而导致系统平均负载升高。</p><p>Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在<strong>多处理器系统</strong>上，缓存是被多个处理器<strong>共享</strong>的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p><p>Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是<strong>优先级最高和等待 CPU 时间最长</strong>的进程来运行。</p><p>进程被CPU重新调度的时机：</p><ol><li>进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行</li><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行</li><li>进程在系统<strong>资源</strong>不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行</li><li>进程通过睡眠函数  sleep 这样的方法将自己主动挂起时，自然也会重新调度</li><li>有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3>线程和进程的区别：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</li></ol><p>所谓内核中的任务调度，实际上的调度对象是<strong>线程</strong>；而进程只是给线程提供了虚拟内存、全局变量等资源。</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的</li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的</li></ul><p>因此，线程的上下文切换分为两种情况：</p><ol><li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样</li><li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的<strong>私有数据、寄存器</strong>等不共享的数据</li></ol><p><strong>注意</strong>：同进程的线程切换要比进程间的切换消耗更少的资源，更加轻量级</p><h3 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h3><p>为了响应硬件事件，<strong>中断处理会打断进程的正常调度和执行</strong>，转而调用中断处理程序，响应设备事件。</p><p>中断上下文切换不会涉及到进程的用户态，它其实只包括内核态中断服务程序执行所必需的状态，包括<strong>CPU 寄存器、内核堆栈、硬件中断参数</strong>等</p><p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以<strong>中断上下文切换并不会与进程上下文切换同时发生</strong></p><p>大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能</p><h1 id="性能指标1——CPU使用率"><a href="#性能指标1——CPU使用率" class="headerlink" title="性能指标1——CPU使用率"></a>性能指标1——CPU使用率</h1><p>CPU的使用率，就是一段时间内有进程在CPU上运行的时间占总时间的比例，包含：用户CPU、系统CPU、iowait、硬件中断、软件中断等。</p><h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top工具的输出一般像下面这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line">top - 23:50:38 up  5:13,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 355 total,   1 running, 257 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  0.1 us,  0.0 sy,  0.0 ni, 99.9 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem : 16350296 total, 12577212 free,  1452916 used,  2320168 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2097148 free,        0 used. 14469300 avail Mem </span><br><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR  S  %CPU %MEM     TIME+ COMMAND    </span><br><span class="line">1477 embedfi+  20   0  897564 268572  90336 S   0.7  1.6   0:06.02 Xorg  </span><br></pre></td></tr></table></figure><blockquote><p>top的输出：<br>us: un-niced用户进程使用的cpu时间；<br>sy：系统的内核进程<br>ni: 被调整过nice值的进程占用的CPU使用率；<br>wa:就是IO-wait；<br>hi:hardware Interrupt<br>si:software interrupt</p></blockquote><h3 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h3><blockquote><p>mpstat的输出和top不一样：<br>%usr: 用户进程使用的cpu时间（包含un-niced和niced）；<br>%nice: niced用户进程使用的cpu时间</p></blockquote><p>显示所有CPU的指标，每秒一次<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 1</span><br></pre></td></tr></table></figure></p><h3 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h3><blockquote><p>pidstat输出:<br>%user表示用户进程使用的cpu时间（包含un-niced和niced）；<br>%wait表示任务等待运行时所占用的CPU百分比。</p></blockquote><p>显示所有进程的CPU指标，每秒一次:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u 1</span><br></pre></td></tr></table></figure><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><h3 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h3><p>实时显示CPU时钟占用最多的函数或指令</p><p>平均负载最理想的指标值是等于CPU的个数。</p><h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><ol><li>us cpu 占用高，说明用户态进程占用了较多cpu，着重排查应用程序本身的代码逻辑问题；</li><li>sy cpu占用高，说明内核态代码占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题；</li><li>wa cpu占用高，说明等待 I/O 完成所花的时间比较长，所以应该着重排查linux系统是不是存在IO相关的性能瓶颈；</li><li>hi和si占用高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重排查内核中的中断服务程序，一般是网络；</li><li>系统整体cpu使用较高，而实际的单个进程的cpu使用都不高，要考虑短时进程是否被频繁创建和销毁；</li></ol><h1 id="性能指标2——平均负载"><a href="#性能指标2——平均负载" class="headerlink" title="性能指标2——平均负载"></a>性能指标2——平均负载</h1><p>平均负载是指单位时间内，系统处于可运行状态（Running）和不可中断等待状态（uninterruptible）的平均进程数</p><p>平均负载为3，意味着：<br>１、在只有3个CPU 的系统上，意味着所有的CPU都刚好被进程完全占用；<br>２、在6个CPU的系统上，意味着CPU有50% 的空闲；<br>３、在只有1个CPU 的系统中，则意味着2/3的进程竞争不到CPU；</p><p>平均负载是一个综合性的指标，需要通过整体变化趋势来看系统是否有压力</p><h2 id="相关工具-1"><a href="#相关工具-1" class="headerlink" title="相关工具"></a>相关工具</h2><p>uptime</p><p>top</p><p>dstat -y</p><h2 id="调优技巧"><a href="#调优技巧" class="headerlink" title="调优技巧"></a>调优技巧</h2><ol><li>平均负载高可能是cpu密集型进程导致的；</li><li>平均负载高并不一定代表 CPU 使用率高，还有可能是等待I/O的进程变多了；</li><li>平均负载高的时候，需要辅助其他的工具来做进一步的分析；</li></ol><h1 id="性能指标3——上下文切换"><a href="#性能指标3——上下文切换" class="headerlink" title="性能指标3——上下文切换"></a>性能指标3——上下文切换</h1><p>如果系统的上下文切换次数比较稳定，那么理想数据是１万以内</p><h2 id="相关工具-2"><a href="#相关工具-2" class="headerlink" title="相关工具"></a>相关工具</h2><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><blockquote><p>cs列：系统每秒上下文切换的次数。<br>r列：处于可运行态的进程数量<br>b列：处于不可中断睡眠状态的进程数量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔5s输出一组数据</span></span><br><span class="line">[root@VM_194_74_centos ~]<span class="comment"># vmstat 5 5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy <span class="built_in">id</span> wa st</span><br><span class="line"> 1  0      0 118120 1188128 13137072    0    0     0    10    0    0  3  1 97  0  0</span><br><span class="line"> 1  0      0 117040 1188128 13137080    0    0     0    22 1071 1311  1  0 99  0  0</span><br><span class="line"> 0  0      0 116824 1188128 13137092    0    0     0    13 1181 1421  1  0 99  0  0</span><br><span class="line"> 0  0      0 117328 1188128 13137100    0    0     0    12 1165 1374  1  0 99  0  0</span><br><span class="line"> 1  0      0 117168 1188128 13137112    0    0     0    22 1148 1391  1  0 99  0  0</span><br></pre></td></tr></table></figure></p></blockquote><p>参数：</p><ul><li><code>cs</code>：context switch，每秒上下文切换的次数</li><li><code>in</code>：interrupt ，每秒中断的次数</li><li><code>r</code>：就绪队列的长度（正在运行和等待CPU的进程数）</li><li><code>b</code>：blocked，处于不可中断睡眠状态的进程数<h3 id="pidstat-1"><a href="#pidstat-1" class="headerlink" title="pidstat"></a>pidstat</h3></li></ul><p>显示进程的每秒自愿和非自愿上下文切换次数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pidstat -w</span></span><br></pre></td></tr></table></figure><br>命令：pidstat<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ [root@VM_194_74_centos ~]<span class="comment"># pidstat -w 5</span></span><br><span class="line">Linux 3.10.107-1-tlinux2_kvm_guest-0049 (VM_194_74_centos)      05/07/20        _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">08:20:54      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:20:59        0         1      0.80      0.00  systemd</span><br><span class="line">08:20:59        0         7      0.80      0.00  migration/0</span><br><span class="line">08:20:59        0         9     90.40      0.00  rcu_sched</span><br><span class="line">08:20:59        0        10      0.20      0.00  watchdog/0</span><br><span class="line">08:20:59        0        11      0.20      0.00  watchdog/1</span><br><span class="line">08:20:59        0        12      2.00      0.00  migration/1</span><br><span class="line">08:20:59        0        16      0.20      0.00  watchdog/2</span><br><span class="line">08:20:59        0        17      1.00      0.00  migration/2</span><br><span class="line">08:20:59        0        18      0.20      0.00  ksoftirqd/2</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>参数：</p><ul><li>cswch：每秒自愿上下文切换的次数（voluntary context switch）</li><li>nvcswch：每秒非自愿上下文切换的次数(non voluntary context switch)</li></ul><blockquote><p>自愿上下文切换：进程无法获取所需资源导致的上下文切换，比如I/O，内存等<strong>系统资源不足</strong>时发生的上下文切换</p><p>非自愿上下文切换：进程因<strong>时间片</strong>已到等原因，被系统强制<strong>调度</strong>发生的上下文切换，比如多个进程<strong>竞争</strong>CPU是发生的上下文切换</p></blockquote><p>/proc/interrupts</p><p>/proc/softirqs</p><h2 id="调优技巧-1"><a href="#调优技巧-1" class="headerlink" title="调优技巧"></a>调优技巧</h2><blockquote><p>如果进程的自愿上下文切换多了，表示进程在等待资源；<br>如果进程的非自愿上下文切换多了，说明进程在被强制调度（被实时性更高的进程抢占）；<br>如果中断次数多了，说明中断处理程序在占用大量的cpu;<br>如果软中断次数多了，说明下半部处理程序在占用大量的cpu，一般是网络；</p></blockquote><h1 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h1><h2 id="top-1"><a href="#top-1" class="headerlink" title="top"></a>top</h2><p>数据及指标</p><blockquote><p>us: 代表用户态cpu时间，不包含被调 整过nice值的进程所占的cpu时间；<br>ni: 代表被调整过nice值的进程占用的cpu时间；　<br>sy: 代表内核态cpu时间<br>id: 空闲时间，注意，它不包括等待 I/O 的时间（iowait）<br>wa: 代表等待I/O的cpu时间<br>hi: 代表硬件中断占据的cpu时间<br>si: 代表软件中断占据的cpu时间</p></blockquote><p>[例子]</p><blockquote><p>１、stress命令起1个进程：<br>stress -c 1<br>2、top查看<br>3、renice<br>renice -n 5 -p 26205<br>4、top查看可见进程26205的cpu用量由原来的统计到us变成了统计到ni上</p></blockquote><h3 id="可添加的参数"><a href="#可添加的参数" class="headerlink" title="可添加的参数"></a>可添加的参数</h3><blockquote><p>-p {pid}：只显示某个进程的状态</p><p>以下内容中【交互】表示使用top命令实时显示数据时输入对应的选项会将实时显示的数据进行对应的变化</p><p>【交互】h: 显示帮助<br>【交互】c: 切换显示完整的命令行<br>【交互】M：根据常驻内存(RES)用量进行排序<br>【交互】P: 根据CPU使用百分比大小进行排序<br>【交互】S：切换到累加模式<br>【交互】T：根据时间或者累计时间进行排序(TIME+列)<br>【交互】s：改变两次刷新的延迟时间，默认是3s<br>【交互】r：修改某个进程的nice值（对应top的NI列）</p></blockquote><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>显示所有进程：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><br>显示所有线程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf或ps -eTf</span><br></pre></td></tr></table></figure><p>ps统计的是进程的整个生命周期，top是实时的消耗，默认是三秒内</p><p>ps的可选项：</p><blockquote><p>-e：选择所有进程</p><p>-o：用于设定输出格式<br>例如： -o stat,ppid,pid,cmd 表示只输出进程的stat(状态信息)、ppid(父进程pid)、pid（当前进程的pid)，cmd(即进程的可执行文件）<br>-L Show threads, possibly with LWP and NLWP columns<br>-T Show threads, possibly with SPID column<br>-m Show threads after processes.<br>-f 全格式输出<br>-a 选择所有进程，除了session leader(见getsid(2))和与terminal不相关的进程。<br>-A, 选择所有进程（同-e）</p></blockquote><h2 id="mpstat-1"><a href="#mpstat-1" class="headerlink" title="mpstat"></a>mpstat</h2><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><h3 id="mpstat-P-ALL-1"><a href="#mpstat-P-ALL-1" class="headerlink" title="mpstat -P ALL 1"></a>mpstat -P ALL 1</h3><h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>前提条件： 1. sudo vi /etc/default/sysstat　　//把false修改为true 2. sudo service sysstat restart　　//重启sysstat服务</p><h2 id="pidstat-2"><a href="#pidstat-2" class="headerlink" title="pidstat"></a>pidstat</h2><blockquote><p>％usr: 进程在用户态执行的cpu时间 %system: 进程在内核态执行的cpu时间 %wait: 进程等待运行时所花费的CPU时间</p></blockquote><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>每隔１秒输出一组进程的cpu数据： <code>$ pidstat -u 1</code></p><blockquote><p>-p {pid} 指定查看某个进程的信息<br>-U {usrname} 显示属于这个用户的进程<br>-r：内存</p><p>-d: IO<br>kB_rd/s：该进程每秒从磁盘读取的数据大小<br>kB_wr/s：该进程每秒写入磁盘的数据大小<br>kB_ccwr/s：每秒取消的写请求数据大小</p><p>iodelay：块 I/O 延迟，包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期。</p><p>-u: cpu（默认）</p><p>-R: 进程的realtime priority and scheduling policy</p><p>-w：进程的上下文切换信息</p><p>cswch/s：每秒自愿进行上下文切换的次数</p><p>１、所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换； ２、而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。<br>nvcswch/s：表示每秒非自愿上下文切换的次数</p><p>-v：进程相关的线程数和文件描述符数量</p><p>-s：进程stack所用内存信息</p></blockquote><h2 id="perf-1"><a href="#perf-1" class="headerlink" title="perf"></a>perf</h2><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><p>perf list：<br>列出所有能够触发perf采样点的事件，类似/sys/kernel/debug/tracing/available_events的输出<br>实测发现，perf 支持的事件要比ftrace多一倍左右。</p><p>perf probe：<br>定义新的动态tracepoint</p><blockquote><p>—add：添加一个probe event</p><p>例如：perf probe —add do_sys_open<br>—del：删除probe event<br>例如：perf probe —del probe:do_sys_open<br>例子：perf record -e probe:do_sys_open -aR sleep 10</p></blockquote><p>perf trace：<br>类似strace，不过性能更佳，例如：perf trace ls</p><p>perf stat：<br>运行命令并收集性能统计信息</p><p>perf top：<br>可以实时查看当前系统进程函数占用率情况</p><p>perf record：<br>运行命令并保存profile到perf.data</p><blockquote><p>-p {pid} 记录进程的events<br>-a：从所有cpu上进行采集<br>-e {event}：指定PMU（处理器监控单元） event ，默认是cycles:ppp（CPU周期数）<br>-g：启用调用图(堆栈链/回溯)记录<br>-F {freq}：采样频率</p><p>例如：<br>perf record -p 12069 -a -g -F 99 — sleep 10<br>perf record -p 12069 -a -g -F 999 — sleep 10<br>perf record -g -e cpu-clock ./perftest </p></blockquote><p>perf report：<br>从perf.data读取并显示profile</p><blockquote><p>—no-children：不统计Children开销</p><blockquote><p>Self：Self 记录的是最后一列的符号（可以理解为函数）本身的采样数占总采样数的百分比<br>目的：找到最底层的热点函数</p><p>Children：记录的是这个符号调用的其他符号（理解为子函数，包括直接调用和间接调用）的采样数之和占总采样数的百分比<br>目的：找到较高层的热点函数</p></blockquote></blockquote><p>perf script：<br>从perf.data读取并显示详细的采样数据</p><p>perf kmem：<br>跟踪/测量内核内存属性</p><blockquote><p>record：记录kmem events</p><blockquote><p>—slab：记录slab申请器的events</p><p>—page：记录page 申请器的events</p></blockquote><p>stat：报告内核内存统计信息</p><blockquote><p>—slab：统计slab申请器的events</p><p>—page：统计page 申请器的events</p></blockquote></blockquote><p>perf mem：<br>分析内存访问</p><p>perf lock：<br>分析锁性能</p><p>perf kvm：<br>针对kvm虚拟化分析</p><p>perf sched：<br>分析内核调度器性能</p><blockquote><p>record：采集和记录scheduling events</p><blockquote><p>例如（全局）：perf sched record — sleep 10<br>例如（进程）：perf sched record -p 752 — sleep 10</p></blockquote><p>script：报告采集到的事件</p><p>latency：报告每个任务的调度延迟和进程的其他调度属性</p><p>timehist：提供调度事件的分析报告</p></blockquote><p>火焰图</p><p>火焰图的横轴和纵轴的含义： - 横轴表示采样数和采样比例。一个函数占用的横轴越宽，就代表它的执行时间越长。同一层的多个函数，则是按照字母来排序。 - 纵轴表示调用栈，由下往上根据调用关系逐个展开。换句话说，上下相邻的两个函数中，下面的函数，是上面函数的父函数。这样，调用栈越深，纵轴就越高。 火焰图不包含任何时间的因素，所以并不能看出横向各个函数的执行次序。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>寻找热点函数，定位性能瓶颈</p><p>具体实现是对事件进行采样，然后再根据采样数，评估各个函数的调用频率，</p><p>perf 可以用来分析 CPU cache、CPU 迁移、分支预测、指令周期等各种硬件事件</p><p>perf 也可以只对感兴趣的事件进行动态追踪</p><p>实践过程</p><p>寻找热点函数，定位性能瓶颈</p><p>自定义追踪函数</p><p>1、添加 do_sys_open 探针 $ perf probe —add do_sys_open 2、采样和追踪 $ perf record -e probe:do_sys_open -aR sleep 1 3、查看采样结果 $ perf script 4、删除探针 $ perf probe —del probe:do_sys_open</p><h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><h3 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h3><p>经典用法： $ pstree -p 5638 显示5638这个进程的进程树（包含线程） $ pstree -T -p 5638 显示5638这个进程的进程树（不包含线程）</p><blockquote><p>-a 显示命令行参数  If the command line of a process is swapped out，则该进程将显示在括号中，例如类似这样： -{kubeensaas}(8)</p><p>-c 禁止压缩子树（压缩后不显示子树信息）</p><p>-n 通过pid而不是name对相同祖先的进程排序</p><p>-g 显示PGIDs</p><p>-p 显示某个进程的进程树（包含线程）</p><p>-T 隐藏线程、只显示进程</p></blockquote><h2 id="taskset"><a href="#taskset" class="headerlink" title="taskset"></a>taskset</h2><h3 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h3><p>-pc 0x3 {pid}：绑定cpu0和cpu1到进程</p><p>-pc {pid}：查看进程绑定的cpu(输出为３，也就是011，表示第０，１个cpu)</p><h2 id="cpulimit"><a href="#cpulimit" class="headerlink" title="cpulimit"></a>cpulimit</h2><h3 id="用法-5"><a href="#用法-5" class="headerlink" title="用法"></a>用法</h3><p>-p {pid} -l {percent}：进程允许的cpu用量为percent%</p><p>-k：如果进程cpu超量，直接杀掉进程而不是限制cpu使用(默认)；</p><p>-m：输出统计信息；</p><h2 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h2><p>$ pstack 11613 11613: ./jin pstack: Input/output error failed to read target. 【解决】 参考此处： <a href="https://blog.csdn.net/u010164190/article/details/111059283">https://blog.csdn.net/u010164190/article/details/111059283</a></p><h3 id="用法-6"><a href="#用法-6" class="headerlink" title="用法"></a>用法</h3><p>pstack｛pid｝对指定PID的进程输出函数调用栈</p><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p>应用并未崩溃，如何查看stack trace信息？</p><h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><h3 id="用法-7"><a href="#用法-7" class="headerlink" title="用法"></a>用法</h3><blockquote><p>-p {pid｝<br>-f 跟踪子进程<br>-t 在输出中的每一行前加上时间信息<br>-T 显示每一个系统调用所耗的时间<br>-c 统计每一个系统调用的调用次数、错误次数、执行时间和执行时间占比</p></blockquote><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p>正在运行的程序实际读取的是哪个配置文件？</p><p>程序好像hang住了，具体是什么情况，为什么hang住？hang在了哪里？</p><p>进程运行很慢，但是没有源代码，想看看时间都花在了哪里？</p><p>容器环境下，如何对应用程序的网络行为进行调试和追踪？</p><h2 id="stap"><a href="#stap" class="headerlink" title="stap"></a>stap</h2><h3 id="用法-8"><a href="#用法-8" class="headerlink" title="用法"></a>用法</h3><p>stap —all-modules dropwatch.stp</p><h2 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h2><p>用法</p><p>通过子进程的Pid得到父进程的Pid：<code>cat /proc/&#123;pid&#125;/status | grep PPid</code></p><h1 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h1><h2 id="用户cpu使用率较高-checklist"><a href="#用户cpu使用率较高-checklist" class="headerlink" title="用户cpu使用率较高 checklist"></a>用户cpu使用率较高 checklist</h2><p>分析过程</p><ol><li>通过top命令查看系统整体的cpu使用率和平均负载</li><li>pidstat -u 1| more 查看进程的cpu使用率，找到可疑进程</li><li>pstree -p {pid}查看进程的进程结构（继承关系）</li><li>strace -f -p {pid} 追踪进程的系统调用情况，是否存在频繁的系统调用？</li><li>pstack {pid}找到代码瓶颈点</li></ol><h2 id="软中断cpu使用率较高，Checklist"><a href="#软中断cpu使用率较高，Checklist" class="headerlink" title="软中断cpu使用率较高，Checklist"></a>软中断cpu使用率较高，Checklist</h2><p>分析过程</p><ol><li>通过top命令查看系统整体的cpu使用率和平均负载</li><li>watch -d cat /proc/softirqs 找到瓶颈所在的软件中断</li><li>perf record -g 采集内核事件</li><li>perf report分析事件，找到瓶颈所在的内核函数代码</li></ol><h2 id="cpu使用率较高，Checklist"><a href="#cpu使用率较高，Checklist" class="headerlink" title="cpu使用率较高，Checklist"></a>cpu使用率较高，Checklist</h2><p>分析过程</p><ol><li>通过top命令查看系统整体的cpu使用率和平均负载</li><li>pidstat -u 1| more<br>查看进程的cpu使用率，找到可疑进程</li><li>iostat查看系统整体的I/O情况</li><li>iotop查看进程的I/O压力情况</li><li>strace -f -p {pid} 追踪进程的系统调用情况，是否存在频繁的系统调用？</li></ol><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p><code>sysbench</code>模拟多线程调度切换</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><blockquote><p>一台Linux机器，打开三个终端</p></blockquote><h3 id="正式实战"><a href="#正式实战" class="headerlink" title="正式实战"></a>正式实战</h3><ol><li><p>第一个终端：运行<code>sysbench</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以10个线程运行5分钟的基准测试，模拟多线程切换的问题</span><br><span class="line">$ sysbench --threads=10 --max-time=300 threads run</span><br></pre></td></tr></table></figure></li><li><p>第二个终端：运行<code>vmstat</code></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔1秒输出1组数据（需要Ctrl+C才结束）</span></span><br><span class="line">$ vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy <span class="built_in">id</span> wa st</span><br><span class="line"> 6  0      0 6487428 118240 1292772    0    0     0     0 9019 1398830 16 84  0  0  0</span><br><span class="line"> 8  0      0 6487428 118240 1292772    0    0     0     0 10191 1392312 16 84  0  0  0</span><br></pre></td></tr></table></figure><p>指标观察：</p><ul><li><p>cs列：上升到39万</p></li><li><p>r列：就绪队列长度上升到8</p></li><li>in列：终端次数上升到1万</li><li>us（user）和sy（system）列：使用率加起来100%，sy为84%，主要被内核占用</li></ul><ol><li>查看进程情况<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 每隔1秒输出1组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标</span></span><br><span class="line">$ pidstat -w -u 1</span><br><span class="line">08:06:33      UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">08:06:34        0     10488   30.00  100.00    0.00    0.00  100.00     0  sysbench</span><br><span class="line">08:06:34        0     26326    0.00    1.00    0.00    0.00    1.00     0  kworker/u4:2</span><br><span class="line"></span><br><span class="line">08:06:33      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:06:34        0         8     11.00      0.00  rcu_sched</span><br><span class="line">08:06:34        0        16      1.00      0.00  ksoftirqd/1</span><br><span class="line">08:06:34        0       471      1.00      0.00  hv_balloon</span><br><span class="line">08:06:34        0      1230      1.00      0.00  iscsid</span><br><span class="line">08:06:34        0      4089      1.00      0.00  kworker/1:5</span><br><span class="line">08:06:34        0      4333      1.00      0.00  kworker/0:3</span><br><span class="line">08:06:34        0     10499      1.00    224.00  pidstat</span><br><span class="line">08:06:34        0     26326    236.00      0.00  kworker/u4:2</span><br><span class="line">08:06:34     1000     26784    223.00      0.00  sshd</span><br></pre></td></tr></table></figure></li></ol><p><strong>分析</strong>：CPU 使用率的升高果然是 sysbench 导致的，它的 CPU 使用率已经达到了 100%。但上下文切换则是来自其他进程，包括非自愿上下文切换频率最高的 pidstat  ，以及自愿上下文切换频率最高的内核线程 kworker 和 sshd</p><p><strong>注意</strong>：pidstat 输出的上下文切换次数，加起来也就几百，比 vmstat 的 139 万明显小了太多？</p><ol><li>查看线程的情况</li></ol><p>可以看到，sysbench 进程（也就是主线程）的上下文切换次数看起来并不多，但它的子线程的上下文切换次数却有很多。上下文切换罪魁祸首，还是过多的 sysbench 线程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔1秒输出一组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -wt 参数表示输出线程的上下文切换指标</span></span><br><span class="line">$ pidstat -wt 1</span><br><span class="line">08:14:05      UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">...</span><br><span class="line">08:14:05        0     10551         -      6.00      0.00  sysbench</span><br><span class="line">08:14:05        0         -     10551      6.00      0.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10552  18911.00 103740.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10553  18915.00 100955.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10554  18827.00 103954.00  |__sysbench</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol><li>查看中断升高的原因<br>根据前文的分析，中断次数也升高到了1万左右，从/proc/interrupts只读文件查看中断情况<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 参数表示高亮显示变化的区域</span></span><br><span class="line">$ watch -d <span class="built_in">cat</span> /proc/interrupts</span><br><span class="line">           CPU0       CPU1</span><br><span class="line">...</span><br><span class="line">RES:    2450431    5279697   Rescheduling interrupts</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p>观察发现，变化速度最快的是<strong>重调度中断（RES）</strong>，它代表唤醒空闲状态的 CPU 来调度新的任务运行，这是在多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为<strong>处理器间中断</strong>（Inter-Processor Interrupts，IPI）</p><p><strong>分析</strong>：过多任务导致了重调度中断的升高，和前面分析结果一致</p><h3 id="每秒上下文切换多少次正常？"><a href="#每秒上下文切换多少次正常？" class="headerlink" title="每秒上下文切换多少次正常？"></a>每秒上下文切换多少次正常？</h3><p><strong>上下文切换次数取决于系统本身的CPU性能</strong>。如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题，这时根据具体上下文切换的类型具体分析：</p><ul><li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题</li><li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈</li><li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型</li></ul><h3 id="系统出现大量不可中断进程和僵尸进程怎么办？"><a href="#系统出现大量不可中断进程和僵尸进程怎么办？" class="headerlink" title="系统出现大量不可中断进程和僵尸进程怎么办？"></a>系统出现大量不可中断进程和僵尸进程怎么办？</h3><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><ul><li><p><strong>R</strong>：表示正在就绪队列中的进程，正在运行或者正在等待运行</p></li><li><p><strong>D</strong>：Disk Sleep，不可中断状态睡眠（Uninterruptible Sleep），一般是进程和硬件交互，并且交互过程不允许其他进程或中断打断</p></li><li><p><strong>Z</strong> ：Zombie 的缩写，它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）</p></li><li><p><strong>S</strong> ：Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态</p></li><li><p><strong>I</strong>： Idle 的缩写，也就是空闲状态，用在<strong>不可中断睡眠的内核线程</strong>上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会</p></li><li><p><strong>T</strong>：Stopped或者Traced，表示进程处于暂停或者跟踪状态（SIGSTOP信号会让进程变为暂停状态，再发送SIGCONT信号，进程又会恢复运行）</p></li><li><p><strong>X</strong>：Dead，表示进程已经消亡，top或者ps看不到</p></li></ul><blockquote><p>不可中断状态，是为了保证进程数据与硬件状态一致，正常情况下，不可中断状态在很短时间内就会结束。短时的不可中断状态进程，我们一般可以忽略。</p><p>但如果系统或硬件发生了故障，进程可能会在不可中断状态保持很久，甚至导致系统中出现大量不可中断进程。需要注意下，系统是不是出现了 I/O 等性能问题。</p></blockquote><p><strong>注意</strong>：ps查看进程状态时，会有Ss+，D+等情况，其中s表示进程是会话的领导进程，+表示前台进程组</p><h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="指标分析"><a href="#指标分析" class="headerlink" title="指标分析"></a>指标分析</h5><ol><li>运行案例的docker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --privileged --name=app -itd feisky/app:iowait</span><br></pre></td></tr></table></figure><ol><li>top查看指标</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按下数字 1 切换到所有 CPU 的使用情况，观察一会儿按 Ctrl+C 结束</span></span><br><span class="line">$ top</span><br><span class="line">top - 05:56:23 up 17 days, 16:45,  2 <span class="built_in">users</span>,  load average: 2.00, 1.68, 1.39</span><br><span class="line">Tasks: 247 total,   1 running,  79 sleeping,   0 stopped, 115 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  0.7 sy,  0.0 ni, 38.9 <span class="built_in">id</span>, 60.5 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  0.7 sy,  0.0 ni,  4.7 <span class="built_in">id</span>, 94.6 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 4340 root      20   0   44676   4048   3432 R   0.3  0.0   0:00.05 top</span><br><span class="line"> 4345 root      20   0   37280  33624    860 D   0.3  0.0   0:00.01 app</span><br><span class="line"> 4344 root      20   0   37280  33624    860 D   0.3  0.4   0:00.01 app</span><br><span class="line">    1 root      20   0  160072   9416   6752 S   0.0  0.1   0:38.59 systemd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol><li>分析</li></ol><ul><li>第一行的平均负载（ Load Average），过去 1 分钟、5 分钟和 15 分钟内的平均负载在依次减小，说明平均负载正在升高；而 1 分钟内的平均负载已经达到系统的 CPU 个数，说明系统很可能已经有了性能瓶颈。</li><li>第二行的 Tasks，有 1 个正在运行的进程，但僵尸进程比较多，而且还在不停增加，说明有子进程在退出时没被清理。</li><li>CPU 的使用率情况，用户 CPU 和系统 CPU 都不高，但 iowait 分别是 60.5% 和 94.6%，好像有点儿不正常。</li><li>最后再看每个进程的情况， CPU 使用率最高的进程只有 0.3%，看起来并不高；但有两个进程处于 D 状态，它们可能在等待 I/O，但光凭这里并不能确定是它们导致了 iowait 升高。</li></ul><ol><li>结论</li></ol><ul><li>第一点，iowait 太高了，导致系统的平均负载升高，甚至达到了系统 CPU 的个数</li><li>第二点，僵尸进程在不断增多，说明有程序没能正确清理子进程的资源。</li></ul><h5 id="iowait分析"><a href="#iowait分析" class="headerlink" title="iowait分析"></a>iowait分析</h5><ol><li>dstat查看系统I/O情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔1秒输出10组数据</span></span><br><span class="line">$ dstat 1 10</span><br><span class="line">You did not <span class="keyword">select</span> any stats, using -cdngy by default.</span><br><span class="line">--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai stl| <span class="built_in">read</span>  writ| recv  send|  <span class="keyword">in</span>   out | int   csw</span><br><span class="line">  0   0  96   4   0|1219k  408k|   0     0 |   0     0 |  42   885</span><br><span class="line">  0   0   2  98   0|  34M    0 | 198B  790B|   0     0 |  42   138</span><br><span class="line">  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  42   135</span><br><span class="line">  0   0  84  16   0|5633k    0 |  66B  342B|   0     0 |  52   177</span><br><span class="line">  0   3  39  58   0|  22M    0 |  66B  342B|   0     0 |  43   144</span><br><span class="line">  0   0   0 100   0|  34M    0 | 200B  450B|   0     0 |  46   147</span><br><span class="line">  0   0   2  98   0|  34M    0 |  66B  342B|   0     0 |  45   134</span><br><span class="line">  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  39   131</span><br><span class="line">  0   0  83  17   0|5633k    0 |  66B  342B|   0     0 |  46   168</span><br><span class="line">  0   3  39  59   0|  22M    0 |  66B  342B|   0     0 |  37   134</span><br></pre></td></tr></table></figure><p>可以看到，每当 iowait 升高（wai）时，磁盘的读请求（read）都会很大。这说明 iowait 的升高跟磁盘的读请求有关，很可能就是磁盘读导致的</p><ol><li>pidstat分析D状态的进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 展示 I/O 统计数据，-p 指定进程号，间隔 1 秒输出 3 组数据</span></span><br><span class="line">$ pidstat -d -p 4344 1 3</span><br><span class="line">06:38:50      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:38:51        0      4344      0.00      0.00      0.00       0  app</span><br><span class="line">06:38:52        0      4344      0.00      0.00      0.00       0  app</span><br><span class="line">06:38:53        0      4344      0.00      0.00      0.00       0  app</span><br></pre></td></tr></table></figure><ul><li>kB_rd 表示每秒读的 KB 数</li><li>kB_wr 表示每秒写的 KB 数</li><li>iodelay 表示 I/O 的延迟（单位是时钟周期）。</li><li>它们都是 0，那就表示此时没有任何的读写，说明问题不是 4344 进程导致的。</li></ul><ol><li>pidstat查看所有进程情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 1 秒输出多组数据 (这里是 20 组)</span></span><br><span class="line">$ pidstat -d 1 20</span><br><span class="line">...</span><br><span class="line">06:48:46      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:47        0      4615      0.00      0.00      0.00       1  kworker/u4:1</span><br><span class="line">06:48:47        0      6080  32768.00      0.00      0.00     170  app</span><br><span class="line">06:48:47        0      6081  32768.00      0.00      0.00     184  app</span><br><span class="line"></span><br><span class="line">06:48:47      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:48        0      6080      0.00      0.00      0.00     110  app</span><br><span class="line"></span><br><span class="line">06:48:48      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:49        0      6081      0.00      0.00      0.00     191  app</span><br><span class="line"></span><br><span class="line">06:48:49      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line"></span><br><span class="line">06:48:50      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:51        0      6082  32768.00      0.00      0.00       0  app</span><br><span class="line">06:48:51        0      6083  32768.00      0.00      0.00       0  app</span><br><span class="line"></span><br><span class="line">06:48:51      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:52        0      6082  32768.00      0.00      0.00     184  app</span><br><span class="line">06:48:52        0      6083  32768.00      0.00      0.00     175  app</span><br><span class="line"></span><br><span class="line">06:48:52      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:53        0      6083      0.00      0.00      0.00     105  app</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>观察一会儿可以发现，的确是 app 进程在进行磁盘读，并且每秒读的数据有 32 MB，看来就是 app 的问题。不过，app 进程到底在执行啥 I/O 操作呢？<strong>进程想要访问磁盘，就必须使用系统调用，所以接下来，重点就是找出 app 进程的系统调用</strong></p><ol><li>strace跟踪进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ strace -p 6082</span><br><span class="line">strace: attach: ptrace(PTRACE_SEIZE, 6082): Operation not permitted</span><br></pre></td></tr></table></figure><ul><li>检查一下进程的状态，已经变成僵尸进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep 6082</span><br><span class="line">root      6082  0.0  0.0      0     0 pts/0    Z+   13:43   0:00 [app] &lt;defunct&gt;</span><br></pre></td></tr></table></figure><ol><li>动态追踪</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ perf record -g</span><br><span class="line">$ perf report</span><br></pre></td></tr></table></figure><p>如下图，swapper是内核的调度进程，可忽略</p><p>可以发现， app 的确在通过系统调用 <strong>sys_read()</strong> 读取数据。并且从 new_sync_read 和 blkdev_direct_IO  能看出，进程正在对磁盘进行<strong>直接读</strong>，也就是<strong>绕过了系统缓存</strong>，每个读请求都会从磁盘直接读，这就可以解释我们观察到的 iowait 升高了<br><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/21e79416e946ed049317a4b4c5a576a1.webp.webp" alt="img"></p><ol><li>打开app.py文件，可以看到使用了 O_DIRECT 选项打开磁盘</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(disk, O_RDONLY|O_DIRECT|O_LARGEFILE, 0755)</span><br></pre></td></tr></table></figure><blockquote><p>直接读写磁盘，对 I/O 敏感型应用（比如数据库系统）是很友好的，因为你可以在应用中，直接控制磁盘的读写。但在大部分情况下，我们最好还是通过系统缓存来优化磁盘 I/O</p></blockquote><ol><li>修复代码</li></ol><p>修复后的文件名app-fix1.py，运行docker如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 首先删除原来的应用</span><br><span class="line">$ docker rm -f app</span><br><span class="line"># 运行新的应用</span><br><span class="line">$ docker run --privileged --name=app -itd feisky/app:iowait-fix1</span><br></pre></td></tr></table></figure><p>top检查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ top</span><br><span class="line">top - 14:59:32 up 19 min,  1 user,  load average: 0.15, 0.07, 0.05</span><br><span class="line">Tasks: 137 total,   1 running,  72 sleeping,   0 stopped,  12 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  1.7 sy,  0.0 ni, 98.0 <span class="built_in">id</span>,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  1.3 sy,  0.0 ni, 98.7 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 3084 root      20   0       0      0      0 Z   1.3  0.0   0:00.04 app</span><br><span class="line"> 3085 root      20   0       0      0      0 Z   1.3  0.0   0:00.04 app</span><br><span class="line">    1 root      20   0  159848   9120   6724 S   0.0  0.1   0:09.03 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd</span><br><span class="line">    3 root      20   0       0      0      0 I   0.0  0.0   0:00.40 kworker/0:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="僵尸进程分析"><a href="#僵尸进程分析" class="headerlink" title="僵尸进程分析"></a>僵尸进程分析</h5><blockquote><p>僵尸进程是因为父进程没有回收子进程的资源而出现的，那么，就需要找出父进程，然后在父进程里解决。</p></blockquote><ol><li>pstree</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a 表示输出每个程序完整的命令（包含路径，参数或是常驻服务的标示）</span></span><br><span class="line"><span class="comment"># p指定PID</span></span><br><span class="line"><span class="comment"># s表示显示指定进程的父进程</span></span><br><span class="line">$ pstree -aps 3084</span><br><span class="line">systemd,1</span><br><span class="line">  └─dockerd,15006 -H fd://</span><br><span class="line">      └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml</span><br><span class="line">          └─docker-containe,3991 -namespace moby -workdir...</span><br><span class="line">              └─app,4009</span><br><span class="line">                  └─(app,3084)</span><br></pre></td></tr></table></figure><ol><li>查看app-fix1.py代码</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> status = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fork()== <span class="number">0</span>) &#123;</span><br><span class="line">        sub_process();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(wait(&amp;status)&gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以发现，文件错误地把 wait() 放到了 for 死循环的外面，也就是说，wait() 函数实际上并没被调用到，我们把它挪到 for 循环的里面就可以了。</p><p>修改后的文件我放到了 app-fix2.c ，运行对应的docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先停止产生僵尸进程的 app</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f app</span><br><span class="line"><span class="comment"># 然后启动新的 app</span></span><br><span class="line">$ docker run --privileged --name=app -itd feisky/app:iowait-fix2</span><br></pre></td></tr></table></figure><ol><li><p>top查看</p><p>僵尸进程（Z 状态）没有了， iowait 也是 0，问题解决</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ top</span><br><span class="line">top - 15:00:44 up 20 min,  1 user,  load average: 0.05, 0.05, 0.04</span><br><span class="line">Tasks: 125 total,   1 running,  72 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  1.7 sy,  0.0 ni, 98.3 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  1.3 sy,  0.0 ni, 98.7 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 3198 root      20   0    4376    840    780 S   0.3  0.0   0:00.01 app</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd</span><br><span class="line">    3 root      20   0       0      0      0 I   0.0  0.0   0:00.41 kworker/0:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="怎么理解CPU软中断"><a href="#怎么理解CPU软中断" class="headerlink" title="怎么理解CPU软中断"></a>怎么理解CPU软中断</h3><blockquote><p>中断是一种异步的事件处理机制，可以提高系统的并发处理能力</p><p>为了减少对正常进程运行调度的影响，中断处理程序应该尽快完成</p></blockquote><h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><p>中断过程分为上半部和下半部：</p><ul><li>上半部：用来快速处理中断，它在中断禁止模式下运行，主要处理和<strong>硬件紧密相关</strong>或者<strong>时间敏感</strong>的工作</li><li>下半部：用来延迟处理上半部未完成的工作，通常以<strong>内核线程</strong>的形式运行</li></ul><p>网卡接收数据包的例子：网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。对上半部来说，既然是快速处理，其实就是要把网卡的数据<strong>读到内存</strong>中，然后<strong>更新硬件寄存器的状态</strong>（表示数据已经读好了），最后再发送一个软中断信号，通知下半部做进一步的处理。而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照<strong>网络协议栈</strong>，对数据进行<strong>逐层解析和处理</strong>，直到把它送给应用程序。</p><p>可以理解为：<strong>上半部快速执行，下半部延迟执行</strong></p><h4 id="查看软中断和内核线程"><a href="#查看软中断和内核线程" class="headerlink" title="查看软中断和内核线程"></a>查看软中断和内核线程</h4><ol><li>查看/proc文件系统</li></ol><ul><li>/proc/softirqs，提供了软中断的运行情况</li><li>/proc/interrupts，提供了硬中断的运行情况</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看到各类软中断在不同CPU上累积的运行次数</span></span><br><span class="line">$ <span class="built_in">cat</span> /proc/softirqs</span><br><span class="line">                    CPU0       CPU1</span><br><span class="line">          HI:          0          0</span><br><span class="line">       TIMER:     811613    1972736</span><br><span class="line">      NET_TX:         49          7</span><br><span class="line">      NET_RX:    1136736    1506885</span><br><span class="line">       BLOCK:          0          0</span><br><span class="line">    IRQ_POLL:          0          0</span><br><span class="line">     TASKLET:     304787       3691</span><br><span class="line">       SCHED:     689718    1897539</span><br><span class="line">     HRTIMER:          0          0</span><br><span class="line">         RCU:    1330771    1354737</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>软中断的类型：第一列的内容，对应软中断的类型，比如<strong>NET_TX代表网络接收中断，NET_RX代表网络发送中断，SCHE代表调度，TIMER代表定时器</strong>等等</li><li>每种软中断在不同CPU上的运行情况：同一行的内容，正常情况下，同一种中断在不同CPU上的累计次数应该差不多，比如NET_RX。 而TASKLET只在调用它的函数所在的CPU运行（存在的<strong>问题</strong>：由于只在一个 CPU 上运行导致的调度不均衡，或者因为不能在多个 CPU 上并行运行带来了性能限制）</li></ul><ol><li>软中断以内核线程方式运行，每个CPU都对应一个软中断内核线程（ksoftirqd/CPU编号）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep softirq</span><br><span class="line">root         7  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/0]</span><br><span class="line">root        16  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/1]</span><br></pre></td></tr></table></figure><h3 id="系统的软中断CPU使用率升高，该怎么办？"><a href="#系统的软中断CPU使用率升高，该怎么办？" class="headerlink" title="系统的软中断CPU使用率升高，该怎么办？"></a>系统的软中断CPU使用率升高，该怎么办？</h3><h4 id="案例准备"><a href="#案例准备" class="headerlink" title="案例准备"></a>案例准备</h4><p>工具介绍：</p><ul><li>sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。</li><li>hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等。</li><li>tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题</li></ul><p>案例图示</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image.webp" alt="image.png"></p><p>其中一台虚拟机运行 Nginx ，用来模拟待分析的 Web 服务器；而另一台当作 Web 服务器的客户端，用来给 Nginx 增加压力请求</p><h4 id="操作和分析"><a href="#操作和分析" class="headerlink" title="操作和分析"></a>操作和分析</h4><p>运行Nginx应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行Nginx服务并对外开放80端口</span></span><br><span class="line">$ docker run -itd --name=nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>在另一个终端运行hping3模拟客户端的请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -S参数表示设置TCP协议的SYN（同步序列号），-p表示目的端口为80</span></span><br><span class="line"><span class="comment"># -i u100表示每隔100微秒发送一个网络帧</span></span><br><span class="line"><span class="comment"># 注：如果你在实践过程中现象不明显，可以尝试把100调小，比如调成10甚至1</span></span><br><span class="line">$ hping3 -S -p 80 -i u100 192.168.0.30</span><br></pre></td></tr></table></figure><p>会发现简单的shell命令都变慢了，执行top查看系统整体情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># top运行后按数字1切换到显示所有CPU</span></span><br><span class="line">$ top</span><br><span class="line">top - 10:50:58 up 1 days, 22:10,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 122 total,   1 running,  71 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni, 96.7 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  3.3 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni, 95.6 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  4.4 si,  0.0 st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    7 root      20   0       0      0      0 S   0.3  0.0   0:01.64 ksoftirqd/0</span><br><span class="line">   16 root      20   0       0      0      0 S   0.3  0.0   0:01.97 ksoftirqd/1</span><br><span class="line"> 2663 root      20   0  923480  28292  13996 S   0.3  0.3   4:58.66 docker-containe</span><br><span class="line"> 3699 root      20   0       0      0      0 I   0.3  0.0   0:00.13 kworker/u4:0</span><br><span class="line"> 3708 root      20   0   44572   4176   3512 R   0.3  0.1   0:00.07 top</span><br><span class="line">    1 root      20   0  225384   9136   6724 S   0.0  0.1   0:23.25 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.03 kthreadd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>平均负载全是 0，就绪队列里面只有一个进程（1 running）。</li><li>每个 CPU 的使用率都挺低，最高的 CPU1 的使用率也只有 4.4%，并不算高。</li><li>再看进程列表，CPU 使用率最高的进程也只有 0.3%</li><li>两个 CPU 的使用率虽然分别只有 3.3% 和 4.4%，但都用在了软中断上；而从进程列表上也可以看到，CPU 使用率最高的也是软中断进程 ksoftirqd</li></ul><p>查看软中断变化情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d <span class="built_in">cat</span> /proc/softirqs</span><br><span class="line">                    CPU0       CPU1</span><br><span class="line">          HI:          0          0</span><br><span class="line">       TIMER:    1083906    2368646</span><br><span class="line">      NET_TX:         53          9</span><br><span class="line">      NET_RX:    1550643    1916776</span><br><span class="line">       BLOCK:          0          0</span><br><span class="line">    IRQ_POLL:          0          0</span><br><span class="line">     TASKLET:     333637       3930</span><br><span class="line">       SCHED:     963675    2293171</span><br><span class="line">     HRTIMER:          0          0</span><br><span class="line">         RCU:    1542111    1590625</span><br></pre></td></tr></table></figure><p>可以发现， TIMER（定时中断）、NET_RX（网络接收）、SCHED（内核调度）、RCU（RCU 锁）等这几个软中断都在不停变化，这些中断是保证 Linux 调度、时钟和临界区保护这些正常工作所必需，变化是正常的。而其中的NET_RX，也就是<strong>网络数据包接收软中断</strong>的变化速率最快</p><p>使用sar工具查看网络收发情况(可以观察网络收发吞吐量和PPS)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -n DEV 表示显示网络收发的报告，间隔1秒输出一组数据</span></span><br><span class="line">$ sar -n DEV 1</span><br><span class="line">15:03:46        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">15:03:47         eth0  12607.00   6304.00    664.86    358.11      0.00      0.00      0.00      0.01</span><br><span class="line">15:03:47      docker0   6302.00  12604.00    270.79    664.66      0.00      0.00      0.00      0.00</span><br><span class="line">15:03:47           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">15:03:47    veth9f6bbcd   6302.00  12604.00    356.95    664.66      0.00      0.00      0.00      0.05</span><br></pre></td></tr></table></figure><p>可以发现：</p><ul><li>对网卡 eth0 来说，每秒接收的网络帧数比较大，达到了 12607，而发送的网络帧数则比较小，只有 6304；每秒接收的千字节数只有 664 KB，而发送的千字节数更小，只有 358 KB。</li><li>docker0 和 veth9f6bbcd 的数据跟 eth0 基本一致，只是发送和接收相反，发送的数据较大而接收的数据较小。这是 Linux 内部网桥转发导致的，暂且不用深究，只要知道这是系统把 eth0 收到的包转发给 Nginx 服务即可</li><li>重点来看 eth0 ：接收的 PPS 比较大，达到 12607，而接收的 BPS 却很小，只有 664 KB。直观来看网络帧应该都是比较小的，664<em>1024/12607 = 54 字节，说明平均每个网络帧只有 54 字节，这显然是很小的网络帧，也就是所谓的<em>*小包问题</em></em></li></ul><p>tcpdump抓取eth0上的包，指定TCP协议和80端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -i eth0 只抓取eth0网卡，-n不解析协议名和主机名</span></span><br><span class="line"><span class="comment"># tcp port 80表示只抓取tcp协议并且端口号为80的网络帧</span></span><br><span class="line">$ tcpdump -i eth0 -n tcp port 80</span><br><span class="line">15:11:32.678966 IP 192.168.0.2.18238 &gt; 192.168.0.30.80: Flags [S], <span class="built_in">seq</span> 458303614, win 512, length 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从 tcpdump 的输出中，你可以发现：</p><ul><li>192.168.0.2.18238 &gt; 192.168.0.30.80  ，表示网络帧从 192.168.0.2 的 18238 端口发送到 192.168.0.30 的 80 端口，也就是从运行 hping3 机器的 18238 端口发送网络帧，目的为 Nginx 所在机器的 80 端口。</li><li>Flags [S] 则表示这是一个 SYN 包</li></ul><p><strong>最后，可以确定这是从192.168.0.2.18238来的SYN FLOOF攻击</strong></p><p>SYN FLOOD 问题最简单的解决方法：从交换机或者硬件防火墙中封掉来源 IP，这样 SYN FLOOD 网络帧就不会发送到服务器中（后面的网络篇再进一步深究）</p><h3 id="套路篇：如何迅速分析出CPU的瓶颈在哪里？"><a href="#套路篇：如何迅速分析出CPU的瓶颈在哪里？" class="headerlink" title="套路篇：如何迅速分析出CPU的瓶颈在哪里？"></a>套路篇：如何迅速分析出CPU的瓶颈在哪里？</h3><h4 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h4><p>性能指标总览</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image.webp" alt="image.png"></p><h5 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h5><p>CPU 使用率描述了非空闲时间占总 CPU 时间的百分比，根据 CPU 上运行任务的不同，又被分为用户 CPU、系统 CPU、等待 I/O CPU、软中断和硬中断等。用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态 </p><ul><li>CPU 使用率（nice），表示 CPU 在<strong>用户态</strong>运行的时间百分比。用户 CPU 使用率高，通常说明有<strong>应用程序</strong>比较繁忙。</li><li>系统 CPU 使用率，表示 CPU 在<strong>内核态</strong>运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明<strong>内核</strong>比较繁忙。</li><li>等待 I/O 的 CPU 使用率，通常也称为 <strong>iowait</strong>，表示<strong>等待 I/O</strong> 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互时间比较长。</li><li>软中断和硬中断的 CPU 使用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断。</li><li>除了上面这些，还有在虚拟化环境中会用到的<strong>窃取 CPU 使用率（steal）</strong>和<strong>客户 CPU 使用率（guest）</strong>，分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比。</li></ul><h5 id="平均负载"><a href="#平均负载" class="headerlink" title="平均负载"></a>平均负载</h5><blockquote><p>系统的平均活跃进程数。它反应了系统的整体负载情况，主要包括三个数值，分别指过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。</p><p>理想情况下，平均负载等于逻辑 CPU 个数，这表示每个 CPU 都恰好被充分利用。如果平均负载大于逻辑 CPU 个数，就表示负载比较重了。</p></blockquote><h5 id="进程上下文切换-1"><a href="#进程上下文切换-1" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h5><p>进程上下文切换分为：</p><ol><li>自愿上下文切换</li><li>非自愿上下文切换</li></ol><p><strong>注意</strong>：过多的上下文切换，会将原本运行进程的 CPU 时间，消耗在<strong>寄存器、内核栈以及虚拟内存等数据的保存和恢复</strong>上，缩短进程真正运行的时间，成为性能瓶颈</p><h5 id="CPU缓存命中率"><a href="#CPU缓存命中率" class="headerlink" title="CPU缓存命中率"></a>CPU缓存命中率</h5><p>CPU 缓存的速度介于 CPU 和内存之间，缓存的是<strong>热点的内存数据</strong>。</p><p>如下图，根据不断增长的热点数据，这些缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 常用在单核中， L3 则用在多核中。从 L1 到 L3，三级缓存的大小依次增大，相应的，性能依次降低（当然比内存还是好得多）。而它们的命中率，衡量的是 <strong>CPU 缓存的复用情况</strong>，命中率越高，则表示性能越好。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/aa08816b60e453b52b5fae5e63549e33.webp.webp" alt="img"></p><h4 id="CPU性能工具"><a href="#CPU性能工具" class="headerlink" title="CPU性能工具"></a>CPU性能工具</h4><ul><li>平均负载案例：使用<strong>uptime</strong>查看平均负载，在平均负载升高时，使用<strong>mpstat</strong>和<strong>pidstat</strong>分别观察每个CPU和每个进程CPU的使用情况，找到导致平均负载升高的stress进程</li><li>上下文切换的案例：先使用<strong>vmstat</strong>，查看系统的上下文切换次数和中断次数；然后通过<strong>pidstat</strong>（-w参数）观察进程的自愿上下文切换和非自愿上下文切换；最后通过<strong>vmstat</strong>（-wt参数）查看线程的上下文切换情况，从而找到了线程上下文切换增多的原因是sysbench工具</li><li>进程CPU使用率升高的案例：先使用top找出系统和进程CPU的使用情况，发现了CPU使用率很高的进程php-fpm，再使用perf top找出热点函数sqrt()；如果是Python应用，可以使用profiler工具<strong>pyflame</strong>对指定进程分析（pyflame -p pid —threads -s 检测时间 -r 取样间隔 -o <file.txt>），再通过flamegraph.pl将输出的txt文件转换为*.svg格式的火焰图（./flamegraph.pl prof.txt &gt; prof.svg）</li><li>不可中断进程和僵尸进程的案例：<ul><li>不可中断进程分析过程：先使用top查看，发现存在D状态（不可中断休眠进程）和Z状态（僵尸进程），并且iowait较高；使用<strong>dstat</strong>分析磁盘I/O，发现<strong>app</strong>进程有大量的磁盘读请求；使用<strong>pidstat</strong>(-d -p 参数)分析app进程的I/O操作，发现没有大量的I/O操作，再用pidstat -d分析系统的I/O情况，发现还是app进程在进行磁盘读；再使用<strong>strace</strong>跟踪D状态进程对应进程号的系统调用，发现没有权限；ps查看发现对应进程号的进程已经变成僵尸进程；之后，通过perf record -g和perf report生成报告，查看app进程的调用栈，发现CPU使用主要是在sys_read()函数，定位到是在对磁盘进行直接读（direct_IO）；查看代码发现open()系统调用使用了O_DIRECT参数</li><li>僵尸进程分析：使用pstree命令找出僵尸进程的父进程是app进程，然后查看app.c文件，发现wait()使用位置不当导致不能回收子进程</li></ul></li><li>软中断的案例：先使用top查看系统指标，发现系统CPU使用率很低，但是主要是在软中断si上，然后查看/proc/softirqs查看系统软中断变化情况，发现NET_RX变化率很快，再使用sar工具查看系统的网络收发情况，发现eth0网卡接收到了大量的小包；在通过抓包工具tcpdump，发现eth0接受到了大量的SYN包，最终确定了是SYN FLOOD攻击</li></ul><h5 id="性能指标找工具"><a href="#性能指标找工具" class="headerlink" title="性能指标找工具"></a>性能指标找工具</h5><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/202406012245720.webp" alt="image.png"></p><h5 id="工具找指标"><a href="#工具找指标" class="headerlink" title="工具找指标"></a>工具找指标</h5><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/202406012244925.webp" alt="image.png"></p><h4 id="如何分析CPU的性能瓶颈"><a href="#如何分析CPU的性能瓶颈" class="headerlink" title="如何分析CPU的性能瓶颈"></a>如何分析CPU的性能瓶颈</h4><p><strong>重点</strong>：弄清楚性能指标之间的关联性</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/202406012244017.webp" alt="image.png"></p><h3 id="CPU性能优化的几个思路"><a href="#CPU性能优化的几个思路" class="headerlink" title="CPU性能优化的几个思路"></a>CPU性能优化的几个思路</h3><h4 id="性能优化方法论"><a href="#性能优化方法论" class="headerlink" title="性能优化方法论"></a>性能优化方法论</h4><p>确定三个问题：</p><ul><li>判断所做的性能优化是否有效？优化后，能提升多少性能，有多少收益？</li><li>如果有多个性能问题同时存在，应该先优化哪一个？</li><li>当有多种优化的方法，应该选择哪一种？</li></ul><h5 id="怎么评估性能优化的效果"><a href="#怎么评估性能优化的效果" class="headerlink" title="怎么评估性能优化的效果"></a>怎么评估性能优化的效果</h5><p><strong>三步走</strong>的原则：</p><ol><li>确定性能的量化指标</li><li>测试优化前的性能指标</li><li>测试优化后的性能指标</li></ol><p><strong>第一步</strong>，性能的量化指标包括CPU使用率、应用的吞吐量、响应时间等等，<strong>不要局限在单一维度的指标上</strong>。例如，以Web应用为例：</p><ul><li>应用程序的维度，使用<strong>吞吐量和请求延时</strong>来评估</li><li>系统资源的维度，使用<strong>CPU使用率</strong>来评估</li></ul><p>好的应用程序是性能优化的最终结果和目的，要使用应用程序的指标，来评估性能优化的整体效果；而系统资源的使用情况是影响应用程序的根源，需要用资源的指标，来分析应用性能的瓶颈来源</p><p><strong>第二三步</strong>，对比第一步确定的<strong>量化指标</strong>在优化前后的差距，拿数据说话。例如，使用ab工具测试Web应用的并发请求数和响应延时，同时使用vmstat,pidstat等工具，观察系统和进程的CPU使用率，同时获得了应用和系统两个维度的性能指标</p><p><strong>进行性能测试需要注意的是</strong>：</p><ul><li>要避免性能测试工具干扰应用程序的性能</li><li>避免外部环境的变化影响性能指标的评估。在优化前、后的应用程序，都运行在相同配置的机器上，并且它们的外部依赖也要完全一致</li></ul><h5 id="多个性能问题同时存在，怎么选择？"><a href="#多个性能问题同时存在，怎么选择？" class="headerlink" title="多个性能问题同时存在，怎么选择？"></a>多个性能问题同时存在，怎么选择？</h5><p>遵循<strong>二八原则</strong>，80%的性能问题都是由于20%的代码导致的，<strong>并不是所有的性能问题都值得优化</strong></p><p>分析的步骤：</p><ul><li>挨个分析出所有的性能瓶颈，排除掉有因果关系的性能问题</li><li>在剩下的几个性能问题中，选择能明显提升应用性能的问题进行修复，有两种方法：<ul><li>如果系统资源出现瓶颈，首先优化系统资源使用的问题</li><li>针对不同类型的指标，，首先优化导致<strong>性能指标变化幅度最大</strong>的那些瓶颈问题</li></ul></li></ul><h5 id="有多种优化方法时，如何选择？"><a href="#有多种优化方法时，如何选择？" class="headerlink" title="有多种优化方法时，如何选择？"></a>有多种优化方法时，如何选择？</h5><p><strong>性能优化并非没有成本</strong>。</p><p>一个很典型的例子网络中的 DPDK（Data Plane Development Kit）。DPDK 是一种优化网络处理速度的方法，它通过绕开内核网络协议栈的方法，提升网络的处理能力。不过它有一个很典型的要求，就是要<strong>独占一个 CPU 以及一定数量的内存大页</strong>，并且总是以 100% 的 CPU 使用率运行。所以，如果你的 CPU 核数很少，就有点得不偿失了。</p><p>因此，在考虑性能优化方法时，要结合实际情况，考虑多方面的因素，进行权衡在做选择</p><h4 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h4><h5 id="应用程序优化"><a href="#应用程序优化" class="headerlink" title="应用程序优化"></a>应用程序优化</h5><p>常见的几种优化方法：</p><ul><li><strong>编译器优化</strong>：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如， gcc 就提供了优化选项 -O2，开启后会自动对应用程序的代码进行优化。</li><li><strong>算法优化</strong>：使用复杂度更低的算法，显著加快处理速度</li><li><strong>异步处理</strong>：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题。</li><li><strong>多线程代替多进程</strong>：前面讲过，相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本。</li><li><strong>善用缓存</strong>：经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度。</li></ul><h5 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h5><p>常见的系统优化方法：</p><ul><li><strong>CPU 绑定</strong>：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题</li><li><strong>CPU 独占</strong>：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU</li><li><strong>优先级调整</strong>：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。可以适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理</li><li><strong>为进程设置资源限制</strong>：使用 Linux cgroups  来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。</li><li><strong>NUMA（Non-Uniform Memory Access）优化</strong>：支持 NUMA 的处理器会将内存划分为多个 node，每个 node 关联到系统的一个处理器。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存。</li><li><strong>中断负载均衡</strong>：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把<strong>中断处理过程自动负载均衡到多个 CPU 上</strong>。</li></ul><h5 id="避免过早优化"><a href="#避免过早优化" class="headerlink" title="避免过早优化"></a>避免过早优化</h5><p>性能优化最好是<strong>逐步完善，动态进行，不追求一步到位</strong>，而要<strong>首先保证能满足当前的性能要求</strong>。当发现性能不满足要求或者出现性能瓶颈时，再根据性能评估的结果，选择最重要的性能问题进行优化</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>要忍住“把 CPU 性能优化到极致”的冲动</strong>，因为 CPU 并不是唯一的性能因素，还会有其他的性能问题，比如内存、网络、I/O 甚至是架构设计的问题。</p><p>如果不做全方位的分析和测试，只是单纯地把某个指标提升到极致，并不一定能带来整体的收益。</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの嵌入式笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 嵌入式Linux </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git操作学习——从一个可视化的git练习网站说起</title>
      <link href="/2023/12/27/Git%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84git%E7%BB%83%E4%B9%A0%E7%BD%91%E7%AB%99%E8%AF%B4%E8%B5%B7/"/>
      <url>/2023/12/27/Git%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84git%E7%BB%83%E4%B9%A0%E7%BD%91%E7%AB%99%E8%AF%B4%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自以为自己已经学会了使用git，但是当我被分配了大量的bug需要修复并且大量使用git时才知道自己的git的掌握程度有多菜，因此回家开始补习git的操作了。</p><p>最好的练习方式自然是能够可视化的进行练习，因此我找到了一个进行可视化练习git操作的网站<a href="https://learngitbranching.js.org/?locale=zh_CN">Learngitbranching</a>来学习git相关的操作，本文为学习的记录，以便后续查询使用。</p><h1 id="Git-本地操作"><a href="#Git-本地操作" class="headerlink" title="Git 本地操作"></a>Git 本地操作</h1><h2 id="git-commit——提交更改"><a href="#git-commit——提交更改" class="headerlink" title="git commit——提交更改"></a>git commit——提交更改</h2><p><code>git commit</code> 主要是用于记录下各种修改的历史记录，<code>git commit</code> 的提交记录类似文件快照，但做的非常轻量化。</p><p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p><p>进行<code>git commit</code>的时候，他会将你add过的文件进行提交，每次提交会检查当前目录下所有跟踪的文件是否发生了变化，如果有则会提醒你进行add，在所有跟踪了的文件都add了以后，Git会保存add了的文件与上次提交间的差异，并要求你输入一定的commit message。</p><h2 id="git-branch——新建分支"><a href="#git-branch——新建分支" class="headerlink" title="git branch——新建分支"></a>git branch——新建分支</h2><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">早建分支！多用分支！</span><br></pre></td></tr></table></figure><p>这是因为<strong>即使创建再多的分支也不会造成储存或内存上的开销</strong>，因为分支只是相当于新建了个指向当前提交的指针而已，并不会复制任何文件，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p><p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：<strong>“我想基于这个提交以及它所有的 parent 提交进行新的工作。”</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch NewBranch</span><br></pre></td></tr></table></figure><p>这个语句仅仅相当于新建一个名为NewBranch的分支，指向目前最新的一个提交。</p><p>分支相关的操作如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建分支</span><br><span class="line">git branch newImage</span><br><span class="line">git commit</span><br><span class="line">// 切换分支</span><br><span class="line">git checkout newImage</span><br><span class="line">git commit</span><br><span class="line">// 创建并切换分支</span><br><span class="line">git checkout -b bugFix</span><br></pre></td></tr></table></figure><h2 id="git-merge——合并分支"><a href="#git-merge——合并分支" class="headerlink" title="git merge——合并分支"></a>git merge——合并分支</h2><p>使用 <code>git merge</code>在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent 节点。翻译成自然语言相当于：“我要把这两个 parent 节点本身及它们所有的祖先都包含进来。</p><p>当目前工作区中没有未提交的更改并且不产生冲突时，<code>git merge bugFix</code>操作会将下图的C2、C3提交合并到一起并产生一个新提交C4</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227222857591.png" alt="image-20231227222857591"></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227223357594.png" alt="image-20231227223357594"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 当前分支与目标分支合并</span><br><span class="line">git merge bugFix</span><br><span class="line">git checkout bugFix</span><br><span class="line">git merge main</span><br><span class="line">// 由于 main 的一个父节点是 bugFix</span><br><span class="line">// 换句话说，main 继承自 bugFix</span><br><span class="line">// 所以 Git 什么也没做</span><br></pre></td></tr></table></figure><p>由于<code>git merge</code>会在本地产生一个merge的提交，而一般远程不会允许普通开发者进行merge操作，故我们在本地进行开发时一般不适用merge操作，更常用的是rabase操作</p><h2 id="git-rebase——分支合并方法之二"><a href="#git-rebase——分支合并方法之二" class="headerlink" title="git rebase——分支合并方法之二"></a>git rebase——分支合并方法之二</h2><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227233048032.png" alt="image-20231227233048032"></p><p>执行<code>git rebase main</code>后得到下图所示提交情况</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227233139759.png" alt="image-20231227233139759"></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227233250524.png" alt="image-20231227233250524"></p><p>rebase 第二个参数是要移动的源分支，如果不提供默认为 HEAD。如果当前分支不在源分支上，使用第二个参数可以节省一次 checkout 动作。</p><h2 id="在提交树上移动"><a href="#在提交树上移动" class="headerlink" title="在提交树上移动"></a>在提交树上移动</h2><p>HEAD：你目前正在工作的提交记录，一般指向当前分支的最近一次提交记录，但有时候checkout或者别的原因也可能导致头指针和工作的分支分离，需要查看<code>HEAD</code>的指向可以使用使用<code>cat .git/HEAD</code>命令或者直接使用<code>git branch</code>指令</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101162004970.png" alt="image-20240101162004970"></p><p><code>git checkout hashnumber</code>指令的作用即为将目前的头指针指向hashnumber对应的提交，也即执行<code>git checkout C1</code>后，头指针会从main上分离，变为下图的状态</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101162117892.png" alt="image-20240101162117892"></p><h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用(^)(~)"></a>相对引用(^)(~)</h3><p>Git中提供了一些操作符来引用提交，这样便于我们进行快速的移动头指针而不用随时都列出当前工作区的log来checkout过去。相对引用非常给力，这里我介绍两个简单的用法：</p><ul><li>使用 <code>^</code> 向上移动 1 个提交记录</li><li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li></ul><p>首先看看操作符 (^)。把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的 parent 提交。</p><p>所以 <code>main^</code> 相当于“<code>main</code> 的 parent 节点”，<code>main^^</code> 是 <code>main</code> 的第二个 parent 节点。我们也可以将 <code>HEAD</code> 作为相对引用的参照，将头指针相对自己往上移动一定的位置。</p><p>如果你想在提交树中向上移动很多步的话，敲那么多 <code>^</code> 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 <code>~</code>。</p><p>该操作符后面可以跟一个数字（可选，不跟数字时与 <code>^</code> 相同，向上移动一次），指定向上移动多少次。</p><h3 id="git-branch-f-强制修改分支位置"><a href="#git-branch-f-强制修改分支位置" class="headerlink" title="git branch -f 强制修改分支位置"></a>git branch -f 强制修改分支位置</h3><p>我使用相对引用最多的就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交。例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -f main HEAD~3</span><br></pre></td></tr></table></figure><p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级 parent 提交。</p><p>也可以直接使用绝对引用，将分支切换到某个特定提交，但是在切换前一般会要保存工作区的内容，并且移动有时候也会有比较多的冲突之类的问题因此需要最好不要将该分支直接移动到另外的分支中某个与要移动的分支不重合的提交前，也即对于下图而言最好不用使用如下命令，建议多建分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -f main C3</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101163648382.png" alt="image-20240101163648382"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 查看日志</span><br><span class="line">git log</span><br><span class="line">// 找到 main 的父节点</span><br><span class="line">git checkout main^</span><br><span class="line">// 找到 HEAD 的父节点</span><br><span class="line">git checkout HEAD^</span><br><span class="line">// 让 main 分支指向 HEAD 的第三级父提交节点</span><br><span class="line">// 可以说，git branch -f 和 git branch 内容都不一样</span><br><span class="line">// git branch 是创建分支，而 git branch -f 是改变分支指向提交节点</span><br><span class="line">git branch -f main HEAD~3</span><br><span class="line">// 注意，不能写 git branch -f HEAD HEAD^，因为没有这个分支</span><br><span class="line">// 只能用 checkout 调整 HEAD</span><br><span class="line">git checkout HEAD^</span><br></pre></td></tr></table></figure><h2 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h2><p>可以通过 Reset 和 Revert 撤销变更。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>Reset 相当于撤销历史。通过它可以回退本地的提交节点。但是无法处理远程分支。</p><p>Revert 用于撤销远程提交。这个过程引入了新的提交节点，因为这个节点做的事情是撤销上个提交节点的内容，所以和上上个节点的内容是一样的。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101164209093.png" alt="image-20240101164209093"></p><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p><p>在我们输入指令git revert C2后要撤销的提交记录后面多了一个新提交！这是因为新提交记录 <code>C2&#39;</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2&#39;</code> 的状态与 <code>C1</code> 是相同的。</p><p>revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101164931457.png" alt="image-20240101164931457"></p><p>PS：事实上，我们在本地使用revert撤销提交一般较少，为了保证更清晰的提交线，我们一般是<strong>在云端进行revert</strong>，本地如果要对上一次修改进行重新修改的话直接<code>git commit --amend</code>就行，对于云端已merge的提交要再次进行修改，最好的做法是<strong>提交一个新的提交来修复上次提交存在的问题而不是revert</strong>，因为当你reverse 再commit后就会存在两个提交需要审核再合入，因此会多一个提交的审核量，所以更建议使用新提交来修复</p><h2 id="变更提交顺序"><a href="#变更提交顺序" class="headerlink" title="变更提交顺序"></a>变更提交顺序</h2><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>Cherry-pick 可以用于将指定提交节点复制到 <code>HEAD</code> 分支上，它的命令的格式如下</p><p><code>git cherry-pick &lt;提交号&gt;...</code></p><p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。</p><p>PS：如果你cherry-pick的是一个云端的未合并的提交，你在本地进行开发后再提交会将这个未合并的提交再commit一遍，这个提交的uploader就变成你了</p><h3 id="交互式rebase"><a href="#交互式rebase" class="headerlink" title="交互式rebase"></a>交互式rebase</h3><p>当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p><p>但是如果你不清楚你想要的提交记录的哈希值呢? 或者你想要再修改前面的提交呢？幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p><p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p><p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p><p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。 </p><p>下图为我的博客中使用指令<code>git rebase -i HEAD~2</code>得到的交互式指令界面，我们要调整提交的顺序就可以通过这里pick的顺序来修改，其他的指令如下图所示。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103214804407.png" alt="image-20240103214804407"></p><ul><li><p>pick：保留该 commit</p></li><li><p>reword：保留该 commit，但我需要修改该 commit 的注释</p></li><li>edit：保留该 commit，但我要停下来修改该提交（不禁惊修改注释）</li><li>squash：将该 commit 和前一个 commit 合并</li><li>fixup：将该 commit 和前一个 commit 合并，但我不要保留该提交的注释信息</li><li>exec：执行 shell 命令</li><li>drop：我要丢弃该 commit</li></ul><p>当 rebase UI界面打开时, 你能做3件事:</p><ul><li>调整提交记录的顺序（通过鼠标拖放来完成）</li><li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li><li>合并提交。 它允许你把多个提交记录合并成一个。</li></ul><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="截取单次提交"><a href="#截取单次提交" class="headerlink" title="截取单次提交"></a>截取单次提交</h3><p>来看两个在开发中经常会遇到的情况：</p><p>1.我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息，这些调试和打印语句都在它们各自的提交记录里，最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p><p>最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>main</code> 分支上，但这样的话 <code>main</code> 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用<code>git rebase -i</code> <code>git cherry-pick</code>来达到目的。</p><p>使用<code>git rebase -i</code>时将某几个提交放弃，就会只保留最新的提交</p><p>在原分支<code>cherry-pick</code>某个提交即可只保留该提交</p><p>2.当我们一次性提交了5个提交，后三个提交已经merge，而第二个提交需要有新的修改时</p><p>我们就可以使用<code>git rebase -i HEAD~4</code>指令，然后将顶部的我们要修改的提交改为edit状态，然后修改后使用<code>git add</code>+<code>git commit --amend</code>再使用<code>git rebase --continue</code>回到最新的工作区</p><h3 id="提交的技巧"><a href="#提交的技巧" class="headerlink" title="提交的技巧"></a>提交的技巧</h3><h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><p>接下来这种情况也是很常见的：你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，然后又提交了一次。</p><p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p><p>我们可以通过下面的方法来克服困难：</p><ol><li>用 git rebase -i 将提交重新排序，然后把我们想要修改的提交记录挪到最前</li><li>用 git commit —amend 来进行一些小修改</li><li>用 git rebase -i 来将他们调回原来的顺序</li><li>把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li></ol><p>或者觉得调整顺序麻烦的话，我们也可以按下列步骤修改</p><ol><li>用 git rebase -i 打开交互界面，将我们要修改的提交状态改为edit</li><li>修改然后使用git add 和 git commit —amend的连招</li><li>使用git rebase —continue将当前指针移动到最前，大功告成</li></ol><h4 id="git-cherry-pick-1"><a href="#git-cherry-pick-1" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h4><p>我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p><p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。</p><p>使用<code>git cherry-pick</code> 就可以避免一些这些问题，我们使用<code>cherry-pick</code>时会把某个分支上的某个提交拉到我们当前分支的最新提交处，为避免本地和云端冲突，比较好的做法是使用一个Develop分支来作为与云端保持同步的分支，当我们需要cherry-pick某个关系比较复杂的提交时，我们就可以先checkout到这个Develop分支来使用git pull拉取最新的代码，然后再使用git checkout -b bugFix建立一个bugFix分支来进行我们的修改，此时我们就可以在bugFix这个分支上使用<code>cherry-pick</code>拉取要修改的那个提交到最新当前分支处，修改然后使用git add 和 git commit —amend的连招，此时就可以进行push而不存在冲突了</p><h4 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h4><p>分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p><p>你可能会问了：有没有什么可以<em>永远</em>指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p><p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p><p>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103224553317.png" alt="image-20240103224553317"></p><h4 id="git-describe"><a href="#git-describe" class="headerlink" title="git describe"></a>git describe</h4><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p><p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p><p><code>git describe</code> 的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会使用你目前所在的位置（<code>HEAD</code>）。</p><p>它输出的结果是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</span><br></pre></td></tr></table></figure><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p><p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103224657939.png" alt="image-20240103224657939"></p><h2 id="多分支rebase"><a href="#多分支rebase" class="headerlink" title="多分支rebase"></a>多分支rebase</h2><p><code>git rebase side2 side1</code>操作会将当前side1的所有和side2有分支差异且可合并的提交合并到side2的提交上并将HEAD移动到side1上</p><h2 id="选择-parent-提交记录"><a href="#选择-parent-提交记录" class="headerlink" title="选择 parent 提交记录"></a>选择 parent 提交记录</h2><p>操作符 <code>^</code> 与 <code>~</code> 符一样，后面也可以跟一个数字。</p><p>但是该操作符后面的数字与 <code>~</code> 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个 parent 提交。还记得前面提到过的一个合并提交有两个 parent 提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p><p>Git 默认选择合并提交的“第一个” parent 提交，在操作符 <code>^</code> 后跟一个数字可以改变这一默认行为。</p><h2 id="纠缠不清的分支"><a href="#纠缠不清的分支" class="headerlink" title="纠缠不清的分支"></a>纠缠不清的分支</h2><p>现在我们的 <code>main</code> 分支是比 <code>one</code>、<code>two</code> 和 <code>three</code> 要多几个提交。出于某种原因，我们需要把 <code>main</code> 分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。</p><p><code>one</code> 需要重新排序并删除 <code>C5</code>，<code>two</code> 仅需要重排排序，而 <code>three</code> 只需要提交一次。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103230610668.png" alt="image-20240103230610668"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout one</span><br><span class="line">git cherry-pick C4 C3 C2</span><br><span class="line">git checkout two</span><br><span class="line">git cherry-pick C5 C4 C3 C2</span><br><span class="line">git branch -f three C2</span><br></pre></td></tr></table></figure><h1 id="Git-云端仓库"><a href="#Git-云端仓库" class="headerlink" title="Git 云端仓库"></a>Git 云端仓库</h1><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录</p><p>话虽如此, 远程仓库却有一系列强大的特性</p><ul><li>首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</li><li>还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</li></ul><p>现在用网站来对远程仓库进行可视化操作变得越发流行了(像 <a href="https://github.com/">GitHub</a>), 但远程仓库<strong>永远</strong>是这些工具的顶梁柱, 因此理解其概念非常的重要!</p><p>我们现在需要学习远程仓库的操作 —— 我们需要一个配置这种环境的命令, 它就是 <code>git clone</code>。 从技术上来讲，<code>git clone</code> 命令在真实的环境下的作用是在<strong>本地</strong>创建一个远程仓库的拷贝（比如从 github.com）。</p><p>使用<code>git clone</code> 命令完成对远程仓库和本地仓库的建立，咱们深入地看一下发生了什么。</p><p>你可能注意到的第一个事就是在我们的本地仓库多了一个名为 <code>origin/main</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。由于远程分支的特性导致其拥有一些特殊属性。</p><p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p><p>远程分支有一个特别的属性，在你切换到远程分支时，自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p><p><strong>为什么有 <code>origin/</code>？</strong></p><p>你可能想问这些远程分支的前面的 <code>origin/</code> 是什么意思呢？远程分支有一个命名规范 —— 它们的格式是:</p><ul><li><code>&lt;remote name&gt;/&lt;branch name&gt;</code></li></ul><p>因此，如果你看到一个名为 <code>origin/main</code> 的分支，那么这个分支就叫 <code>main</code>，远程仓库的名称就是 <code>origin</code>。</p><p>大多数的开发人员会将它们主要的远程仓库命名为 <code>origin</code>，这是因为当你用 <code>git clone</code> 某个仓库时，Git 已经帮你把远程仓库的名称设置为 <code>origin</code> 了</p><p>如果切换到远程分支会怎么样呢？</p><p>Git 变成了分离 HEAD 状态，当添加新的提交时 <code>o/main</code> 也不会更新。这是因为 <code>o/main</code> 只有在远程仓库中相应的分支更新了以后才会更新。</p><h2 id="Git-Fetch"><a href="#Git-Fetch" class="headerlink" title="Git Fetch"></a>Git Fetch</h2><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p><p>本节课我们将学习如何从远程仓库获取数据 —— 命令如其名，它就是 <code>git fetch</code>。</p><p>你会看到当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103231358387.png" alt="image-20240103231358387"></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103231413367.png" alt="image-20240103231413367"></p><h3 id="git-fetch-做了些什么"><a href="#git-fetch-做了些什么" class="headerlink" title="git fetch 做了些什么"></a>git fetch 做了些什么</h3><p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>o/main</code>)</li></ul><p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p><p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你<strong>最后一次与它通信时</strong>的状态，<code>git fetch</code> 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 <code>git fetch</code> 与远程分支之间的关系了吧。</p><p><code>git fetch</code> 通常通过互联网（使用 <code>http://</code> 或 <code>git://</code> 协议) 与远程仓库通信。</p><h3 id="git-fetch-不会做的事"><a href="#git-fetch-不会做的事" class="headerlink" title="git fetch 不会做的事"></a>git fetch 不会做的事</h3><p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p><p>理解这一点很重要，因为许多开发人员误以为执行了 <code>git fetch</code> 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令 :D</p><p>所以, 你可以将 <code>git fetch</code> 的理解为单纯的下载操作。</p><h2 id="Git-Pull"><a href="#Git-Pull" class="headerlink" title="Git Pull"></a>Git Pull</h2><p>既然我们已经知道了如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p><ul><li><code>git cherry-pick o/main</code></li><li><code>git rebase o/main</code></li><li><code>git merge o/main</code></li><li>等等</li></ul><p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103231614317.png" alt="image-20240103231614317"></p><p>事实上，<code>git pull</code> 就是 git fetch 和 git merge 的缩写！</p><h2 id="Git-Push"><a href="#Git-Push" class="headerlink" title="Git Push"></a>Git Push</h2><p><code>git push</code> 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 <code>git push</code> 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p><p>你可以将 <code>git push</code> 想象成发布你成果的命令。它有许多应用技巧，稍后我们会了解到，但是咱们还是先从基础的开始吧……</p><p><em>注意 —— <code>git push</code> 不带任何参数时的行为与 Git 的一个名为 <code>push.default</code> 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 <code>upstream</code>。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。</em></p><h2 id="偏离的工作"><a href="#偏离的工作" class="headerlink" title="偏离的工作"></a>偏离的工作</h2><p>现在我们已经知道了如何从其它地方 <code>pull</code> 提交记录，以及如何 <code>push</code> 我们自己的变更。看起来似乎没什么难度，但是为何还会让人们如此困惑呢？</p><p>困难来自于远程库提交历史的<strong>偏离</strong>。在讨论这个问题的细节前，我们先来看一个例子……</p><p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目<strong>旧版</strong>的代码，与远程仓库最新的代码不匹配了。</p><p>这种情况下, <code>git push</code> 就不知道该如何操作了。如果你执行 <code>git push</code>，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p><p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 <code>push</code> 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103232357772.png" alt="image-20240103232357772"></p><p>那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。</p><p>有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。咱们继续，看看怎么 rebase！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase o/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103232635349.png" alt="image-20240103232635349"></p><p>还有其它的方法可以在远程仓库变更了以后更新我的工作吗? 当然有，我们还可以使用 <code>merge</code></p><p>尽管 <code>git merge</code> 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。</p><p>看下演示…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git merge o/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103232746342.png" alt="image-20240103232746342"></p><p>事实上，因为merge会多一个单独的C4的提交，对于公司的开发而言，有很多需要审核的地方， 所以不要添加这个merge的提交，最好的方式就是rebase。</p><p>很好！但是要敲那么多命令，有没有更简单一点的？</p><p>当然 —— 前面已经介绍过 <code>git pull</code> 就是 fetch 和 merge 的简写，类似的 <code>git pull --rebase</code> 就是 fetch 和 rebase 的简写！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebae</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103232949536.png" alt="image-20240103232949536"></p><h2 id="远程服务器拒绝-Remote-Rejected"><a href="#远程服务器拒绝-Remote-Rejected" class="headerlink" title="远程服务器拒绝!(Remote Rejected)"></a>远程服务器拒绝!(Remote Rejected)</h2><p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</span><br></pre></td></tr></table></figure><p><strong>为什么会被拒绝?</strong></p><p>远程服务器拒绝直接推送(push)提交到main, 因为策略配置要求 pull requests 来提交更新.</p><p>你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新.</p><h2 id="合并特性分支"><a href="#合并特性分支" class="headerlink" title="合并特性分支"></a>合并特性分支</h2><p>既然你应该很熟悉 fetch、pull、push 了，现在我们要通过一个新的工作流来测试你的这些技能。</p><p>在大型项目中开发人员通常会在（从 <code>main</code> 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.</p><p>但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。</p><p>对于接下来这个工作流，我们集成了两个步骤：</p><ul><li>将特性分支集成到 <code>main</code> 上</li><li>推送并更新远程分支</li></ul><p><strong>接下来的关卡建议全部都到网站实操一下，能学到很多</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase o/main side1</span><br><span class="line">git rebase side1 side2</span><br><span class="line">git rebase side2 side3</span><br><span class="line">git rebase side3 main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103233859300.png" alt="image-20240103233859300"></p><h2 id="为什么不用-merge-呢"><a href="#为什么不用-merge-呢" class="headerlink" title="为什么不用 merge 呢?"></a>为什么不用 merge 呢?</h2><p>为了 push 新变更到远程仓库，你要做的就是<strong>包含</strong>远程仓库中最新变更。意思就是只要你的本地分支包含了远程分支（如 <code>o/main</code>）中的最新变更就可以了，至于具体是用 rebase 还是 merge，并没有限制。</p><p>那么既然没有规定限制，为何前面几节都在着重于 rebase 呢？为什么在操作远程分支时不喜欢用 <code>merge</code> 呢</p><p>在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：</p><p>优点:</p><ul><li>Rebase 使你的提交树变得很干净, 所有的提交都在一条线上</li></ul><p>缺点:</p><ul><li>Rebase 修改了提交树的历史</li></ul><p>比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。</p><p>一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 :D</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103234212700.png" alt="image-20240103234212700"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull</span><br><span class="line">git merge side1</span><br><span class="line">git merge side2</span><br><span class="line">git merge side3</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h3><p>在前几节课程中有件事儿挺神奇的，Git 好像知道 <code>main</code> 与 <code>o/main</code> 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：</p><ul><li>pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。</li><li>push 操作时, 我们把工作从 <code>main</code> 推到远程仓库中的 <code>main</code> 分支(同时会更新远程分支 <code>o/main</code>) 。这个推送的目的地也是由这种关联确定的！</li></ul><p>直接了当地讲，<code>main</code> 和 <code>o/main</code> 的关联关系就是<strong>由分支的“remote tracking”属性决定</strong>的。<code>main</code> 被设定为跟踪 <code>o/main</code> —— 这意味着为 <code>main</code> 分支指定了推送的目的地以及拉取后合并的目标。</p><p>你可能想知道 <code>main</code> 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, <strong>当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了</strong>。</p><p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 <code>o/main</code>）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 <code>main</code>。</p><p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p><p>这也解释了为什么会在克隆的时候会看到下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local branch &quot;main&quot; set to track remote branch &quot;o/main&quot;</span><br></pre></td></tr></table></figure><p><strong>我能自己指定这个属性吗？</strong></p><p>当然可以啦！你可以让任意分支跟踪 <code>o/main</code>, 然后该分支会像 <code>main</code> 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 <code>totallyNotMain</code> 上执行 <code>git push</code>，将工作推送到远程仓库的 <code>main</code> 分支上。</p><p>有两种方法设置这个属性，第一种就是通过远程分支切换到一个新的分支，执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b totallyNotMain o/main</span><br></pre></td></tr></table></figure><p>就可以创建一个名为 <code>totallyNotMain</code> 的分支，它跟踪远程分支 <code>o/main</code><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103234641248.png" alt="image-20240103234641248"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b foo o/main</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>git push 同样适用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b foo o/main</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>我们将一个并不叫 <code>main</code> 的分支上的工作推送到了远程仓库中的 <code>main</code> 分支上</p><p><strong>第二种方法</strong></p><p>另一种设置远程追踪分支的方法就是使用：<code>git branch -u</code> 命令，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o/main foo</span><br></pre></td></tr></table></figure><p>这样 <code>foo</code> 就会跟踪 <code>o/main</code> 了。如果当前就在 foo 分支上, 还可以省略 foo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o/main</span><br></pre></td></tr></table></figure><h2 id="Git-Push-的参数"><a href="#Git-Push-的参数" class="headerlink" title="Git Push 的参数"></a>Git Push 的参数</h2><p>很好! 既然你知道了远程跟踪分支，我们可以开始揭开 git push、fetch 和 pull 的神秘面纱了。我们会逐个介绍这几个命令，它们在理念上是非常相似的。</p><p>首先来看 <code>git push</code>。在远程跟踪课程中，你已经学到了 Git 是通过当前所在分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;place&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;place&gt;</code> 参数是什么意思呢？我们稍后会深入其中的细节, 先看看例子, 这个命令是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>把这个命令翻译过来就是：</p><p><strong>切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</strong></p><p>我们通过<code>&lt;place&gt;</code>参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。</p><p>需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所切换分支的属性！</p><h2 id="lt-place-gt-参数详解"><a href="#lt-place-gt-参数详解" class="headerlink" title="&lt;place&gt;参数详解"></a><code>&lt;place&gt;</code>参数详解</h2><p>还记得之前课程说的吧，当为 git push 指定 place 参数为 <code>main</code> 时，我们同时指定了提交记录的来源和去向。</p><p>你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 <code>foo</code> 分支推送到远程仓库中的 <code>bar</code> 分支。</p><p>哎，很遗憾 Git 做不到…… 开个玩笑，别当真！当然是可以的啦 :) Git 拥有超强的灵活性（有点过于灵活了）</p><p>接下来咱们看看是怎么做的……</p><p>要同时为源和目的地指定 <code>&lt;place&gt;</code> 的话，只需要用冒号 <code>:</code> 将二者连起来就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;source&gt;:&lt;destination&gt;</span><br></pre></td></tr></table></figure><p>这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 <code>foo</code> 或者 <code>HEAD~1</code>）</p><p>一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了，让我们看看演示！</p><p>记住，<code>source</code> 可以是任何 Git 能识别的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin foo^:main</span><br></pre></td></tr></table></figure><p>这是个令人困惑的命令，但是它确实是可以运行的 —— Git 将 <code>foo^</code> 解析为一个位置，上传所有未被包含到远程仓库里 <code>main</code> 分支中的提交记录。</p><p>如果你要推送到的目的分支不存在会怎么样呢？没问题！<strong>Git 会在远程仓库中根据你提供的名称帮你创建这个分支！</strong></p><h2 id="Git-fetch-的参数"><a href="#Git-fetch-的参数" class="headerlink" title="Git fetch 的参数"></a>Git fetch 的参数</h2><p>我们刚学习了 git push 的参数，很酷的 <code>&lt;place&gt;</code> 参数，还有用冒号分隔的 refspecs（<code>&lt;source&gt;:&lt;destination&gt;</code>）。 这些参数可以用于 <code>git fetch</code> 吗？</p><p>你猜中了！<code>git fetch</code> 的参数和 <code>git push</code> 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）</p><p>让我们逐个讨论下这些概念……</p><h3 id="lt-place-gt-参数"><a href="#lt-place-gt-参数" class="headerlink" title="&lt;place&gt; 参数"></a><code>&lt;place&gt;</code> 参数</h3><p>如果你像如下命令这样为 git fetch 设置 的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo</span><br></pre></td></tr></table></figure><p>Git 会到远程仓库的 <code>foo</code> 分支上，然后获取所有本地不存在的提交，放到本地的 <code>o/foo</code> 上。</p><p>来看个例子（还是前面的例子，只是命令不同了）</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240104001239753.png" alt="image-20240104001239753"></p><p>你可能会好奇 —— 为何 Git 会将新提交放到 <code>o/foo</code> 而不是放到我本地的 foo 分支呢？之前不是说这样的 参数就是同时应用于本地和远程的位置吗？</p><p>好吧, 本例中 Git 做了一些特殊处理，因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。还记得在 <code>git fetch</code> 课程里我们讲到的吗 —— 它不会更新你的本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检查或者合并了）。</p><p>“如果我们指定 <code>&lt;source&gt;:&lt;destination&gt;</code> 会发生什么呢？”</p><p>如果你觉得直接更新本地分支很爽，那你就用冒号分隔的 refspec 吧。不过，你不能在当前切换的分支上干这个事，但是其它分支是可以的。</p><p>这里有一点是需要注意的 —— <code>source</code> 现在指的是远程仓库中的位置，而 <code>&lt;destination&gt;</code> 才是要放置提交的本地仓库的位置。它与 git push 刚好相反，这是可以讲的通的，因为我们在往相反的方向传送数据。</p><p>理论上虽然行的通，但开发人员很少这么做。我在这里介绍它主要是为了从概念上说明 <code>fetch</code> 和 <code>push</code> 的相似性，只是方向相反罢了。</p><p>来看个疯狂的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo~:bar</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240104001532665.png" alt="image-20240104001532665"></p><p>如果执行命令前目标分支不存在会怎样呢？我们看一下上个对话框中没有 bar 分支的情况。</p><p>跟 git push 一样，<strong>Git 会在 fetch 前自己创建立本地分支</strong>, 就像是 Git 在 push 时，如果远程仓库中不存在目标分支，会自己在建立一样。</p><p>没有参数呢?</p><p><strong>如果 <code>git fetch</code> 没有参数，它会下载所有的提交记录到各个远程分支……</strong></p><p>相当简单，但是仅需更新一次，值得你去做！</p><h3 id="古怪的-lt-source-gt"><a href="#古怪的-lt-source-gt" class="headerlink" title="古怪的 &lt;source&gt;"></a>古怪的 <code>&lt;source&gt;</code></h3><p>Git 有两种关于 <code>&lt;source&gt;</code> 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 <code>source</code>，方法就是仅保留冒号和 destination 部分，source 部分留空。</p><ul><li><code>git push origin :side</code></li><li><code>git fetch origin :bugFix</code></li></ul><p>我们分别来看一下这两条命令的作用……</p><p>如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :foo</span><br></pre></td></tr></table></figure><p>就是这样子, 我们通过给 push 传空值 source，成功删除了远程仓库中的 <code>foo</code> 分支, 这真有意思…</p><p>如果 fetch 空 到本地，会在本地创建一个新分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin :bugFix</span><br></pre></td></tr></table></figure><p>很神奇吧！但无论怎么说, 这就是 Git！</p><h2 id="Git-pull-参数"><a href="#Git-pull-参数" class="headerlink" title="Git pull 参数"></a>Git pull 参数</h2><p>既然你已经掌握关于 <code>git fetch</code> 和 <code>git push</code> 参数的方方面面了，关于 git pull 几乎没有什么可以讲的了 :)</p><p>因为 git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。</p><p>还可以和其它更复杂的参数一起使用, 来看一些例子:</p><p>以下命令在 Git 中是等效的:</p><p><code>git pull origin foo</code> 相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo; git merge o/foo</span><br></pre></td></tr></table></figure><p>还有…</p><p><code>git pull origin bar~1:bugFix</code> 相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin bar~1:bugFix; git merge bugFix</span><br></pre></td></tr></table></figure><p>看到了? git pull 实际上就是 fetch + merge 的缩写, git pull 唯一关注的是提交最终合并到哪里（也就是为 git fetch 所提供的 destination 参数）</p><p>一起来看个例子吧：</p><p>如果我们指定要抓取的 place，所有的事情都会跟之前一样发生，只是增加了 merge 操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240104002457100.png" alt="image-20240104002457100"></p><p>pull 也可以用 source:destination 吗? 当然喽, 看看吧:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main:foo</span><br></pre></td></tr></table></figure><p>哇, 这个命令做的事情真多。它先在本地创建了一个叫 <code>foo</code> 的分支，从远程仓库中的 main 分支中下载提交记录，并合并到 <code>foo</code>，然后再 merge 到我们的当前所在的分支 <code>bar</code> 上。操作够多的吧？！</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの计算机基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>考研复习日记</title>
      <link href="/2022/08/26/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>/2022/08/26/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>最近太摆了，开个帖子来记录自己的复(bai)习(lan)日记，希望在帖子的监督下，自己能稍微认真点学习。</p><p>专业课一轮都还没干完，属实拉胯，而且一天天的越来越不想学专业课，打开书就想打开B站之类的逃避，属实是不应该。</p><h2 id="08-26"><a href="#08-26" class="headerlink" title="08-26"></a>08-26</h2><p>今日复习记录：摆了一天，看完了概率的最后一章，写了下张宇基础30+李正元全书的一部分题，本来上个月就能结束的一轮，嗯是拖到了这个月的现在，值得反思。。。</p><p>明日目标：明天不用去健身房，可以好好学一波咯</p><p>数学：写完李正元第七章的题，开始写660。之前写到了第15题，希望明天能写到40题。</p><p>计组：明天必须结束浮点数和前面编码这一节，写完这部分的选择，开足马力 好好复习，拒绝摆烂 从我做起。</p><p>英语：写完02年的text1 2，3尽力写。</p><span id="more"></span><h2 id="08-27"><a href="#08-27" class="headerlink" title="08-27"></a>08-27</h2><p>今日进度：</p><p>数学：发下李正元概率论的第六章还没做完，补做了一波概率论的六七章，然后660刷了一下前30里的重点题，今天九点左右才开始进入状态，导致刷数学刷了好久，而且效率不高导致早上下午都在数学，希望明天能提高点效率。</p><p>英语和计组都没写，晚上开摆了。。。</p><p>总结：寄</p><p>明日计划：</p><p>数学：李正元概率论最后一章收尾，早上再把勾了的660里的题写一下，把前60题里的重点题做一做。</p><p>英语：晚上得写点英语了，不说多的，02年text1,2。。。单词得接着背</p><p>计组：下午多看点计组，不要睡一觉起来想着数学没整完又去整数学了，专业课进度严重落后，要重视。</p><h2 id="8-28"><a href="#8-28" class="headerlink" title="8-28"></a>8-28</h2><p>寄×2</p><p>今天和朋友键政了一下午，早上也没学进去多少，一整天加起来写了两三个题，只能说：寄</p><h2 id="8-29"><a href="#8-29" class="headerlink" title="8-29"></a>8-29</h2><p>今日进度：</p><p>660做完了前60题里的重点题，刚开始进度挺快，做到后面几个积分题后越写越慢，不管怎么说，今天效率还可以。</p><p>计组继续学了一下浮点数这节，还差点运算就能结束这节了，专业课进度属实缓慢。</p><p>今日英语：无。。。希望明天能学点英语</p><p>明日计划：660中60-90题的重点题</p><p>计组完成王道第二章，适当学一点操作系统</p><p>英语读两篇文章</p><h2 id="8-30"><a href="#8-30" class="headerlink" title="8-30"></a>8-30</h2><p>660做到了70题左右的重点题，积分和微分方程这两节开始有挺多难题了，收录进入错题本好几个题</p><p>计组继续看了一些王道的视频，感觉这课像没学过一样</p><p>写了一波实习报告，然后花了50块钱找了个代抄。4000字手写报告是真的TMD傻逼。</p><p>明日计划</p><p>计组浮点数运算写题</p><p>数学继续660</p><p>英语复习一两个list的单词+做点阅读</p><h2 id="8-31"><a href="#8-31" class="headerlink" title="8-31"></a>8-31</h2><p>今日进度：660做到了80题左右，这部分题目难度还是挺大的</p><p>计组写了浮点数这一节的题，写的很迷茫，感觉这两天是白听了</p><p>英语写了一篇阅读</p><p>明日计划：660：做到100题</p><p>计组：结束浮点数，开下一节的存储器</p><p>英语：两篇阅读保底+两个list</p><p>状态渐入佳境，是个好兆头。到现在一共翘了6个大课了，有两个签到没到，一个课堂抽人抽到了我，老师三连击，全是翘了的，真不戳。</p><h2 id="9-1-9-4"><a href="#9-1-9-4" class="headerlink" title="9-1~9-4"></a>9-1~9-4</h2><p>懵逼了三四天，做的东西不多，浪费了挺多时间，晚上睡的太晚，而且摆烂能力太强以至于408学不完了还在摆</p><p>计组：还在浮点数，到了乘除法有点懵逼，希望能在9.4晚上刷完</p><p>数学：660做到了116题，继续加油吧</p><p>英语：我哭死，我又浪费了好几天</p><h2 id="9-5-9-6"><a href="#9-5-9-6" class="headerlink" title="9.5-9.6"></a>9.5-9.6</h2><p>计组：学到了Cache前面一个小部分</p><p>OS：学完了第一章</p><p>660：做到了153T，先做到160左右就继续搞880错题吧</p><p>英语：背了一点单词</p><h2 id="9-7-9-11"><a href="#9-7-9-11" class="headerlink" title="9.7-9.11"></a>9.7-9.11</h2><p>这次浪费的时间更多</p><p>9.11打了一天游戏，应该是这个学期最后一次LOL，后面顶多看看比赛的比分了，天天和ZZB、ZZB盆友、游戏认识的一个28岁大姐姐打游戏，持续了一个暑假到现在，浪费了挺多时间，以后好好学习，天天向上了</p><p>9.7-9.10主要完成了880前两章里的错题整理和复习，计组查缺补漏看完了存储这章，但是题还没做完，这四天学习时间大概相当于两天</p><p>以后的记录改为周记吧，啥时候想起来了就写点</p><p>下周计划：计组一天一章，在下周内结束。</p><p>数学改错（即880二刷）完成高数部分</p><p>英语写完02-04年的卷子</p><h2 id="一点杂记"><a href="#一点杂记" class="headerlink" title="一点杂记"></a>一点杂记</h2><p>今天前女友贼喜欢的明星李易峰《多次嫖娼》被行政拘留咯，看她qq里的反应还是挺大的，换头像，换个签，估计受的打击还挺大的。看她keep里的动态推断出她的作息来看，她应该也在准备考研，不过我也不好意思去问她想去哪，等着都考完以后捷报飞来贺自己吧。</p><h2 id="9-12"><a href="#9-12" class="headerlink" title="9.12"></a>9.12</h2><p>今天看到了下周预报名的消息了，趁机查了一波考408的学校的分数线，发现一流的均分基本都在400+，次一流385+，再次一流370+</p><p><strong>计算机是真他娘的卷呐</strong></p><p>现在还没结束一轮，不知道自己究竟有多少能耐，但是按照自己英语和408的学习进度这尿性。。。370可能都不一定。</p><p><strong>现在看过来，自己大一到现在一路上错过了好多好多机会啊</strong></p><p>军训时期考卓越班转专业没好好把握当时考前也没仔细想想，被转专业群里的几个学长学姐的指南劝退，以为都是选择数竞选手，直接放弃了准备，考前也没好好选，头铁往最难的方向考，自然被淘汰。要是选个容易进去的，就能进有40%+的保研名额的班级，后面保研也容易很多，当初没多接触几个学长学姐问问经验，只能说自己的性格决定了现在的命运吧。</p><p>正式转专业考试时准备的也不够充分，还头铁选了最难的，刚好碰到了最卷的一年，从180进120变为了我们这一年的300+进60，信息类的自动化、通信工程等转专业时同时缩招，调剂都没得卷的。时也，命也。</p><p>分流时期又没去个不卷的方向83 84的分数稳稳拿名额，硬卷一个88 89才能拿名额的专业方向。卷也就算了，在大二又得了疫情后综合征，变得没有大一时候那么能卷了，于是想考好的时候考不好，改好好复习的时候学不进去，导致大二成绩很不理想，到了大三又直接开摆，被舍友同化成了游戏小子。大一大二都没怎么玩游戏，大三居然瘾大到不可理喻的地步。大三的寒假二月份在家就开了考研的复习，结果开学后4、5、6三个月加起来的复习速度赶不上寒假里学的一个月。到了现在，对自己的考试水平和能力完全没有个底，是真的废物，醒不过来的废物。明明第二天都是七点多就起床，结果天天晚上都是两点多三点多睡觉，永远都不能保持满状态学习，废物</p><p><strong>错过了四五个机会的我，希望可以把握住考研这次机会</strong></p><h2 id="9-18周记"><a href="#9-18周记" class="headerlink" title="9-18周记"></a>9-18周记</h2><p>本周进度喜人，戒掉游戏之后就是不一样，</p><p>主要在看计组了，看到了第五章结束，上周刚差不多看完第二章，这周All in计组有点效果，看完了三章，基本两天一章，OS也看完了两章，预计下周能结束计组+OS，计网可以开了，本周数学基本处于荒废状态，赶408进度去了，下次学快点，没时间了，提高速度，提高效率。</p><h2 id="9-25周记"><a href="#9-25周记" class="headerlink" title="9-25周记"></a>9-25周记</h2><p>本周进度:于9.24完成了OS与组原的复习，复习效率提上来了，学习速度不错。唉，要是早戒掉游戏，今天应该二轮复习了挺多了。9.25开了计网，9.24完成了浙大的预报名，190报名费。。政治开始加大小程序刷题的力度，一天刷个一百题左右，争取十月中旬结束1600题。</p><p>希望这周结束计网，开始408二轮及大题的复习，同时数学继续放回原应有的地位，每日刷2个小时吧先。加油，一定上岸!</p><h2 id="10-4记录"><a href="#10-4记录" class="headerlink" title="10.4记录"></a>10.4记录</h2><p>本来这个记录应该在10.2完成的，但是复习的太投入了，今天才想起来写记录</p><p>总体进度赶上来了，计网结束，刚开始DS的二轮，大题写算法忘得有点多，要捡起来的有点多，预计一周结束DS二轮，接下来的408二轮3天一科，预计到10月的17-18号能结束，开启真题。</p><p>数学复习了三四天高数了，感觉再来两三天可以开线代，三四天结束线代，再来两三天结束概率，然后是10.15左右能开真题。</p><p>英语真题阅读刷了01-03年以及05年的，坚持一天两到三篇阅读，坚持背单词！</p><p>政治算是这周才找到了复习节奏吧，看了马原的两章，写了肖1000，预计这周结束马原，史纲能做一半。赶进度赶了快一个月了，效率还可以，但是有点怀疑自己的水平了，不知道处于考浙大的人群中的什么水平</p><p>这周心灵导师辰哥给了我挺多激励，说的也有道理——你的学习能力是经过高考验证的，按照自己学习的方法论和节奏走肯定是能有结果的。</p><p>——每个考研的人复习就像在一间没有灯光的房间里洗衣服，谁也不知道自己洗的怎么样，但是只要坚持洗，不断地洗，最后从房间里拿出来的时候一定挺干净</p><p>——985的没考上，大部分不是水平不够，而是努力不够</p><p>涛涛和宇哥也是两个好的教育者，涛涛说：你会遭到某些人的嫉妒之类的情绪是因为你比他们优秀，但只比他们优秀一点点，你们之间还有太多的同一性，所以你们才会处在不断的斗争性中间。要想没有斗争性，你就要让自己变得更优秀，优秀到能斩断你和他之间的同一性，没有了同一性，你们就没有斗争性了</p><p>宇哥则是每天都给我们激励，考研之路不易，不断斩断前路的艰难险阻，才能曲折的前进</p><p>道路是曲折的，前路是光明的</p><p>坚定信念，前进，不择手段的前进！</p><p>（此处应该有一句 自然选择，前进四！😁😁😁</p><h2 id="10-9记录"><a href="#10-9记录" class="headerlink" title="10-9记录"></a>10-9记录</h2><p>又是一个周记，本周结束了高数的二轮并开启了线代的二轮，DS二轮学的有点慢，进度并不能使人满意，故打算放一放，开启时间片轮转模式，将408的四科都轮一轮。</p><p>DS：结束了查找和排序算法的学习，刚开始几天去温习快排的代码写法了，走了弯路，花了时间没有取得什么成果，应试学习应以应试为主，记几个模板让自己到时候能根据模板做些修改写出来就差不多了，没必要那么严谨的让他跑通，所以换学习模式了，一天复个一两科408，防止某一科长时间不碰饥饿致死。</p><p>计组：结束了前两章的二轮，开启存储系统</p><p>计网：结束前两章</p><p>英语：完成了03、04、05、18、的阅读，日经List单词完成至Day10</p><p>政治：肖1000完成了马原的前四五章内容，史纲完成了前三四章，看完了腿姐带背的对应内容。</p><p>下周计划：</p><p>数学：结束线代+概率二轮，开启真题</p><p>英语：完成06-10年的阅读，List的单词推进至Day11结束</p><p>计组：结束存储系统+指令系统+中央处理器</p><p>OS：结束进程+内存</p><p>DS：结束线性表+树+图</p><p>计网：复习至传输层结束</p><p>408预计于10.18-19日结束，于10.20左右开启每日一套真题的节奏。</p><p>数学预计于10.15-10.16结束，开启真题节奏。</p><p>英语预计月底左右结束真题阅读一刷。</p><p>政治预计于10.20刷完肖1000除毛中特外的所有部分。</p><p>进度不快，但求扎实学好每个知识。</p><h1 id="考后碎碎念"><a href="#考后碎碎念" class="headerlink" title="考后碎碎念"></a>考后碎碎念</h1><p>一次忘记记录就拖啊拖，拖到了现在，已经考完咯！</p><blockquote><p>从二月开始复习，到开学后开摆四个月，从七八的低强度复习，到九月开始的删游戏高强度复习，再到一步步的择校，择专业，择梦想。</p><p>这是我第一次，完完全全由自己自主做决定，并为之全权负责的时刻。</p><p>一路中反反复复，磕磕绊绊。见证了自己的弱小与傲慢，见证了自己的懒惰与怯懦，也见证了自己的进步与成长。</p><p>要是没那么粗心，要是多看几遍错题本，要是当时看多往后看几页冷僻的知识点……</p><p>哪有那么多要是！落子无悔！小孩子可以哭，但成年人不行。</p><p>即使发挥的没有那么理想，但我依然可以说，我来过，我战斗过，这里的风景，独好。</p><p>感谢那个努力的自己，愿所有努力，都能得尝所愿。</p></blockquote><p>以上是我刚考完研的那个晚上记录下的文字，如今考研已经过去了一个星期，我也在考完研回家的第一个晚上就感染了新冠，现在已经基本痊愈了。</p><p>有一说一，新冠是真的痛苦，要是考研的那几天得了新冠，估计是直接寄了，高烧了3天，39度两天，38度一天，即使已经痊愈了依旧还是在咳嗽，在疯狂地流鼻涕，高烧那两天，近乎无眠，可以说，能发烧烧到这种程度，是我疫情三年，乃至初中以来的10年里都没有过的体验。我感染的还是BF7毒株，应该是回宿舍收东西准备回家时候感染的，当时看舍友都没啥症状了也，自己也考完研了，就没那么小心了。回家时候因为爸妈新冠还没好，就让我单独去住到一个亲戚家的房子里，结果才住进去的当天喉咙就开始疼，第二天起床就烧起来了，38度，持续到晚上变成了39度，烧了两天39度，速释的对乙酰氨基酚第一天吃了完全没用，烧到了四五点睡不着，我爸妈给我拿来了布洛芬的缓释胶囊吃完才退烧，舒服到了第二天下午，又开始烧，依旧是坚挺的39度，这回布洛芬也没用了，吃了三个小时从39.4掉到了39.3，反正就是很绝望，此时还好还有人吹吹牛，和祁医生进行的话疗很有效，在吃下退烧药后第五个小时，拉出了堵在肚子里三四天的💩，祁医生说是张仲景讲过，高热且便秘，便通则烧退，嘿，还真灵，拉完第二天就舒服了。虽然这天还是烧到了38度多，但是已经没有了明显的不适感，我也就此把药停了。停药以后就是咳，咳咳咳咳咳咳咳咳咳咳，一直咳到肺都快咳出来了，喉咙还疼的要死，只求它慢慢地好了吧。</p><p>在我差不多好了的时候，我爷爷和我外婆又几乎同时得了新冠，打了几天针以后又送去医院里住院了，只希望他们尽快好了吧，关关难过关关过，都能到这个年纪了，希望他们能渡过眼前的难关，健健康康地活下去。</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摆烂日记 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 生活记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外挂标签写法汇总</title>
      <link href="/2022/08/09/Markdown%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE%E5%86%99%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2022/08/09/Markdown%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE%E5%86%99%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Markdown语法自带格式"><a href="#1-Markdown语法自带格式" class="headerlink" title="1.Markdown语法自带格式"></a>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块"><a href="#1-1-代码块" class="headerlink" title="1.1 代码块"></a>1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-2-多级标题"><a href="#1-2-多级标题" class="headerlink" title="1.2 多级标题"></a>1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-3-文字样式"><a href="#1-3-文字样式" class="headerlink" title="1.3 文字样式"></a>1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<del>删除</del>线演示</p><font size = 5>5号字</font><font face="黑体">黑体</font><font color=blue>蓝色</font><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用"><a href="#1-4-引用" class="headerlink" title="1.4 引用"></a>1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p> Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>….</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-5-分割线"><a href="#1-5-分割线" class="headerlink" title="1.5 分割线"></a>1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-6-列表-跟空格都可以"><a href="#1-6-列表-跟空格都可以" class="headerlink" title="1.6 列表(*,+,-跟空格都可以)"></a>1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表"><a href="#1-6-1-无序列表" class="headerlink" title="1.6.1 无序列表"></a>1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表"><a href="#1-6-2-有序列表" class="headerlink" title="1.6.2 有序列表"></a>1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-7-图片"><a href="#1-7-图片" class="headerlink" title="1.7 图片"></a>1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-8-表格"><a href="#1-8-表格" class="headerlink" title="1.8 表格"></a>1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="table-container"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-9-公式"><a href="#1-9-公式" class="headerlink" title="1.9 公式"></a>1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><script type="math/tex; mode=display">\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.</script><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="2-Butterfly外挂标签"><a href="#2-Butterfly外挂标签" class="headerlink" title="2.Butterfly外挂标签"></a>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text"><a href="#2-1-行内文本样式-text" class="headerlink" title="2.1 行内文本样式 text"></a>2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-2-行内文本-span"><a href="#2-2-行内文本-span" class="headerlink" title="2.2 行内文本 span"></a>2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-3-段落文本-p"><a href="#2-3-段落文本-p" class="headerlink" title="2.3 段落文本 p"></a>2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-4-引用note"><a href="#2-4-引用note" class="headerlink" title="2.4 引用note"></a>2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><div class="table-container"><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table></div><p>2.外部icon</p><div class="table-container"><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><br>2.<code>modern</code>样式<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了….</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-5-上标标签-tip"><a href="#2-5-上标标签-tip" class="headerlink" title="2.5 上标标签 tip"></a>2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-6-动态标签-anima"><a href="#2-6-动态标签-anima" class="headerlink" title="2.6 动态标签 anima"></a>2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>   1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><br>3.On hover（当鼠标悬停时显示动画）<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><br>4.On parent hover（当鼠标悬停在父级元素时显示动画）<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-7-复选列表-checkbox"><a href="#2-7-复选列表-checkbox" class="headerlink" title="2.7 复选列表 checkbox"></a>2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-8-单选列表-radio"><a href="#2-8-单选列表-radio" class="headerlink" title="2.8 单选列表 radio"></a>2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-9-时间轴-timeline"><a href="#2-9-时间轴-timeline" class="headerlink" title="2.9 时间轴 timeline"></a>2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-10-链接卡片-link"><a href="#2-10-链接卡片-link" class="headerlink" title="2.10 链接卡片 link"></a>2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-11-按钮-btns"><a href="#2-11-按钮-btns" class="headerlink" title="2.11 按钮 btns"></a>2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure></p><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-12-github卡片-ghcard"><a href="#2-12-github卡片-ghcard" class="headerlink" title="2.12 github卡片 ghcard"></a>2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><div class="table-container"><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><div class="table-container"><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table></div><p>2.仓库信息卡片</p><div class="table-container"><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-13-github徽标-ghbdage"><a href="#2-13-github徽标-ghbdage" class="headerlink" title="2.13 github徽标 ghbdage"></a>2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object><p>3.拓展参数，支持shields的API的全部参数内容</p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-14-网站卡片-sites"><a href="#2-14-网站卡片-sites" class="headerlink" title="2.14 网站卡片 sites"></a>2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-15-行内图片-inlineimage"><a href="#2-15-行内图片-inlineimage" class="headerlink" title="2.15 行内图片 inlineimage"></a>2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-16-单张图片-image"><a href="#2-16-单张图片-image" class="headerlink" title="2.16 单张图片 image"></a>2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><br>2.指定宽度<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><br>3.指定宽度并添加描述：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><br>4.设置占位背景色：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-17-音频-audio"><a href="#2-17-音频-audio" class="headerlink" title="2.17 音频 audio"></a>2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-18-视频-video"><a href="#2-18-视频-video" class="headerlink" title="2.18 视频 video"></a>2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><br>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-19-相册-gallery"><a href="#2-19-相册-gallery" class="headerlink" title="2.19 相册 gallery"></a>2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><br>2.gallery 相册<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><div class="table-container"><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table></div><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-20-折叠框-folding"><a href="#2-20-折叠框-folding" class="headerlink" title="2.20 折叠框 folding"></a>2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><br><!-- tab 参数配置 --></p><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-21-分栏-tab"><a href="#2-21-分栏-tab" class="headerlink" title="2.21 分栏 tab"></a>2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-22-诗词标签-poem"><a href="#2-22-诗词标签-poem" class="headerlink" title="2.22 诗词标签 poem"></a>2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-23-阿里图标-icon"><a href="#2-23-阿里图标-icon" class="headerlink" title="2.23 阿里图标 icon"></a>2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-24-特效标签wow"><a href="#2-24-特效标签wow" class="headerlink" title="2.24 特效标签wow"></a>2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><br>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><br>3.slideInRight动画效果，持续5s，延时5s<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><br>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-25-进度条-progress"><a href="#2-25-进度条-progress" class="headerlink" title="2.25  进度条 progress"></a>2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-26-注释-notation"><a href="#2-26-注释-notation" class="headerlink" title="2.26 注释 notation"></a>2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-27-气泡注释-bubble"><a href="#2-27-气泡注释-bubble" class="headerlink" title="2.27 气泡注释 bubble"></a>2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span>&lt;/span&gt;，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局”，用来为盒状模型提供最大的灵活性”</span>&lt;/span&gt;，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span>&lt;/span&gt;，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span>&lt;/span&gt;写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span>&lt;/span&gt;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-28-引用文献-reference"><a href="#2-28-引用文献-reference" class="headerlink" title="2.28 引用文献 reference"></a>2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;，Butterfly主题<span class="hidden-anchor" id="referto_[3]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;</p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;<br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;<span class="hidden-anchor" id="referto_[7]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;<span class="hidden-anchor" id="referto_[8]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;<span class="hidden-anchor" id="referto_[9]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;</p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-29-PDF展示"><a href="#2-29-PDF展示" class="headerlink" title="2.29 PDF展示"></a>2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-30-Hexo-tag-map-插件"><a href="#2-30-Hexo-tag-map-插件" class="headerlink" title="2.30 Hexo-tag-map 插件"></a>2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="table-container"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table></div><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div>&lt;/div&gt;<script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><br></p><p><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><br></p><p><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><br></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-31-隐藏块"><a href="#2-31-隐藏块" class="headerlink" title="2.31 隐藏块"></a>2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 外挂标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>琐碎的记录——生活真美好</title>
      <link href="/2021/09/25/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E7%90%90%E7%A2%8E%E7%9A%84%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E7%94%9F%E6%B4%BB%E7%9C%9F%E7%BE%8E%E5%A5%BD/"/>
      <url>/2021/09/25/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E7%90%90%E7%A2%8E%E7%9A%84%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E7%94%9F%E6%B4%BB%E7%9C%9F%E7%BE%8E%E5%A5%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="先写不开心的事——抠出一万套海景房的尬聊"><a href="#先写不开心的事——抠出一万套海景房的尬聊" class="headerlink" title="先写不开心的事——抠出一万套海景房的尬聊"></a>先写不开心的事——抠出一万套海景房的尬聊</h1><p>今天在地铁上可真是把我尬的受不了了，我本来开开心心的坐在座位上打游戏，打的正开心的时候，一个老哥过来问我借充电宝，借过去稍微讲了两句话，到目前为止一切正常。然后过了一会之后，这个老哥开始和我疯狂地吹牛：“兄弟，我跟你说，充电宝这玩意还得是以前质量高！我爸有一个，牌子货！呵，一个用了十多年！” 嚯，好家伙，难道这就是传说中的葫芦娃合体的牛逼闪闪的充电宝嘛，我不禁向这么🐮🍺的充电宝低下了头，继续玩我的游戏，然后这位大哥似乎没有停下来的意思，继续给我讲充电宝的故事，顺带补充了一下他那🐮🍺的充一次电可以玩十天的手机，然后他讲这个讲了二十多分钟。。。我打了两三局炉石后停下来听他继续吹牛，，，然后我开始左顾右盼，他开始越来越离谱，给我扯他的充电宝多多少钱。。。属实听不下去，，，尬的抠出一万套海景房</p><span id="more"></span><h1 id="其次是今天的出游"><a href="#其次是今天的出游" class="headerlink" title="其次是今天的出游"></a>其次是今天的出游</h1><p>在图书馆写了一天代码的我决定放空下自我，约舍友出门游玩，阔惜莫得一个人理我，那行，爷自己去🙃晚上六点多坐着地铁奔向了江汉路。</p><p>虽然来过了几遍了，但是这次过来还是有很多耳目一新的收获</p><p>又会想起了当初一个人游荡在杭州的街头，感受着这个世界的美好与喧嚣，感受着生活的存在，感受着社会的存在，感受着学校的三点一线以外的生活，我这才意识到——原来这才是生活啊，原来世界有这么大，原来世界有这么精彩，原来生活可以活的这么有趣</p><p>在象牙塔里待一段时间一定要出来走走，要出来见识见识这个美妙的世界，见识见识生活本来的样子，这样我才会更热爱生活！</p><p>吹着江风，看着江上的轮渡，和江边钓鱼的大叔唠上几句，再欣赏欣赏长江大桥的壮阔，生活遍由此而变得多姿多彩了，变得更能使我快乐了</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>另外，今天还是学院的国家奖学金答辩的日子，啊，不知不觉已经大三了，不知不觉减已经到了第二次奖学金的评审了，在第一次评审时自己还为总成绩差了一名没法参与评审而懊恼，现在已经完全放下了这些狗屁奖学金，不就是几千块钱嘛，将来工作了一两个月就能挣回来了。</p><p>想想各个卷王为了争抢那么点荣誉拼的你死我活，课堂知识在课上学一遍就算了，回了寝室还要再在慕课上刷一遍，恨不得把所有时间都拿来学，这有什么值得的呢？为了拿点分数，都不管学的这些知识有没有什么作用，卷就完了，保了研我就🐮🍺了。</p><p>这些知识体系是几十年前工业时代下建立起来的学科体系遗留下来的传统知识。我个人非常反对学院设置的这些非常非常传统的传统机械的相关的知识体系的灌输，我认为即使是本科生，也应该接收最新的，最前沿的技术与知识，而不是抱着九几年，八几年甚至六几年出的课本传授一堆很可能已经过时的知识！</p><p>现在再想想大一大二为了点加权，为了点加分，各种蹭比赛，各种蹭科研项目，即使是打杂也要一头钻进去，为了这些个项目急红了眼，真是不值得。一切的项目，都是基于某些学长做了95%的项目进行修改，做一个机器人70%的时间装配，20%的时间调参数，剩下10%的时间看学长的代码里哪些参数有什么用，能怎么调，时间是花了，技术呢？一无所获。除了所获奖项上又能增加那么一行意外一无是处，真是后悔了自己当初的所作所为。</p><p>不过还好，现在已经悟到了自己不喜欢这些东西，既然不喜欢，那就拒绝呗，开始认真做能使我感到快乐的事情！</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jyy与yzh的折磨——从0到1撸PA的日子</title>
      <link href="/2021/09/23/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-jyy%E4%B8%8Eyzh%E7%9A%84%E6%8A%98%E7%A3%A8%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%92%B8PA%E4%B9%8B%E8%B7%AF/"/>
      <url>/2021/09/23/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-jyy%E4%B8%8Eyzh%E7%9A%84%E6%8A%98%E7%A3%A8%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%92%B8PA%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文为自己做南京大学计算机科学与技术系<code>计算机系统基础</code>课程的小(mo)型(gui)项目 (Programming Assignment, PA)的一些心路历程与实验记录，会一直更新到把整个PA给写完了</p><p>博主目前为国内某中流985天坑专业在读大三老🐶一枚，在学CSAPP的时候了解到了这个小(mo)型(gui)项目，于是下定决心来做它，为了变强，加油！</p><p>至于标题为啥这么取，，，只是为了补偿一下我最近被他摧残的差不多了的小心脏😭，yzh老师真是太太太太太好了，把这么好的资料都公开了出来，唯一的小瑕疵就是不提供OJ给我们测试，，，不过我也很理解，能有这么好的学习资料我这种天坑专业的已经很满足了！🤑</p><p>南大真是太好了，南大就是中国的CMU啊——某中流985学子投来羡慕的目光</p><h1 id="PA0😏——我已出仓，感觉良好"><a href="#PA0😏——我已出仓，感觉良好" class="headerlink" title="PA0😏——我已出仓，感觉良好"></a>PA0😏——我已出仓，感觉良好</h1><p>PA0还算蛮简单的，也就是配配环境，玩玩Git和vim。虽然之前都了解过这两个家伙，但是都没怎么用过，所以熟悉它们还是花了些时间的。就是唯一想吐槽的是老师这里的讲义居然是全英文的😭，英语不好的我流下了不争气的泪水😭 但是作为一名”工程师“应有的素质，我觉得老师这里做的肥肠棒，成功的让我燃起了好好学英语的兴趣！而且强制使用英语看这些报告虽然刚开始慢了点，还得时刻借助翻译的插件，但是时间长了之后对自己肯定只有好处，没有坏处。正如讲义里提到的：坚持一年, 你就会发现有不同; 坚持两年, 你就会发现大有不同。</p><p>整个讲义看下来，能明显的感觉到老师的良苦用心，又是让我阅读<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a>和<a href="https://github.com/tangx/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md">别像弱智一样提问</a>然后写800字的感想，又是随时都在让我</p><ul><li><p>STFW——Search The Friendly Web</p></li><li><p>RTFM——Read The Friendly Menu</p></li><li><p>RTFSC——Read The Friendly Source Code</p><span id="more"></span></li></ul><h1 id="PA1——开始有些难度"><a href="#PA1——开始有些难度" class="headerlink" title="PA1——开始有些难度"></a>PA1——开始有些难度</h1><p>这个PA我读完手册还是一脸懵逼，不知道从哪开始，然后找了<a href="https://www.bilibili.com/video/BV1qa4y1j7xk?p=1">老师相关的习题课</a>以及相关的博客文章看了一些之后才有了一丝修改的意识与方法</p><h2 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h2><p>这里看了看了好久才知道是要自己实现让CPU单步执行程序的功能（原谅我菜的真实555）</p><p>然后需要使用老师提示使用的<code>strtok</code>和<code>sscanf</code>函数，具体应该是解析指令然后解析出数字，传送到CPU处使用CPU提供的指令单步执行</p><p>一次si多行倒是实现的快，但是无参数默认单步执行一直实现不出来，X了狗了，就先跳过，去做下一个命令</p><h2 id="打印寄存器信息"><a href="#打印寄存器信息" class="headerlink" title="打印寄存器信息"></a>打印寄存器信息</h2><p>这个看起来比较简单，找到CPU的寄存器结构体的定义和数据用printf打印出来就行，就是看工程文件看的有点头秃，第一波打印完之后数据有点对不齐，因为数字超过了8位，<code>\t</code>直接控制到下一个光标去了，就很丑，在这里卡了一会终于搞完了，很舒服</p><h1 id="扫描内存"><a href="#扫描内存" class="headerlink" title="扫描内存"></a>扫描内存</h1><p>感觉每个任务最难的是理解题目需求和意思，看懂了要干什么之后找起文件来也就容易多了</p><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの项目记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> PA </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP——bomblab</title>
      <link href="/2021/09/21/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E2%80%94%E2%80%94bomblab/"/>
      <url>/2021/09/21/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E2%80%94%E2%80%94bomblab/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：看了好久的书，写了好几个晚上，参考了一些大佬的笔记，终于把这个bomblab写完了</p></blockquote><h1 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h1><p>这个著名的bomblab为我们提供了一个二进制文件，然后我们需要将这个二进制文件进行反汇编得到一堆的汇编文件，通过阅读汇编文件中的代码以及GDB的调试来得到需要输入的字符密码来进入下一关。</p><p>整个实验一共有六个正式关卡，一个隐藏关卡，密码和进入隐藏关卡的方法也藏在文件中，需要我们一点点的探寻其中的蛛丝马迹，拆开炸弹。如果拆弹失败的话，实验文件会给我们打印出一个BOMB！！！如果你是CMU的学生，每次不小心的BOMB还会扣你这个实验的分数，不过我们不是CMU的学生，就随便他炸了23333</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>没有实验文件的需要先到<a href="http://csapp.cs.cmu.edu/3e/bomb.tar">这个网站</a>下载一个</p><p>首先我们需要进入到这个lab的文件所在的文件夹下，可以看到有README、bomb、和bomb.c三个文件，我们先打开bomb.c看看有些什么东西</p><p>可以看到有6个phase，每个phase基本都是要我们输入一段字符，然后它调用了判断我们字符对不对的函数。大概浏览一下，知道要干什么之后先把bomb文件反汇编一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump bomb -d &gt; disassemble.txt</span><br></pre></td></tr></table></figure><p>得到了bomb的反汇编代码打开</p><p>看到一堆莫名其妙的东西，不知道怎么下手，想起来之前有6个phase，于是就搜索了下phase，找到了phase所在地，就用GDB来进行调试了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb bomb</span><br></pre></td></tr></table></figure><p>然后给爆炸和phase_1先打上断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b explode_bomb</span><br><span class="line">b phase_1</span><br></pre></td></tr></table></figure><p>run了之后，随便输入一点字符进入phase_1，先把当前的函数用disas指令反汇编一下</p><blockquote><p>不熟悉GDB调试的可以参考CMU的<a href="http://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf">课程提供的手册</a></p></blockquote><span id="more"></span><h1 id="phase1"><a href="#phase1" class="headerlink" title="phase1"></a>phase1</h1><p>phase1的反汇编代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">=&gt; 0x0000000000400ee0 &lt;+0&gt;:        sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:        mov    $0x402400,%esi</span><br><span class="line">   0x0000000000400ee9 &lt;+9&gt;:        callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:    retq   </span><br></pre></td></tr></table></figure><p>在第二行我们看到了个很奇怪的地址<code>0x402400</code>先把它移动到了<code>esi</code>里，有使用了一个判断字符是否相等的函数，所以我们可以大胆推测密码应该就在<code>0x402400</code>里,直接展示这个地址里的数据：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109211752381.png" alt="image-20210921175234221"></p><p>猜的差不多，我们再run一次，这次直接把上面的字符粘贴进去：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109211755754.png" alt="image-20210921175556714"></p><p>发现已经通过了第一关</p><p>注意：在每个lab里，每个使用到了固定地址的都很重要，一般都要打印出来看看是个啥</p><p>hhh在这里还发现了点彩蛋</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109242321631.png" alt="image-20210921183658215"></p><h1 id="phase2"><a href="#phase2" class="headerlink" title="phase2"></a>phase2</h1><p>现在我们已经有了第一关的密码，所以我们先把它存到一个文档里，然后进入gdb，设置好断点后设置一下命令参数，然后run一波，可以看到我们已经过了第一个phase</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109242340808.png" alt="image-20210924234044751"></p><p>接下来我们开始解决phase2，随便输入一点参数后进入phase2，phase2的反汇编代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:    55                   push   %rbp</span><br><span class="line">  400efd:    53                   push   %rbx</span><br><span class="line">  400efe:    48 83 ec 28          sub    $0x28,%rsp# 堆栈操作</span><br><span class="line">  400f02:    48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  400f05:    e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;# 读入6个数字</span><br><span class="line">  400f0a:    83 3c 24 01          cmpl   $0x1,(%rsp)</span><br><span class="line">  400f0e:    74 20                je     400f30 &lt;phase_2+0x34&gt;# 堆栈顶部数字 != 1 爆炸</span><br><span class="line">  400f10:    e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:    eb 19                jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  循环体：</span><br><span class="line">  &#123;</span><br><span class="line">  400f17:    8b 43 fc             mov    -0x4(%rbx),%eax# %eax = %rsp </span><br><span class="line">  400f1a:    01 c0                add    %eax,%eax# (%eax) += (%eax)</span><br><span class="line">  400f1c:    39 03                cmp    %eax,(%rbx)# %eax == valueat(%rsp+4)</span><br><span class="line">  400f1e:    74 05                je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:    e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:    48 83 c3 04          add    $0x4,%rbx# %rbx += 4 #地址+4，相当于移向下一个数</span><br><span class="line">  400f29:    48 39 eb             cmp    %rbp,%rbx# %rbx == %rsp+24#rbx是否为第六个数后的地址</span><br><span class="line">  400f2c:    75 e9                jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  400f2e:    eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:    48 8d 5c 24 04       lea    0x4(%rsp),%rbx# %rbx = %rsp+4 #rbx存储的应该是地址</span><br><span class="line">  400f35:    48 8d 6c 24 18       lea    0x18(%rsp),%rbp# %rbp = %rsp+24</span><br><span class="line">  400f3a:    eb db                jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:    48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  400f40:    5b                   pop    %rbx</span><br><span class="line">  400f41:    5d                   pop    %rbp</span><br><span class="line">  400f42:    c3                   retq   </span><br></pre></td></tr></table></figure><p>这段代码比较长，仔细看可以看出来第一次判断的数字一定是1，需要六个数字，然后每次判断的数字都是前一个数字的两倍，于是我们就可以推导出来答案是<code>1 2 4 8 16 32</code></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109250022389.png" alt="image-20210925002200317"></p><h1 id="phase3"><a href="#phase3" class="headerlink" title="phase3"></a>phase3</h1><p>phase3的代码稍微有点长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:    48 83 ec 18          sub    $0x18,%rsp</span><br><span class="line">  400f47:    48 8d 4c 24 0c       lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:    48 8d 54 24 08       lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:    be cf 25 40 00       mov    $0x4025cf,%esi</span><br><span class="line">  400f56:    b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400f5b:    e8 90 fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:    83 f8 01             cmp    $0x1,%eax</span><br><span class="line">  400f63:    7f 05                jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:    e8 d0 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:    83 7c 24 08 07       cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:    77 3c                ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">  400f71:    8b 44 24 08          mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:    ff 24 c5 70 24 40 00 jmpq   *0x402470(,%rax,8)</span><br><span class="line">  400f7c:    b8 cf 00 00 00       mov    $0xcf,%eax</span><br><span class="line">  400f81:    eb 3b                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:    b8 c3 02 00 00       mov    $0x2c3,%eax</span><br><span class="line">  400f88:    eb 34                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:    b8 00 01 00 00       mov    $0x100,%eax</span><br><span class="line">  400f8f:    eb 2d                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:    b8 85 01 00 00       mov    $0x185,%eax</span><br><span class="line">  400f96:    eb 26                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:    b8 ce 00 00 00       mov    $0xce,%eax</span><br><span class="line">  400f9d:    eb 1f                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:    b8 aa 02 00 00       mov    $0x2aa,%eax</span><br><span class="line">  400fa4:    eb 18                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:    b8 47 01 00 00       mov    $0x147,%eax</span><br><span class="line">  400fab:    eb 11                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:    e8 88 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:    b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400fb7:    eb 05                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:    b8 37 01 00 00       mov    $0x137,%eax</span><br><span class="line">  400fbe:    3b 44 24 0c          cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:    74 05                je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:    e8 71 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:    48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  400fcd:    c3                   retq   </span><br></pre></td></tr></table></figure><p>阅读下来看到第四行有个奇怪的地址<code>0x4025cf</code>，不管三七二十一先把它打印出来看看：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109250025504.png" alt="image-20210925002556461"></p><p>可以看出来题目需要我们输入两个整数</p><p>继续往下读，看到它使用了一个好像是库函数的函数<code>&lt;__isoc99_sscanf@plt&gt;</code>搜了一下得知它的返回数字为读入的数字数目</p><p>接下来就是比较了一下我们输入的第一个数字是否大于7，然后跳转到<code>0x402470+8*%rax</code>的位置，此时我们rax有0~7一共八种选择，所以我们打印一下<code>0x402470</code>附近的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/8a 0x402470</span><br><span class="line">0x402470:    0x400f7c &lt;phase_3+57&gt;0x400fb9 &lt;phase_3+118&gt;</span><br><span class="line">0x402480:    0x400f83 &lt;phase_3+64&gt;0x400f8a &lt;phase_3+71&gt;</span><br><span class="line">0x402490:    0x400f91 &lt;phase_3+78&gt;0x400f98 &lt;phase_3+85&gt;</span><br><span class="line">0x4024a0:    0x400f9f &lt;phase_3+92&gt;0x400fa6 &lt;phase_3+99&gt;</span><br></pre></td></tr></table></figure><p>再对照代码中的逻辑可以知道按照以下任意一对数字输入都可以通过</p><div class="table-container"><table><thead><tr><th style="text-align:center">数字1</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">数字2</td><td style="text-align:center">207</td><td style="text-align:center">311</td><td style="text-align:center">707</td><td style="text-align:center">256</td><td style="text-align:center">389</td><td style="text-align:center">206</td><td style="text-align:center">682</td><td style="text-align:center">327</td></tr></tbody></table></div><h1 id="phase4"><a href="#phase4" class="headerlink" title="phase4"></a>phase4</h1><p>接下来我们就进入到了phase_4，它的反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">=&gt; 0x000000000040100c &lt;+0&gt;:        sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401010 &lt;+4&gt;:        lea    0xc(%rsp),%rcx# %rcx = %rsp + 12</span><br><span class="line">   0x0000000000401015 &lt;+9&gt;:        lea    0x8(%rsp),%rdx# %rdx = %rsp + 8</span><br><span class="line">   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi# 0x4025cf:&quot;%d %d&quot;</span><br><span class="line">   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax</span><br><span class="line">   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)# (%rsp+8) &lt;= 14</span><br><span class="line">   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx# %edx = 14</span><br><span class="line">   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi# %esi = 0</span><br><span class="line">   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi# %edi = %rsp + 8 </span><br><span class="line">   0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax</span><br><span class="line">   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;# 返回值%rax一定为0</span><br><span class="line">   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)</span><br><span class="line">   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;# (%rsp + 12) == 0</span><br><span class="line">   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp</span><br><span class="line">   0x0000000000401061 &lt;+85&gt;:    retq   </span><br></pre></td></tr></table></figure><p>第四行出现了一个地址，打印之后得到的是<code># 0x4025cf:    &quot;%d %d&quot;</code>说明需要我们输入两个整数，然后继续往下读，在倒数第四行可以看出来我们要输入的一个数字一定为0。func4具体的内容还不清楚，把func4的代码输出一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function func4:</span><br><span class="line">=&gt; 0x0000000000400fce &lt;+0&gt;:        sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:        mov    %edx,%eax# %eax = 14</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:        sub    %esi,%eax# %eax -= %esi = 14-0 = 14</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:        mov    %eax,%ecx# %ecx = %eax = 14</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx# %ecx&gt;&gt;31 = 0//%ecx = sign of %eax</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax# %eax += %ecx = 14</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:    sar    %eax# %eax&gt;&gt;1 // %eax = 7</span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx# %ecx = %rax+%rsi = 7+0=7</span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx</span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;# %edi = %ecx</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx# %edx = %rcx-1</span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax# %eax = 2*%eax</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax# %eax = 0</span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx# %ecx &gt;= %edi?</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi# %esi = %rcx+1</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax# %rax = 2%rax</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x000000000040100b &lt;+61&gt;:    retq  </span><br></pre></td></tr></table></figure><p>在func4里推了一推，发现7满足要求，所以答案可以为<code>7 0</code></p><p>看了下知乎大佬<a href="https://www.zhihu.com/people/yansongtw">@Yannick</a>逆向出来的C代码，发现答案不止一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a:%rdi b:%rsi  c:%rdx</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">  <span class="type">int</span> return_v = c - b; <span class="comment">// %rax</span></span><br><span class="line">  <span class="type">int</span> t = ((<span class="type">unsigned</span>)return_v) &gt;&gt; <span class="number">31</span>; <span class="comment">// %rcx</span></span><br><span class="line">  return_v = (t + return_v) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  t = return_v + b;</span><br><span class="line">  <span class="keyword">if</span> (t - a &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    return_v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (t - a &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> return_v;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      b = t + <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> r = func4(a,b,c);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span> * r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = t - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r = func4(a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后的代码</span></span><br><span class="line"><span class="comment">// x为输入的数</span></span><br><span class="line"><span class="comment">// y为0 z为14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k = z - y;</span><br><span class="line">    k = ((<span class="type">int</span>)(((<span class="type">unsigned</span>)k&gt;&gt;<span class="number">31</span>) + k) &gt;&gt; <span class="number">1</span>) + y;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*func4(x, k+<span class="number">1</span>, z)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*func4(x, y, k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现其实第一个数的取值范围是[0,0xe]，我们可以对它进行一个穷举：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(!func4(i, <span class="number">0</span>, <span class="number">14</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ./func4 </span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure></p><p>所以最终答案是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 | 1 0 | 3 0 | 7 0</span><br></pre></td></tr></table></figure><h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><p>进入phase_5，首先查看phase5的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">=&gt; 0x0000000000401062 &lt;+0&gt;:        push   %rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:        sub    $0x20,%rsp#堆栈相关</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:        mov    %rdi,%rbx# rbx = rdi</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:        mov    %fs:0x28,%rax# 将内存中一段数据移到rax</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)# rax = (rsp + 24)</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax# 输入的字符串长度为6</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   </span><br><span class="line">   # 循环,作用为将读入的字符串取二进制后四位作为偏移量，从0x4024b0处偏移取出字符，然后压入堆栈</span><br><span class="line">   &#123;</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx# ecx = rax+rbx = rax</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)# (rsp) = ecx</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx# rdx = rsp</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx# 取edx二进制的后四位</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx# edx = rdx+0x4024b0</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)# rsp+rax+10 = rdx</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax# rax += 1</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;# rax!=6时循环</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:    nopl   0x0(%rax,%rax,1)</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:    jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:    mov    $0x0,%eax# eax = 0</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:    jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:    mov    0x18(%rsp),%rax</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:    xor    %fs:0x28,%rax</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:    je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:    callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:    add    $0x20,%rsp</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:    pop    %rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:    retq   </span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>可以看到这段代码的逻辑是取出输入的字符的二进制后四位作为偏移量，从0x4024b0处偏移此偏移量取出字符，然后压入堆栈，再到后面的循环中从第一个压入的堆栈与地址<code>$0x40245e</code>中所含的字符进行比较，先打印<code>0x4024b0</code>处的字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4024b0</span><br><span class="line">0x4024b0 &lt;array.3449&gt;:    <span class="string">&quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span></span><br></pre></td></tr></table></figure><p>再打印<code>$0x40245e</code>中的字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br><span class="line">0x40245e:    <span class="string">&quot;flyers&quot;</span></span><br></pre></td></tr></table></figure><p>由此可知<strong>我们只要让输入的6个字符的ascii码的后四位作为偏移量，在<code>maduiersnfotvbyl</code>这十六个字符中偏移正确的值，最后取出flyers</strong>就可以了，flyers 对应的偏移量为 9fe567</p><p>所以我们的答案就很显然了，在Terminal中使用<code>man ascii</code>语句查看所有字符对应的ascii码，找出正确偏移的字符，得到一组可行的答案：<code>9?&gt;567</code></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109251104999.jpeg" alt="img"></p><h1 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h1><p>phase_6的代码就有点长了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:    41 56                push   %r14</span><br><span class="line">  4010f6:    41 55                push   %r13</span><br><span class="line">  4010f8:    41 54                push   %r12</span><br><span class="line">  4010fa:    55                   push   %rbp</span><br><span class="line">  4010fb:    53                   push   %rbx</span><br><span class="line">  4010fc:    48 83 ec 50          sub    $0x50,%rsp</span><br><span class="line">  401100:    49 89 e5             mov    %rsp,%r13</span><br><span class="line">  401103:    48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  401106:    e8 51 03 00 00       callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  </span><br><span class="line">  40110b:    49 89 e6             mov    %rsp,%r14# r14 = rsp[0]</span><br><span class="line">  40110e:    41 bc 00 00 00 00    mov    $0x0,%r12d# r12d = 0</span><br><span class="line">  # 循环体2 r13每次+4，r12每次+1直到r12 = 6</span><br><span class="line">  &#123;</span><br><span class="line">  401114:    4c 89 ed             mov    %r13,%rbp# rbp = r13</span><br><span class="line">  401117:    41 8b 45 00          mov    0x0(%r13),%eax# eax = r13+0x0</span><br><span class="line">  40111b:    83 e8 01             sub    $0x1,%eax# eax--</span><br><span class="line">  40111e:    83 f8 05             cmp    $0x5,%eax# 小于等于5时不爆炸</span><br><span class="line">  401121:    76 05                jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:    e8 12 03 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401128:    41 83 c4 01          add    $0x1,%r12d# r12d += 1</span><br><span class="line">  40112c:    41 83 fc 06          cmp    $0x6,%r12d</span><br><span class="line">  401130:    74 21                je     401153 &lt;phase_6+0x5f&gt;# r12d是否等于6</span><br><span class="line">  401132:    44 89 e3             mov    %r12d,%ebx# ebx = r12d</span><br><span class="line">  </span><br><span class="line">  # 循环体1，作用为读入堆栈上的第2-6个数字，和第1个数字相比，如果相同就爆炸</span><br><span class="line">      &#123;</span><br><span class="line">  401135:    48 63 c3             movslq %ebx,%rax# rax = ebx</span><br><span class="line">  401138:    8b 04 84             mov    (%rsp,%rax,4),%eax# 读入堆栈上第rax个数放到eax上</span><br><span class="line">  40113b:    39 45 00             cmp    %eax,0x0(%rbp)</span><br><span class="line">  40113e:    75 05                jne    401145 &lt;phase_6+0x51&gt;# eax 为rbp的第0个数时 爆炸</span><br><span class="line">  401140:    e8 f5 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:    83 c3 01             add    $0x1,%ebx# ebx += 1 </span><br><span class="line">  401148:    83 fb 05             cmp    $0x5,%ebx</span><br><span class="line">  40114b:    7e e8                jle    401135 &lt;phase_6+0x41&gt;# 小于等于5跳转</span><br><span class="line">      &#125;</span><br><span class="line">  40114d:    49 83 c5 04          add    $0x4,%r13# r13 += 4</span><br><span class="line">  401151:    eb c1                jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  401153:    48 8d 74 24 18       lea    0x18(%rsp),%rsi# rsi = rsp[6]</span><br><span class="line">  401158:    4c 89 f0             mov    %r14,%rax# rax = r14 = *rsp[0]</span><br><span class="line">  40115b:    b9 07 00 00 00       mov    $0x7,%ecx# ecx = 7</span><br><span class="line">  </span><br><span class="line">  # 循环体3, 对输入的每个数进行 a[i] = 7 - a[i]操作</span><br><span class="line">  &#123;</span><br><span class="line">  401160:    89 ca                mov    %ecx,%edx# edx = 7</span><br><span class="line">  401162:    2b 10                sub    (%rax),%edx# edx -= rax</span><br><span class="line">  401164:    89 10                mov    %edx,(%rax)# (rax) = 7-rsp[0]</span><br><span class="line">  401166:    48 83 c0 04          add    $0x4,%rax# rax += 4</span><br><span class="line">  40116a:    48 39 f0             cmp    %rsi,%rax</span><br><span class="line">  40116d:    75 f1                jne    401160 &lt;phase_6+0x6c&gt;# 循环直到 rax == rsp[0]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  40116f:    be 00 00 00 00       mov    $0x0,%esi# esi = 0</span><br><span class="line">  401174:    eb 21                jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">  </span><br><span class="line">  # 循环体4，rsi == 24时跳出</span><br><span class="line">  &#123;</span><br><span class="line">  # 循环5，ecx == eax 跳出//即eax == 7 跳出</span><br><span class="line">      &#123;</span><br><span class="line">  401176:    48 8b 52 08          mov    0x8(%rdx),%rdx# rdx = (rdx所存地址+8)</span><br><span class="line">  40117a:    83 c0 01             add    $0x1,%eax# eax += 1</span><br><span class="line">  40117d:    39 c8                cmp    %ecx,%eax</span><br><span class="line">  40117f:    75 f5                jne    401176 &lt;phase_6+0x82&gt;# ecx = eax</span><br><span class="line">      &#125;</span><br><span class="line">  401181:    eb 05                jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  </span><br><span class="line">  # 循环体6，ecx &gt; 1 跳出</span><br><span class="line">      &#123;</span><br><span class="line">  401183:    ba d0 32 60 00       mov    $0x6032d0,%edx# edx = 0x6032d0</span><br><span class="line">  401188:    48 89 54 74 20       mov    %rdx,0x20(%rsp,%rsi,2)# rsp + 0x20 + 2rsi = rdx</span><br><span class="line">  40118d:    48 83 c6 04          add    $0x4,%rsi# rsi += 4</span><br><span class="line">  401191:    48 83 fe 18          cmp    $0x18,%rsi</span><br><span class="line">  401195:    74 14                je     4011ab &lt;phase_6+0xb7&gt;# rsi == 24</span><br><span class="line">  401197:    8b 0c 34             mov    (%rsp,%rsi,1),%ecx# ecx = rsp[rsi]</span><br><span class="line">  40119a:    83 f9 01             cmp    $0x1,%ecx</span><br><span class="line">  40119d:    7e e4                jle    401183 &lt;phase_6+0x8f&gt;# ecx &lt;= 1</span><br><span class="line">      &#125;</span><br><span class="line">  40119f:    b8 01 00 00 00       mov    $0x1,%eax# eax = 1</span><br><span class="line">  4011a4:    ba d0 32 60 00       mov    $0x6032d0,%edx# edx = 0x6032d0</span><br><span class="line">  4011a9:    eb cb                jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  4011ab:    48 8b 5c 24 20       mov    0x20(%rsp),%rbx# rbx = rsp[8]</span><br><span class="line">  4011b0:    48 8d 44 24 28       lea    0x28(%rsp),%rax# rax = rsp[9]</span><br><span class="line">  4011b5:    48 8d 74 24 50       lea    0x50(%rsp),%rsi# rax = rsp[20]</span><br><span class="line">  4011ba:    48 89 d9             mov    %rbx,%rcx# rcx = rbx</span><br><span class="line">  </span><br><span class="line">  # 循环7,循环直到rsi == rax</span><br><span class="line">  &#123;</span><br><span class="line">  4011bd:    48 8b 10             mov    (%rax),%rdx# rdx = rax</span><br><span class="line">  4011c0:    48 89 51 08          mov    %rdx,0x8(%rcx)# (rcx+8) = rax</span><br><span class="line">  4011c4:    48 83 c0 08          add    $0x8,%rax# rax += 8</span><br><span class="line">  4011c8:    48 39 f0             cmp    %rsi,%rax</span><br><span class="line">  4011cb:    74 05                je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:    48 89 d1             mov    %rdx,%rcx</span><br><span class="line">  4011d0:    eb eb                jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  4011d2:    48 c7 42 08 00 00 00 movq   $0x0,0x8(%rdx)# (rdx + 8) = 0</span><br><span class="line">  4011d9:    00 </span><br><span class="line">  4011da:    bd 05 00 00 00       mov    $0x5,%ebp# ebp = 5</span><br><span class="line">  </span><br><span class="line">  # 循环8 循环直到ebp &lt; 0</span><br><span class="line">  &#123;</span><br><span class="line">  4011df:    48 8b 43 08          mov    0x8(%rbx),%rax# rax = (rbx + 8)</span><br><span class="line">  4011e3:    8b 00                mov    (%rax),%eax# eax = (rax)</span><br><span class="line">  4011e5:    39 03                cmp    %eax,(%rbx)</span><br><span class="line">  4011e7:    7d 05                jge    4011ee &lt;phase_6+0xfa&gt;# 如果 rbx &lt; eax,爆炸</span><br><span class="line">  4011e9:    e8 4c 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:    48 8b 5b 08          mov    0x8(%rbx),%rbx# rbx = (rbx + 8)</span><br><span class="line">  4011f2:    83 ed 01             sub    $0x1,%ebp# ebp--</span><br><span class="line">  4011f5:    75 e8                jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  4011f7:    48 83 c4 50          add    $0x50,%rsp</span><br><span class="line">  4011fb:    5b                   pop    %rbx</span><br><span class="line">  4011fc:    5d                   pop    %rbp</span><br><span class="line">  4011fd:    41 5c                pop    %r12</span><br><span class="line">  4011ff:    41 5d                pop    %r13</span><br><span class="line">  401201:    41 5e                pop    %r14</span><br><span class="line">  401203:    c3                   retq   </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/24w 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:    332163044800</span><br><span class="line">0x6032e0 &lt;node2&gt;:    168263044960</span><br><span class="line">0x6032f0 &lt;node3&gt;:    924363045120</span><br><span class="line">0x603300 &lt;node4&gt;:    691463045280</span><br><span class="line">0x603310 &lt;node5&gt;:    477563045440</span><br><span class="line">0x603320 &lt;node6&gt;:    443600</span><br></pre></td></tr></table></figure><p>可以看出来前面的代码要求我们输入的数字都不一样且小于等于6，然后它里面有有个链表需要我们进行比较，我们输入的数字的顺序就是比较链表节点的顺序，而其中有个判断又需要我们将比较的这些链表中的数据降序输出，带入数字推断后得到期望的顺序<code>3 4 5 6 1 2</code>，每位都与7取余后得到答案: <code>4 3 2 1 6 5</code></p><p>写的很简陋，详细的分析建议看大佬的<a href="https://zhuanlan.zhihu.com/p/104130161">Introduction to CSAPP（十九）：这可能是你能找到的分析最全的Bomblab了</a></p><h1 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret phase"></a>secret phase</h1><p>在看bomb文件的反汇编代码的时候，看到了个<code>secret_phase</code>全局搜索后在<code>phase_defuse</code>中发现了调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">4015c4:  sub    $0x78,%rsp</span><br><span class="line">4015c8:  mov    %fs:0x28,%rax</span><br><span class="line">4015cf:  </span><br><span class="line">4015d1:  mov    %rax,0x68(%rsp)</span><br><span class="line">4015d6:  xor    %eax,%eax</span><br><span class="line">4015d8:  cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;</span><br><span class="line">4015df:  jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line">4015e1:  lea    0x10(%rsp),%r8</span><br><span class="line">4015e6:  lea    0xc(%rsp),%rcx</span><br><span class="line">4015eb:  lea    0x8(%rsp),%rdx</span><br><span class="line">4015f0:  mov    $0x402619,%esi # 这里包括下面发现了奇怪的地址，打印看看，发现是 &quot;%d %d %s&quot;</span><br><span class="line">4015f5:  mov    $0x603870,%edi # 这里是 &quot;&quot;</span><br><span class="line">4015fa:  callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">4015ff:  cmp    $0x3,%eax # sscanf的返回值表示输入的参数个数，如果是3个，就到401604行，那么究竟什么时候会执行这段逻辑呢？</span><br><span class="line">401602:  jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401604:  mov    $0x402622,%esi # &quot;DrEvil&quot;</span><br><span class="line">401609:  lea    0x10(%rsp),%rdi # 比较 &quot;DrEvil&quot; 和某个值</span><br><span class="line">40160e:  callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">401613:  test   %eax,%eax</span><br><span class="line">401615:  jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401617:  mov    $0x4024f8,%edi # &quot;Curses, you&#x27;ve found the secret phase!&quot;</span><br><span class="line">40161c:  callq  400b10 &lt;puts@plt&gt; # 打印之</span><br><span class="line">401621:  mov    $0x402520,%edi # &quot;But finding it and solving it are quite different...&quot;</span><br><span class="line">401626:  callq  400b10 &lt;puts@plt&gt; # 打印之</span><br><span class="line">40162b:  mov    $0x0,%eax</span><br><span class="line">401630:  callq  401242 &lt;secret_phase&gt; # 调用了彩蛋关</span><br><span class="line">401635:  mov    $0x402558,%edi # &quot;Congratulations! You&#x27;ve defused the bomb!&quot;</span><br><span class="line">40163a:  callq  400b10 &lt;puts@plt&gt; # 打印之</span><br><span class="line">40163f:  mov    0x68(%rsp),%rax</span><br><span class="line">401644:  xor    %fs:0x28,%rax</span><br><span class="line">40164b:  </span><br><span class="line">40164d:  je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line">40164f:  callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">401654:  add    $0x78,%rsp</span><br><span class="line">401658:  retq   </span><br><span class="line">401659:  nop</span><br><span class="line">40165a:  nop</span><br><span class="line">40165b:  nop</span><br><span class="line">40165c:  nop</span><br><span class="line">40165d:  nop</span><br><span class="line">40165e:  nop</span><br><span class="line">40165f:  nop</span><br></pre></td></tr></table></figure><p>阅读后发现在前面某个关卡处输入的秘文为整数 整数 字符串时进入secret，推测字符串为前文发现的<code>DrEvil</code>，又发现只有phase4和phase3能满足这个要求，然后都尝试后发现在phase4输入的秘文后接一个<code>DrEvil</code>可以进入隐藏的secret_phase，以下为secret_phase的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">401242:  push   %rbx</span><br><span class="line">401243:  callq  40149e &lt;read_line&gt;</span><br><span class="line">401248:  mov    $0xa,%edx</span><br><span class="line">40124d:  mov    $0x0,%esi</span><br><span class="line">401252:  mov    %rax,%rdi</span><br><span class="line">401255:  callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">40125a:  mov    %rax,%rbx # 断点可以设置在这里，打印后发现，rax中存的是我们输入的值</span><br><span class="line">40125d:  lea    -0x1(%rax),%eax # eax = eax - 1</span><br><span class="line">401260:  cmp    $0x3e8,%eax # eax - 0x3e8 &lt;= 0 即 in - 1 &lt;= 1000</span><br><span class="line">401265:  jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">401267:  callq  40143a &lt;explode_bomb&gt; # 不满足时 爆炸</span><br><span class="line">40126c:  mov    %ebx,%esi # 这个是我们输入的值</span><br><span class="line">40126e:  mov    $0x6030f0,%edi # 观察输入的参数：</span><br><span class="line"># (gdb) x 0x6030f0</span><br><span class="line"># 0x6030f0 &lt;n1&gt;:  0x00000024</span><br><span class="line">401273:  callq  401204 &lt;fun7&gt;</span><br><span class="line">401278:  cmp    $0x2,%eax</span><br><span class="line">40127b:  je     401282 &lt;secret_phase+0x40&gt; # fun7返回值和2比，如果等于零，则成功</span><br><span class="line">40127d:  callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401282:  mov    $0x402438,%edi</span><br><span class="line">401287:  callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">40128c:  callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">401291:  pop    %rbx</span><br></pre></td></tr></table></figure><p>关键点就在于func7这个函数了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line"># %esi 存我们输入的值</span><br><span class="line"># %edi 存某一地址</span><br><span class="line">401204: sub    $0x8,%rsp</span><br><span class="line">401208: test   %rdi,%rdi # 查看是否为null</span><br><span class="line">40120b: je     401238 &lt;fun7+0x34&gt; # 满足跳转</span><br><span class="line">40120d: mov    (%rdi),%edx </span><br><span class="line">40120f: cmp    %esi,%edx</span><br><span class="line">401211: jle    401220 &lt;fun7+0x1c&gt;</span><br><span class="line">401213: mov    0x8(%rdi),%rdi</span><br><span class="line">401217: callq  401204 &lt;fun7&gt;</span><br><span class="line">40121c: add    %eax,%eax</span><br><span class="line">40121e: jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">401220: mov    $0x0,%eax</span><br><span class="line">401225: cmp    %esi,%edx</span><br><span class="line">401227: je     40123d &lt;fun7+0x39&gt;</span><br><span class="line">401229: mov    0x10(%rdi),%rdi</span><br><span class="line">40122d: callq  401204 &lt;fun7&gt;</span><br><span class="line">401232: lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">401236: jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">401238: mov    $0xffffffff,%eax # 返回全1序列</span><br><span class="line">40123d: add    $0x8,%rsp</span><br><span class="line">401241: retq</span><br></pre></td></tr></table></figure><p>大佬<a href="https://www.zhihu.com/people/yansongtw">@Yannick</a>逆向的等价C语言:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun7</span><span class="params">(<span class="type">int</span> cmp, Node* addr)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(addr == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> v = addr-&gt;value;</span><br><span class="line">  <span class="keyword">if</span> (v == cmp)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( v &lt; cmp)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span>*fun7(cmp, addr-&gt;right);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*func7(cmp, addr-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看这个二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/120 0x6030f0</span><br><span class="line">0x6030f0 &lt;n1&gt;:    36063040160</span><br><span class="line">0x603100 &lt;n1+16&gt;:    6304048000</span><br><span class="line">0x603110 &lt;n21&gt;:    8063041440</span><br><span class="line">0x603120 &lt;n21+16&gt;:    6304080000</span><br><span class="line">0x603130 &lt;n22&gt;:    50063041120</span><br><span class="line">0x603140 &lt;n22+16&gt;:    6304176000</span><br><span class="line">0x603150 &lt;n32&gt;:    22063043680</span><br><span class="line">0x603160 &lt;n32+16&gt;:    6304304000</span><br><span class="line">0x603170 &lt;n33&gt;:    45063042080</span><br><span class="line">0x603180 &lt;n33+16&gt;:    6304400000</span><br><span class="line">0x603190 &lt;n31&gt;:    6063042400</span><br><span class="line">0x6031a0 &lt;n31+16&gt;:    6304336000</span><br><span class="line">0x6031b0 &lt;n34&gt;:    107063042720</span><br><span class="line">0x6031c0 &lt;n34+16&gt;:    6304432000</span><br><span class="line">0x6031d0 &lt;n45&gt;:    40000</span><br><span class="line">0x6031e0 &lt;n45+16&gt;:    0000</span><br><span class="line">0x6031f0 &lt;n41&gt;:    1000</span><br><span class="line">0x603200 &lt;n41+16&gt;:    0000</span><br><span class="line">0x603210 &lt;n47&gt;:    99000</span><br><span class="line">0x603220 &lt;n47+16&gt;:    0000</span><br><span class="line">0x603230 &lt;n44&gt;:    35000</span><br><span class="line">0x603240 &lt;n44+16&gt;:    0000</span><br><span class="line">0x603250 &lt;n42&gt;:    7000</span><br><span class="line">0x603260 &lt;n42+16&gt;:    0000</span><br><span class="line">0x603270 &lt;n43&gt;:    20000</span><br><span class="line">0x603280 &lt;n43+16&gt;:    0000</span><br><span class="line">0x603290 &lt;n46&gt;:    47000</span><br><span class="line">0x6032a0 &lt;n46+16&gt;:    0000</span><br><span class="line">0x6032b0 &lt;n48&gt;:    1001000</span><br><span class="line">0x6032c0 &lt;n48+16&gt;:    0000</span><br></pre></td></tr></table></figure><p>画出其结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">└─ 36</span><br><span class="line">   ├─ 8</span><br><span class="line">   │  ├─ 6</span><br><span class="line">   │  │  ├─ left: 1</span><br><span class="line">   │  │  └─ right: 7</span><br><span class="line">   │  └─ 22</span><br><span class="line">   │     ├─ left: 20</span><br><span class="line">   │     └─ right: 35</span><br><span class="line">   └─ 50</span><br><span class="line">      ├─ 45</span><br><span class="line">      │  ├─ left: 40</span><br><span class="line">      │  └─ right: 47</span><br><span class="line">      └─ 107</span><br><span class="line">         ├─ left: 99</span><br><span class="line">         └─ right: 1001</span><br></pre></td></tr></table></figure><p>然后我就穷举了。。。</p><p>得到的答案是<code>22</code>或者<code>20</code>，终于拆外所有炸弹</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109251141149.png" alt="image-20210925114142077"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://wdxtub.com/csapp/thick-csapp-lab-2/2016/04/16/">【读厚 CSAPP】II Bomb Lab</a></p><p><a href="https://zhuanlan.zhihu.com/p/104130161">Introduction to CSAPP（十九）：这可能是你能找到的分析最全的Bomblab了</a></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの项目记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> bomblab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划2——线性动态规划问题</title>
      <link href="/2021/09/07/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A02/"/>
      <url>/2021/09/07/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：本文为学习力扣文章<a href="https://leetcode-cn.com/leetbook/detail/dynamic-programming-1-plus/">《动态规划精讲（一）》</a>时的学习笔记，本文对其进行线性动态规划相关的文章和问题进行了一定的转载和修改并在其中加入了一些个人的理解。</p></blockquote><h1 id="线性动态规划简介"><a href="#线性动态规划简介" class="headerlink" title="线性动态规划简介"></a>线性动态规划简介</h1><p>线性动态规划主要是从0开始从小到大依次递推过去的，特点为问题规模依次从0到i依次递增，较大规模的问题依赖较小规模问题的解</p><p>这里问题规模为 i 的含义是考虑前 i 个元素 [0..i] 时问题的解。</p><p>状态定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[n] := [0..n] 上问题的解</span><br></pre></td></tr></table></figure><p>状态转移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[n] = f(dp[n-1], ..., dp[0])</span><br></pre></td></tr></table></figure><h1 id="单串"><a href="#单串" class="headerlink" title="单串"></a>单串</h1><p>单串是线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 dp[i] := 考虑[0…i]上，原问题的解，其中 i 位置的处理，根据不同的问题，主要有两种方式：</p><ul><li>第一种是 i 位置必须取，此时状态可以进一步描述为 dp[i] := 考虑[0…i]上，且取 i，原问题的解；</li><li>第二种是 i 位置可以取可以不取</li></ul><span id="more"></span><h2 id="1-依赖比-i-小的-O-1-个子问题"><a href="#1-依赖比-i-小的-O-1-个子问题" class="headerlink" title="1. 依赖比 i 小的 O(1) 个子问题"></a>1. 依赖比 i 小的 O(1) 个子问题</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></p><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><p>一个数组有很多个子数组，求哪个子数组的和最大。可以按照子数组的最后一个元素来分子问题，确定子问题后设计状态</p><p>状态的推导是按照 i 从 0 到 n - 1 按顺序推的，推到 dp[i]，时，dp[i - 1], …, dp[0] 已经计算完。因为子数组是连续的，所以子问题 dp[i] 其实只与子问题 dp[i - 1] 有关。如果 [0..i-1] 上以 nums[i-1] 结尾的最大子数组和(缓存在 dp[i-1] )为非负数，则以 nums[i] 结尾的最大子数组和就在 dp[i-1] 的基础上加上 nums[i] 就是 dp[i] 的结果否则以 i 结尾的子数组就不要 i-1 及之前的数，因为选了的话子数组的和只会更小。</p><p>按照以上的分析，状态的转移可以写出来，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = nums[i] + max(dp[i - 1], 0)</span><br></pre></td></tr></table></figure><h2 id="2-依赖比-i-小的-O-n-个子问题"><a href="#2-依赖比-i-小的-O-n-个子问题" class="headerlink" title="2. 依赖比 i 小的 O(n) 个子问题"></a>2. 依赖比 i 小的 O(n) 个子问题</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a></p><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p></blockquote><p>输入是一个单串，首先思考单串问题中设计状态 dp[i] 时拆分子问题的方式：枚举子串或子序列的结尾元素来拆分子问题，设计状态 dp[i] := 在子数组 [0..i] 上，且选了 nums[i] 时，的最长上升子序列。</p><p>因为子序列需要上升，因此以 i 结尾的子序列中，nums[i] 之前的数字一定要比 nums[i] 小才行，因此目标就是先找到以此前比 nums[i] 小的各个元素，然后每个所选元素对应一个以它们结尾的最长子序列，从这些子序列中选择最长的，其长度加 1 就是当前的问题的结果。如果此前没有比 nums[i] 小的数字，则当前问题的结果就是 1 。</p><p>按照以上的分析，状态的转移方程可以写出来，如下</p><script type="math/tex; mode=display">dp[i] = max_{j}(dp[j]) + 1</script><p>其中 $0 \leq j &lt; i, nums[j] &lt; nums[i]$。</p><h2 id="单串问题：最经典单串LIS系列"><a href="#单串问题：最经典单串LIS系列" class="headerlink" title="单串问题：最经典单串LIS系列"></a>单串问题：最经典单串LIS系列</h2><h3 id="1-最长上升子序列"><a href="#1-最长上升子序列" class="headerlink" title="1.最长上升子序列"></a>1.最长上升子序列</h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></p><p>提示：</p><p><code>1 &lt;= nums.length &lt;= 2500</code><br>$-10^4 \leq nums[i] \leq 10^4$</p><p>进阶：</p><p>你可以设计时间复杂度为 O(n2) 的解决方案吗？</p><p>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer15——双指针（简单）</title>
      <link href="/2021/09/04/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer15/"/>
      <url>/2021/09/04/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer15/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h1><p>难度 简单</p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 链表长度 &lt;= 1000</span><br></pre></td></tr></table></figure><p>注意：本题与主站 21 题相同：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>开辟一个空节点用来返回，也可以在进入循环前进行一下判断，不开辟节点直接进循环</p><p>循环：将l1和l2中值较大的节点作为当前节点的下一节点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode *head,*cur;</span><br><span class="line">        head = (ListNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ListNode));</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>( l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h1><p>难度 简单</p><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109050042866.png" alt="img"></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109050042483.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109050042893.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Reference of the node with value = 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109050043045.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li><li>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li></ul><h2 id="思路与题解"><a href="#思路与题解" class="headerlink" title="思路与题解"></a>思路与题解</h2><p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p><p>这样，当它们相遇时，所指向的结点就是第一个公共结点。</p><p>两个链表长度分别为L1+C、L2+C， C为公共部分的长度， 第一个人走了L1+C步后，回到第二个人起点走L2步；第2个人走了L2+C步后，回到第一个人起点走L1步。 当两个人走的步数都为L1+L2+C时就两个家伙就相爱了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *node1 = headA, *node2 = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (node1 != node2) &#123;</span><br><span class="line">            node1 = node1 != <span class="literal">NULL</span> ? node1-&gt;next : headB;</span><br><span class="line">            node2 = node2 != <span class="literal">NULL</span> ? node2-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer14——双指针（简单）</title>
      <link href="/2021/09/03/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer14/"/>
      <url>/2021/09/03/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer14/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h1><p>难度 简单</p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="思路与题解"><a href="#思路与题解" class="headerlink" title="思路与题解"></a>思路与题解</h2><p>循环两次：</p><pre><code>1. 统计链表节点数n2. 遍历到第n-k个节点（即倒数第k个节点）并返回</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* getKthFromEnd(ListNode* head, int k) &#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        int n = 0,i;</span><br><span class="line">        while(cur != NULL) </span><br><span class="line">        &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        for(i = 0;i &lt; n-k;i++)</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h1><p>难度 简单</p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p><strong>注意：</strong>此题对比原题有改动</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>题目保证链表中节点的值互不相同</li><li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历链表，遇到这个节点就修改并删除</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *cur;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val == val) head = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题13——动态规划（中等）</title>
      <link href="/2021/09/02/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer13/"/>
      <url>/2021/09/02/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer13/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h1><p>难度 中等</p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="思路与题解"><a href="#思路与题解" class="headerlink" title="思路与题解"></a>思路与题解</h2><p>这是一道典型的动态规划题目。对于一个数 num[i]，我们有两种选择：</p><ol><li>只翻译自己；</li><li>和前面的数字组合翻译，前提是组合的数在 10−25 之间。</li></ol><p>用F[i]表示前 i 个数字的翻译方法数。根据以上两种选择，我们进行如下分析：</p><ul><li>如果只翻译自己，比如 12345，如果 5 单独翻译，那么方法数与 1234 是一样的， dp(i)=dp(i-1)。</li><li>如果和前面的数字组合，比如 1235，如果 35 组合翻译，从两方面考虑：<br>35 看成一个整体，虽然加了 5 但是和没加是一样的，状态 dp(i)=dp(i-1)；<br>35 组合就意味着不能再组合了，相当于条件 11 中的单独翻译自己，方法数与 12 是一样的。这时 dp(i)=dp(i-2)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">translateNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">           <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, x, y = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            x = num % <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">10</span> * x + y;</span><br><span class="line">            <span class="type">int</span> c = (tmp &gt;= <span class="number">10</span> &amp;&amp; tmp &lt;= <span class="number">25</span>) ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">            y = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-48-最长不含重复字符的子字符串-1"><a href="#剑指-Offer-48-最长不含重复字符的子字符串-1" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h1><p>难度 中等</p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h2 id="思路与题解-1"><a href="#思路与题解-1" class="headerlink" title="思路与题解"></a>思路与题解</h2><p>PS:这题剑指里归类为了动态规划，不过感觉好像滑动窗口更适合这个题点，解出来的时间也更快，不过可能主要是因为测试样例的原因把。。。</p><ol><li>用一个字符串str来存储从s[0]到s[i]中最长的字符串，初始化为空</li><li>遍历s，如果str中含有此时的s[i]，删除从第一位到重复位的字符串</li><li>每个遍历过程中更新最大值max</li><li>返回最大值</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Max = <span class="number">0</span>,i,j,index;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            index = str.<span class="built_in">find</span>(s[i],<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(index != <span class="number">-1</span>) str.<span class="built_in">erase</span>(<span class="number">0</span>,index+<span class="number">1</span>);</span><br><span class="line">            str+=s[i];</span><br><span class="line">            Max = <span class="built_in">max</span>((<span class="type">int</span>)str.<span class="built_in">length</span>(), Max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer12——动态规划（中等）</title>
      <link href="/2021/09/01/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer12/"/>
      <url>/2021/09/01/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer12/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h1><p>难度 简单</p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-100 &lt;= arr[i] &lt;= 100</code></li></ul><p>注意：本题与主站 53 题相同：<a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设数组为[-2,1,-3,4,-1,2,1,-5,4]，分解每一步问题：</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1,2,1,-5,4] -&gt; 6</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1,2,1,-5] -&gt; 6</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1,2,1] -&gt; 6</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1,2] -&gt; 5</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1] -&gt; 4</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4] -&gt; 4</span></span><br><span class="line"><span class="comment">    [-2,1,-3] -&gt; 1</span></span><br><span class="line"><span class="comment">    [-2,1] -&gt; 1</span></span><br><span class="line"><span class="comment">    [-2] -&gt; -2</span></span><br><span class="line"><span class="comment">    转移方程：F[i] = nums[i] + F[i-1]; //F[i-1] &gt; 0</span></span><br><span class="line"><span class="comment">            F[i] = nums[i];           //F[i-1] &lt;= 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.<span class="built_in">empty</span>() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max,n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        max = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i<span class="number">-1</span>] &gt; <span class="number">0</span> ) nums[i] += nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &gt; max ) max = nums[i];</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h1><p>难度 中等</p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt; grid.length &lt;= 200</code></li><li><code>0 &lt; grid[0].length &lt;= 200</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>转移方程：</p><script type="math/tex; mode=display">dp(i,j)= \left\{\begin{array}{**lr**}grid(i,j) & i=0;j=0;\\grid(i,j)+dp(i,j−1) & ,i=0,j\neq0\\grid(i,j)+dp(i−1,j) & ,i\neq0,j=0\\grid(i,j)+max[dp(i−1,j),dp(i,j−1)] & ,i\neq0,j\neq0\\\end{array}\right.</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    转移方程：F[i][j] = max(F[i-1][j], F[i][j-1]) + grid[i][j];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m,n,sum;</span><br><span class="line"></span><br><span class="line">        sum = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        m = grid.<span class="built_in">size</span>();</span><br><span class="line">        n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>( j = <span class="number">1</span>; j &lt; n ;j++ )</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; m ;i++ )</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i<span class="number">-1</span>][<span class="number">0</span>] ;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; m ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( j = <span class="number">1</span>; j &lt; n; j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                grid[i][j] += <span class="built_in">max</span>(grid[i][j<span class="number">-1</span>], grid[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer11——动态规划（简单）</title>
      <link href="/2021/08/31/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer11/"/>
      <url>/2021/08/31/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer11/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h1><p>难度 简单</p><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><span id="more"></span><h2 id="思路与题解"><a href="#思路与题解" class="headerlink" title="思路与题解"></a>思路与题解</h2><ol><li><p><strong>状态定义：</strong>F[i]为第i个斐波那契数列的数字</p></li><li><p><strong>转移方程：</strong>$F[i] = F[i-1]+F[i-2]$</p></li><li><p><strong>初始状态：</strong>$F[0]=0;F[1]=1$</p></li><li><p><strong>计算顺序：</strong>从0开始向目标迭代</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *F = <span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        F[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n ; i++)</span><br><span class="line">            F[i] = ( F[i<span class="number">-1</span>] + F[i<span class="number">-2</span>] ) % <span class="number">1000000007</span>;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> F[n] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h1><p>难度 简单</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><p>注意：本题与主站 70 题相同：<a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><h2 id="思路与题解-1"><a href="#思路与题解-1" class="headerlink" title="思路与题解"></a>思路与题解</h2><p>由于最后一级台阶只能从倒数第二级和倒数第三级跳上来，所以<br>跳上第n个台阶的方法数量 = 跳上第n-1个台阶的方法数量 + 跳上第n-2个台阶的方法数量<br>所以本题和斐波那契数列的题是一致的，只不过初始条件由$F(0) = 0,F (1) = 1,F(2) = 1$变成了$F(0) = 1,F (1) = 1,F(2) = 2$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    转移方程：F[n] = F[n-1]+F[n-2]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> a,b,tmp,i,sum;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            tmp = b;</span><br><span class="line">            b = sum;</span><br><span class="line">            a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h1><p>难度 中等</p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 数组长度 &lt;= 10^5</span><br></pre></td></tr></table></figure><h2 id="思路与题解-2"><a href="#思路与题解-2" class="headerlink" title="思路与题解"></a>思路与题解</h2><p>  假设输入为[7,1,5,3,6,4]</p><p>  分解问题并缩小为六个子问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[7,1,5,3,6,4] -&gt; max = 5</span><br><span class="line"></span><br><span class="line">[7,1,5,3,6] -&gt; max = 5</span><br><span class="line"></span><br><span class="line">[7,1,5,3] -&gt; max = 4</span><br><span class="line"></span><br><span class="line">[7,1,5] -&gt; max = 4</span><br><span class="line"></span><br><span class="line">[7,1] -&gt; max = 0</span><br><span class="line"></span><br><span class="line">[7] -&gt; max = 0</span><br></pre></td></tr></table></figure><p>则</p><script type="math/tex; mode=display">F[n] = max( F[n-1], max(prices[n] - prices[i]))</script><p>即 F[n] 为过去的最高利润 与 在第n日卖出时利润更高者</p><p>但是这里我用了两个循环来解，把时间复杂度整高了。。。导致了超时。。。    </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设输入为[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">    分解问题并缩小为六个子问题：</span></span><br><span class="line"><span class="comment">    [7,1,5,3,6,4] -&gt; max = 5</span></span><br><span class="line"><span class="comment">    [7,1,5,3,6] -&gt; max = 5</span></span><br><span class="line"><span class="comment">    [7,1,5,3] -&gt; max = 4</span></span><br><span class="line"><span class="comment">    [7,1,5] -&gt; max = 4</span></span><br><span class="line"><span class="comment">    [7,1] -&gt; max = 0</span></span><br><span class="line"><span class="comment">    [7] -&gt; max = 0</span></span><br><span class="line"><span class="comment">    F[n] = max( F[n-1], max(nums[n] - nums[i]))</span></span><br><span class="line"><span class="comment">    即 F[n] 为过去的最高利润 与 在第n日卖出时利润更高者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( prices.<span class="built_in">empty</span>() ) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> *F = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"></span><br><span class="line">        F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; n; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            F[i] = F[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i] - prices[j] &gt; F[i] )</span><br><span class="line">                    F[i] = <span class="built_in">max</span>(F[i<span class="number">-1</span>], prices[i] - prices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> F[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>大佬的思路：</p><p>大佬的转移方程写的比我的清楚：</p><script type="math/tex; mode=display">前i日最大利润=\max(前(i−1)日最大利润,第i日价格−前i日最低价格)\\dp[i]=\max(dp[i−1],prices[i]−\min(prices[0:i]))</script><p><strong>时间复杂度降低：</strong> 前 $i$ 日的最低价格 $min(prices[0:i]) $时间复杂度为 $O(i)$ 。而在遍历 $prices$时，可以借助一个变量（记为成本 $cost$ ）每日更新最低价格。优化后的转移方程为：</p><script type="math/tex; mode=display">dp[i]=\max(dp[i−1],prices[i]−\min(cost,prices[i]))</script><p><strong>空间复杂度降低：</strong> 由于$ dp[i]$ 只与 $dp[i - 1] , prices[i] , cost$ 相关，因此可使用一个变量（记为利润 $profit$ ）代替 $dp $列表。优化后的转移方程为：</p><script type="math/tex; mode=display">profit = \max(profit, prices[i] - \min(cost, prices[i])</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设输入为[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">    分解问题并缩小为六个子问题：</span></span><br><span class="line"><span class="comment">    [7,1,5,3,6,4] -&gt; max = 5</span></span><br><span class="line"><span class="comment">    [7,1,5,3,6] -&gt; max = 5</span></span><br><span class="line"><span class="comment">    [7,1,5,3] -&gt; max = 4</span></span><br><span class="line"><span class="comment">    [7,1,5] -&gt; max = 4</span></span><br><span class="line"><span class="comment">    [7,1] -&gt; max = 0</span></span><br><span class="line"><span class="comment">    [7] -&gt; max = 0</span></span><br><span class="line"><span class="comment">    F[n] = max( F[n-1], max(nums[n] - nums[i]))</span></span><br><span class="line"><span class="comment">    即 F[n] 为过去的最高利润 与 在第n日卖出时利润更高者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Special case</span></span><br><span class="line">        <span class="keyword">if</span>( prices.<span class="built_in">empty</span>() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Variable declaration</span></span><br><span class="line">        <span class="type">int</span> n,cost,profit;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Initialize</span></span><br><span class="line">        n = prices.<span class="built_in">size</span>();</span><br><span class="line">        profit = <span class="number">0</span>;</span><br><span class="line">        cost = prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Main loop</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cost = <span class="built_in">min</span>(cost,prices[i]);</span><br><span class="line">            profit = <span class="built_in">max</span>(profit, prices[i] - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划问题的常规解法</title>
      <link href="/2021/08/30/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/08/30/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：最近刷剑指offer刷到了动态规划相关的问题，之前没怎么学过，所以特地抽一天时间来学一下，以下为学习的笔记</p></blockquote><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h2><p><strong>1. 计数：</strong><br>    有多少种方式走到右下角<br>    有多少种方法选出k个数使得和为Sum<br><strong>2. 求最大最小值：</strong><br>    从左上角走到右下角路径的最大数字和<br>    最长上升子序列长度<br><strong>3. 求存在性：</strong><br>    取石子游戏，先手是否必胜<br>    能不能选出k个数使得和是Sum</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><ol><li><strong>确定状态</strong><br> 简单的说，就是解动态规划时需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么，类似解数学题中，xyz代表什么一样，具体分为下面两个步骤：<ul><li>研究最优策略的最后一步</li><li>化为子问题</li></ul></li><li><strong>转移方程</strong><br> 根据子问题定义直接得到</li><li><strong>初始条件和边界情况</strong><br> 初始条件一般都是a[0]、a[1]这种，多看看<br> 边界条件主要是看数组的边界，数组越不越界</li><li><strong>计算顺序</strong><br> 大部分从小到大迭代，精髓在于使用之前计算得到的结果</li></ol><span id="more"></span><h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h1><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1<br>示例 2：</p><p>输入：coins = [2], amount = 3<br>输出：-1<br>示例 3：</p><p>输入：coins = [1], amount = 0<br>输出：0<br>示例 4：</p><p>输入：coins = [1], amount = 1<br>输出：1<br>示例 5：</p><p>输入：coins = [1], amount = 2<br>输出：2</p><p>提示：</p><p>1 &lt;= coins.length &lt;= 12<br>1 &lt;= coins[i] &lt;= 231 - 1<br>0 &lt;= amount &lt;= 104</p><h2 id="思路与题解"><a href="#思路与题解" class="headerlink" title="思路与题解"></a>思路与题解</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    最后一步：添加一个硬币组成当前的金额，前面几步已经得到最优解</span></span><br><span class="line"><span class="comment">    转移方程：F[amount] = min&#123;F[amount-coins]&#125;</span></span><br><span class="line"><span class="comment">    边界条件：1. F[0] = 0; 2.负数硬币为正无穷</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>* F = <span class="keyword">new</span> <span class="type">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> N = coins.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= amount;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            F[i] = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; N; j++)</span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span>( i-coins[j] &gt;= <span class="number">0</span> &amp;&amp; F[i-coins[j]]!= INT_MAX)</span><br><span class="line">                &#123;</span><br><span class="line">                     F[i] = <span class="built_in">min</span>(F[i-coins[j]] + <span class="number">1</span> ,F[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(F[amount] == INT_MAX) F[amount] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> F[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h1><p>难度 中等</p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><h2 id="思路与题解-1"><a href="#思路与题解-1" class="headerlink" title="思路与题解"></a>思路与题解</h2><p><strong>转移方程</strong>：$F[i][j] = F[i-1][j] + F[i][j-1];$</p><p><strong>初始状态</strong>：$F[i][0]=1;F[0][j] = 1$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="C-二维数组开辟方法"><a href="#C-二维数组开辟方法" class="headerlink" title="C++二维数组开辟方法"></a>C++二维数组开辟方法</h4><p>这里还学到了点C++的二维数组的开辟方法，以开辟m行，n列的二维数组 <code>array2D[m][n]</code></p><p>方法总结如下：</p><ol><li><p>n为已知常量；二维数组开辟时第二位不能为变量，因此需要n已知且为常量才能使用<br>假设 n = 5;则可开辟<code>array2D[m][5]</code></p></li><li><p>使用指针间接引用；即先开辟 m 个指向指针的指针<code>`array2D</code>再在每一行开辟新的行数组</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **array2D = <span class="keyword">new</span> <span class="type">int</span> *[m];  </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)  </span><br><span class="line">&#123;  </span><br><span class="line">array2D[i] = <span class="keyword">new</span> <span class="type">int</span>[n];  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ol><li>使用STL中的vector容器</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt;  IntVector;  </span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;IntVector&gt;    IntVector2D;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i, j;  </span><br><span class="line"></span><br><span class="line">IntVector2D *pArray2D = <span class="keyword">new</span> IntVector2D;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态设置大小.  </span></span><br><span class="line">pArray2D-&gt;<span class="built_in">resize</span>(height);  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;height; ++i)  </span><br><span class="line">&#123;  </span><br><span class="line">    (*pArray2D)[i].<span class="built_in">resize</span>(width);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    转移方程：F[i][j] = F[i-1][j] + F[i][j-1];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="type">int</span> **F = <span class="keyword">new</span> <span class="type">int</span>*[m];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; m; i++ )</span><br><span class="line">            F[i] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; m;i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) F[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> F[i][j] = F[i<span class="number">-1</span>][j] + F[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> F[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h1><p>难度 中等</p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实这题并不适合拿动态规划来解，因为写出来的时间复杂度有$O(n^2)$数量级（所以我的题解在LeetCode里因为超时挂了。。。不过还是作为一个DP的典型题目写下思路</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j,Size;</span><br><span class="line">        Size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> *F = <span class="keyword">new</span> <span class="type">bool</span>[Size];</span><br><span class="line"></span><br><span class="line">        F[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; Size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            F[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(F[j] &amp;&amp; nums[j] + j &gt;= i)</span><br><span class="line">                &#123;</span><br><span class="line">                    F[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> F[Size<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题10——搜索与回溯算法（简单）</title>
      <link href="/2021/08/29/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer10/"/>
      <url>/2021/08/29/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer10/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h1><p>难度 中等</p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><p><code>3  / \  4  5 / \ 1  2</code><br>给定的树 B：</p><p><code>4  / 1</code><br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,3], B = [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [3,4,5,1,2], B = [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 10000</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>采用递归判断的方法比较好撸，先序遍历树A的所有节点，判断每个节点的子树是否包含树B</p><p><strong><code>recur(A, B)</code> 函数：</strong></p><ol><li>终止条件：<ol><li>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；</li><li>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；</li><li>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li></ol></li><li><p>返回值：</p><ol><li>继续判断 A 和 B 的左子节点是否相等，即 recur(A.left, B.left) ；</li><li>判断 A 和 B 的右子节点是否相等，即 recur(A.right, B.right) ；<br><strong><code>isSubStructure(A, B)</code> 函数：</strong></li></ol></li><li><p>特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false ；</p></li><li>返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<ol><li>以 节点 A 为根节点的子树 包含树 BB ，对应 recur(A, B)；</li><li>树 B 是 树 A 左子树 的子结构，对应 isSubStructure(A.left, B)；</li><li>树 B 是 树 A 右子树 的子结构，对应 isSubStructure(A.right, B)；<br>以上 2. 3. 实质上是在对树 AA 做 先序遍历 。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ( A != <span class="literal">NULL</span> &amp;&amp; B != <span class="literal">NULL</span>) &amp;&amp; (<span class="built_in">helper</span>(A, B)</span><br><span class="line">        || <span class="built_in">isSubStructure</span>(A-&gt;left,B) || <span class="built_in">isSubStructure</span>(A-&gt;right,B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(TreeNode* A, TreeNode* B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( B == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( A == <span class="literal">NULL</span> || A-&gt;val != B-&gt;val ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">helper</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>刚开始想一个函数直接解决，于是有了以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( A == <span class="literal">NULL</span> &amp;&amp; B == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>( B == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( A == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>( A-&gt;val == B-&gt;val ) <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(A-&gt;left, B-&gt;left) </span><br><span class="line">                            &amp;&amp; <span class="built_in">isSubStructure</span>(A-&gt;right,B-&gt;right);</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//即if(A-&gt;val != B-&gt;val)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后来发现一个函数不方便判断当两个节点值不相同时候的情况，我这里写的两个节点值不相同只能继续往下遍历，没有办法知道是在判断A的子树里的值是否和B的子树的值相同这个逻辑里还是在判断A的子树节点值是否与B的根节点的值相同的逻辑里导致了结果与遍历到底层的结果相同，所以这个题必须分成两个函数来写。</p><h1 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h1><p>难度 简单</p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><p><code>4  /  \ 2   7 / \  / \1  3 6  9</code><br>镜像输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4  /  \ 7   2 / \  / \9  6 3  1</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 1000</span><br></pre></td></tr></table></figure><p>注意：本题与主站 226 题相同：<a href="https://leetcode-cn.com/problems/invert-binary-tree/">https://leetcode-cn.com/problems/invert-binary-tree/</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>先序遍历，回溯反向</p><ol><li>终止条件：空树直接返回</li><li>递推工作：<ol><li>新建节点暂存root的左子节点,防止修改后左子节点丢失</li><li>进入root的右子树返回为root的左子节点</li><li>进入root的左子树返回为root的右子节点<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    先序遍历，回溯反向</span></span><br><span class="line"><span class="comment">    1.终止条件：空树直接返回</span></span><br><span class="line"><span class="comment">    2.递推工作：</span></span><br><span class="line"><span class="comment">        1.新建节点暂存root的左子节点,防止修改后左子节点丢失</span></span><br><span class="line"><span class="comment">        2.进入root的右子树返回为root的左子节点</span></span><br><span class="line"><span class="comment">        3.进入root的左子树返回为root的右子节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* Node = root-&gt;left;</span><br><span class="line">        root-&gt;left = <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;right = <span class="built_in">mirrorTree</span>(Node);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h1><p>难度简单226收藏分享切换为英文接收动态反馈</p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p><code>1  / \ 2  2 / \ / \3  4 4  3</code><br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1  / \ 2  2  \  \  3   3</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 1000</span><br></pre></td></tr></table></figure><p>注意：本题与主站 101 题相同：<a href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol><li>终止条件：<ol><li>左右节点均为空，返回true</li><li>左右节点的值不同，返回false</li><li>左右节点只有一节点为空，返回false</li></ol></li><li>递推内容：<ol><li>左右节点值相同，进入左节点的左子树与右节点的右子树继续比较，同时，进入左节点的右子树与右节点的左子树继续比较</li></ol></li></ol><p>大佬的思路：<br><code>isSymmetric(root) ：</code></p><p>特例处理： 若根节点 root 为空，则直接返回 true 。<br>返回值： 即 <code>recur(root.left, root.right)</code>;<br><code>recur(L, R) ：</code></p><ol><li>终止条件：<ul><li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li><li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；</li><li>当节点 LL 值 ≠节点 R 值： 此树不对称，因此返回 false；</li></ul></li><li>递推工作：<ul><li>判断两节点 L.left 和 R.right是否对称，即 recur(L.left, R.right) ；</li><li>判断两节点 L.right 和 R.left 是否对称，即 recur(L.right, R.left) ；</li><li>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp;&amp; 连接。</li></ul></li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>```C++<br>/**</p><ul><li>Definition for a binary tree node.</li><li>struct TreeNode {</li><li>int val;</li><li>TreeNode *left;</li><li>TreeNode *right;</li><li>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</li><li>};<br><em>/<br>/</em><ol><li>终止条件：<ol><li>左右节点均为空，返回true</li><li>左右节点的值不同，返回false</li><li>左右节点只有一节点为空，返回false</li></ol></li><li>递推内容：<ol><li>左右节点值相同，进入左节点的左子树与右节点的右子树继续比较，同时，进入左节点的右子树与右节点的左子树继续比较<br><em>/<br>class Solution {<br>public:<br>bool isSymmetric(TreeNode</em> root) {<br>if(!root) return true;<br>return helper(root-&gt;left, root-&gt;right);<br>}<br>bool helper(TreeNode<em> Left, TreeNode</em> Right)<br>{<br>if( Left == NULL &amp;&amp; Right == NULL)  return true;<br>if( Left == NULL || Right == NULL) return false;<br>if( Left-&gt;val != Right-&gt;val ) return false;<br>return helper( Left-&gt;left, Right-&gt;right) &amp;&amp; helper(Left-&gt;right, Right-&gt;left);<br>}<br>};</li></ol></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 先序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题9——搜索与回溯算法（简单）</title>
      <link href="/2021/08/28/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer9/"/>
      <url>/2021/08/28/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer9/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h1><p>难度 简单</p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><p>注意：本题与主站 102 题相同：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><span id="more"></span><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><blockquote><p>建议先做 <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">面试题32 - I. 从上到下打印二叉树</a> 再做此题，两题仅有微小区别，即本题需将 每一层打印到一行 。</p></blockquote><p>I. 按层打印： 题目要求的二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。BFS 通常借助 队列 的先入先出特性来实现。</p><p>II. 每层打印到一行： 将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> i,N;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        TreeNode* Node;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            N = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; rol;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Node = que.<span class="built_in">front</span>();</span><br><span class="line">                rol.<span class="built_in">push_back</span>(Node-&gt;val);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(Node-&gt;left != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(Node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(Node-&gt;right != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(Node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(rol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h1><p>难度 中等</p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解题思路：<br>面试题32 - I. <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">从上到下打印二叉树 主要考察 树的按层打印</a> ；<br>面试题32 - II. <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树 II 额外要求 每一层打印到一行</a> ；<br>本题额外要求 打印顺序交替变化（建议按顺序做此三道题）。</p><p>BFS层序遍历，每遍历完两层就将要添加的行内数据反转一次</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> i,N;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        TreeNode* Node;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            N = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; rol;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Node = que.<span class="built_in">front</span>();</span><br><span class="line">                rol.<span class="built_in">push_back</span>(Node-&gt;val);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(Node-&gt;left != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(Node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(Node-&gt;right != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(Node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( res.<span class="built_in">size</span>()%<span class="number">2</span> == <span class="number">1</span>) <span class="built_in">reverse</span>(rol.<span class="built_in">begin</span>(), rol.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(rol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 层序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题7——搜索与回溯算法（简单）</title>
      <link href="/2021/08/27/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer8/"/>
      <url>/2021/08/27/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer8/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h1><p>难度 中等 </p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code><span id="more"></span></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>层序遍历。</p><p>特殊情况：树为空，直接返回一个空容器</p><p>算法流程：</p><ol><li>将根节点入队，进入循环</li><li>队头元素出队的同时队头元素的左右非空节点入队，同时将队头元素的数值推入返回的容器内。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>```C++<br>/**<ul><li>Definition for a binary tree node.</li><li>struct TreeNode {</li><li>int val;</li><li>TreeNode *left;</li><li>TreeNode *right;</li><li>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</li><li>};<br><em>/<br>class Solution {<br>public:<br>vector<int> levelOrder(TreeNode</em> root) {<br>   vector<int> res;<br>   if(!root)<pre><code>   return res;</code></pre>   queue<TreeNode*> Que;<br>   Que.push(root);<br>   while(!Que.empty())<br>   {<pre><code>   res.push_back(Que.front()-&gt;val);   if(Que.front()-&gt;left != NULL)Que.push(Que.front()-&gt;left);   if(Que.front()-&gt;right != NULL)Que.push(Que.front()-&gt;right);   Que.pop();</code></pre>   }<br>   return res;<br>}<br>};</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 层序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题7——查找算法（中等）</title>
      <link href="/2021/08/26/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer7/"/>
      <url>/2021/08/26/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer7/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h1><p>难度 简单</p><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s = &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= s 的长度 &lt;= 50000</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>建立一个大小为 26 的数组统计字符串中各个字母出现的次数，遍历字符串，将第一个出现次数为1的字母输出，没有则输出空格’ ‘</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> CHAR[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++ )</span><br><span class="line">            CHAR[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++ )</span><br><span class="line">            <span class="keyword">if</span>(CHAR[s[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> s[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题6——查找算法（中等）</title>
      <link href="/2021/08/25/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer6/"/>
      <url>/2021/08/25/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer6/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h1><p>难度 简单</p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。 </p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>注意：本题与主站 154 题相同：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解题思路：<br>为精简篇幅，本文将数组 <code>numbers</code> 缩写为 <code>nums</code>。</p><p>如下图所示，寻找旋转数组的最小元素即为寻找 右排序数组 的首个元素 <code>nums[x]</code> ，称 x 为 旋转点 。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108292216271.png" alt="Picture1.png"></p><p>排序数组的查找问题首先考虑使用 二分法 解决，其可将 遍历法 的 线性级别 时间复杂度降低至 对数级别 。</p><p><strong>算法流程</strong>：</p><ol><li>初始化： 声明 i, j 双指针分别指向 nums 数组左右两端；</li><li>循环二分： 设 m = (i + j) / 2为每次二分的中点（ “<code>/</code>“ 代表向下取整除法，因此恒有 $i \leq m &lt; j$ ），可分为以下三种情况：<ol><li>当 nums[m] &gt; nums[j] 时： m 一定在 左排序数组 中，即旋转点 x 一定在 [m + 1, j] 闭区间内，因此执行 i = m + 1;<ol><li>当 nums[m] &lt; nums[j]时： m 一定在 右排序数组 中，即旋转点 x 一定在[i, m] 闭区间内，因此执行 j = m；</li><li>当 nums[m] = nums[j]时： 无法判断 m 在哪个排序数组中，即无法判断旋转点 x 在 [i, m] 还是 [m + 1, j] 区间中。解决方案： 执行 j — 缩小判断范围，分析见下文。</li></ol></li></ol></li><li>返回值： 当 i = j时跳出二分循环，并返回 旋转点的值 nums[i] 即可。</li></ol><p><strong>正确性证明：</strong><br>  当 nums[m] = nums[j]] 时，无法判定 m 在左（右）排序数组，自然也无法通过二分法安全地缩小区间，因为其会导致旋转点 x 不在区间 [i, j] 内。举例如下：</p><blockquote><p>设以下两个旋转点值为 00 的示例数组，则当 i = 0,j=4 时 m = 2 ，两示例结果不同。<br><strong>示例一</strong> [1, 0, 1, 1, 1]：旋转点 x = 1，因此 m = 2在 右排序数组 中。<br><strong>示例二</strong> [1, 1, 1, 0, 1]：旋转点 x = 3 ，因此 m= 2 在 左排序数组 中。</p></blockquote><p>而证明 j = j - 1 正确（缩小区间安全性），需分为两种情况：</p><ol><li><p>当 x &lt; j 时： 易得执行 j = j - 1 后，旋转点 xx 仍在区间 [i, j]内。</p></li><li><p>当 x = j 时： 执行 j = j - 1后越过（丢失）了旋转点 x ，但最终返回的元素值 nums[i] 仍等于旋转点值 nums[x] 。</p><ol><li>由于 x = j ，因此 $nums[x] = nums[j] = nums[m] \leq number[i]$;</li><li>又由于 $i \leq m &lt;j$恒成立，因此有 m &lt; x ，即此时 m 一定在左排序数组中，因此 $nums[m] \geq nums[i]$ ;<br>综合 1. , 2. ，可推出 nums[i] = nums[m]nums[i]=nums[m] ，且区间 [i, m][i,m] 内所有元素值相等，即有：<script type="math/tex; mode=display">nums[i] = nums[i+1] = \cdots = nums[m] = nums[x]</script></li></ol></li></ol><ul><li>此时，执行 j = j - 1 后虽然丢失了旋转点 xx ，但之后区间 [i, j] 只包含左排序数组，二分下去返回的一定是本轮的 nums[i]，而其与 nums[x] 相等。</li><li>综上所述，此方法可以保证返回值 nums[i] 等于旋转点值 nums[x] ，但在少数特例下 $i \ne x$ ；而本题目只要求返回 “旋转点的值” ，因此本方法正确。</li></ul><p>补充思考： 为什么本题二分法不用 nums[m] 和 nums[i] 作比较？</p><p>二分目的是判断 m 在哪个排序数组中，从而缩小区间。而在 nums[m] &gt; nums[i]情况下，无法判断 mm 在哪个排序数组中。本质上是由于 j 初始值肯定在右排序数组中； i 初始值无法确定在哪个排序数组中。举例如下：</p><blockquote><p>对于以下两示例，当 i = 0, j = 4, m = 2 时，有 nums[m] &gt; nums[i] ，而结果不同。<br>[1, 2, 3, 4 ,5]旋转点 x = 0 ： m 在右排序数组（此示例只有右排序数组）；<br>[3, 4, 5, 1 ,2]旋转点 x = 3 ： m 在左排序数组。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Left,Right,mid;</span><br><span class="line">        Left = <span class="number">0</span>; Right = numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(Left &lt; Right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (Left+Right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &gt; numbers[Right]) Left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt; numbers[Right]) Right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] == numbers[Right]) Right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[Left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题5——查找算法（中等）</title>
      <link href="/2021/08/24/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer5/"/>
      <url>/2021/08/24/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer5/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h1><p>难度 中等</p><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= n &lt;= 1000</span><br><span class="line">0 &lt;= m &lt;= 1000</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>若使用暴力法遍历矩阵 matrix ，则时间复杂度为 O(NM)O(NM) 。暴力法未利用矩阵 “从上到下递增、从左到右递增” 的特点，显然不是最优解法。</p></blockquote><p>刚开始的想法是行内做二分，列内也做二分，每次排除四分之三的数据，然后发现等矩阵小了之后好像就不方便找了，写起来很麻烦，然后参考了下题解，想到了这是个二叉搜索树就用二叉搜索树的性质了</p><p>如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值 target 。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108292205244.png" alt="Picture1.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        i = matrix.<span class="built_in">size</span>()<span class="number">-1</span>;  j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i&gt;=<span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 链表 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题4——字符串（简单）</title>
      <link href="/2021/08/23/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer4/"/>
      <url>/2021/08/23/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer4/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h1><p>难度简单152收藏分享切换为英文接收动态反馈</p><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= s 的长度 &lt;= 10000</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>建立一个大小为3*Size（保证足够用来替换）的新的字符串str，遍历s并复制进入str中，每次遇到空格就复制<code>&quot;%20&quot;</code>，最后新建一个大小为替换后的字符数的字符串STR，把str中有效位复制进STR并返回</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i,Size,j;</span><br><span class="line">        Size = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">string <span class="title">str</span><span class="params">(<span class="number">3</span>*Size,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; Size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                str[j++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                str[j++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                str[j++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                str[j++] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">STR</span><span class="params">(j,<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; j;i++)</span><br><span class="line">            STR[i] = str[i];</span><br><span class="line">        <span class="keyword">return</span> STR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h1><p>难度简单144收藏分享切换为英文接收动态反馈</p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;lrloseumgh&quot;, k = 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= k &lt; s.length &lt;= 10000</code></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li><p>把需要翻转的前N位复制进str；</p></li><li><p>遍历s，把前 length()-n 位向前移动n位</p></li><li>把str复制进入后n位</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">string <span class="title">str</span><span class="params">(s,<span class="number">0</span>,n)</span></span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(i &lt; s.<span class="built_in">length</span>()-n)</span><br><span class="line">                s[i] = s[i+n];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s[i] = str[i-(s.<span class="built_in">length</span>()-n)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题3——链表2（简单）</title>
      <link href="/2021/08/22/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer3/"/>
      <url>/2021/08/22/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer3/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h1><p>难度 简单</p><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 5000</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="1-迭代（双指针）"><a href="#1-迭代（双指针）" class="headerlink" title="1.迭代（双指针）"></a>1.迭代（双指针）</h2><p>考虑遍历链表，并在访问各节点时修改 next 引用指向，算法流程见注释。</p><p>复杂度分析：<br><strong>时间复杂度 O(N)O(N)</strong> ： 遍历链表使用线性大小时间。<br><strong>空间复杂度 O(1)O(1)</strong> ： 变量 pre 和 cur 使用常数大小额外空间。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur,*pre,*tmp;</span><br><span class="line">        pre = <span class="literal">NULL</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(pre)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = cur-&gt;next;    <span class="comment">// 暂存后继节点 cur.next</span></span><br><span class="line">            cur-&gt;next = pre;    <span class="comment">// 修改 next 引用指向</span></span><br><span class="line">            pre = cur;            <span class="comment">// pre 暂存 cur</span></span><br><span class="line">            cur = tmp;            <span class="comment">// cur 访问下一节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h2><p>考虑使用递归法遍历链表，当越过尾节点后终止递归，在回溯时修改各节点的 next 引用指向。</p><p><code>recur(cur, pre)</code>递归函数：<br>终止条件：当 cur 为空，则返回尾节点 pre （即反转链表的头节点）；<br>递归后继节点，记录返回值（即反转链表的头节点）为 res ；<br>修改当前节点 cur 引用指向前驱节点 pre ；<br>返回反转链表的头节点 res ；<br><code>reverseList(head)</code> 函数：<br>调用并返回 recur(head, null) 。传入 null 是因为反转链表后， head 节点指向 null ；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(head, <span class="literal">nullptr</span>);           <span class="comment">// 调用递归并返回</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">recur</span><span class="params">(ListNode* cur, ListNode* pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> pre;        <span class="comment">// 终止条件</span></span><br><span class="line">        ListNode* res = <span class="built_in">recur</span>(cur-&gt;next, cur); <span class="comment">// 递归后继节点</span></span><br><span class="line">        cur-&gt;next = pre;                       <span class="comment">// 修改节点引用指向</span></span><br><span class="line">        <span class="keyword">return</span> res;                            <span class="comment">// 返回反转链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h1><p>难度 中等</p><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li><li>节点数目不超过 1000 。</li></ul><p><strong>注意：</strong>本题与主站 138 题相同：<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">https://leetcode-cn.com/problems/copy-list-with-random-pointer/</a></p><h2 id="迭代-结点拆分"><a href="#迭代-结点拆分" class="headerlink" title="迭代+结点拆分"></a>迭代+结点拆分</h2><p>第一次遍历：在链表各节点中间插入新的节点，复制节点的值</p><p>第二次遍历：复制链表各节点的random指向</p><p>第三次遍历：分离链表，将两个链表之间的next关系分离形成两个链表</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        Node *headNew, *cur, *Pre;</span><br><span class="line">        Pre = head;</span><br><span class="line">        <span class="keyword">while</span>(Pre != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">            cur-&gt;val = Pre-&gt;val;</span><br><span class="line">            cur-&gt;next = Pre-&gt;next;</span><br><span class="line">            Pre-&gt;next = cur;</span><br><span class="line">            Pre = Pre-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;random!=<span class="literal">NULL</span>) cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> cur-&gt;next-&gt;random = <span class="literal">NULL</span>;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        headNew = head-&gt;next;cur = head-&gt;next;Pre = head;  </span><br><span class="line">        <span class="keyword">while</span>(Pre)</span><br><span class="line">        &#123;</span><br><span class="line">            Pre-&gt;next = cur-&gt;next;</span><br><span class="line">            Pre = Pre-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next!=<span class="literal">NULL</span>) cur-&gt;next = Pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题2——链表1（简单）</title>
      <link href="/2021/08/21/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer2/"/>
      <url>/2021/08/21/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer2/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h1><p>难度 简单</p><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 链表长度 &lt;= 10000</span><br></pre></td></tr></table></figure><p>通过次数277,964</p><p>提交次数369,505<br><span id="more"></span></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="辅助栈法："><a href="#辅助栈法：" class="headerlink" title="辅助栈法："></a>辅助栈法：</h2><p>遍历整个链表，把所有元素压入堆栈中，最后把堆栈中的元素顺序弹出并存储到 Vector 容器中返回</p><p><strong>算法流程：</strong><br>入栈： 遍历链表，将各节点值 push 入栈。</p><p>出栈： 将各节点值 pop 出栈，存储于Vector并返回。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">reversePrint</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">        <span class="type">int</span> top,i,tmp;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; sta;</span><br><span class="line">        ListNode* P = head;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; Val;</span><br><span class="line">        <span class="keyword">while</span>(P)</span><br><span class="line">        &#123;</span><br><span class="line">            sta.push( P-&gt;val ); </span><br><span class="line">            P = P-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!sta.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            Val.push_back(sta.top());</span><br><span class="line">            sta.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归法："><a href="#递归法：" class="headerlink" title="递归法："></a>递归法：</h2><blockquote><p><strong>利用递归</strong>： 先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出。</p></blockquote><p><strong>递推阶段</strong>： 每次传入 head-&gt;next ，以 head == null（即走过链表尾部节点）为递归终止条件，此时直接返回。<br><strong>回溯阶段</strong>： 层层回溯时，将当前节点值加入列表，最后返回即可</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">reversePrint</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; V = reversePrint(head-&gt;next);</span><br><span class="line">        V.push_back(head-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题1——栈与队列</title>
      <link href="/2021/08/20/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer1/"/>
      <url>/2021/08/20/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer1/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h1><p>难度 简单</p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li></ul><span id="more"></span><h1 id="思路与题解"><a href="#思路与题解" class="headerlink" title="思路与题解"></a>思路与题解</h1><p>使用两个数组和两个top表示出两个栈，然后一个栈用来入栈和存储数据，另一个用来做队列的出队列操作。</p><blockquote><p>不过笔者在写这个题的时候偷了点懒，直接使用数组和top来实现队列了。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">10000</span>];</span><br><span class="line">&#125; CQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CQueue* <span class="title function_">cQueueCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    CQueue* Queue;</span><br><span class="line">    Queue = (CQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CQueue));</span><br><span class="line">    Queue-&gt;top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        Queue-&gt;data[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> Queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cQueueAppendTail</span><span class="params">(CQueue* obj, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    obj-&gt;data[obj-&gt;top] = value;</span><br><span class="line">    obj-&gt;top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cQueueDeleteHead</span><span class="params">(CQueue* obj)</span> &#123;</span><br><span class="line">    <span class="type">int</span> value,i;</span><br><span class="line">    <span class="keyword">if</span>( obj-&gt;top == <span class="number">0</span> )</span><br><span class="line">            value = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            value = obj-&gt;data[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; obj-&gt;top;i++ )</span><br><span class="line">                obj-&gt;data[i] = obj-&gt;data[i+<span class="number">1</span>];</span><br><span class="line">            obj-&gt;top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cQueueFree</span><span class="params">(CQueue* obj)</span> &#123;</span><br><span class="line">        <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = cQueueCreate();</span></span><br><span class="line"><span class="comment"> * cQueueAppendTail(obj, value);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = cQueueDeleteHead(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * cQueueFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h1><p>难度 简单 </p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><h2 id="提示：-1"><a href="#提示：-1" class="headerlink" title="提示："></a>提示：</h2><ol><li>各函数的调用总次数不超过 20000 次</li></ol><h1 id="思路与题解-1"><a href="#思路与题解-1" class="headerlink" title="思路与题解"></a>思路与题解</h1><p>在设计的堆栈里增加一个数值min来存储最小值，每次入栈和出栈都更新堆栈里的最小值</p><blockquote><p>不知道为什么，最后一个测试样例一直通不过，调试了无数次终于成功了</p></blockquote><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> min;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">10000</span>];</span><br><span class="line">&#125; MinStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line">MinStack* <span class="title function_">minStackCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MinStack* Mystack;</span><br><span class="line">    Mystack = (MinStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStack));</span><br><span class="line">    Mystack -&gt; top = <span class="number">0</span>;</span><br><span class="line">    Mystack -&gt; min = <span class="number">0x01</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> Mystack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">minStackPush</span><span class="params">(MinStack* obj, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    obj-&gt;data[obj-&gt;top++] = x;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; obj-&gt;min)obj-&gt;min = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">minStackPop</span><span class="params">(MinStack* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;data[obj-&gt;top<span class="number">-1</span>] == obj-&gt;min)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;min = obj-&gt;data[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; obj-&gt;top<span class="number">-1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(obj-&gt;min &gt; obj-&gt;data[i])obj-&gt;min=obj-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minStackTop</span><span class="params">(MinStack* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[obj-&gt;top<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minStackMin</span><span class="params">(MinStack* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)obj-&gt;min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">minStackFree</span><span class="params">(MinStack* obj)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = minStackCreate();</span></span><br><span class="line"><span class="comment"> * minStackPush(obj, x);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * minStackPop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = minStackTop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_4 = minStackMin(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * minStackFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 堆栈 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构刷题笔记14</title>
      <link href="/2021/08/19/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%9514/"/>
      <url>/2021/08/19/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%9514/</url>
      
        <content type="html"><![CDATA[<h1 id="11-散列2-Hashing-25-分"><a href="#11-散列2-Hashing-25-分" class="headerlink" title="11-散列2 Hashing (25 分)"></a>11-散列2 Hashing (25 分)</h1><p>The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be <em>H</em>(<em>k**ey</em>)=<em>k**ey</em>%<em>TS<strong>i</strong>ze</em> where <em>TS<strong>i</strong>ze</em> is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.</p><p>Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.</p><h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. For each case, the first line contains two positive numbers: <em>MS<strong>i</strong>ze</em> (≤104) and <em>N</em> (≤<em>MS<strong>i</strong>ze</em>) which are the user-defined table size and the number of input numbers, respectively. Then <em>N</em> distinct positive integers are given in the next line. All the numbers in a line are separated by a space.</p><span id="more"></span><h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print “-“ instead.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">10 6 4 15</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 1 4 -</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hs-1-2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100005</span></span><br><span class="line"><span class="type">int</span> H[MAX];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    pos = x%m;</span><br><span class="line">    <span class="keyword">if</span>(H[pos] == <span class="number">-1</span>) &#123;</span><br><span class="line">        H[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(H[pos] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(H[(pos+k*k)%m] == <span class="number">-1</span>) &#123;</span><br><span class="line">                H[(pos+k*k)%m] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> (pos+k*k)%m;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextPrime</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,p=(N%<span class="number">2</span>)?N+<span class="number">2</span>:N+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (N==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&lt;=MAX) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=(<span class="type">int</span>)<span class="built_in">sqrt</span>(p);i&gt;<span class="number">2</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(!(p%i)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> p+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,n,x;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    m = NextPrime(m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) H[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(flag) flag =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        t = Hash(x,m);</span><br><span class="line">        <span class="keyword">if</span>(t != <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构刷题笔记13</title>
      <link href="/2021/08/18/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%9513/"/>
      <url>/2021/08/18/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%9513/</url>
      
        <content type="html"><![CDATA[<h1 id="11-散列1-电话聊天狂人-25-分"><a href="#11-散列1-电话聊天狂人-25-分" class="headerlink" title="11-散列1 电话聊天狂人 (25 分)"></a>11-散列1 电话聊天狂人 (25 分)</h1><p>给定大量手机用户通话记录，找出其中通话次数最多的聊天狂人。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入首先给出正整数<em>N</em>（≤105），为通话记录条数。随后<em>N</em>行，每行给出一条通话记录。简单起见，这里只列出拨出方和接收方的11位数字构成的手机号码，其中以空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>在一行中给出聊天狂人的手机号码及其通话次数，其间以空格分隔。如果这样的人不唯一，则输出狂人中最小的号码及其通话次数，并且附加给出并列狂人的人数。<br><span id="more"></span></p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">13005711862 13588625832</span><br><span class="line">13505711862 13088625832</span><br><span class="line">13588625832 18087925832</span><br><span class="line">15005713862 13588625832</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">13588625832 3</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><blockquote><p>本篇文章主要代码源自于陈越姥姥的课程里的小白专场</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lt-1-1.c</span></span><br><span class="line"><span class="comment">//分离链接方法.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYLENGTH 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTABLESIZE 100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXD 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElementType[KEYLENGTH+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Index;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">    <span class="type">int</span> Count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TblNode</span> *<span class="title">HashTable</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TblNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> TableSize;</span><br><span class="line">    List Heads;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextPrime</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,p=(N%<span class="number">2</span>)?N+<span class="number">2</span>:N+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&lt;=MAXTABLESIZE) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=(<span class="type">int</span>)<span class="built_in">sqrt</span>(p);i&gt;<span class="number">2</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(!(p%i)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> p+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> Key,<span class="type">int</span> TableSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Key%TableSize;</span><br><span class="line">&#125;</span><br><span class="line">HashTable <span class="title function_">CreateTable</span><span class="params">(<span class="type">int</span> TableSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    HashTable H;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    H = (HashTable)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TblNode));</span><br><span class="line">    H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line">    H-&gt;Heads = (List)<span class="built_in">malloc</span>(H-&gt;TableSize * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;H-&gt;TableSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        H-&gt;Heads[i].Data[<span class="number">0</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        H-&gt;Heads[i].Next = <span class="literal">NULL</span>;</span><br><span class="line">        H-&gt;Heads[i].Count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Position <span class="title function_">Find</span><span class="params">(HashTable H,ElementType Key)</span></span><br><span class="line">&#123;</span><br><span class="line">    Position P;</span><br><span class="line">    Index Pos;</span><br><span class="line">    Pos = Hash(atoi(Key+KEYLENGTH-MAXD),H-&gt;TableSize);</span><br><span class="line">    P = H-&gt;Heads[Pos].Next;</span><br><span class="line">    <span class="keyword">while</span>(P &amp;&amp; <span class="built_in">strcmp</span>(P-&gt;Data,Key))</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert</span><span class="params">(HashTable H,ElementType Key)</span></span><br><span class="line">&#123;</span><br><span class="line">    Position P,NewCell;</span><br><span class="line">    Index Pos;</span><br><span class="line">    P = Find(H,Key);</span><br><span class="line">    <span class="keyword">if</span>(! P) &#123;</span><br><span class="line">        NewCell = (Position)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">        <span class="built_in">strcpy</span>(NewCell-&gt;Data,Key);</span><br><span class="line">        NewCell-&gt;Count = <span class="number">1</span>;</span><br><span class="line">        Pos = Hash(atoi(Key+KEYLENGTH-MAXD),H-&gt;TableSize);</span><br><span class="line">        NewCell-&gt;Next = H-&gt;Heads[Pos].Next;</span><br><span class="line">        H-&gt;Heads[Pos].Next = NewCell;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        P-&gt;Count ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyTable</span><span class="params">(HashTable H)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Position P,Tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;H-&gt;TableSize;i++) &#123;</span><br><span class="line">        P = H-&gt;Heads[i].Next;</span><br><span class="line">        <span class="keyword">while</span>(P) &#123;</span><br><span class="line">            Tmp = P-&gt;Next;</span><br><span class="line">            <span class="built_in">free</span>(P);</span><br><span class="line">            P = Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(H-&gt;Heads);</span><br><span class="line">    <span class="built_in">free</span>(H);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要用到HashTable 的定义</span></span><br><span class="line"><span class="comment">//NextPrime </span></span><br><span class="line"><span class="comment">//CreateTable</span></span><br><span class="line"><span class="comment">//Hash Find </span></span><br><span class="line"><span class="comment">//Insert</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ScanAndOutput</span><span class="params">(HashTable H)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> MaxCnt  = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> PCnt = <span class="number">0</span>;</span><br><span class="line">    ElementType MinPhone;</span><br><span class="line">    List Ptr;</span><br><span class="line">    MinPhone[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;H-&gt;TableSize;i++) &#123;</span><br><span class="line">        Ptr = H-&gt;Heads[i].Next;</span><br><span class="line">        <span class="keyword">while</span>(Ptr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Ptr-&gt;Count &gt; MaxCnt) &#123;</span><br><span class="line">                MaxCnt = Ptr-&gt;Count;</span><br><span class="line">                <span class="built_in">strcpy</span>(MinPhone,Ptr-&gt;Data);</span><br><span class="line">                PCnt = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Ptr-&gt;Count == MaxCnt) &#123;</span><br><span class="line">                PCnt ++;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(MinPhone,Ptr-&gt;Data)&gt;<span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">strcpy</span>(MinPhone,Ptr-&gt;Data);</span><br><span class="line">            &#125;</span><br><span class="line">            Ptr = Ptr-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d&quot;</span>,MinPhone,MaxCnt);</span><br><span class="line">    <span class="keyword">if</span>(PCnt &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,PCnt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建散列表</span></span><br><span class="line">    <span class="comment">//读入号码插入表中</span></span><br><span class="line">    <span class="comment">//扫描表输出狂人；</span></span><br><span class="line">    <span class="type">int</span> N,i;</span><br><span class="line">    ElementType Key;</span><br><span class="line">    HashTable H;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N);</span><br><span class="line">    H = CreateTable(N*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,Key); Insert(H,Key);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,Key);Insert(H,Key);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanAndOutput(H);</span><br><span class="line">    DestroyTable(H);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构刷题笔记12</title>
      <link href="/2021/08/17/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%9512/"/>
      <url>/2021/08/17/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%9512/</url>
      
        <content type="html"><![CDATA[<h1 id="10-排序4-统计工龄-20-分"><a href="#10-排序4-统计工龄-20-分" class="headerlink" title="10-排序4 统计工龄 (20 分)"></a>10-排序4 统计工龄 (20 分)</h1><p>给定公司<em>N</em>名员工的工龄，要求按工龄增序输出每个工龄段有多少员工。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入首先给出正整数<em>N</em>（≤105），即员工总人数；随后给出<em>N</em>个整数，即每个员工的工龄，范围在[0, 50]。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>按工龄的递增顺序输出每个工龄的员工个数，格式为：“工龄:人数”。每项占一行。如果人数为0则不输出该项。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">10 2 0 5 7 2 5 2</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:1</span><br><span class="line">2:3</span><br><span class="line">5:2</span><br><span class="line">7:1</span><br><span class="line">10:1</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><p>这题取了个巧，都没排序，直接按照工龄从低到高且不为空顺序输出了<br>```C</p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<stdio.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<stdlib.h></h1><p>int main()<br>{<br>    int i, x, n;<br>    scanf(“%d”, &amp;n);<br>    int s[51] = {0};<br>    for(i = 0; i &lt; n; i ++) {<br>        scanf(“%d”, &amp;x);<br>        s[x] ++;<br>    }<br>    for(i = 0; i &lt;= 50; i ++) {<br>        if(s[i]) {<br>            printf(“%d:%d\n”, i, s[i]);<br>        }<br>    }</p><pre><code>return 0;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构刷题笔记11</title>
      <link href="/2021/08/16/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%9511/"/>
      <url>/2021/08/16/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%9511/</url>
      
        <content type="html"><![CDATA[<h1 id="09-排序2-Insert-or-Merge-25-分"><a href="#09-排序2-Insert-or-Merge-25-分" class="headerlink" title="09-排序2 Insert or Merge (25 分)"></a>09-排序2 Insert or Merge (25 分)</h1><p>According to Wikipedia:</p><p><strong>Insertion sort</strong> iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p><p><strong>Merge sort</strong> works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining.</p><p>Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?</p><h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤100). Then in the next line, <em>N</em> integers are given as the initial sequence. The last line contains the partially sorted sequence of the <em>N</em> numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.</p><span id="more"></span><h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each test case, print in the first line either “Insertion Sort” or “Merge Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 6 0</span><br><span class="line">1 2 3 7 8 5 9 4 6 0</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Insertion Sort</span><br><span class="line">1 2 3 5 7 8 9 4 6 0</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 0 6</span><br><span class="line">1 3 2 8 5 7 4 9 0 6</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Merge Sort</span><br><span class="line">1 2 3 8 4 5 7 9 0 6</span><br></pre></td></tr></table></figure><p>题目谷歌翻译：</p><h1 id="09-排序2-Insert-or-Merge-25分"><a href="#09-排序2-Insert-or-Merge-25分" class="headerlink" title="09-排序2 Insert or Merge (25分)"></a>09-排序2 Insert or Merge (25分)</h1><p>根据维基百科：</p><p><strong>插入排序</strong>迭代，每次重复消耗一个输入元素，并增长一个排序的输出列表。每次迭代，插入排序从输入数据中删除一个元素，在排序列表中找到它所属的位置，并将其插入到那里。它重复直到没有输入元素剩余。</p><p><strong>归并排序</strong>的工作原理如下：将未排序的列表分成 N 个子列表，每个子列表包含 1 个元素（1 个元素的列表被视为已排序）。然后重复合并两个相邻的子列表以产生新的排序子列表，直到只剩下 1 个子列表为止。</p><p>现在给定整数的初始序列，以及由某种排序方法多次迭代得到的序列，您能说出我们使用的是哪种排序方法吗？</p><h2 id="输入规格："><a href="#输入规格：" class="headerlink" title="输入规格："></a>输入规格：</h2><p>每个输入文件包含一个测试用例。对于每种情况，第一行给出一个正整数 N (≤100)。然后在下一行，给出 N 个整数作为初始序列。最后一行包含 N 个数字的部分排序序列。假设目标序列总是升序。一行中的所有数字都用空格分隔。</p><h2 id="输出规格："><a href="#输出规格：" class="headerlink" title="输出规格："></a>输出规格：</h2><p>对于每个测试用例，在第一行打印“插入排序”或“合并排序”以指示用于获取部分结果的方法。然后再运行此方法进行一次迭代，并在第二行输出结果序列。保证每个测试用例的答案都是唯一的。一行中的所有数字必须用空格隔开，行尾不能有多余的空格。</p><h2 id="样本输入-1："><a href="#样本输入-1：" class="headerlink" title="样本输入 1："></a>样本输入 1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 6 0</span><br><span class="line">1 2 3 7 8 5 9 4 6 0</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h2 id="示例输出-1："><a href="#示例输出-1：" class="headerlink" title="示例输出 1："></a>示例输出 1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Insertion Sort</span><br><span class="line">1 2 3 5 7 8 9 4 6 0</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h2 id="样本输入-2："><a href="#样本输入-2：" class="headerlink" title="样本输入 2："></a>样本输入 2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 0 6</span><br><span class="line">1 3 2 8 5 7 4 9 0 6</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h2 id="示例输出-2："><a href="#示例输出-2：" class="headerlink" title="示例输出 2："></a>示例输出 2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Merge Sort</span><br><span class="line">1 2 3 8 4 5 7 9 0 6</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="type">int</span> BIAO=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> B[MAX];</span><br><span class="line"><span class="type">int</span> <span class="title function_">BIJIAO</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> A[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i]!=B[i])</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> A[],<span class="type">int</span> B[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">int</span> tep;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    sum=BIJIAO(n,A);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tep=A[i];</span><br><span class="line">        <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>&amp;&amp;A[j<span class="number">-1</span>]&gt;tep;j--)</span><br><span class="line">            A[j]=A[j<span class="number">-1</span>];</span><br><span class="line">        A[j]=tep;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">             sum=BIJIAO(n, A);</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum!=<span class="number">1</span>&amp;&amp;i==n)</span><br><span class="line">        sum=BIJIAO(n,A);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BIAO=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Insertion Sort\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>  <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> Tepa[],<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> RE)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> LE,NE,tep;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    LE=R<span class="number">-1</span>;</span><br><span class="line">    tep=L;</span><br><span class="line">    NE=RE-L+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=LE&amp;&amp;R&lt;=RE)</span><br><span class="line">        <span class="keyword">if</span>(A[L]&lt;=A[R])</span><br><span class="line">           Tepa[tep++]=A[L++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Tepa[tep++]=A[R++];</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=LE)</span><br><span class="line">        Tepa[tep++]=A[L++];</span><br><span class="line">    <span class="keyword">while</span>(R&lt;=RE)</span><br><span class="line">         Tepa[tep++]=A[R++];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NE;i++,RE--)</span><br><span class="line">        A[RE]=Tepa[RE];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_pass</span><span class="params">( <span class="type">int</span> A[], <span class="type">int</span> TmpA[], <span class="type">int</span> N, <span class="type">int</span> length )</span></span><br><span class="line">&#123; <span class="comment">/* 两两归并相邻有序子列 */</span></span><br><span class="line">     <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> ( i=<span class="number">0</span>; i &lt;= N<span class="number">-2</span>*length; i += <span class="number">2</span>*length )</span><br><span class="line">         Merge( A, TmpA, i, i+length, i+<span class="number">2</span>*length<span class="number">-1</span> );</span><br><span class="line">     <span class="keyword">if</span> ( i+length &lt; N ) <span class="comment">/* 归并最后2个子列*/</span></span><br><span class="line">         Merge( A, TmpA, i, i+length, N<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="comment">/* 最后只剩1个子列*/</span></span><br><span class="line">         <span class="keyword">for</span> ( j = i; j &lt; N; j++ ) TmpA[j] = A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_Sort</span><span class="params">( <span class="type">int</span> A[], <span class="type">int</span> N )</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> length;</span><br><span class="line">     <span class="type">int</span> *TmpA;</span><br><span class="line">     <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">     length = <span class="number">1</span>; <span class="comment">/* 初始化子序列长度*/</span></span><br><span class="line">     TmpA = <span class="built_in">malloc</span>( N * <span class="keyword">sizeof</span>( <span class="type">int</span> ) );</span><br><span class="line">     sum=BIJIAO(N,A);</span><br><span class="line">     <span class="keyword">if</span> ( TmpA != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">          <span class="keyword">while</span>( length &lt; N ) &#123;</span><br><span class="line">              Merge_pass( A, TmpA, N, length );</span><br><span class="line">              <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">                  sum=BIJIAO(N,A);</span><br><span class="line">              length *= <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span>(flag)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  flag=<span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              Merge_pass( TmpA, A, N, length );</span><br><span class="line">              length *= <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">                   sum=BIJIAO(N,TmpA);</span><br><span class="line">              <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span>(flag)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  flag=<span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">free</span>( TmpA );</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="built_in">printf</span>( <span class="string">&quot;空间不足&quot;</span> );</span><br><span class="line">     <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Merge Sort\n&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,A[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> A[MAX],C[MAX];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;j);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;A[i]);</span><br><span class="line">        C[i]=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;B[i]);</span><br><span class="line"></span><br><span class="line">    Sort(j,A,B);</span><br><span class="line">    <span class="keyword">if</span>(BIAO==<span class="number">0</span>)</span><br><span class="line">       Merge_Sort(C,j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*6</span></span><br><span class="line"><span class="comment">1 3 2 6 5 4</span></span><br><span class="line"><span class="comment">1 2 3 5 6 4*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP6——程序机器级表示2</title>
      <link href="/2021/08/15/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP6/"/>
      <url>/2021/08/15/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP6/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编入门（二）"><a href="#汇编入门（二）" class="headerlink" title="汇编入门（二）"></a>汇编入门（二）</h1><p>x86-64 架构中的整型寄存器如下图所示（暂时不考虑浮点数的部分）</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108191422580.jpeg" alt="img"></p><p>仔细看看寄存器的分布，我们可以发现有不同的颜色以及不同的寄存器名称，黄色部分是 16 位寄存器，也就是 16 位处理器 8086 的设计，然后绿色部分是 32 位寄存器（这里我是按照比例画的），给 32 位处理器使用，而蓝色部分是为 64 位处理器设计的。这样的设计保证了令人震惊的向下兼容性，几十年前的 x86 代码现在仍然可以运行！</p><p>前六个寄存器(%rax, %rbx, %rcx, %rdx, %rsi, %rdi)称为通用寄存器，有其『特定』的用途：</p><ul><li>%rax(%eax) 用于做累加</li><li>%rcx(%ecx) 用于计数</li><li>%rdx(%edx) 用于保存数据</li><li>%rbx(%ebx) 用于做内存查找的基础地址</li><li>%rsi(%esi) 用于保存源索引值</li><li>%rdi(%edi) 用于保存目标索引值</li></ul><p>而 %rsp(%esp) 和 %rbp(%ebp) 则是作为栈指针和基指针来使用的。下面我们通过 <code>movq</code> 这个指令来了解操作数的三种基本类型：立即数(Imm)、寄存器值(Reg)和内存值(Mem)。</p><span id="more"></span><p>对于 <code>movq</code> 指令来说，需要源操作数和目标操作数，源操作数可以是立即数、寄存器值或内存值的任意一种，但目标操作数只能是寄存器值或内存值。指令的具体格式可以这样写 <code>movq [Imm|Reg|Mem], [Reg|Mem]</code>，第一个是源操作数，第二个是目标操作数，例如：</p><ul><li><code>movq Imm, Reg</code> -&gt; <code>mov $0x5, %rax</code> -&gt; <code>temp = 0x5;</code></li><li><code>movq Imm, Mem</code> -&gt; <code>mov $0x5, (%rax)</code> -&gt; <code>*p = 0x5;</code></li><li><code>movq Reg, Reg</code> -&gt; <code>mov %rax, %rdx</code> -&gt; <code>temp2 = temp1;</code></li><li><code>movq Reg, Mem</code> -&gt; <code>mov %rax, (%rdx)</code> -&gt; <code>*p = temp;</code></li><li><code>movq Mem, Reg</code> -&gt; <code>mov (%rax), %rdx</code> -&gt; <code>temp = *p;</code></li></ul><p>这里有一种情况是不存在的，没有 <code>movq Mem, Mem</code> 这个方式，也就是说，我们没有办法用一条指令完成内存间的数据交换。</p><p>上面的例子中有些操作数是带括号的，括号的意思就是寻址，这也分两种情况：</p><ul><li>普通模式，(R)，相当于 <code>Mem[Reg[R]]</code>，也就是说寄存器 R 指定内存地址，类似于 C 语言中的指针，语法为：<code>movq (%rcx), %rax</code> 也就是说以 %rcx 寄存器中存储的地址去内存里找对应的数据，存到寄存器 %rax 中</li><li>移位模式，D(R)，相当于 <code>Mem[Reg[R]+D]</code>，寄存器 R 给出起始的内存地址，然后 D 是偏移量，语法为：<code>movq 8(%rbp),%rdx</code> 也就是说以 %rbp 寄存器中存储的地址再加上 8 个偏移量去内存里找对应的数据，存到寄存器 %rdx 中</li></ul><p>因为寻址这个内容比较重要，所以多说两句，不然之后接触指针会比较吃力。对于寻址来说，比较通用的格式是 <code>D(Rb, Ri, S)</code> -&gt; <code>Mem[Reg[Rb]+S*Reg[Ri]+D]</code>，其中：</p><ul><li><code>D</code> - 常数偏移量</li><li><code>Rb</code> - 基寄存器</li><li><code>Ri</code> - 索引寄存器，不能是 %rsp</li><li><code>S</code> - 系数</li></ul><p>除此之外，还有如下三种特殊情况</p><ul><li><code>(Rb, Ri)</code> -&gt; <code>Mem[Reg[Rb]+Reg[Ri]]</code></li><li><code>D(Rb, Ri)</code> -&gt; <code>Mem[Reg[Rb]+Reg[Ri]+D]</code></li><li><code>(Rb, Ri, S)</code> -&gt; <code>Mem[Reg[Rb]+S*Reg[Ri]]</code></li></ul><p>我们通过具体的例子来巩固一下，这里假设 %rdx 中的存着 <code>0xf000</code>，%rcx 中存着 <code>0x0100</code>，那么</p><ul><li><code>0x8(%rdx)</code> = <code>0xf000</code> + <code>0x8</code> = <code>0xf008</code></li><li><code>(%rdx, %rcx)</code> = <code>0xf000</code> + <code>0x100</code> = <code>0xf100</code></li><li><code>(%rdx, %rcx, 4)</code> = <code>0xf000</code> + <code>4*0x100</code> = <code>0xf400</code></li><li><code>0x80(, %rdx, 2)</code> = <code>2*0xf000</code> + <code>0x80</code> = <code>0x1e080</code></li></ul><p>了解了寻址之后，我们来看看运算指令，这里以 <code>leaq</code> 指令为例子。具体格式为 <code>leaq Src, Dst</code>，其中 <code>Src</code> 是地址的表达式，然后把计算的值存入 <code>Dst</code> 指定的寄存器，也就是说，无须内存引用就可以计算，类似于 <code>p = &amp;x[i];</code>。我们来看一个具体的例子，假设一个 C 函数是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">m12</span><span class="params">(<span class="type">long</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制</p><p>对应的汇编代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leaq (%rdi, %rdi, 2), %rax # t &lt;- x+x*2</span><br><span class="line">salq $2, %rax              # return t &lt;&lt; 2</span><br></pre></td></tr></table></figure><p>复制</p><p>可以看到是直接对 %rdi 寄存器中存的数据（地址）进行运算，然后赋值给 %rax。最后给出一些常见的算术运算指令，注意参数的顺序，而且对于有符号和无符号数都是一样的，更多的信息可以参考 Intel 官方文档[3]。</p><p>需要两个操作数的指令</p><ul><li><code>addq Src, Dest</code> -&gt; <code>Dest = Dest + Src</code></li><li><code>subq Src, Dest</code> -&gt; <code>Dest = Dest - Src</code></li><li><code>imulq Src, Dest</code> -&gt; <code>Dest = Dest * Src</code></li><li><code>salq Src, Dest</code> -&gt; <code>Dest = Dest &lt;&lt; Src</code></li><li><code>sarq Src, Dest</code> -&gt; <code>Dest = Dest &gt;&gt; Src</code></li><li><code>shrq Src, Dest</code> -&gt; <code>Dest = Dest &gt;&gt; Src</code></li><li><code>xorq Src, Dest</code> -&gt; <code>Dest = Dest ^ Src</code></li><li><code>andq Src, Dest</code> -&gt; <code>Dest = Dest &amp; Src</code></li><li><code>orq Src, Dest</code> -&gt; <code>Dest = Dest | Src</code></li></ul><p>需要一个操作数的指令</p><ul><li><code>incq Dest</code> -&gt; <code>Dest = Dest + 1</code></li><li><code>decq Dest</code> -&gt; <code>Dest = Dest - 1</code></li><li><code>negq Dest</code> -&gt; <code>Dest = -Dest</code></li><li><code>notq Dest</code> -&gt; <code>Dest = ~Dest</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの项目记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP5——程序机器级表示</title>
      <link href="/2021/08/14/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP5/"/>
      <url>/2021/08/14/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP5/</url>
      
        <content type="html"><![CDATA[<h1 id="从C到机器代码"><a href="#从C到机器代码" class="headerlink" title="从C到机器代码"></a>从C到机器代码</h1><p>机器代码就是处理器能够直接执行的字节层面上的程序，但是对于人类来说基本上是不可读的，所以把字节按照具体含义进行『翻译』，就成了人类可读的汇编代码。注意这里的用词是『翻译』而不是『编译』，可以认为汇编代码就是机器代码的可读形式。</p><p>C-&gt;可执行程序：</p><ul><li>C 语言代码(a.c)经过编译器的处理(<code>gcc -0g -S</code>)成为汇编代码(a.s)</li><li>汇编代码(a.s)经过汇编器的处理(<code>gcc</code> 或 <code>as</code>)成为对象程序(a.o)</li><li>对象程序(a.o)以及所需静态库(lib.a)经过链接器的处理(<code>gcc</code> 或 <code>ld</code>)最终成为计算机可执行的程序</li></ul><p>先来看一段C代码及其经过汇编产生的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 代码</span></span><br><span class="line">*dest = t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的汇编代码</span></span><br><span class="line">movq    %rax, (%rbx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的对象代码</span></span><br><span class="line"><span class="number">0x40059e</span>:   <span class="number">46</span> <span class="number">89</span> <span class="number">03</span></span><br></pre></td></tr></table></figure><p>C 代码的意思很简单，就是把值 <code>t</code> 存储到指针 <code>dest</code> 指向的内存中。对应到汇编代码，就是把 8字节（也就是四个字, Quad words）移动到内存中（这也就是为什叫做 <code>movq</code>）。<code>t</code> 的值保存在寄存器 %rax 中，<code>dest</code> 指向的地址保存在 %rbx 中，而 <code>*dest</code> 是取地址操作，对应于在内存中找到对应的值，也就是 <code>M[%rbx]</code>，在汇编代码中用小括号表示取地址，即 <code>(%rbx)</code>。最后转换成 3 个字节的指令，并保存在 <code>0x40059e</code> 这个地址中。</p><span id="more"></span><h2 id="CPU-指令"><a href="#CPU-指令" class="headerlink" title="CPU 指令"></a>CPU 指令</h2><h3 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h3><p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int add_a_and_b(int a, int b) &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">return add_a_and_b(2, 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc 将这个程序转成汇编语言。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -S example.c</span><br></pre></td></tr></table></figure><p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p><p><code>example.s</code>经过简化以后，大概是下面的样子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_add_a_and_b:</span><br><span class="line">push   %ebx</span><br><span class="line">mov    %eax, [%esp+8] </span><br><span class="line">mov    %ebx, [%esp+12]</span><br><span class="line">add    %eax, %ebx </span><br><span class="line">pop    %ebx </span><br><span class="line">ret  </span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line">push   3</span><br><span class="line">push   2</span><br><span class="line">call   _add_a_and_b </span><br><span class="line">add    %esp, 8</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push   %ebx</span><br></pre></td></tr></table></figure><p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><p>下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。</p><h3 id="push-指令"><a href="#push-指令" class="headerlink" title="push 指令"></a>push 指令</h3><p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p><p>然后，开始执行第一行代码。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push   3</span><br></pre></td></tr></table></figure></blockquote><p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p><p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push   2</span><br></pre></td></tr></table></figure></blockquote><p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4个字节（累计减去8）。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108191407057.png" alt="img"></p><h3 id="call-指令"><a href="#call-指令" class="headerlink" title="call 指令"></a>call 指令</h3><p>第三行的<code>call</code>指令用来调用函数。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call   _add_a_and_b</span><br></pre></td></tr></table></figure></blockquote><p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p><p>下面就开始执行<code>_add_a_and_b</code>的代码。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push   %ebx</span><br></pre></td></tr></table></figure></blockquote><p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p><p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p><h3 id="mov-指令"><a href="#mov-指令" class="headerlink" title="mov 指令"></a>mov 指令</h3><p><code>mov</code>指令用于将一个值写入某个寄存器。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    %eax, [%esp+8] </span><br></pre></td></tr></table></figure></blockquote><p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p><p>下一行代码也是干同样的事情。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    %ebx, [%esp+12] </span><br></pre></td></tr></table></figure></blockquote><p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p><h3 id="add-指令"><a href="#add-指令" class="headerlink" title="add 指令"></a>add 指令</h3><p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add    %eax, %ebx</span><br></pre></td></tr></table></figure></blockquote><p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p><h3 id="pop-指令"><a href="#pop-指令" class="headerlink" title="pop 指令"></a>pop 指令</h3><p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop    %ebx</span><br></pre></td></tr></table></figure></blockquote><p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p><p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。ret 指令</p><p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret</span><br></pre></td></tr></table></figure></blockquote><p>可以看到，该指令没有运算子。</p><p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add    %esp, 8 </span><br></pre></td></tr></table></figure></blockquote><p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret</span><br></pre></td></tr></table></figure></blockquote><p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">汇编语言入门教程</a></p><p><a href="https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/">【读薄 CSAPP】贰 机器指令与程序优化</a></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの项目记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法刷题笔记10——排序算法(快排)</title>
      <link href="/2021/08/13/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B010/"/>
      <url>/2021/08/13/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B010/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>每次排序先选出一个主元，然后将比主元小的数放到左边，比主元大的放右边然后再分别进入左边右边快排。</p><p>需要注意的是</p><ol><li>主元的选取方法，一般是选择头中尾三个数中的中位数，而非固定的某个位置的数字</li><li>当数据规模剩下的比较小的时候采用其它的排序来完成剩下的排序，防止数据规模不大时候仍然各种递归导致处理得很慢</li><li>遇到相等的元素也要进行交换，防止得到的两个子集大小相差较大</li></ol><span id="more"></span><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Quick_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> *B)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Qsort</span><span class="params">(<span class="type">int</span> *Data, <span class="type">int</span> Left, <span class="type">int</span> Right)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Insertion_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Median3</span><span class="params">(<span class="type">int</span> *Data, <span class="type">int</span> Left, <span class="type">int</span> Right )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Cutoff = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,N,*Data;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;N);</span><br><span class="line">    Data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>,&amp;Data[i]);</span><br><span class="line">    Quick_sort(Data,N);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Data[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Data[N<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Quick_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    Qsort( Data, <span class="number">0</span>, N<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> *B)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    tmp = *A;</span><br><span class="line">    *A = *B;</span><br><span class="line">    *B = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Qsort</span><span class="params">(<span class="type">int</span> *Data, <span class="type">int</span> Left, <span class="type">int</span> Right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Pivot, i, j;</span><br><span class="line">    <span class="keyword">if</span>( Cutoff &lt;= Right-Left )&#123;</span><br><span class="line">        Pivot = Median3( Data, Left, Right );</span><br><span class="line">        i = Left; j = Right - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( Data[++i] &lt; Pivot );</span><br><span class="line">            <span class="keyword">while</span>( Data[--j] &gt; Pivot );</span><br><span class="line">            <span class="keyword">if</span>( i &lt; j )</span><br><span class="line">                swap( &amp;Data[i], &amp;Data[j] );</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap( &amp;Data[i], &amp;Data[Right<span class="number">-1</span>]);</span><br><span class="line">        Qsort( Data, Left, i<span class="number">-1</span> );</span><br><span class="line">        Qsort( Data, i+<span class="number">1</span>, Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Insertion_sort(Data+Left,Right-Left+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Insertion_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,tmp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = Data[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i;j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; Data[j<span class="number">-1</span>];j--)</span><br><span class="line">            Data[j] = Data[j<span class="number">-1</span>];</span><br><span class="line">        Data[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Median3</span><span class="params">( <span class="type">int</span> *Data, <span class="type">int</span> Left, <span class="type">int</span> Right )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> center = ( Left + Right ) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>( Data[Left] &gt; Data[center] )</span><br><span class="line">        swap( &amp;Data[Left], &amp;Data[center] );</span><br><span class="line">    <span class="keyword">if</span>( Data[Left] &gt; Data[Right] )</span><br><span class="line">        swap( &amp;Data[Left], &amp;Data[Right] );</span><br><span class="line">    <span class="keyword">if</span>( Data[center] &gt; Data[Right] )</span><br><span class="line">        swap( &amp;Data[center], &amp;Data[Right] );</span><br><span class="line">    swap( &amp;Data[center], &amp;Data[Right<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> Data[Right<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>快速排序不愧是实际使用中最快的排序算法，总体而言已经很快了</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108181739081.png" alt="image-20210818173934940"></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一文之影评随笔</title>
      <link href="/2021/08/12/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E6%AF%8F%E6%97%A5%E4%B8%80%E6%96%87%E2%80%94%E2%80%94%E5%BD%B1%E8%AF%84%E9%9A%8F%E7%AC%94/"/>
      <url>/2021/08/12/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E6%AF%8F%E6%97%A5%E4%B8%80%E6%96%87%E2%80%94%E2%80%94%E5%BD%B1%E8%AF%84%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>今天不写技术，天天写也累了，今天换换口味，记录一下最近看的电影</p><h1 id="教父系列"><a href="#教父系列" class="headerlink" title="教父系列"></a>教父系列</h1><p>首先谈谈这几天看的《教父》系列电影，目前只看了前两部，不过给我的触动也还是挺深的，两代教父有着完全不同的境遇，所谓打江山难，守江山更难呐！</p><p>一代教父白手起家，从西西里镇被追杀来到当时充满希望和梦想的美国，一步步开始为美国的意大利人提供保护，重感情的品质加上雷厉风行的行事风格，总体感觉一代的维多克里昂是个很可靠的教父，最终的结局也还算可以，在与孙子的玩耍中逝去。</p><p>二代目虽然继承了一代目的处事能力与判断力，但是对于亲情和家庭的重视不太够，在第二部里众叛亲离，最后柯里昂家族基本只剩下他一个人结局算是比较悲惨的。不过这个人物的形象在这部剧里还是很饱满的</p><span id="more"></span><h2 id="金句摘录"><a href="#金句摘录" class="headerlink" title="金句摘录"></a>金句摘录</h2><p>俗话说教父是男人处世的圣经，个人感觉里面的很多句子确实是非常的有意味，因此将一些金句摘录进来<br><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108181804411.png" alt="image-20210818180446071"></p><p>首先就是这句很能体现一代目教父大人的性格的话</p><p>不抽空陪家人的男人，不是真正的男人。</p><p>这句话看似是对之前被教训”You can act like a man!”的Johnny说的，实际上是对他的大儿子说的，这也体现了一代目教父维多·柯里昂对于家人和亲情的重视。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108181757175.png" alt="image-20210818175754998"></p><p>然后就是就是谈判时候的技巧，沉住气，永远别让外人知道你在想什么</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108181815477.png" alt="image-20210818181511081"></p><p>以及某《无法拒绝的条件》<a href="https://emojiguide.com/smileys-emotion/grinning-face-with-sweat/">😅</a>名场面</p><p>下面几句是看影评得到的</p><p><strong>离你的朋友要近些，但离你的敌人要更近，这样你才能了解他</strong></p><p><strong>不要憎恨你的敌人，那会影响你的判断力</strong></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108181927196.png" alt="image-20210818192738567"></p><p>女人和小孩可以粗心大意，但男人不行，这句也挺有意思，维多老爷子一辈子总结出来的人生经验，”花了一辈子来学会小心”</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 影评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法刷题笔记9——排序算法（堆、归并）</title>
      <link href="/2021/08/11/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B09%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/08/11/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B09%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="09-排序1-排序-堆、归并"><a href="#09-排序1-排序-堆、归并" class="headerlink" title="09-排序1 排序 (堆、归并)"></a><strong>09-排序1 排序 (堆、归并)</strong></h1><p>题目全文见此文<a href="https://www.snowmoon.top/2021/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B08%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#more">数据结构与算法刷题笔记8——排序（冒泡、插入、希尔）</a></p><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="中心思想"><a href="#中心思想" class="headerlink" title="中心思想"></a>中心思想</h2><p>选择排序的优化版，选择排序是顺序扫描整个数组，找到最大值然后放到末尾，堆排序是使用了一个最大堆来存储最大值，然后每次找最大值就使用删除首节点的方法，最终继续使用选择排序完成剩下的排序过程。</p><span id="more"></span><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Heap_sort</span><span class="params">(<span class="type">int</span> Data[],<span class="type">int</span> N)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PercDown</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> M,<span class="type">int</span> N)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> *B)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,N,*Data;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;N);</span><br><span class="line">    Data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>,&amp;Data[i]);</span><br><span class="line">    Heap_sort(Data,N);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Data[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Data[N<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Heap_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = N/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        PercDown(Data,i,N);</span><br><span class="line">    <span class="keyword">for</span>(i = N<span class="number">-1</span>;i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;Data[<span class="number">0</span>],&amp;Data[i]);</span><br><span class="line">        PercDown(Data,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PercDown</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> M,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> parent,child,X;</span><br><span class="line">    X = Data[M];</span><br><span class="line">    <span class="keyword">for</span>(parent = M; parent*<span class="number">2</span> + <span class="number">2</span> &lt;= N; parent = child)&#123;</span><br><span class="line">        child = parent*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((child != N<span class="number">-1</span>)&amp;&amp;(Data[child] &lt; Data[child+<span class="number">1</span>]))</span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span>(Data[child] &lt;= X) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Data[parent] = Data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    Data[parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> *B)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    tmp = *A;</span><br><span class="line">    *A = *B;</span><br><span class="line">    *B = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108111017612.png" alt="image-20210811101701248"></p><p>堆排序是一个复杂度为$O(NlogN)$的排序算法，可以看出来它的排序效率和希尔排序是差不多的，不过堆排序额外开辟了一个数量级为$N$的数组，导致了可排序的数字减少了一半，不过使用空间换时间也是比较常见的策略</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="中心思想-1"><a href="#中心思想-1" class="headerlink" title="中心思想"></a>中心思想</h2><p>归并排序的想法是开辟一个数组，把我们要排序的数组分成左右两部分，先解决左边的排序问题在解决右边的排序问题。要怎么解决左边的问题呢？再递归调用归并排序的函数，继续分而治之。</p><h2 id="递归实现代码"><a href="#递归实现代码" class="headerlink" title="递归实现代码"></a>递归实现代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">( <span class="type">int</span> Data[], <span class="type">int</span> TmpData[], <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> RightEnd )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Msort</span><span class="params">(<span class="type">int</span> Data[], <span class="type">int</span> TmpData[], <span class="type">int</span> L, <span class="type">int</span> RightEnd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,N,*Data;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;N);</span><br><span class="line">    Data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>,&amp;Data[i]);</span><br><span class="line">    Merge_sort(Data,N);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Data[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Data[N<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *TmpData;</span><br><span class="line">    TmpData = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    Msort( Data, TmpData, <span class="number">0</span>, N<span class="number">-1</span> );</span><br><span class="line">    <span class="built_in">free</span>( TmpData );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Msort</span><span class="params">(<span class="type">int</span> Data[], <span class="type">int</span> TmpData[], <span class="type">int</span> L, <span class="type">int</span> RightEnd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Center;</span><br><span class="line">    <span class="keyword">if</span>( L &lt; RightEnd )</span><br><span class="line">    &#123;</span><br><span class="line">        Center = ( L + RightEnd ) / <span class="number">2</span>;</span><br><span class="line">        Msort( Data, TmpData, L, Center );</span><br><span class="line">        Msort( Data, TmpData, Center+<span class="number">1</span>, RightEnd );</span><br><span class="line">        Merge( Data, TmpData, L, Center+<span class="number">1</span>, RightEnd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">( <span class="type">int</span> Data[], <span class="type">int</span> TmpData[], <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> RightEnd )</span></span><br><span class="line">&#123; <span class="comment">/* 将有序的Data[L]~Data[R-1]和Data[R]~Data[RightEnd]归并成一个有序序列 */</span></span><br><span class="line">    <span class="type">int</span> LeftEnd, NumElements, Tmp, i;</span><br><span class="line">    NumElements = RightEnd - L + <span class="number">1</span>;</span><br><span class="line">    LeftEnd = R<span class="number">-1</span>;</span><br><span class="line">    Tmp = L;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Data[L] &gt; Data[R])</span><br><span class="line">            TmpData[Tmp++] = Data[R++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TmpData[Tmp++] = Data[L++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( L &lt;= LeftEnd )</span><br><span class="line">        TmpData[Tmp++] = Data[L++];</span><br><span class="line">    <span class="keyword">while</span>( R &lt;= RightEnd )</span><br><span class="line">        TmpData[Tmp++] = Data[R++];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NumElements; i++, RightEnd--)</span><br><span class="line">        Data[RightEnd] = TmpData[RightEnd];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108111127687.png" alt="image-20210811112743604"></p><h2 id="非递归实现代码"><a href="#非递归实现代码" class="headerlink" title="非递归实现代码"></a>非递归实现代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">( <span class="type">int</span> Data[], <span class="type">int</span> TmpData[], <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> RightEnd )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Msort</span><span class="params">(<span class="type">int</span> Data[], <span class="type">int</span> TmpData[], <span class="type">int</span> N, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,N,*Data;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;N);</span><br><span class="line">    Data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>,&amp;Data[i]);</span><br><span class="line">    Merge_sort(Data,N);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Data[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Data[N<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *TmpData,length;</span><br><span class="line">    length = <span class="number">1</span>;</span><br><span class="line">    TmpData = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">while</span>(length &lt; N)&#123;</span><br><span class="line">        Msort( Data, TmpData, N, length );</span><br><span class="line">        length *= <span class="number">2</span>;</span><br><span class="line">        Msort( TmpData, Data, N, length );</span><br><span class="line">        length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">free</span>( TmpData );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Msort</span><span class="params">(<span class="type">int</span> Data[], <span class="type">int</span> TmpData[], <span class="type">int</span> N, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; N - <span class="number">2</span>*length; i+=<span class="number">2</span>*length)</span><br><span class="line">        Merge(Data, TmpData, i, i+length, i+<span class="number">2</span>*length<span class="number">-1</span> );</span><br><span class="line">    <span class="keyword">if</span>(i + length &lt; N)</span><br><span class="line">        Merge(Data, TmpData, i, i+length, N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(j = i;j &lt; N;j++)TmpData[j] = Data[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">( <span class="type">int</span> Data[], <span class="type">int</span> TmpData[], <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> RightEnd )</span></span><br><span class="line">&#123; <span class="comment">/* 将有序的Data[L]~Data[R-1]和Data[R]~Data[RightEnd]归并成一个有序序列 */</span></span><br><span class="line">    <span class="type">int</span> LeftEnd, NumElements, Tmp;</span><br><span class="line">    NumElements = RightEnd - L + <span class="number">1</span>;</span><br><span class="line">    LeftEnd = R<span class="number">-1</span>;</span><br><span class="line">    Tmp = L;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Data[L] &gt; Data[R])</span><br><span class="line">            TmpData[Tmp++] = Data[R++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TmpData[Tmp++] = Data[L++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( L &lt;= LeftEnd )</span><br><span class="line">        TmpData[Tmp++] = Data[L++];</span><br><span class="line">    <span class="keyword">while</span>( R &lt;= RightEnd )</span><br><span class="line">        TmpData[Tmp++] = Data[R++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108111305102.png" alt="image-20210811130527026"></p><p>感觉看整体测试效果里面的非递归实现的效率相对于递归实现的效率并没有特别特别大的提升，算是中规中矩，不过总体看来非递归还是要比递归更快一些，也更节省资源</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPPLAB1——Datalab(下)</title>
      <link href="/2021/08/10/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPPLAB2%E2%80%94%E2%80%94Datalab-%E4%B8%8B/"/>
      <url>/2021/08/10/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPPLAB2%E2%80%94%E2%80%94Datalab-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：本文为CSAPP3.0配套Lab的刷题笔记，这是第一个lab——Datalab的笔记</p></blockquote><p>每个实验题目将采用以下格式来记录</p><ul><li>题目描述</li><li>题解和思路</li><li>解题代码</li></ul><h1 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果x&lt;=y，返回1，否则返回</p><h2 id="题解与思路"><a href="#题解与思路" class="headerlink" title="题解与思路"></a>题解与思路</h2><p>本来刚开始一看：诶，这简单嘛，让y-x&gt;=0就行了嘛，就想着写个y+x的相反数然后判断它的符号位，然后没想到又是该死的TMin，这该死的按位取反加一仍然为它本身的数字！还有一个原因是如果相减的结果大于Tmax会溢出为负数，也会有错误，所以修改了实现的逻辑</p><p>分成两种情况：x和y符号相同和不同时：y为正为真<br>x和y符号相同时：y-x&gt;0为真<br>由于溢出只有在x和y异号的时候才会出现，所以这种方法巧妙的规避了溢出的情况</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> xsign = x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> ysign = y&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> check = xsign^ysign;</span><br><span class="line">  <span class="type">int</span> yminusx = (y+~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> (check&amp;(!ysign))|(!check&amp;(!yminusx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>不使用逻辑非 ‘!’ 实现逻辑非 ‘!’</p><h2 id="题解与思路-1"><a href="#题解与思路-1" class="headerlink" title="题解与思路"></a>题解与思路</h2><ol><li><p>在所有数字中，只有0和Tmin取它的补码相反数后还为它本身，也即<code>~0+1=0,~Tmin+1=Tmin</code>而Tmin为0x80000000，符号位为1，所以可以将x取补码的相反数后判断符号位是否为0</p></li><li><p>转换为考虑筛选出<code>x&lt;0&amp;&amp;x&gt;=1</code>的数字然后返回0</p></li></ol><span id="more"></span><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ((x&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>)&amp;((x+~<span class="number">1</span>+<span class="number">1</span>&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="今日体重"><a href="#今日体重" class="headerlink" title="今日体重"></a>今日体重</h1><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108110029080.png" alt="image-20210811002904543"></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの项目记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> Datalab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPPLAB1——Datalab(上)</title>
      <link href="/2021/08/09/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPPLAB1%E2%80%94%E2%80%94Datalab-%E4%B8%8A/"/>
      <url>/2021/08/09/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPPLAB1%E2%80%94%E2%80%94Datalab-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：本文为CSAPP3.0配套Lab的刷题笔记，这是第一个lab——Datalab的笔记</p></blockquote><p>每个实验题目将采用以下格式来记录</p><ul><li>题目描述</li><li>题解和思路</li><li>解题代码</li></ul><h1 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>只使用按位与非逻辑实现按位异或逻辑</p><h2 id="题解与思路"><a href="#题解与思路" class="headerlink" title="题解与思路"></a>题解与思路</h2><p>排除掉两个不能通过的逻辑，写成的代码就能通过。</p><p>即：把x与y相同的答案都否定掉</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~x&amp;~y)&amp;~(x&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>返回补码表示数字的最小值。</p><h2 id="题解与思路-1"><a href="#题解与思路-1" class="headerlink" title="题解与思路"></a>题解与思路</h2><p>补码的最小值是符号位为1，其余均为0，所以返回这个数字就行了。</p><p>我的思路也很简单粗暴，直接通过移位得到</p><span id="more"></span><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xff</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断一个数是不是补码表示的最大数字，是则返回1，否返回0</p><h2 id="题解与思路-2"><a href="#题解与思路-2" class="headerlink" title="题解与思路"></a>题解与思路</h2><p>补码最大数字应该是符号位为0，其余位均为1，所以将它向左移1位再加1之后得到的应该是全为1的数，此时再按位取反后就得到0，再用逻辑非判断即可。</p><p>需要注意的是，补码表示的-1进行上述操作后得到的也是一样的结果，所以要把-1排除了，方法是按位取反得到0，然后用逻辑非把这个结果否定了。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !(~(x+x+<span class="number">1</span>))&amp;!!(~x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断所有奇数位是否都为1，如果都为1返回1，否则返回0</p><p>PS：这里的位置编号是从0到31</p><h2 id="题解与思路-3"><a href="#题解与思路-3" class="headerlink" title="题解与思路"></a>题解与思路</h2><p>由于只能使用0x00到0xFF间的16进制数，故需要每8位判断1次，所以要考虑移位8、16、24位之后的数字，然后按位取反后与0xAA进行&amp;操作，如果x的奇数位上均为1，取反后应该均为0，与0xAA进行&amp;操作后应均为0，所以再对这个式子求一个逻辑非即可</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !(~(x &amp; (x &gt;&gt; <span class="number">8</span>) &amp; (x &gt;&gt; <span class="number">16</span>) &amp; (x &gt;&gt; <span class="number">24</span>)) &amp; <span class="number">0xAA</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* </span></span><br></pre></td></tr></table></figure><h1 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>不用<code>-</code>操作符返回数字的负值</p><h2 id="题解与思路-4"><a href="#题解与思路-4" class="headerlink" title="题解与思路"></a>题解与思路</h2><p>补码的正常表示，按位取反加一</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断一个数是否是数字’0’到’9’的ASCII码，也即判断一个数字是否位于0x30与0x39之间</p><h2 id="题解与思路-5"><a href="#题解与思路-5" class="headerlink" title="题解与思路"></a>题解与思路</h2><p>若要位于0x30与0x39之间，则这个数减去0x30&gt;=0;减去0x3a&lt;0</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !((x+~<span class="number">0x30</span>+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>)&amp;!~((x+~<span class="number">0X3a</span>+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>返回操作结果与语句<code>x ? y : z</code>相同，也即x为1返回y，x为0返回z</p><h2 id="题解与思路-6"><a href="#题解与思路-6" class="headerlink" title="题解与思路"></a>题解与思路</h2><p>先把x利用逻辑非<code>!</code>转换为0或1，保证我们需要转换的只有0或1，然后接下来就是把0或1转换之后造出一个<code>`0x00000000</code>或者<code>0xffffffff</code>再与y和z进行相应的与操作保留y/z即可。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (~!!x+<span class="number">1</span>&amp;y)|(~!x+<span class="number">1</span>&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="今日体重"><a href="#今日体重" class="headerlink" title="今日体重"></a>今日体重</h1><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108100047882.png" alt="image-20210810004740111"></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの项目记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> Datalab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP阅读笔记4——数据编码4</title>
      <link href="/2021/08/08/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%814/"/>
      <url>/2021/08/08/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%814/</url>
      
        <content type="html"><![CDATA[<h1 id="浮点数2"><a href="#浮点数2" class="headerlink" title="浮点数2"></a>浮点数2</h1><h2 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h2><p>对于浮点数的加法和乘法来说，我们可以先计算出准确值，然后转换到合适的精度。在这个过程中，既可能会溢出，也可能需要舍入来满足 frac 的精度。</p><p>在二进制中，我们舍入到最近的偶数，即如果出现在中间的情况，舍入之后最右边的值要是偶数，对于十进制数，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  原数值       舍入结果    原因</span><br><span class="line"><span class="number">2.8949999</span>      <span class="number">2.89</span>    <span class="comment">#不到一半，正常四舍五入</span></span><br><span class="line"><span class="number">2.8950001</span>      <span class="number">2.90</span>    <span class="comment">#超过一般，正常四舍五入</span></span><br><span class="line"><span class="number">2.8950000</span>      <span class="number">2.90</span>    <span class="comment">#刚好在一半时，保证最后一位是偶数，所以向上舍入</span></span><br><span class="line"><span class="number">2.8850000</span>      <span class="number">2.88</span>    <span class="comment">#刚好在一半时，保证最后一位是偶数，所以向下舍入</span></span><br></pre></td></tr></table></figure><p>对于二进制数也是类似的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  十进制    二进制     舍入结果  十进制    原因</span><br><span class="line">2 又 3/32  10.00011   10.00     2    \\不到一半，正常四舍五入</span><br><span class="line">2 又 3/16  10.00110   10.01  2 又 1/4 \\超过一般，正常四舍五入</span><br><span class="line">2 又 7/8   10.11100   11.00     3    \\刚好在一半时，保证最后一位是偶数，所以向上舍入</span><br><span class="line">2 又 5/8   10.10100   10.10  2 又 1/2 \\刚好在一半时，保证最后一位是偶数，所以向下舍入</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="浮点数加法"><a href="#浮点数加法" class="headerlink" title="浮点数加法"></a>浮点数加法</h3><script type="math/tex; mode=display">(−1)^{s1}M_12^{E1}+(−1)^{s2}M_22^{E2}</script><p>这里假设 E1&gt;E2，结果是 $(−1)^sM2^E$ ，其中 $s=s1∧s2,M=M1+M2,E=E1$</p><ul><li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值</li><li>如果 M 小于 1，把 M 左移 k 位，E 减少 k</li><li>如果 E 超出了可以表示的范围，溢出</li><li>把 M 舍入到 frac 的精度</li></ul><p>基本性质</p><ul><li>相加可能产生 infinity 或者 NaN</li><li>满足交换率</li><li>不满足结合律（因为舍入会造成精度损失，如 <code>(3.14+1e10)-1e10=0</code>，但 <code>3.14+(1e10-1e10)=3.14</code>）</li><li>加上 0 等于原来的数</li><li>除了 infinity 和 NaN，每个元素都有对应的倒数</li><li>除了 infinity 和 NaN，满足单调性，即 $a≥b→a+c≥b+c$</li></ul><h3 id="浮点数乘法"><a href="#浮点数乘法" class="headerlink" title="浮点数乘法"></a>浮点数乘法</h3><script type="math/tex; mode=display">(−1)^{s1}M_12^{E1}×(−1)^{s2}M_22^{E2}</script><p>结果是 $(−1)^sM2^E$，其中 $s=s1∧s2,M=M1×M2,E=E1+E2$</p><ul><li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值。</li><li>如果 E 超出了可以表示的范围，溢出</li><li>把 M 舍入到 frac 的精度</li></ul><p>基本性质</p><ul><li>相乘可能产生 infinity 或者 NaN</li><li>满足交换率</li><li>不满足结合律（因为舍入会造成精度损失）</li><li>乘以 1 等于原来的数</li><li>不满足分配率 <code>1e20*(1e20-1e20)=0.0</code> 但 <code>1e20*1e20-1e20*1e20=NaN</code></li><li>除了 infinity 和 NaN，满足单调性，即 a≥b→a×c≥a×b</li></ul><h1 id="今日体重"><a href="#今日体重" class="headerlink" title="今日体重"></a>今日体重</h1><p>又回去了，虽然跑了个一两天步，但感觉总体运动量还是不太够</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108090008183.png" alt="image-20210809000841088"></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの项目记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 浮点数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP阅读笔记3——数据编码3</title>
      <link href="/2021/08/07/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%813/"/>
      <url>/2021/08/07/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%813/</url>
      
        <content type="html"><![CDATA[<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>浮点数的定义：</p><script type="math/tex; mode=display">d=\sum_{i=-n}^m2^i \times d_i</script><p>这个定义导致我们只有在表示$\frac{x}{2^k}$时候是精确的，其它数字的小数部分都会变成循环小数。而由于这些数字的编码长度都是有限的，通过这种表达方式表示的浮点数都是有限的。</p><h2 id="IEEE-浮点数标准"><a href="#IEEE-浮点数标准" class="headerlink" title="IEEE 浮点数标准"></a>IEEE 浮点数标准</h2><p>以下内容引用自文章<a href="https://wdxtub.com/csapp/thin-csapp-1/2016/04/16/">【读薄 CSAPP】壹 数据表示</a></p><p>IEEE 的浮点数标准更多是从数值角度来建立的，对于舍入，上溢出和下溢出都有比较统一的处理方法。但与此同时也给硬件优化带来了比较大的困难。因为和平时使用的数制也有一定差异，从理解的角度来看不够直观，但是好在主流的 CPU 都支持浮点数，所以我们不必过多涉及这方面的细节。</p><p>在 IEEE 标准中，我们用下面的公式来表达浮点数：</p><script type="math/tex; mode=display">(−1)^sM2^E</script><span id="more"></span><p>其中 s 是符号位，决定正负；M 通常是一个值在 [1.0, 2.0) 的小数；E 是次方数。具体编码时结构如下，这里用单精度、双精度和扩展精度为例：其中 s 是符号位，决定正负；M 通常是一个值在 [1.0, 2.0) 的小数；E 是次方数。具体编码时结构如下，这里用单精度、双精度和扩展精度为例：</p><p>下图中 <code>s</code> 对应着符号位，<code>exp</code> 对应着 E（注意，不一定等于 E，因为位数限制表达能力有限），<code>frac</code> 对应着 <code>M</code>（注意，不一定等于 <code>M</code>，因为位数限制表达能力有限）。不同的位数就代表了不同的表示能力，也就是单精度，双精度，扩展精度的来源。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108081400558.png" alt="image-20210808140048419"></p><div class="table-container"><table><thead><tr><th style="text-align:center">形式</th><th style="text-align:center">指数</th><th style="text-align:center">小数部分</th></tr></thead><tbody><tr><td style="text-align:center">零</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">非规约形式</td><td style="text-align:center">0</td><td style="text-align:center">大于0小于1</td></tr><tr><td style="text-align:center">规约形式</td><td style="text-align:center">1到$2^e-2$</td><td style="text-align:center">大于等于1小于2</td></tr><tr><td style="text-align:center">无穷</td><td style="text-align:center">$2^e-1$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">NaN</td><td style="text-align:center">$2^e-1$</td><td style="text-align:center">非0</td></tr></tbody></table></div><p>例子如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    s exp  frac   E   值</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">    <span class="number">0</span> <span class="number">0000</span> <span class="number">000</span>   -<span class="number">6</span>   <span class="number">0</span>   <span class="comment"># 这部分是非规范化数值，下一部分是规范化值</span></span><br><span class="line">    <span class="number">0</span> <span class="number">0000</span> 001   -<span class="number">6</span>   <span class="number">1</span>/<span class="number">8</span> * <span class="number">1</span>/<span class="number">64</span> = <span class="number">1</span>/<span class="number">512</span> <span class="comment"># 能表示的最接近零的值</span></span><br><span class="line">    <span class="number">0</span> <span class="number">0000</span> <span class="number">0</span>10   -<span class="number">6</span>   <span class="number">2</span>/<span class="number">8</span> * <span class="number">1</span>/<span class="number">64</span> = <span class="number">2</span>/<span class="number">512</span> </span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0</span> <span class="number">0000</span> <span class="number">110</span>   -<span class="number">6</span>   <span class="number">6</span>/<span class="number">8</span> * <span class="number">1</span>/<span class="number">64</span> = <span class="number">6</span>/<span class="number">512</span></span><br><span class="line">    <span class="number">0</span> <span class="number">0000</span> <span class="number">111</span>   -<span class="number">6</span>   <span class="number">7</span>/<span class="number">8</span> * <span class="number">1</span>/<span class="number">64</span> = <span class="number">7</span>/<span class="number">512</span> <span class="comment"># 能表示的最大非规范化值</span></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">    <span class="number">0</span> 0001 <span class="number">000</span>   -<span class="number">6</span>   <span class="number">8</span>/<span class="number">8</span> * <span class="number">1</span>/<span class="number">64</span> = <span class="number">8</span>/<span class="number">512</span> <span class="comment"># 能表示的最小规范化值</span></span><br><span class="line">    <span class="number">0</span> 0001 001   -<span class="number">6</span>   <span class="number">9</span>/<span class="number">8</span> * <span class="number">1</span>/<span class="number">64</span> = <span class="number">9</span>/<span class="number">512</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0</span> 0110 <span class="number">110</span>   -<span class="number">1</span>   <span class="number">14</span>/<span class="number">8</span> * <span class="number">1</span>/<span class="number">2</span> = <span class="number">14</span>/<span class="number">16</span></span><br><span class="line">    <span class="number">0</span> 0110 <span class="number">111</span>   -<span class="number">1</span>   <span class="number">15</span>/<span class="number">8</span> * <span class="number">1</span>/<span class="number">2</span> = <span class="number">15</span>/<span class="number">16</span> <span class="comment"># 最接近且小于 1 的值</span></span><br><span class="line">    <span class="number">0</span> 0111 <span class="number">000</span>    <span class="number">0</span>   <span class="number">8</span>/<span class="number">8</span> * <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">    <span class="number">0</span> 0111 001    <span class="number">0</span>   <span class="number">9</span>/<span class="number">8</span> * <span class="number">1</span> = <span class="number">9</span>/<span class="number">8</span>      <span class="comment"># 最接近且大于 1 的值</span></span><br><span class="line">    <span class="number">0</span> 0111 <span class="number">0</span>10    <span class="number">0</span>   <span class="number">10</span>/<span class="number">8</span> * <span class="number">1</span> = <span class="number">10</span>/<span class="number">8</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0</span> <span class="number">1110</span> <span class="number">110</span>    <span class="number">7</span>   <span class="number">14</span>/<span class="number">8</span> * <span class="number">128</span> = <span class="number">224</span></span><br><span class="line">    <span class="number">0</span> <span class="number">1110</span> <span class="number">111</span>    <span class="number">7</span>   <span class="number">15</span>/<span class="number">8</span> * <span class="number">128</span> = <span class="number">240</span>   <span class="comment"># 能表示的最大规范化值</span></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">    <span class="number">0</span> <span class="number">1111</span> <span class="number">000</span>   n/a  无穷               <span class="comment"># 特殊值</span></span><br></pre></td></tr></table></figure><h1 id="今日体重"><a href="#今日体重" class="headerlink" title="今日体重"></a>今日体重</h1><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108080019434.png" alt="image-20210808001912353"></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの项目记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 浮点数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP阅读笔记2——数据编码2</title>
      <link href="/2021/08/06/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%812/"/>
      <url>/2021/08/06/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%812/</url>
      
        <content type="html"><![CDATA[<h1 id="整形变量Integer"><a href="#整形变量Integer" class="headerlink" title="整形变量Integer"></a>整形变量Integer</h1><h2 id="类型拓展与截取"><a href="#类型拓展与截取" class="headerlink" title="类型拓展与截取"></a>类型拓展与截取</h2><p><strong>无符号数的零拓展</strong>：无符号数转换为更大的数据类型，只需要在开头添加0即可，这种运算也被称为零拓展。</p><p><strong>补码数的符号拓展：</strong>补码数转换为更大的数据类型需要在开头添加最高有效位的值，即：如果为负数，需要在拓展出来的开头位置添加数个1，正数需要添加数个0。</p><h2 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h2><p>当我们将一个位数为 w 的数字截断为 k 位的数字时，我们会丢弃最高的w-k位。</p><p><strong>截断无符号数：</strong>相当于做mod运算，$x’=x\ mod\ 2^k$</p><p><strong>截断补码数值：</strong>和无符号值相似，不过需要将最高位转换为符号位</p><span id="more"></span><h2 id="运算与溢出"><a href="#运算与溢出" class="headerlink" title="运算与溢出"></a>运算与溢出</h2><p>无符号数字加法：溢出时会丢弃最高位，实际上相当于做了个mod操作</p><script type="math/tex; mode=display">x+^u_wy=\left\{\begin{array}{l}    x+y,\quad x+y<2^w\\    x+y-2^w, \quad 2^w\leq x+y<2^{w+1}\\\end{array}\right.</script><p>检测无符号数是否溢出：当$s&lt;x$或$s&lt;y$时发生了溢出</p><p>补码加法：溢出时会产生正溢出和负溢出，正溢出是数字太大，把符号位改成了1而变成了负数，负溢出为数字太小把符号位改成了0而变成了正数</p><p>对于满足$-2^{w-1} \leq x,y&lt;2^{w-1}$​的整数，有：</p><script type="math/tex; mode=display">x+^t_wy = \left\{\begin{array}{l}x+y-2^w,\qquad 2^{w-1} \leq x+y\qquad \quad 正溢出\\x+y,\qquad -2^{w-1}\leq x+y < 2^{w-1}\qquad 正常\\x+y+2^w,\quad x+y<-2^{w-1} \qquad \quad负溢出\end{array}\right.</script><p>对于乘法来说，值的范围会大很多，这里分情况讨论一下，假设两个乘数是 x,y 并且都是 w 位的：</p><ul><li>无符号数：至多 2w 位<ul><li>范围$ 0≤x×y≤(2w−1)^2=2^{2w}−2^{w+1}+1$</li></ul></li><li>有符号数，最小的负数：至多 2w - 1 位<ul><li>范围$x×y≥(−2^{w−1})×(2^{w−1}−1)=−2^{2w−2}+2^{w−1}$</li></ul></li><li>有符号数，最大的正数：至多 2w 位，只有$(TMin_w)^2$一种情况<ul><li>范围 $x×y≤(−2^{w−1})^2=2^{2w−2}$</li></ul></li></ul><p>如果需要保证精度，就需要用软件来实现了。另外，计算的无符号乘法的时候，会忽略最高的 w 位，相当于 $UMult_w(u,v)=u⋅v\ mod\ 2^w$</p><h1 id="今日体重"><a href="#今日体重" class="headerlink" title="今日体重"></a>今日体重</h1><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108080018693.png" alt="image-20210808001824599"></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの项目记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 原码 </tag>
            
            <tag> 补码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP阅读笔记1——数据编码</title>
      <link href="/2021/08/05/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"/>
      <url>/2021/08/05/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h1><p>假设字长(word size)为 $w$,也即数据的位数，则二进制向十进制的转换分别是：</p><ul><li>无符号数：<script type="math/tex; mode=display">B2U(X)=\sum_{i=0}^{w-1}x_i\cdot2^i</script></li><li>有符号数： <script type="math/tex; mode=display">B2T(X)=-x_{w-1}\cdot2^{w-1}+\sum_{i=0}^{w-2}x_i\cdot2^{i}</script></li></ul><p>左移：x向左移动k位，丢弃最高的k位，在右端补k个0；</p><p>逻辑右移 ：在左端补k个0</p><p>算术右移：在左端补k个最高有效位的值</p><p>PS：移位操作优先级低于+-，</p><p>无符号数编码定义：</p><script type="math/tex; mode=display">B2U_w(x)=\sum_{i=0}^{w-1}x_i2^i</script><p>原码：正数是其二进制本身；负数是符号位为1,数值部分取X绝对值的二进制。</p><p>最高位是符号位，用来确定剩下的位是应该取负权还是正权。</p><script type="math/tex; mode=display">B2S_w(x)=(-1)^{x_{w-1}}\cdot(\sum_{i=0}^{w-2}x_i2^i)</script><p>补码：正数的补码和原码，反码相同；负数是符号位为1，其它位是原码按位取反，未位加1。（或者说负数的补码是其绝对值反码未位加1）</p><p>最高位$x_{w-1}$也称为符号位，其权重为$-2^{w-1}$​</p><span id="more"></span><script type="math/tex; mode=display">B2T_w(x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i</script><p>反码：正数的反码和原码相同；负数是符号位为1,其它位是原码取反。</p><p>除最高位权为$-(2^{w-1}-1)$而不是$-2^{w-1}$其余和补码一样。</p><script type="math/tex; mode=display">B2O_w(x)=-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_i2^i</script><div class="table-container"><table><thead><tr><th style="text-align:center">编码</th><th style="text-align:center">10810（sbyte）</th><th style="text-align:center">-10810（sbyte）</th></tr></thead><tbody><tr><td style="text-align:center">原码</td><td style="text-align:center"><strong>0</strong>1101100</td><td style="text-align:center"><strong>1</strong>1101100</td></tr><tr><td style="text-align:center">反码</td><td style="text-align:center"><strong>0</strong>1101100</td><td style="text-align:center"><strong>1</strong>0010011</td></tr><tr><td style="text-align:center">补码</td><td style="text-align:center"><strong>0</strong>1101100</td><td style="text-align:center"><strong>1</strong>0010100</td></tr></tbody></table></div><ul><li>与 And：<code>A=1</code> 且 <code>B=1</code> 时，<code>A&amp;B = 1</code></li><li>或 Or：<code>A=1</code> 或 <code>B=1</code> 时，<code>A|B = 1</code></li><li>非 Not：<code>A=1</code> 时，<code>~A=0</code>；<code>A=0</code> 时，<code>~A=1</code></li><li>异或 Exclusive-Or(Xor)：<code>A=1</code> 或 <code>B=1</code> 时，<code>A^B = 1</code>；<code>A=1</code> 且 <code>B=1</code> 时，<code>A^B = 0</code></li></ul><p>对应与集合运算则是交集、并集、差集和补集，假设集合 A 是 <code>&#123;0, 3, 5, 6&#125;</code>，集合 B 是 <code>&#123;0, 2, 4, 6&#125;</code>，全集为 <code>&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>那么：</p><ul><li><p><code>&amp;</code> 交集 Intersection <code>&#123;0, 6&#125;</code></p></li><li><p><code>|</code> 并集 Union <code>&#123;0, 2, 3, 4, 5, 6&#125;</code></p></li><li><p><code>^</code> 差集 Symmetric difference <code>&#123;2, 3, 4, 5&#125;</code></p></li><li><p><code>~</code> 补集 Complement <code>&#123;1, 3, 5, 7&#125;</code></p></li></ul><p>类型转换<br>我们在数轴上把有符号数和无符号数画出来的话，就能很清晰的看出相对的关系：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108052336446.png" alt="image-20210805233558134"></p><p>在 C 语言中，如果不加关键字限制，默认的整型是有符号的。如果想要无符号数的话，需要在数字后面加 U，例如下面的代码段<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a_signed_number = <span class="number">-15213</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a_unsigned_number = <span class="number">15213U</span>;</span><br></pre></td></tr></table></figure></p><p>在进行有符号和无符号数的互相转换时：</p><ul><li><p>具体每一个字节的值不会改变，<strong>改变的是计算机解释当前值的方式</strong></p></li><li><p>如果一个表达式既包含有符号数也包含无符号数，那么<strong>会被隐式转换成无符号数进行比较</strong></p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">比较对象</th><th style="text-align:center">求值</th></tr></thead><tbody><tr><td style="text-align:center">0 == 0U</td><td style="text-align:center">无符号数</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">-1 &lt; 0</td><td style="text-align:center">有符号数</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">-1 &lt; 0U</td><td style="text-align:center">无符号数</td><td style="text-align:center">0*</td></tr><tr><td style="text-align:center">2147483647 &gt; (-2147483647-1)</td><td style="text-align:center">有符号数</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2147483647U &lt; (-2147483647-1)</td><td style="text-align:center">无符号数</td><td style="text-align:center">0*</td></tr><tr><td style="text-align:center">-1 &gt; -2</td><td style="text-align:center">有符号数</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">(unsigned)-1 &gt; -2</td><td style="text-align:center">无符号数</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2147483647 &lt; 2147483648U</td><td style="text-align:center">无符号数</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2147483647 &gt; (int)2147483648U</td><td style="text-align:center">有符号数</td><td style="text-align:center">1*</td></tr></tbody></table></div><p><em>注：\</em>号标注的为比较反直觉的一些结果*</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://wdxtub.com/csapp/thin-csapp-1/2016/04/16/">【读薄 CSAPP】壹 数据表示</a></p><p><a href="https://www.jianshu.com/p/abbdae4f3841">原码、反码、补码和移码详解</a></p><h1 id="今日体重更新"><a href="#今日体重更新" class="headerlink" title="今日体重更新"></a>今日体重更新</h1><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108052347505.png" alt="image-20210805234727407"></p><p>今天和朋友出去搓了顿周麻婆，体重略有上涨，意料之中。。。</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの项目记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 原码 </tag>
            
            <tag> 补码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言函数参数传递的错误与避免</title>
      <link href="/2021/08/04/SnowMoon%E3%81%AE%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92/"/>
      <url>/2021/08/04/SnowMoon%E3%81%AE%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今日第二更嘿嘿</p><p>前言：博主在实现各种排序算法时很多函数的参数传递方法啥的出现了很多记忆的错误，因此停下来总结一下这些容易犯的错误同时方便自己将来复习</p></blockquote><h1 id="函数参数的调用"><a href="#函数参数的调用" class="headerlink" title="函数参数的调用"></a>函数参数的调用</h1><div class="table-container"><table><thead><tr><th style="text-align:center">调用类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.runoob.com/cprogramming/c-function-call-by-value.html">传值调用</a></td><td style="text-align:center">该方法把参数的实际值复制给函数的形式参数。对应下述ERROR1<br/>在这种情况下，修改函数内的形式参数不会影响实际参数。</td></tr><tr><td style="text-align:center"><a href="https://www.runoob.com/cprogramming/c-function-call-by-pointer.html">引用调用</a></td><td style="text-align:center">通过指针传递方式，形参为指向实参地址的指针，对应正确写法<br/>当对形参的指向操作时，就相当于对实参本身进行的操作。</td></tr></tbody></table></div><h1 id="例：利用Swap函数交换变量a，b的常见错误"><a href="#例：利用Swap函数交换变量a，b的常见错误" class="headerlink" title="例：利用Swap函数交换变量a，b的常见错误"></a>例：利用Swap函数交换变量a，b的常见错误</h1><span id="more"></span><h2 id="ERROR1——使用局部变量代替原始变量"><a href="#ERROR1——使用局部变量代替原始变量" class="headerlink" title="ERROR1——使用局部变量代替原始变量"></a>ERROR1——使用局部变量代替原始变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Sawp_error1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    Sawp_error1(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb = %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">Process returned <span class="number">0</span> (<span class="number">0x0</span>)   execution time : <span class="number">0.015</span> s</span><br><span class="line">Press any key to <span class="keyword">continue</span>.</span><br></pre></td></tr></table></figure><p>局部变量：定义在函数内部的变量，只能在函数内部使用。<br>上面代码里在main函数中定义的a，b与Swap函数中a，b只是同名，只在Swap函数中交换a与b的值而不影响main函数中的原始变量a与b的值</p><h2 id="ERROR2——只交换了地址"><a href="#ERROR2——只交换了地址" class="headerlink" title="ERROR2——只交换了地址"></a>ERROR2——只交换了地址</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Sawp_error2</span><span class="params">(<span class="type">int</span> *p1,<span class="type">int</span> *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *tmp;</span><br><span class="line">    tmp = p1;<span class="comment">//将a的地址赋值给tmp</span></span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    Sawp_error2(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb = %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">Process returned <span class="number">0</span> (<span class="number">0x0</span>)   execution time : <span class="number">0.015</span> s</span><br><span class="line">Press any key to <span class="keyword">continue</span>.</span><br></pre></td></tr></table></figure><p>可以看到上述代码并没有完成对ab的交换。</p><p>在上面代码中Swap函数虽然使用了指针，但是未做取值运算，所以只是将两个变量a,b的存储位置交换了一下</p><h2 id="ERROR3——野指针"><a href="#ERROR3——野指针" class="headerlink" title="ERROR3——野指针"></a>ERROR3——野指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Sawp_error2</span><span class="params">(<span class="type">int</span> *p1,<span class="type">int</span> *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *tmp=*p1;<span class="comment">//野指针</span></span><br><span class="line">    *p1=*p2;</span><br><span class="line">    *p2=*tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    Sawp_error3(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb = %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">———————————</span><br><span class="line"></span><br><span class="line">Process returned -1073741819 (0xC0000005)   execution time : 1.663 s</span><br><span class="line">Press any key to continue.</span><br></pre></td></tr></table></figure><p>上述程序在运行了一段时间之后就崩了，没有输出任何东西，这是因为我们在给tmp初始化的时候直接把P1的值，也即a的值当做地址赋给了tmp，导致tmp指向了不能访问的地区导致了程序崩溃。</p><p>野指针（悬挂指针）：没有访问权限的指针，这个指针有可能存在也有可能不存在，但是你不能访问。（野指针不好判断）<br>1、地址不存在（例如电话号码少一位）。<br>2、地址存在，但是不能访问（例如电话号码写成别人）。<br>3、地址之前可以访问，但现在不可以（更换电话号码）</p><h2 id="正确写法"><a href="#正确写法" class="headerlink" title="正确写法"></a>正确写法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Sawp_error2</span><span class="params">(<span class="type">int</span> *p1,<span class="type">int</span> *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    tmp = *p1;<span class="comment">//tmp＝a</span></span><br><span class="line">    *p1 = *p2;<span class="comment">//a＝b</span></span><br><span class="line">    *p2 = tmp;<span class="comment">//b＝tmp</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    Sawp(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb = %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论<br>一个函数（父函数）调用另一个函数（子函数），想通过子函数修改父函数的数据，必须传指针，子函数内部解引用。也就是子函数的改变要想影响父函数的数据必须传指针和解引用。<br>error1中既没有指针也没有解引用，error2中只是传指针但在Swap函数中没有使用解引用 error3中传了野指针导致程序崩溃。</p><p>参考文章：<a href="https://blog.csdn.net/qq_51663917/article/details/109206266">C语言中利用Swap函数交换变量a，b</a></p><p><a href="https://www.runoob.com/cprogramming/c-functions.html">菜鸟教程——C函数</a></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冒泡排序 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法刷题笔记8——排序（冒泡、插入、希尔）</title>
      <link href="/2021/08/04/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B08%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/08/04/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B08%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="09-排序1-排序（冒泡、插入、希尔）"><a href="#09-排序1-排序（冒泡、插入、希尔）" class="headerlink" title="09-排序1 排序（冒泡、插入、希尔）"></a>09-排序1 排序（冒泡、插入、希尔）</h1><p>给定<em>N</em>个（长整型范围内的）整数，要求输出从小到大排序后的结果。</p><p>本题旨在测试各种不同的排序算法在各种数据情况下的表现。各组测试数据特点如下：</p><p>数据1：只有$1$个元素；</p><p>数据2：$11$个不相同的整数，测试基本正确性；</p><p>数据3：$10^3$个随机整数；</p><p>数据4：$10^4$个随机整数；</p><p>数据5：$10^5$个随机整数；</p><p>数据6：$10^5$个顺序整数；</p><p>数据7：$10^5$个逆序整数；</p><p>数据8：$10^5$个基本有序的整数；</p><p>数据9：$10^5$个随机正整数，每个数字不超过$1000$。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入第一行给出正整数<em>N</em>$(≤10^5)$，随后一行给出<em>N</em>个（长整型范围内的）整数，其间以空格分隔。</p><span id="more"></span><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>在一行中输出从小到大排序后的结果，数字间以1个空格分隔，行末不得有多余空格。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">4 981 10 -17 0 -20 29 50 8 43 -5</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-20 -17 -5 0 4 8 10 29 43 50 981</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="中心思想"><a href="#中心思想" class="headerlink" title="中心思想"></a>中心思想</h2><p>多次遍历数组，如果相邻的数字左边比右边大就交换，一趟遍历完后最后一位是最大的数，第二趟遍历后，次大的在倒二；</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bubble_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> *B)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,N,*Data;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;N);</span><br><span class="line">    Data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>,&amp;Data[i]);</span><br><span class="line">    Bubble_sort(Data,N);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Data[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Data[N<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bubble_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,flag;</span><br><span class="line">    <span class="keyword">for</span>(i = N<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Data[j] &gt; Data[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(&amp;Data[j],&amp;Data[j+<span class="number">1</span>]);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> *B)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *tmp;</span><br><span class="line">    tmp = *A;</span><br><span class="line">    *A = *B;</span><br><span class="line">    *B = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>可以看到数据量才涨到$10^3$的时候冒泡排序的效率就已经比较差了，等数据量更大了之后如果不是输入已经有序都是超时的</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108042102637.png" alt="image-20210804210235543"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>小结<br><strong>最坏时间复杂度是$O(N^2)$​​​，如果数组基本有序，那么经过若干趟排序之后数组就可能是有序的，所以可能复杂度是$O(N)$​，所以通过了测试点7</strong><br>评价：交换排序，简单排序，最坏时间复杂度是$O(N^2)$，在数组基本有序的情况下时间复杂度可能是$O(N)$​​​​。空间复杂度$O(1)$。</li></ul><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="中心思想："><a href="#中心思想：" class="headerlink" title="中心思想："></a>中心思想：</h2><p>就像打牌时候整理手牌，一张张的摸牌，每拿入一张牌都插入到手牌中合适的位置，保证每次插入后都是有序的</p><p>可以做的一点优化是用移位来代替交换；</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insersion_sort</span><span class="params">(<span class="type">int</span> Data[],<span class="type">int</span> N)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,N,*Data;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;N);</span><br><span class="line">    Data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>,&amp;Data[i]);</span><br><span class="line">    Insersion_sort(Data,N);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Data[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Data[N<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insersion_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,tmp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = Data[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i;j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; Data[j<span class="number">-1</span>];j--)</span><br><span class="line">            Data[j] = Data[j<span class="number">-1</span>];</span><br><span class="line">        Data[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h2><p>可以看到插入排序的效果貌似略好于冒泡排序，因为它的稳定性比较好，比较的次数大概率是小于冒泡排序的</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108042310285.png" alt="image-20210804231041200"></p><p>可以看出来插入排序虽然全部测试点都通过了，但是有几个测试点的数据依然比较慢，但是插入排序的测试结果整体是好于冒泡的；</p><p>插入排序的空间复杂度为$O(1)$，插入排序的时间复杂度最坏是$O(N^2)$​，是所有数据都处于逆序状态时才会遇到的情况，绝大多数情况下不会遇到，而在数组基本有序的情况下，插入排序甚至都不用移动几次就能够完成排序，所以时间复杂度可能直接降为$O(N)$​；</p><p>插入和冒泡需要完成的交换次数都是相当的，这是由于插入和冒泡每次都只交换相邻的两个元素，这使得他们每次交换都只能消去一个<strong>逆序对</strong>，由此，为了使每次交换都消除更多的逆序对便产生了对插入排序优化后的希尔排序</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>与插入排序类似，但是每次比较的不是相邻的数，而是距离为某个值的两个元素。要定义一个间隔序列： 从大到小，最后是1<br>如Sedgewick序列：<br>int Sedgewick[] = {929, 505, 209, 109, 41, 19, 5, 1, 0};<br>这个序列中的元素一般要是互质的，这样希尔排序性能才会并较好。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*原始希尔排序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Shell_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,tmp,D;</span><br><span class="line">    <span class="keyword">for</span>(D = N/<span class="number">2</span>;D &gt; <span class="number">0</span>;D = D/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = D; i &lt; N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = Data[i];</span><br><span class="line">            <span class="keyword">for</span>(j = i;j &gt;= D &amp;&amp; tmp &lt; Data[j-D];j-=D)</span><br><span class="line">                Data[j] = Data[j-D];</span><br><span class="line">            Data[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 希尔排序 - 用Sedgewick增量序列 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Shell_sort</span><span class="params">(<span class="type">int</span> *Data,<span class="type">int</span> N)</span></span><br><span class="line">&#123;   </span><br><span class="line">     <span class="type">int</span> Si, D, P, i,j,tmp;</span><br><span class="line">     <span class="comment">/* 这里只列出一小部分增量 */</span></span><br><span class="line">     <span class="type">int</span> Sedgewick[] = &#123;<span class="number">929</span>, <span class="number">505</span>, <span class="number">209</span>, <span class="number">109</span>, <span class="number">41</span>, <span class="number">19</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> ( Si=<span class="number">0</span>; Sedgewick[Si]&gt;=N; Si++ );</span><br><span class="line">    <span class="comment">/* 初始的增量Sedgewick[Si]不能超过待排序列长度 */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> ( D=Sedgewick[Si]; D&gt;<span class="number">0</span>; D=Sedgewick[++Si] )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = D; i &lt; N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = Data[i];</span><br><span class="line">            <span class="keyword">for</span>(j = i;j &gt;= D &amp;&amp; tmp &lt; Data[j-D];j-=D)</span><br><span class="line">                Data[j] = Data[j-D];</span><br><span class="line">            Data[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108042340791.png" alt="image-20210804234044710"></p><p>从测试结果来看，希尔排序相对于插入排序已经快了很多，说明相对于插入排序已经优化了很多，但是希尔排序需要它的序列选取比较好才会有比较好的效果，目前人们一般认为对于Sedgewick增量序列：$9\times 4^i-9\times2^i$​或$4^i-3\times2^i+1$​的时间复杂度为$T<em>{arg} = O(N^{7/6})$,$T</em>{worst} = O(4/3)$</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>今日体重，82.95kg，测量于晚饭后，早上刚起床时候还是81.9kg，感觉很不真实，就没有把欺骗自己的体重放出来</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108042002600.png" alt=""></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/bobo1356/article/details/71749720">排序算法-09-排序1 排序 (25分)-第一部分</a></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插入排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法刷题笔记7——公路村村通</title>
      <link href="/2021/08/03/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B07%E2%80%94%E2%80%94%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A/"/>
      <url>/2021/08/03/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B07%E2%80%94%E2%80%94%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="08-图7-公路村村通-30-分"><a href="#08-图7-公路村村通-30-分" class="headerlink" title="08-图7 公路村村通 (30 分)"></a>08-图7 公路村村通 (30 分)</h1><blockquote><p>前言：本题来自浙大PTA上的数据结构练习题</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。</p></blockquote><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入数据包括城镇数目正整数<em>N</em>（≤1000）和候选道路数目<em>M</em>（≤3<em>N</em>）；随后的<em>M</em>行对应<em>M</em>条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到<em>N</em>编号。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">6 15</span><br><span class="line">1 2 5</span><br><span class="line">1 3 3</span><br><span class="line">1 4 7</span><br><span class="line">1 5 4</span><br><span class="line">1 6 2</span><br><span class="line">2 3 4</span><br><span class="line">2 4 6</span><br><span class="line">2 5 2</span><br><span class="line">2 6 6</span><br><span class="line">3 4 6</span><br><span class="line">3 5 1</span><br><span class="line">3 6 1</span><br><span class="line">4 5 10</span><br><span class="line">4 6 8</span><br><span class="line">5 6 3结尾无空行</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h1 id="题目理解与思路"><a href="#题目理解与思路" class="headerlink" title="题目理解与思路"></a>题目理解与思路</h1><p>本题是最小生成树的问题，可以采用Kruskal算法加并查集实现，或者使用简单的Prim算法实现。</p><p>本文使用Kruskal算法来解题，代码如下</p><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><blockquote><p>本解法越写越复杂，而且由于博主今日不在状态，写不动了，还没有通过测试，等待后续完善</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVer 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Inf 65535</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>* <span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> V;</span><br><span class="line">    <span class="type">int</span> E;</span><br><span class="line">    <span class="type">int</span> G[MaxVer][MaxVer];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;</span><br><span class="line"><span class="type">int</span> collected[MaxVer] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> S[MaxVer];</span><br><span class="line"><span class="type">int</span> VisitedE[MaxVer][MaxVer] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">MGraph <span class="title function_">creatGraph</span><span class="params">(<span class="type">int</span> V,<span class="type">int</span> E)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,V1,V2,D,j;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> GNode));</span><br><span class="line">    Graph-&gt;V = V;</span><br><span class="line">    Graph-&gt;E = E;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; V;i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; V;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">            &#123;</span><br><span class="line">                Graph-&gt;G[i][j] = <span class="number">0</span>;</span><br><span class="line">                S[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Graph-&gt;G[i][j] = Inf;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; Graph-&gt;E;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,&amp;V1,&amp;V2,&amp;D);</span><br><span class="line">        Graph-&gt;G[V1<span class="number">-1</span>][V2<span class="number">-1</span>] = Graph-&gt;G[V2<span class="number">-1</span>][V1<span class="number">-1</span>] = D;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findRoot</span><span class="params">(<span class="type">int</span> V)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S[V] &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> S[V] = findRoot(S[V]);<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S[Root1] &lt; S[Root2])</span><br><span class="line">    &#123;</span><br><span class="line">        S[Root1] += S[Root2];</span><br><span class="line">        S[Root2] = Root1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        S[Root2] += S[Root1];</span><br><span class="line">        S[Root1] = Root2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Kruskal</span><span class="params">(MGraph Graph)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> MinEdge,sum;</span><br><span class="line">    <span class="type">int</span> V1,V2,p1,p2;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num = Graph-&gt;V;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MinEdge = Inf;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Graph-&gt;E;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&lt;Graph-&gt;E;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((Graph-&gt;G[i][j] &lt; MinEdge)&amp;&amp;(VisitedE[i][j] == <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    MinEdge = Graph-&gt;G[i][j];</span><br><span class="line">                    V1 = i,V2 = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(MinEdge == Inf)<span class="keyword">break</span>;</span><br><span class="line">        VisitedE[V1][V2] = <span class="number">1</span>;</span><br><span class="line">        VisitedE[V2][V1] = <span class="number">1</span>;</span><br><span class="line">        p1 = findRoot(V1);</span><br><span class="line">        p2 = findRoot(V2);</span><br><span class="line">        <span class="keyword">if</span>(p1 != p2)&#123;</span><br><span class="line">        sum += MinEdge;</span><br><span class="line">        num--;</span><br><span class="line">        Union(V1,V2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> V,E;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d\n&quot;</span>,&amp;V,&amp;E);</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Graph = creatGraph(V,E);</span><br><span class="line">    Kruskal(Graph);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>今日体重</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202108031650116.png" alt="image-20210803165011918"></p><p>今天的体重是脱了鞋称的，所以比昨天轻很多2333</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> Prim </tag>
            
            <tag> Kruskal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法刷题笔记6——旅游规划最短路径问题</title>
      <link href="/2021/08/02/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B06%E2%80%94%E2%80%94%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
      <url>/2021/08/02/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B06%E2%80%94%E2%80%94%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="07-图6-旅游规划-25-分"><a href="#07-图6-旅游规划-25-分" class="headerlink" title="07-图6 旅游规划 (25 分)"></a>07-图6 旅游规划 (25 分)</h1><blockquote><p>前言：这篇文章是我的每日一文计划的第七篇文章，已经完成了一周的记录，在废物了几周之后感觉又一次找到了点好好学习的动力和不废物的目标感，希望自己能长期坚持！</p><p>PS:在文末我又立了点Flag👀👀，希望过一段时间以后这个Flag能够达成！🥳</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入说明：输入数据的第1行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0~(<em>N</em>−1)；<em>M</em>是高速公路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。随后的<em>M</em>行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4 5 0 3</span><br><span class="line">0 1 1 20</span><br><span class="line">1 3 2 30</span><br><span class="line">0 3 4 10</span><br><span class="line">0 2 2 20</span><br><span class="line">2 3 1 20</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 40</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="题目理解与思路"><a href="#题目理解与思路" class="headerlink" title="题目理解与思路"></a>题目理解与思路</h1><p>本题题目理解起来不难，每个城市即为图的节点，每个城市之间的公路距离即为图的边</p><p>难点在于如何优先使用距离来判断路径，然后距离相同时使用收费额来作为判断的第二依据</p><p>本文使用邻接矩阵来存储图，使用Dijkstra算法来动态更新每个节点的最短路径，同时动态更新路径的花销（在计算最短路径的过程中就优先把价格更低的选择为当前路径），在Dijkstra算法计算完成后，保留的最短路径也就是花销最小的路径。代码如下</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVer 505</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Inf 65535</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Vertex;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Edge;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Distance;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Fare;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>* <span class="title">PtrToGraph</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Vertex V;</span><br><span class="line">    Edge E;</span><br><span class="line">    Distance G[MaxVer][MaxVer];</span><br><span class="line">    Fare F[MaxVer][MaxVer];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGraph MGraph;</span><br><span class="line">Fare cost[MaxVer];</span><br><span class="line">Distance Dist[MaxVer];</span><br><span class="line"><span class="type">char</span> collected[MaxVer] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">MGraph <span class="title function_">BuildGraph</span><span class="params">(<span class="type">int</span> V, <span class="type">int</span> E)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(MGraph Graph,Vertex Start,Vertex Destina)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Vertex Start,Destina;</span><br><span class="line">    <span class="type">int</span> V,E;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,&amp;V,&amp;E,&amp;Start,&amp;Destina);</span><br><span class="line">    Graph = BuildGraph(V,E);</span><br><span class="line">    Dijkstra(Graph,Start,Destina);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(MGraph Graph,Vertex Start,Vertex Destina)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,MinDist,Min;</span><br><span class="line">    <span class="comment">/*遍历所有顶点，将开始节点与其邻接点的Dist和cost初始化*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Graph-&gt;V;i++)</span><br><span class="line">        <span class="keyword">if</span>(Graph-&gt;G[Start][i] &lt; Inf)</span><br><span class="line">        &#123;</span><br><span class="line">            Dist[i] = Graph-&gt;G[Start][i];</span><br><span class="line">            cost[i] = Graph-&gt;F[Start][i];</span><br><span class="line">        &#125;</span><br><span class="line">    collected[Start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Min = Inf;<span class="comment">//将最小距离记为Min，用于比较并找出Dis中最小的值</span></span><br><span class="line">        <span class="comment">//刚开始只用了MinDist来找最小值，找到后把i赋给MinDistinct，导致了小样本时不报错，大样本报错</span></span><br><span class="line">        <span class="comment">/*遍历所有节点，在未收集的节点中找出Dist最小的节点并收录*/</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; Graph-&gt;V;i++)</span><br><span class="line">            <span class="keyword">if</span>( Dist[i] &lt; Min &amp;&amp; collected[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                MinDist = i;</span><br><span class="line">                Min = Dist[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(Min == Inf)<span class="keyword">break</span>;</span><br><span class="line">        collected[MinDist] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Graph-&gt;V;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph-&gt;G[MinDist][i] &lt; Inf)<span class="comment">/*对于MinDist的每个未收集的邻接点*/</span></span><br><span class="line">                <span class="keyword">if</span>(collected[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/*如果从新加入的MinDist走过去距离更小就更新Dist中的距离*/</span></span><br><span class="line">                    <span class="keyword">if</span>(Dist[MinDist] + Graph-&gt;G[MinDist][i] &lt; Dist[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        Dist[i] = Dist[MinDist] + Graph-&gt;G[MinDist][i];</span><br><span class="line">                        cost[i] = cost[MinDist] + Graph-&gt;F[MinDist][i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*如果距离相等且有价格更低的就更新价格*/</span></span><br><span class="line">                    <span class="keyword">if</span>((Dist[MinDist] + Graph-&gt;G[MinDist][i] == Dist[i]) </span><br><span class="line">                            &amp;&amp; ( cost[MinDist] + Graph-&gt;F[MinDist][i] &lt; cost[i]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        cost[i] = cost[MinDist] + Graph-&gt;F[MinDist][i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,Dist[Destina],cost[Destina]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MGraph <span class="title function_">BuildGraph</span><span class="params">(<span class="type">int</span> V, <span class="type">int</span> E)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,D,F;</span><br><span class="line">    Vertex V1,V2;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> GNode));</span><br><span class="line">    Graph-&gt;V = V;</span><br><span class="line">    Graph-&gt;E = E;</span><br><span class="line">    <span class="comment">/*对新建的图进行初始化*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; Graph-&gt;V; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; Graph-&gt;V; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">                Graph-&gt;G[i][j] = Graph-&gt;F[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Graph-&gt;F[i][j] = Graph-&gt;G[i][j] = Inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; Graph-&gt;E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,&amp;V1,&amp;V2,&amp;D,&amp;F);</span><br><span class="line">        Graph-&gt;G[V1][V2] = Graph-&gt;G[V2][V1] = D;</span><br><span class="line">        Graph-&gt;F[V1][V2] = Graph-&gt;F[V2][V1] = F;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Graph-&gt;V; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Dist[i] = Inf;</span><br><span class="line">        cost[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记——对于Dijkstra算法与Floyd算法的一些理解"><a href="#后记——对于Dijkstra算法与Floyd算法的一些理解" class="headerlink" title="后记——对于Dijkstra算法与Floyd算法的一些理解"></a>后记——对于Dijkstra算法与Floyd算法的一些理解</h1><p>学习了图这种数据结构之后一直想知道怎么运用这个数据结构不过一直没学到相关的算法，正好最近学了一些就写了点相关的题目，也有了些自己的新的理解。</p><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>Dijkstra算法是用来求单个源点到其它所有点的距离的最小值的算法，使用最小堆来存储未收录点时查找最小点的复杂度为$O(logV)$（适合稀疏图），使用暴力的遍历所有节点查找最小值时复杂度为$O(V^2)$（适合稠密图），其思想是一种贪心算法，把节点分为了收录的和未收录的，收录的节点包含源点s和已经确定了最短路径的节点，每次收录一个节点，该节点也为已经缺定最短路径的节点，然后更新受新收录的节点影响的点到源点的距离和路径，而同时又可以证明收录的节点只会影响其邻接点的最小距离，故只需更新其邻接点的最小距离即可。由于每次收录的节点均为经过当前收录节点而确定的当前到源点距离最小的点（贪心），故保证了收录的所有节点均为确定了最短路径的节点。当所有的节点均收录完毕后，源点到所有对应点的距离也就确定了。<br>总结而言，Dijkstra算法就是每个循环都做以下三件事，直至所有节点都已被收录</p><ol><li>选择未收录节点中距离源点最小的节点收录</li><li>收录后根据收录节点到源点的距离与图中其邻接边的权重来判断是否对邻接点有影响</li><li>更新邻接点的最小距离</li></ol><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>Floyd算法是用来求多个源点到其它所有点的最短路径的算法，对于稠密图来说效果更好一点，复杂度为$O(V^{3})$​，其思想是动态规划的思想，每次迭代就比较源点 I 到一个节点K的距离加上K到目标节点 J 的距离是否小于源点 I 直接到目标节点 J 的距离，小于的时候就动态更新节点 J 的路径和最小距离，通过多次迭代来留下最小的各点到各点的距离值。</p><h1 id="附记"><a href="#附记" class="headerlink" title="附记"></a>附记</h1><p>从今日开始，增肌期结束💪，我将进入减脂期，会在每天的文章最后更新当日的体重噢🤸🏻🤸🏻🤸🏻</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img20210802112328.jpg" alt="IMG_20210802_112256"></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
            <tag> Floyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.计算机系统概论</title>
      <link href="/2021/08/01/SnowMoon%E3%81%AE%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
      <url>/2021/08/01/SnowMoon%E3%81%AE%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天没有刷题，学的也比较水，主要原因有以下两点</p><ol><li>刚开一门新课，学的内容不是很多，不是很充实</li><li>懒！！！今天没有用心学</li></ol></blockquote><p>一、冯·诺依曼计算机的特点</p><ol><li>由五大部件组成</li><li>指令和数据以同等地位存于存储器，可按地址寻访</li><li>指令和数据用二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序</li><li>以[[运算器]]为中心<br><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img20210801230612.png" alt=""></li></ol><p>改进：以存储器为中心</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img20210801230631.png" alt="Pasted image 20210801195410"></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img20210801230640.png" alt="Pasted image 20210801195500">系统复杂性的管理方法(3Y原则)</p><ul><li>层次化（Hierachy）：将被设计的系统划分为多个模块或子模块</li><li>模块化（Modularity）：有明确定义（well-defined）的功能和接口</li><li>规则性（regularity）：模块更容易被重用</li></ul><p>[[存储器]]</p><p><strong>存储单元</strong>：存放一串二进制代码<br><strong>存储字</strong>：存储单元中二进制代码的组合<br><strong>存储字长</strong>：存储单元中二进制代码的位数</p><span id="more"></span><h1 id="MAR-存储器地址寄存器，反映存储单元的个数"><a href="#MAR-存储器地址寄存器，反映存储单元的个数" class="headerlink" title="MAR 存储器地址寄存器，反映存储单元的个数"></a>MAR 存储器地址寄存器，反映存储单元的个数</h1><h1 id="MDR-存储器数据寄存器，反映存储字长"><a href="#MDR-存储器数据寄存器，反映存储字长" class="headerlink" title="MDR 存储器数据寄存器，反映存储字长"></a>MDR 存储器数据寄存器，反映存储字长</h1><p>[[运算器]]</p><p>由ACC、ALU、MQ、X组成</p><p>[[控制器]]</p><p>由CU、IR、PC、组成<br>PC 取指令<br>IR    分析指令<br>CU    执行指令<br>PC 存放当前欲执行指令的地址， 具有计数功能（PC）+ 1 PC<br>IR 存放当前欲执行的指令</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img20210801230702.png" alt="Pasted image 20210801224533"></p><p><strong>机器字长</strong> CPU 一次能处理数据的位数 与 CPU 中的 寄存器位数 有关</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法刷题笔记5——哈利波特的考试</title>
      <link href="/2021/07/31/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B05%E2%80%94%E2%80%94%E5%93%88%E5%88%A9%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95/"/>
      <url>/2021/07/31/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B05%E2%80%94%E2%80%94%E5%93%88%E5%88%A9%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="07-图4-哈利·波特的考试-25-分"><a href="#07-图4-哈利·波特的考试-25-分" class="headerlink" title="07-图4 哈利·波特的考试 (25 分)"></a>07-图4 哈利·波特的考试 (25 分)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。</p><p>现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入说明：输入第1行给出两个正整数<em>N</em> (≤100)和<em>M</em>，其中<em>N</em>是考试涉及的动物总数，<em>M</em>是用于直接变形的魔咒条数。为简单起见，我们将动物按1~<em>N</em>编号。随后<em>M</em>行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。</p><span id="more"></span><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6 11</span><br><span class="line">3 4 70</span><br><span class="line">1 2 1</span><br><span class="line">5 4 50</span><br><span class="line">2 6 50</span><br><span class="line">5 6 60</span><br><span class="line">1 3 70</span><br><span class="line">4 6 60</span><br><span class="line">3 6 80</span><br><span class="line">5 1 100</span><br><span class="line">2 4 60</span><br><span class="line">5 2 80</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 70</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h1 id="题目理解与思路"><a href="#题目理解与思路" class="headerlink" title="题目理解与思路"></a>题目理解与思路</h1><p>这题可抽象为计算多个源点与其它所有点的最小距离然后取出每个点到其它所有点的距离的最大值比较来找出花销最少的节点并记录、输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxAnimal 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Inf 65535</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>* <span class="title">PtrToGraph</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> V,E;</span><br><span class="line">    <span class="type">int</span> G[MaxAnimal][MaxAnimal];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGraph MGraph;</span><br><span class="line"></span><br><span class="line">MGraph <span class="title function_">CreateGraph</span><span class="params">(<span class="type">int</span> V,<span class="type">int</span> E)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,V1,V2,Num;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> GNode));</span><br><span class="line">    Graph-&gt;V = V;</span><br><span class="line">    Graph-&gt;E = E;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; V;i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; V; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">                Graph-&gt;G[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Graph-&gt;G[i][j] = Inf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; E;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,&amp;V1,&amp;V2,&amp;Num);</span><br><span class="line">        Graph-&gt;G[V1<span class="number">-1</span>][V2<span class="number">-1</span>] = Num;</span><br><span class="line">        Graph-&gt;G[V2<span class="number">-1</span>][V1<span class="number">-1</span>] = Num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">FindMaxDist</span><span class="params">(<span class="type">int</span> D[][MaxAnimal],<span class="type">int</span> i, <span class="type">int</span> V)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> MaxDist,j;</span><br><span class="line">    MaxDist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;V;j++)</span><br><span class="line">        <span class="keyword">if</span>(i!=j &amp;&amp; D[i][j]&gt;MaxDist)</span><br><span class="line">            MaxDist = D[i][j];</span><br><span class="line">    <span class="keyword">return</span> MaxDist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Floyd</span><span class="params">(MGraph Graph,<span class="type">int</span> D[][MaxAnimal])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;Graph-&gt;V;i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;Graph-&gt;V;j++)</span><br><span class="line">            D[i][j] = Graph-&gt;G[i][j];</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>;k&lt;Graph-&gt;V;k++)</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;Graph-&gt;V;i++)</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;Graph-&gt;V;j++)</span><br><span class="line">                <span class="keyword">if</span>(D[i][k] + D[k][j] &lt; D[i][j])</span><br><span class="line">                    D[i][j] = D[i][k] + D[k][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Findanimal</span><span class="params">(MGraph Graph)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> D[MaxAnimal][MaxAnimal];</span><br><span class="line">    <span class="type">int</span> Animal,i,MinDist,MaxDist;</span><br><span class="line">    </span><br><span class="line">    Floyd(Graph,D);</span><br><span class="line">    </span><br><span class="line">    MinDist = Inf;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Graph-&gt;V;i++)&#123;</span><br><span class="line">        MaxDist = FindMaxDist(D,i,Graph-&gt;V);</span><br><span class="line">        <span class="keyword">if</span>(MinDist &gt; MaxDist)</span><br><span class="line">        &#123;</span><br><span class="line">            MinDist = MaxDist;</span><br><span class="line">            Animal = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(MaxDist == Inf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,Animal,MinDist);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> V,E;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d\n&quot;</span>,&amp;V,&amp;E);</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Graph = CreateGraph(V,E);</span><br><span class="line">    Findanimal(Graph);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> BFS </tag>
            
            <tag> Floyd算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法刷题笔记4——六度空间</title>
      <link href="/2021/07/30/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/"/>
      <url>/2021/07/30/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="06-图3-六度空间-30-分"><a href="#06-图3-六度空间-30-分" class="headerlink" title="06-图3 六度空间 (30 分)"></a>06-图3 六度空间 (30 分)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。</p><p><img src="https://images.ptausercontent.com/35" alt="img"><br>图1 六度空间示意图</p><p>“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p><p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入第1行给出两个正整数，分别表示社交网络图的结点数<em>N</em>（1&lt;<em>N</em>≤103，表示人数）、边数<em>M</em>（≤33×<em>N</em>，表示社交关系数）。随后的<em>M</em>行对应<em>M</em>条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到<em>N</em>编号）。<br><span id="more"></span></p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">7 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1: 70.00%</span><br><span class="line">2: 80.00%</span><br><span class="line">3: 90.00%</span><br><span class="line">4: 100.00%</span><br><span class="line">5: 100.00%</span><br><span class="line">6: 100.00%</span><br><span class="line">7: 100.00%</span><br><span class="line">8: 90.00%</span><br><span class="line">9: 80.00%</span><br><span class="line">10: 70.00%</span><br><span class="line">//结尾无空行</span><br></pre></td></tr></table></figure><h1 id="思路与题解"><a href="#思路与题解" class="headerlink" title="思路与题解"></a>思路与题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据题目描述，我们只需要建立一个图，而六层的统计要求就比较容易想到从输入的第一个节点进行广度优先搜索遍历所有节点，然后统计六层内的节点数量百分比即可<br>1000个节点的数据而节点间的连接又小于33个，所以可以认为是比较稀疏的图，使用邻接表来存储是比较合算的<br>难点在于遍历的层数的统计<br>有两种解决办法</p><ol><li>在结构体内加入一个数据记录节点层数</li><li>每次遍历记录末尾数字和上一次的末尾数字，相同时层数++<br>本文采用第二种方法进行记录，代码如下<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>第一次使用邻接表存储的图来写算法，虽然不是标准的邻接表，但也感觉有被烦到。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVer 1005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Vertex;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">AdjList</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Vertex Value;</span><br><span class="line">    AdjList Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Visited[MaxVer];</span><br><span class="line"><span class="type">int</span> Que[MaxVer];<span class="comment">//使用数组作为队列</span></span><br><span class="line">AdjList G[MaxVer];</span><br><span class="line"><span class="type">int</span> N,E;<span class="comment">//存储节点的数量和边的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GraphInit</span><span class="params">()</span></span><br><span class="line">&#123;   <span class="comment">/*建图*/</span></span><br><span class="line">    <span class="type">int</span> i,V1,V2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d\n&quot;</span>,&amp;N,&amp;E);</span><br><span class="line">    AdjList NewNode;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    &#123;<span class="comment">/*初始化节点*/</span></span><br><span class="line">        G[i] = (AdjList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> GNode));</span><br><span class="line">        G[i]-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        G[i]-&gt;Value = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; E;i++)</span><br><span class="line">    &#123;<span class="comment">/*初始化边*/</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d\n&quot;</span>,&amp;V1,&amp;V2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*插入V1连向V2的边*/</span></span><br><span class="line">        NewNode = (AdjList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> GNode));</span><br><span class="line">        NewNode-&gt;Next = G[V1]-&gt;Next;</span><br><span class="line">        NewNode-&gt;Value = V2;</span><br><span class="line">        G[V1]-&gt;Next = NewNode;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*插入V2连向V1的边*/</span></span><br><span class="line">        NewNode = (AdjList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> GNode));</span><br><span class="line">        NewNode-&gt;Next = G[V2]-&gt;Next;</span><br><span class="line">        NewNode-&gt;Value = V1;</span><br><span class="line">        G[V2]-&gt;Next = NewNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(<span class="type">int</span> Num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> head,rear,Last,Tail,Level,count;</span><br><span class="line">    AdjList P;</span><br><span class="line">    Level = rear = <span class="number">0</span>;</span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    Que[<span class="number">0</span>] = Num;</span><br><span class="line">    Visited[Num] = <span class="number">1</span>;</span><br><span class="line">    Last = Tail = Num;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; rear )<span class="comment">//当链表为空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        head++;</span><br><span class="line">        P = G[Que[head]]-&gt;Next;</span><br><span class="line">        <span class="keyword">while</span>( P )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!Visited[P-&gt;Value])</span><br><span class="line">            &#123;   </span><br><span class="line">                Visited[P-&gt;Value] =<span class="number">1</span>;</span><br><span class="line">                rear++;</span><br><span class="line">                Que[rear] = P-&gt;Value;</span><br><span class="line">                Tail = P-&gt;Value;</span><br><span class="line">                count++;<span class="comment">/*每个节点出来时都需要统计它的邻接点，</span></span><br><span class="line"><span class="comment">                        如果是在这个遍历外统计节点时最后的尾结</span></span><br><span class="line"><span class="comment">                        点统计会出现一些小问题*/</span></span><br><span class="line">            &#125;</span><br><span class="line">            P = P-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( Que[head] == Last)<span class="comment">//如果当前出队列元素为这层的末尾元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            Last = Tail;</span><br><span class="line">            Level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( Level == <span class="number">6</span>) <span class="keyword">break</span>;<span class="comment">//超过六层就退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">        Visited[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    GraphInit();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %.2f%%\n&quot;</span>,i,<span class="number">100.0</span> * BFS(i) / N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构刷题笔记3——拯救詹姆斯邦德</title>
      <link href="/2021/07/29/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E6%8B%AF%E6%95%91%E8%A9%B9%E5%A7%86%E6%96%AF%E9%82%A6%E5%BE%B7/"/>
      <url>/2021/07/29/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E6%8B%AF%E6%95%91%E8%A9%B9%E5%A7%86%E6%96%AF%E9%82%A6%E5%BE%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="06-图2-Saving-James-Bond-Easy-Version-25-分"><a href="#06-图2-Saving-James-Bond-Easy-Version-25-分" class="headerlink" title="06-图2 Saving James Bond - Easy Version (25 分)"></a>06-图2 Saving James Bond - Easy Version (25 分)</h1><p><strong>题目描述</strong></p><p>This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape — he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p><p>Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.</p><h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of crocodiles, and <em>D</em>, the maximum distance that James could jump. Then <em>N</em> lines follow, each containing the (<em>x</em>,<em>y</em>) location of a crocodile. Note that no two crocodiles are staying at the same position.</p><h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each test case, print in a line “Yes” if James can escape, or “No” if not.</p><span id="more"></span><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">14 20</span><br><span class="line">25 -15</span><br><span class="line">-25 28</span><br><span class="line">8 49</span><br><span class="line">29 15</span><br><span class="line">-35 -2</span><br><span class="line">5 28</span><br><span class="line">27 -29</span><br><span class="line">-8 -28</span><br><span class="line">-20 -35</span><br><span class="line">-25 -20</span><br><span class="line">-13 29</span><br><span class="line">-30 15</span><br><span class="line">-35 40</span><br><span class="line">12 12</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 13</span><br><span class="line">-12 12</span><br><span class="line">12 12</span><br><span class="line">-12 -12</span><br><span class="line">12 -12</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h1 id="谷歌翻译版题目描述"><a href="#谷歌翻译版题目描述" class="headerlink" title="谷歌翻译版题目描述"></a>谷歌翻译版题目描述</h1><h2 id="06-图2-拯救詹姆斯邦德-简易版（25分）"><a href="#06-图2-拯救詹姆斯邦德-简易版（25分）" class="headerlink" title="06-图2 拯救詹姆斯邦德 - 简易版（25分）"></a>06-图2 拯救詹姆斯邦德 - 简易版（25分）</h2><p>这一次让我们考虑一下电影《生与死》中世界上最著名的间谍詹姆斯邦德被一群毒贩抓获的情况。他被送到了一个充满鳄鱼的湖中心的一小块土地上。在那里，他做出了最大胆的逃跑动作——跳到了最近的鳄鱼的头上！还没等那只动物意识到发生了什么事，詹姆斯又跳到了下一个大脑袋上…… 终于在最后一条鳄鱼咬到他之前到达了岸边（实际上特技演员被大嘴卡住了，他的超厚靴子勉强逃过一劫）。</p><p>假设湖是一个 100 x 100 的正方形。假设湖的中心在 (0,0)，东北角在 (50,50)。中央岛是一个以(0,0)为中心、直径为15的圆盘。湖中有许多鳄鱼在不同的位置。给定每条鳄鱼的坐标和詹姆斯可以跳跃的距离，你必须告诉他是否可以逃脱。</p><h2 id="输入规格："><a href="#输入规格：" class="headerlink" title="输入规格："></a>输入规格：</h2><p>每个输入文件包含一个测试用例。每个案例都以一行包含两个正整数 N（≤100）、鳄鱼的数量和 D（詹姆斯可以跳跃的最大距离）开始。然后是 N 行，每行都包含鳄鱼的 (x,y) 位置。请注意，没有两条鳄鱼停留在同一位置。</p><h2 id="输出规格："><a href="#输出规格：" class="headerlink" title="输出规格："></a>输出规格：</h2><p>对于每个测试用例，如果 James 可以逃脱，则打印“Yes”，否则打印“No”。</p><h1 id="题目理解与思路"><a href="#题目理解与思路" class="headerlink" title="题目理解与思路"></a>题目理解与思路</h1><p>本题提供的数据为每个鳄鱼所在的点的坐标，使用DFS和BFS都能实现，感觉总体难点在于存储这些鳄鱼所在的点的数据结构，刚开始时我使用了一个点类来存储，开辟了一系列的含有坐标的点组成的数组，然后通过遍历这个数组来进行DFS，后来发现了更简单的方法，使用两个全局的数组来分别存储这些点的X坐标和Y坐标，然后数组的下标即表示一个点，所以就不用封装到结构里（PS：主要是我对struct不是很熟悉，写着总是报错。。。）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxN 101</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DIS,NUM;</span><br><span class="line"><span class="type">int</span> X[MaxN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> Y[MaxN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> Visited[MaxN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Distance</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(X[i]-X[j],<span class="number">2</span>) + <span class="built_in">pow</span>(Y[i]-Y[j],<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    Visited[N] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(X[N] &gt;= <span class="number">50</span>-DIS||X[N] &lt;= DIS<span class="number">-50</span></span><br><span class="line">       ||Y[N] &gt;= <span class="number">50</span>-DIS||Y[N] &lt;= DIS<span class="number">-50</span>)<span class="comment">//满足边界条件，即能跳到岸边，就返回真，退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= NUM; i++)<span class="comment">//要从1开始遍历（因为用了0来存储原点，第一个点从1开始）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Visited[i] == <span class="number">0</span>&amp;&amp; ( Distance(N,i) &lt;= DIS))</span><br><span class="line">            <span class="keyword">if</span>(DFS(i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d\n&quot;</span>,&amp;NUM,&amp;DIS);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d\n&quot;</span>, &amp;X[i],&amp;Y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(DIS+<span class="number">15</span>&gt;=<span class="number">50</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Distance(<span class="number">0</span>,i) &lt;= <span class="number">15</span> + DIS)<span class="comment">//第一跳，判断原点距离与第一个点的距离来判断是否能跳上去</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(DFS(i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构刷题笔记2——使用DFS和BFS列出连通集</title>
      <link href="/2021/07/28/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8DFS%E5%92%8CBFS%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/"/>
      <url>/2021/07/28/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8DFS%E5%92%8CBFS%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="06-图1-列出连通集-25-分-——PTA"><a href="#06-图1-列出连通集-25-分-——PTA" class="headerlink" title="06-图1 列出连通集 (25 分)——PTA"></a>06-图1 列出连通集 (25 分)——PTA</h1><p>给定一个有<em>N</em>个顶点和<em>E</em>条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到<em>N</em>−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入第1行给出2个整数<em>N</em>(0&lt;<em>N</em>≤10)和<em>E</em>，分别是图的顶点数和边数。随后<em>E</em>行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>按照”{ <em>v</em>1 <em>v</em>2 … <em>v**k</em> }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure><h2 id="题目理解"><a href="#题目理解" class="headerlink" title="题目理解"></a>题目理解</h2><p>本题给了我们几组数据用来建图，在建图完成后需要我们使用DFS与BFS遍历整个图然后按照遍历的顺序输出每个连通的图的节点的值</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据要求走就行了，建图，然后DFS和BFS//第一个完全靠自己写出来的图的题，不容易啊😭😭😭</p><p>本文使用的是邻接矩阵来表示图</p><p>在使用BFS进行遍历时，因为数据量比较小，所以只需要使用一个数组和两个作为头尾的数字就能作为队列</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>* <span class="title">PtrToGraph</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> E,V;<span class="comment">//分别为边数E和顶点数V</span></span><br><span class="line">    <span class="type">int</span> G[MaxVertexNum][MaxVertexNum];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGraph MGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Visited[MaxVertexNum] = &#123;<span class="number">0</span>&#125;;<span class="comment">//是否访问过该节点</span></span><br><span class="line"><span class="type">int</span> Q[MaxVertexNum] = &#123;<span class="number">0</span>&#125;;<span class="comment">//用来做队列的数组</span></span><br><span class="line">MGraph <span class="title function_">CreatGraph</span><span class="params">(<span class="type">int</span> V,<span class="type">int</span> E)</span></span><br><span class="line">&#123;<span class="comment">//建图，初始化图的边和节点值</span></span><br><span class="line">    <span class="type">int</span> i,m,n;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> GNode));</span><br><span class="line">    Graph -&gt; V = V;</span><br><span class="line">    Graph -&gt; E = E;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; E;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d\n&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">        Graph-&gt;G[m][n] = <span class="number">1</span>;</span><br><span class="line">        Graph-&gt;G[n][m] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(MGraph Graph,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Visited[x] = <span class="number">1</span>;<span class="comment">//进入一个节点就把访问过的标记为True</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; Graph-&gt;V;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((Graph-&gt;G[i][x] == <span class="number">1</span>) &amp;&amp; (!Visited[i]))<span class="comment">//使用DFS访问节点x相邻且没有被访问过的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            DFS(Graph,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ResetGraph</span><span class="params">(MGraph Graph)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;MaxVertexNum;i++)</span><br><span class="line">        Visited[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(MGraph Graph,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,head,rear;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    rear = <span class="number">0</span>;</span><br><span class="line">    Q[<span class="number">0</span>] = x;</span><br><span class="line">    Visited[x] = <span class="number">1</span>;<span class="comment">//进入BFS时把BFS的入口节点视为访问过</span></span><br><span class="line">    <span class="keyword">while</span>(head != rear)<span class="comment">//当队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        head++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Q[head]);<span class="comment">//输出头结点</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; Graph-&gt;V;i++)</span><br><span class="line">        &#123;<span class="comment">//遍历所有节点，如果是头结点的邻接点且没有被访问过则入队</span></span><br><span class="line">            <span class="keyword">if</span>(!Visited[i] &amp;&amp; (Graph-&gt;G[i][Q[head]] == <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                rear++;</span><br><span class="line">                Q[rear] = i;</span><br><span class="line">                Visited[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> V,E,i;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d\n&quot;</span>,&amp;V,&amp;E);</span><br><span class="line">    Graph = CreatGraph(V,E);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; V ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&#123; &quot;</span>);</span><br><span class="line">            DFS(Graph,i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ResetGraph(Graph);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; V;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&#123; &quot;</span>);</span><br><span class="line">            BFS(Graph,i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构刷题笔记1——是否同一棵二叉搜索树</title>
      <link href="/2021/07/27/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2021/07/27/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="04-树4-是否同一棵二叉搜索树-25-分"><a href="#04-树4-是否同一棵二叉搜索树-25-分" class="headerlink" title="04-树4 是否同一棵二叉搜索树 (25 分)"></a>04-树4 是否同一棵二叉搜索树 (25 分)</h1><blockquote><p>题目来源：浙江大学数据结构MOOC配套习题（PTA）</p></blockquote><p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数<em>N</em> (≤10)和<em>L</em>，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出<em>N</em>个以空格分隔的正整数，作为初始插入序列。最后<em>L</em>行，每行给出<em>N</em>个插入的元素，属于<em>L</em>个需要检查的序列。</p><p>简单起见，我们保证每个插入序列都是1到<em>N</em>的一个排列。当读到<em>N</em>为0时，标志输入结束，这组数据不要处理。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p><strong>题意</strong></p><p>这个题目是给你一些建树用的数据，第一组树的数据作为判断的基准，后面的数据作为拿来判断是不是同一棵二叉搜索树的测试数据</p><p><strong>思路</strong></p><p>这道题有三种思路</p><ol><li>不建树，根据数据大小分类序列，递归判断序列是否相一致；</li><li>建两棵树，根据序列建两棵树再判断两棵树是否一致；</li><li>建一棵树，把判断基准建立为一棵基准树，其它的数据放进来和这棵树比较</li></ol><p>本文采用第三种方法——建立一棵树然后新的序列与这棵树作比较<br>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Tree Left,Right;<span class="comment">//用两个指针来指向左右子树</span></span><br><span class="line">    <span class="type">int</span> data,flag;<span class="comment">//data来存放这个节点的数据，flag用来判断是否访问过该节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree <span class="title function_">BuildTree</span><span class="params">(<span class="type">int</span> N)</span>;</span><br><span class="line">Tree <span class="title function_">NewNode</span><span class="params">(<span class="type">int</span> V)</span>;</span><br><span class="line">Tree <span class="title function_">Insert</span><span class="params">(Tree T,<span class="type">int</span> V)</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">Judge</span><span class="params">(Tree T,<span class="type">int</span> N)</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">check</span><span class="params">(Tree T,<span class="type">int</span> N)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeTree</span><span class="params">(Tree T)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ResetT</span><span class="params">(Tree T)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> N,i,L;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N);</span><br><span class="line">    <span class="keyword">while</span>(N)<span class="comment">//当N为0时返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;L);</span><br><span class="line">        T = BuildTree(N);<span class="comment">//建立二叉搜索树</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L; i++)<span class="comment">//多组数据，使用读入的L来控制读入的数据组数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Judge(T,N)) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);<span class="comment">//判断是否是一棵树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">            ResetT(T);<span class="comment">//将T初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        FreeTree(T);<span class="comment">//判断完成后释放当前树</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree <span class="title function_">BuildTree</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,V;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;V);</span><br><span class="line">    T = NewNode(V);<span class="comment">//开辟第一个节点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;V);</span><br><span class="line">        T = Insert(T,V);<span class="comment">//后续节点的插入（保证插入完成后该树为二叉搜索树）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree <span class="title function_">NewNode</span><span class="params">(<span class="type">int</span> V)</span></span><br><span class="line">&#123;</span><br><span class="line">    Tree T = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));<span class="comment">//开辟新节点</span></span><br><span class="line">    T -&gt; data = V;</span><br><span class="line">    T -&gt; Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;<span class="comment">//初始化操作</span></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree <span class="title function_">Insert</span><span class="params">(Tree T,<span class="type">int</span> V)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) T = NewNode(V);<span class="comment">//查找到空节点时开辟新节点并插入</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;data &gt; V)<span class="comment">//此节点数据大于要插入的数据时向左插入</span></span><br><span class="line">            T-&gt;Left = Insert(T-&gt;Left,V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T-&gt;Right = Insert(T-&gt;Right,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> <span class="title function_">Judge</span><span class="params">(Tree T,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,V,Jflag = <span class="number">0</span>;<span class="comment">//使用Jflag来保证在中途判断出不是同一棵树后仍能继续读数据和判断</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;V);</span><br><span class="line">    <span class="keyword">if</span>( V != T-&gt;data) Jflag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> T-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;V);</span><br><span class="line">        <span class="keyword">if</span>((!check(T,V)) &amp;&amp; (!Jflag)) Jflag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Jflag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">check</span><span class="params">(Tree T,<span class="type">int</span> V)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;flag)<span class="comment">//当这个节点被访问过</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//要判断的数据和这个节点不等时根据大小关系向左向右判断</span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;data&gt;V) <span class="keyword">return</span> check(T-&gt;Left,V);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data&lt;V) <span class="keyword">return</span> check(T-&gt;Right,V);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果这个节点被访问过且数据和要判断的数据相同说明不是</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(V == T-&gt;data)&#123;<span class="comment">//未访问过该节点且该节点数据和需要判断的数据相等</span></span><br><span class="line">            T-&gt;flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeTree</span><span class="params">(Tree T)</span></span><br><span class="line">&#123;<span class="comment">//释放判断的基准树</span></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;Right) FreeTree(T-&gt;Right);</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;Left) FreeTree(T-&gt;Left);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ResetT</span><span class="params">(Tree T)</span></span><br><span class="line">&#123;<span class="comment">//判断完成后的树的初始化</span></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;Right) ResetT(T-&gt;Right);</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;Left) ResetT(T-&gt;Left);</span><br><span class="line">    T-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO博客部署到github并将个人域名解析至github</title>
      <link href="/2021/03/10/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-HEXO%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A/"/>
      <url>/2021/03/10/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-HEXO%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：由于最近GFW查的比较严，本人的博客是部署在国外服务器上的，已经被封禁了七八次了，所以打算把本人的个人博客迁移到github上，使用阿里云的oss服务来存储照片，提高博客的访问速度</p></blockquote><p> 首先将自己本地的hexo博客部署好，我这边已经配置过了就不再赘述，具体配置过程可移步<a href="https://io-oi.me/tech/hexo-next-optimization/#%E5%BF%85%E8%AF%BB-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2">这篇文章</a>（博主真的写的相当相当用心，墙裂推荐！你想怎么折腾都能看这篇文章，就是有些部分有点过时了）</p><h1 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h1><p>首先在github中新建一个repository</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img20210318211201.png" alt="image-20210318211154319"></p><p>repository name一定要填你的github名称.github.io，否则无法使用github提供的域名访问。填写示例：<code>ASnowMoon.github.io</code>，别的选项随便选</p><p>新建完成后在本地博客的根目录下安装Git部署的插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>安装完成后打开博客根目录下的<strong>站点</strong>配置文件<code>~/blog/_config.yml</code></p><p>找到<code>deploy</code>并配置以下内容</p><span id="more"></span><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#部署</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@github.com:ASnowMoon/ASnowMoon.github.io.git</span>   <span class="comment">#用户名@服务器Ip:git仓库位置</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>其中git仓库位置需要改为你自己新建的</p><p>更改完成后在<code>gitbash</code>中输入以下命令即可把它部署到你的github上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure><p>在浏览器输入 <code>https://帐号名.github.io/</code> 查看你有没有部署完成</p><h1 id="域名注册和解析到github"><a href="#域名注册和解析到github" class="headerlink" title="域名注册和解析到github"></a>域名注册和解析到github</h1><p>首先购买域名，腾讯云、阿里云都还不错，博主用的是腾讯云</p><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>进入控制台，点击解析-添加记录</p><p>主机类型选择www,记录类型选择CNAME，记录值填入刚刚新建的github的域名<code>ASnowMoon.github.io</code>-保存</p><p>再选择<code>@</code>类型主机，保证主域名和包含www的域名都能成功解析，同样的，记录类型选择CNAME，记录值填入刚刚新建的github的域名<code>ASnowMoon.github.io</code>-保存</p><h2 id="添加CNAME文件"><a href="#添加CNAME文件" class="headerlink" title="添加CNAME文件"></a>添加CNAME文件</h2><p>在博客根目录下的<code>source</code>文件下新建一个文本文档<code>CNAME.txt</code>打开文本编辑器输入你的域名www.snowmoon.top保存，退出</p><p>退出后<strong><em>删除.txt后缀文件名</em></strong></p><p>最终CNAME的配置效果：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img20210318214322.png" alt="image-20210318214322886"></p><p>再打开你刚刚新建的github仓库，选择<code>settings</code>，在<code>Options</code>里找到<code>Github Pages</code>，在<code>Custom domain</code>里输入自己的域名</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img20210318214711.png" alt="image-20210318214711681"></p><p>这时候已经配置好了，再次部署到github上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure><p>输入自己的域名进行测试发现打开之后访问的页面不是自己博客的页面</p><p>发现访问的是<code>main</code>分支，打开<code>Settings</code>找到<code>Branches</code>把<code>master</code>分支设置为默认分支并删除<code>main</code>分支后可以正常访问</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/qq_38225558/article/details/95026111">使用Hexo搭建个人博客并部署到GitHub或码云上全过程</a></p><p><a href="https://segmentfault.com/a/1190000023662389">部署在GitHub的个人博客如何绑定个人域名</a></p><p><a href="https://io-oi.me/tech/hexo-next-optimization/#%E5%BF%85%E8%AF%BB-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2">打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化</a></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站建设 </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客部署到云服务器</title>
      <link href="/2021/03/04/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2021/03/04/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：我的国外服务器最近IP被封锁了，于是就打算把本地的服务器部署到另外的服务器上</p></blockquote><h1 id="Git安装及配置"><a href="#Git安装及配置" class="headerlink" title="Git安装及配置"></a>Git安装及配置</h1><p>使用xshell远程连接服务器后先安装git依赖的库</p><h2 id="安装依赖库及编译工具"><a href="#安装依赖库及编译工具" class="headerlink" title="安装依赖库及编译工具"></a>安装依赖库及编译工具</h2><ol><li><p>安装依赖库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>安装编译工具：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc perl-ExtUtils-MakeMaker package </span><br></pre></td></tr></table></figure></li></ol><span id="more"></span><h2 id="二、安装Git"><a href="#二、安装Git" class="headerlink" title="二、安装Git"></a>二、安装Git</h2><p>先删除系统自带的旧版本git<br>切换到root用户<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su root</span><br></pre></td></tr></table></figure></p><p>再删除旧版本git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove git</span><br></pre></td></tr></table></figure><p>安装git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>中途出现<code>Is this ok [y/d/N]:</code>时输入y回车即可</p><p>2、创建个人账户</p><p>在命令框输入（下面不做重复提示了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser ZHY</span><br></pre></td></tr></table></figure><p>3、添加个人账户权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 740 /etc/sudoers</span><br><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure><p>输入上面的命令，回车之后，进入编辑界面。</p><p>点击 I 键进入编辑模式，找到要修改的地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure><p>添加以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZHY     ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure><p>参考博客</p><p><a href="https://hjxlog.com/posts/20191130a1.html">https://hjxlog.com/posts/20191130a1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站建设 </tag>
            
            <tag> 博客部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建SSR教程</title>
      <link href="/2021/03/04/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E8%87%AA%E5%BB%BASSR%E6%95%99%E7%A8%8B/"/>
      <url>/2021/03/04/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E8%87%AA%E5%BB%BASSR%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="自建ss-ssr教程"><a href="#自建ss-ssr教程" class="headerlink" title="自建ss/ssr教程"></a>自建ss/ssr教程</h1><p><strong>如果无法查看图片，可以访问<a href="http://tr1.freeair888.club/自建ss服务器教程">http://tr1.freeair888.club/自建ss服务器教程</a></strong></p><hr><p><strong>自建ss/ssr教程很简单，整个教程分三步</strong>：</p><p>第一步：购买VPS服务器</p><p>第二步：一键部署VPS服务器</p><p>第三步：一键加速VPS服务器 （五合一的TCP网络加速脚本）</p><hr><p><strong>第一步：购买VPS服务器</strong></p><p>VPS服务器需要选择国外的，首选国际知名的vultr，速度不错、稳定且性价比高，按小时计费，能够随时开通和删除服务器，新服务器即是新ip。</p><p>vultr注册地址：<a href="https://www.vultr.com/?ref=7048874">https://www.vultr.com/?ref=7048874</a> （vps最低2.5美元/月，vultr全球17个服务器位置可选，包括日本、韩国、新加坡、洛杉矶、德国、荷兰等。支持支付宝和paypal付款。）</p><p><a href="https://www.vultr.com/?ref=7048874"><img src="https://camo.githubusercontent.com/8caba2064c271f7e6528329d9c91c4c27560606fe6362d556aa7d0103d2eac29/68747470733a2f2f7777772e76756c74722e636f6d2f6d656469612f62616e6e6572732f62616e6e65725f3732387839302e706e67" alt=""></a></p><p>虽然是英文界面，但是现在的浏览器都有网页翻译功能，鼠标点击右键，选择网页翻译即可翻译成中文。</p><p>注册并邮件激活账号，充值后即可购买服务器。充值方式是支付宝或paypal，使用paypal有银行卡（包括信用卡）即可。paypal注册地址：<a href="https://www.paypal.com/">https://www.paypal.com</a> （paypal是国际知名的第三方支付服务商，注册一下账号，绑定银行卡即可购买国外商品）</p><span id="more"></span><hr><p>2.5美元/月的服务器配置信息：单核 512M内存 10G SSD硬盘 带宽1G 500G流量/月 (<strong>不推荐，仅提供ipv6 ip，不推荐</strong>)</p><p>3.5美元/月的服务器配置信息：单核 512M内存 10G SSD硬盘 带宽1G 500G流量/月 (<strong>推荐</strong>)</p><p>5美元/月的服务器配置信息： 单核 1G内存 25G SSD硬盘 带宽1G 1000G流量/月 (<strong>推荐</strong>)</p><p>10美元/月的服务器配置信息： 单核 2G内存 55G SSD硬盘 带宽1G 2000G流量/月</p><p>20美元/月的服务器配置信息： 2cpu 4G内存 80G SSD硬盘 带宽1G 3000G流量/月</p><p>40美元/月的服务器配置信息： 4cpu 8G内存 160G SSD硬盘 带宽1G 4000G流量/月</p><p><strong>注意：2.5美元套餐只提供ipv6 ip，一般的电脑用不了，所以建议选择3.5美元及以上的套餐。</strong></p><p>vultr实际上是折算成小时来计费的，比如服务器是5美元1个月，那么每小时收费为5/30/24=0.0069美元 会自动从账号中扣费，只要保证账号有钱即可。如果你部署的服务器实测后速度不理想，你可以把它删掉（destroy），重新换个地区的服务器来部署，方便且实用。因为新的服务器就是新的ip，所以当ip被墙时这个方法很有用。当ip被墙时，为了保证新开的服务器ip和原先的ip不一样，先开新服务器，开好后再删除旧服务器即可。在账号的Billing选项里可以看到账户余额。</p><!--more--><p><strong>账号充值如图</strong>：</p><p><img src="https://camo.githubusercontent.com/512797b7fc840297c5e901d80a080788460c6b35b982b747b4ca02ef105ad92f/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f70703130302e706e67" alt=""></p><p><img src="https://camo.githubusercontent.com/1b5250d846c97d4a15c452c7fa4f67660817c1374409f68d8e3dcdaf15dbdfa0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f70703130312e706e67" alt=""></p><p><strong>开通服务器步骤如图</strong>：</p><p><img src="https://camo.githubusercontent.com/9515afc76315dee9a2c37c809e0e38cb60fc157ceafb446d2071c4b693d0cba4/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f76756c74722f76756c7472312e504e47" alt=""></p><p><img src="https://camo.githubusercontent.com/8a4052f8fba72e9e00886cf152d0f296514634efbf3aaab188f8b9085a09ec1b/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f76756c74722f76756c7472322e504e47" alt=""></p><p><img src="https://camo.githubusercontent.com/2ad7da69e453efaefe1f8ff34c37682fb7a89cb3d3275a28bb765706ff3f3b13/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f76756c74722f76756c7472332e504e47" alt=""></p><h3 id="点击图中的CentOS几个字，会弹出选项，然后选中centos6或7！-（不要选默认的centos8，脚本不支持centos8！）"><a href="#点击图中的CentOS几个字，会弹出选项，然后选中centos6或7！-（不要选默认的centos8，脚本不支持centos8！）" class="headerlink" title="点击图中的CentOS几个字，会弹出选项，然后选中centos6或7！ （不要选默认的centos8，脚本不支持centos8！）"></a>点击图中的CentOS几个字，会弹出选项，然后选中centos6或7！ （不要选默认的centos8，脚本不支持centos8！）</h3><p><img src="https://camo.githubusercontent.com/b58d21b997258d310dd8530ecad919247396e859c86b234373b1b492d4d0af3c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f76756c74722f76756c7472342e504e47" alt=""></p><p><img src="https://camo.githubusercontent.com/66ca92e4683e07fe68f1cb8edb2acea9bb414b08bbe8720e77c315d7aaee9dce/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f76756c74722f76756c7472352e504e47" alt=""></p><p><img src="https://camo.githubusercontent.com/a844f35807f29b4a4d9e798052033e80a812c009db09712ded16d34dea258414/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f76756c74722f76756c7472362e504e47" alt=""></p><p><strong>开通服务器时，当出现了ip，不要立马去ping或者用xshell去连接，再等5分钟之后，有个缓冲时间。完成购买后，找到系统的密码记下来，部署服务器时需要用到。vps系统密码获取方法如下图：</strong></p><p><img src="https://camo.githubusercontent.com/21f87c9b5604582f633fd30b7d00a59687c65ff0b764c5a7db3366cbb95b2ec8/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f6372705f75702f70616325453625393525393925453725413825384230352e706e67" alt=""></p><p><img src="https://camo.githubusercontent.com/18682cec86277948b122a9e1b71c5392f2281f671d31735495173087d2cf3452/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f6372705f75702f70616325453625393525393925453725413825384230362e706e67" alt=""></p><p><strong>删掉服务器步骤如下图</strong>：</p><p>删除服务器时，先开新的服务器后再删除旧服务器，这样可以保证新服务器的ip与旧ip不同。</p><p><img src="https://camo.githubusercontent.com/cc15ca0d3c4f2de59a63e6aefe834baa24d838617435da631b78fd5a17615519/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f73732f6465342e504e47" alt=""></p><p><img src="https://camo.githubusercontent.com/60ea7e6d8663b1074f22366392168943d5235d71a78c50025c4e27cf2ff15923/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f73732f6465322e504e47" alt=""></p><p><img src="https://camo.githubusercontent.com/555aa1c20df6c105b280c5e56a9b70914a1a37a290bec8ab1e3ad8e0c7d78323/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f73732f6465352e706e67" alt=""></p><hr><p><strong>第二步：部署VPS服务器</strong></p><p>购买服务器后，需要部署一下。因为你买的是虚拟东西，而且又远在国外，我们需要一个叫Xshell的软件来远程部署。Xshell windows版下载地址：</p><p><a href="https://tr101.free4444.xyz/Xshell_setup_wm.exe">国外云盘1下载</a> <a href="https://tr61.free4444.xyz/Xshell_setup_wm.exe">国外云盘2下载</a> <a href="https://tr71.free4444.xyz/Xshell_setup_wm.exe">国外云盘3下载</a></p><p>如果你是Mac苹果电脑操作系统，更简单，无需下载xshell，系统可以直接连接VPS。直接打开Terminal终端，输入：ssh root@43.45.43.21（将45.45.43.21换成你的IP），之后输入你的密码就可以登录了（输入密码的时候屏幕上不会有显示）</p><p><img src="https://camo.githubusercontent.com/8b4690232baa54101cc70f3d0151ab58cf9d54fae97874c55e3a1a18f6699c45/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f4d61632e706e67" alt=""></p><p>如果不能用Mac自带的终端连接的话，直接网上搜“Mac连接SSH的软件”，有很多，然后通过软件来连接vps服务器就行，具体操作方式参考windows xshell。Mac成功连接vps后剩下的操作和windows一样。</p><hr><p>部署教程：</p><p>下载windows xshell软件并安装后，打开软件</p><p><img src="https://camo.githubusercontent.com/94a8616faaa2ad7f514433fdc58690c07ff396d68dd825387bc7603ba99f3655/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f787368656c6c31312e706e67" alt="img"></p><p>选择文件，新建</p><p><img src="https://camo.githubusercontent.com/09e7281a5e514313d1ced5fe9d46a255353ddedefebd1bc10a8ee9434a719c57/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f787368656c6c31322e706e67" alt="img"></p><p>随便取个名字，然后把你的服务器ip填上</p><p><img src="https://camo.githubusercontent.com/381e03d70eb46a2c5dc636ee71ed0db85ecdaee7d51a02528b29a8af66b35509/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f787368656c6c31332e706e67" alt="img"></p><p>连接国外ip即服务器时，软件会先后提醒你输入用户名和密码，用户名默认都是root，密码是你购买的服务器系统的密码。</p><p><strong>如果xshell连不上服务器，没有弹出让你输入用户名和密码的输入框，表明你开到的ip是一个被墙的ip，遇到这种情况，重新开新的服务器，直到能用xshell连上为止，耐心点哦！如果同一个地区开了多台服务器还是不行的话，可以换其它地区。</strong></p><p><img src="https://camo.githubusercontent.com/fd2deccd9cb508d537446c43b91f746bcaf4c27cb72d6cd6abc8b1bfe3302146/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f787368656c6c31342e706e67" alt="img"></p><p><img src="https://camo.githubusercontent.com/b4a1ccb8ef6c89490d294861a9b025df1ed2a3b90836117fa47dc784ef4169e3/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f73732f787368656c6c322e706e67" alt="img"></p><p>连接成功后，会出现如上图所示，之后就可以复制粘贴代码部署了。</p><p><strong>CentOS 6和7/Debian6+/Ubuntu14+ ShadowsocksR/Shadowsocks一键部署管理脚本：</strong></p><p><strong>脚本一(SSR)，安装完成后，快捷管理命令：bash ssr.sh</strong></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure><hr><p><strong>脚本二（SS）</strong></p><p><strong>脚本二没有单独做图文教程，参考脚本一的图文说明摸索下就会了。安装完成后，快捷管理命令：bash ss-go.sh</strong></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubiBackup/doubi/master/ss-go.sh &amp;&amp; chmod +x ss-go.sh &amp;&amp; bash ss-go.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><strong>脚本三（SSR多用户管理脚本）</strong></p><p><strong>脚本三没有单独做图文教程，参考脚本一的图文说明摸索下就会了。安装完成后，快捷管理命令：bash ssrmu.sh 所有用户流量清零命令: bash ssrmu.sh clearall</strong></p><hr><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubiBackup/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh</span><br></pre></td></tr></table></figure></h2><blockquote><p>如果提示 wget: command not found 的错误，这是你的系统精简的太干净了，wget都没有安装，所以需要安装wget。CentOS系统安装wget命令: yum install -y wget Debian/Ubuntu系统安装wget命令:apt-get install -y wget</p></blockquote><hr><p>复制上面的<strong>脚本一代码</strong>到VPS服务器里，复制代码用鼠标右键的复制（整个代码一起复制，而不是分段哦！），然后在vps里面右键粘贴进去，因为ctrl+c和ctrl+v无效。接着按回车键，脚本会自动安装，以后只需要运行这个快捷命令就可以出现下图的界面进行设置，快捷管理命令为：bash ssr.sh</p><p><img src="https://camo.githubusercontent.com/74a61877f22fa65efa57b54d182d9b4231493d6e229e2bbb26e6417029fe6c28/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f73732f382e706e67" alt="img"></p><p>如上图出现管理界面后，<strong>输入数字1来安装SSR服务端</strong>。如果输入1后不能进入下一步，那么请退出xshell，重新连接vps服务器，然后输入快捷管理命令bash ssr.sh 再尝试。</p><p><img src="https://camo.githubusercontent.com/9b03e6f675fbc2bac38e97f8b76aae0b96c2cf93bd2e394f2c9d58d560eb0311/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f64656d6f2f33312e706e67" alt="img"></p><p>根据上图提示，依次输入自己想设置的<strong>端口和密码</strong> (<strong>密码建议用复杂点的字母组合，端口号为40-65535之间的数字</strong>)，回车键用于确认</p><p>注：关于端口的设置，总的网络总端口有6万多个，理论上可以任意设置，但不要以0开头！但是有的地区需要设置特殊的端口才有效，一些特殊的端口比如80、143、443、1433、3306、3389、8080。</p><p><img src="https://camo.githubusercontent.com/27880ffcd56cf87b7cf1309110e5777dd7e41642beb58b774062fc9d894e7f52/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f64656d6f2f33322e706e67" alt="img"></p><p>如上图，选择想设置的<strong>加密方式</strong>，比如10，按回车键确认</p><p>接下来是选择<strong>协议插件</strong>，如下图：</p><p><img src="https://camo.githubusercontent.com/b165dfc754bd8627550b36c17a048ac94284a28b08a42020eb0e5d50b86a69ba/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f73732f31312e706e67" alt="img"></p><p><img src="https://camo.githubusercontent.com/ad320b6dc25699280c386d0cb42c1fb727f9cbb1e0bb8b61fc19a4d7629f05c7/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f64656d6f2f34312e504e47" alt="img"></p><p>选择并确认后，会出现上图的界面，提示你是否选择兼容原版，这里的原版指的是SS客户端（SS客户端没有协议和混淆的选项），可以根据需求进行选择，演示选择y</p><p>之后进行混淆插件的设置。</p><p><strong>注意：如果协议是origin，那么混淆也必须是plain；如果协议不是origin，那么混淆可以是任意的。有的地区需要把混淆设置成plain才好用。因为混淆不总是有效果，要看各地区的策略，有时候不混淆（plain）或者（origin和plain一起使用），让其看起来像随机数据更好。（特别注意：tls 1.2_ticket_auth容易受到干扰！请选择除tls开头以外的其它混淆！！！）</strong></p><p><img src="https://camo.githubusercontent.com/1375917c57f5bd2242431cb6bc2366e52ea7770548214ab887bc153b8a74aa83/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f64656d6f2f33332e706e67" alt="img"></p><p>进行混淆插件的设置后，会依次提示你对设备数、单线程限速和端口总限速进行设置，默认值是不进行限制，个人使用的话，选择默认即可，即直接敲回车键。</p><p>注意：关于限制设备数，这个协议必须是非原版且不兼容原版才有效，也就是必须使用SSR协议的情况下，才有效！</p><p><img src="https://camo.githubusercontent.com/51a16d7b1e91a8525d2212c81e50607cdd2c8f7e056dde0e0f3a1ee5ee0aacc3/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f73732f31342e706e67" alt="img"></p><p>之后代码就正式自动部署了，到下图所示的位置，提示你下载文件，输入：y</p><p><img src="https://camo.githubusercontent.com/60aed25a115a5932c1e3a85e1c5d70b9337356c61c2ace26653a9f660354227b/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f73732f31352e706e67" alt="img"></p><p>耐心等待一会，出现下面的界面即部署完成：</p><p><img src="https://camo.githubusercontent.com/5acc4e0da95115d7aac45a56b00b42f3ecfa8c39a8bb486123ff3fb920cb4c69/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f73732f31362e706e67" alt="img"></p><p><img src="https://camo.githubusercontent.com/75fe024be2624866eb23a8520be8d9c703d22948a92441717034c1ab93e51f98/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f64656d6f2f33342e706e67" alt="img"></p><p>根据上图就可以看到自己设置的SSR账号信息，包括IP、端口、密码、加密方式、协议插件、混淆插件，这些信息需要填入你的SSR客户端。提醒一下：二维码链接地址由于域名失效不可用，所以部署好的账号需要自己在客户端里面手动填写信息。</p><p>如果之后想修改账号信息，直接输入快捷管理命令：bash ssr.sh 进入管理界面，选择相应的数字来进行一键修改。例如：</p><p><img src="https://camo.githubusercontent.com/08274855140e8d2feabfdfa5ef4e9dbce1f731e2154eb4e8e59eeb59d7b58cb1/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f73732f32322e706e67" alt="img"></p><p><img src="https://camo.githubusercontent.com/137c8539ef43bd97a3c35faf339930b4bac10231f432ea9e4c719751ca8aebfe/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f73732f32332e706e67" alt="img"></p><p><strong>脚本演示结束。</strong></p><p>此脚本是开机自动启动，部署一次即可。最后可以重启服务器确保部署生效（一般情况不重启也可以）。重启需要在命令栏里输入reboot ，输入命令后稍微等待一会服务器就会自动重启，一般重启过程需要2～5分钟，重启过程中Xshell会自动断开连接，等VPS重启好后才可以用Xshell软件进行连接。如果部署过程中卡在某个位置超过10分钟，可以用xshell软件断开，然后重新连接你的ip，再复制代码进行部署。</p><p><strong>注意：如果创建的是centos7的服务器，需要使用命令关闭防火墙，否则无法使用代理。CentOS 7.0默认使用的是firewall作为防火墙。</strong></p><p>查看防火墙状态命令：<code>firewall-cmd --state</code></p><p>停止firewall命令：<code>systemctl stop firewalld.service</code></p><p>禁止firewall开机启动命令：<code>systemctl disable firewalld.service</code></p><hr><p><strong>第三步：一键加速VPS服务器</strong></p><p>五合一的TCP网络加速脚本，包括了BBR原版、BBR魔改版、暴力BBR魔改版、BBR plus（首选）、Lotsever(锐速)安装脚本。可用于KVMXen架构，不兼容OpenVZ（OVZ）。支持Centos 6+ / Debian 7+ / Ubuntu 14+，BBR魔改版不支持Debian 8。</p><hr><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;</span><br><span class="line"></span><br><span class="line">chmod +x tcp.sh</span><br><span class="line"></span><br><span class="line">./tcp.sh</span><br></pre></td></tr></table></figure></h2><blockquote><p>如果提示 wget: command not found 的错误，这是你的系统精简的太干净了，wget都没有安装，所以需要安装wget。CentOS系统安装wget命令: yum install -y wget Debian/Ubuntu系统安装wget命令:apt-get install -y wget</p></blockquote><p>安装完成后，脚本管理命令为：./tcp.sh</p><p><img src="https://camo.githubusercontent.com/e6d49f52edd130193d5f52e1da0ca2052ab56fa0091b04531645b38246f31459/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f76756c74722f6e6577626272312e6a7067" alt="img"></p><p>操作方法：先安装内核，重启vps让内核生效，再启动对应的加速即可。数字1的BBR/BBR魔改内核对应数字4、5、6的BBR加速、BBR魔改加速和暴力BBR魔改版加速。数字2的BBRplus内核对应数字7的BBRplus加速。数字3的锐速加速内核对应数字8的锐速加速。</p><p>以安装暴力BBR魔改版加速为例，我们先安装对应的内核，输入数字1</p><p><img src="https://camo.githubusercontent.com/11855b550bfe50040f9febedcc7f6aa4ec20c5e88eab90a9b7b7f6b78a276a8a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f76756c74722f6e6577626272322e6a7067" alt="img"></p><p>内核安装完成后，输入y进行重启，重启才能让内核生效</p><p><img src="https://camo.githubusercontent.com/ff9e008ca6061d92eecf3eb55f00d8aebfa85301a759318ac8dc4a447fef97d1/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f76756c74722f6e6577626272332e6a7067" alt="img"></p><p>重启完成后，输入数字6来启动暴力BBR魔改版加速</p><p><img src="https://camo.githubusercontent.com/fdb4ed21c5db3b5344d0f631a98e317b5cf60ab2aa3b3d73f6192a3473fb0091/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f76756c74722f6e6577626272342e6a7067" alt="img"></p><p><img src="https://camo.githubusercontent.com/55f3bfacee04be5c21cc15e5b6c1772ea34d56e1668354b801026765b5c29f16/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f76756c74722f6e6577626272352e6a7067" alt="img"></p><p>输入./tcp.sh查看最终是否启动成功。</p><p>如果想换一个加速，输入数字9进行卸载加速，然后进行同样的操作，安装内核再安装对应内核的加速即可。</p><p><strong>注意：如果在安装内核环节出现这样一张图，注意选择NO</strong></p><p><img src="https://camo.githubusercontent.com/11e23104c37a2bf3ef44bab2af125c6de46c118200f6d6b3fe45ee91e52b1baf/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f706163322f76756c74722f6e6577626272362e6a7067" alt="img"></p><hr><p>【SSR客户端下载】</p><p>第一次电脑系统使用SSR/SS客户端时，如果提示你需要安装NET Framework 4.0，网上搜一下这个东西，安装一下即可。NET Framework 4.0是SSR/SS的运行库，没有这个SSR/SS客户端无法正常运行。有的电脑系统可能会自带NET Framework 4.0。</p><p>Windows SSR客户端 <a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases">下载地址</a></p><p>Windows SS客户端 <a href="https://github.com/shadowsocks/shadowsocks-windows/releases">下载地址</a></p><p>Mac SSR客户端 <a href="https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases">下载地址</a></p><p><a href="https://github.com/the0demiurge/CharlesScripts/blob/master/charles/bin/ssr">Linux客户端一键安装配置使用脚本</a> (使用方法见注释)</p><p>安卓SSR客户端 <a href="https://github.com/shadowsocksr-backup/shadowsocksr-android/releases/download/3.4.0.8/shadowsocksr-release.apk">下载地址</a></p><p>iOS：<a href="https://github.com/Alvin9999/new-pac/wiki/苹果手机翻墙软件">没有美区AppleID的翻墙教程</a> <a href="https://github.com/Alvin9999/new-pac/wiki/iOS注册美区Apple-ID教程">iOS注册美区Apple ID教程</a></p><p><a href="http://www.mediafire.com/folder/sfqz8bmodqdx5/shadowsocks相关客户端">全平台SS/SSR客户端下载汇总</a></p><hr><p><strong>有了账号后，打开SSR客户端，填上信息，这里以windows版的SSR客户端为例子</strong>：</p><p><img src="https://camo.githubusercontent.com/7d2a9a9257b3ae7d21dd3f03537dd6da3be6ad74464114abf0b341465b21bf35/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f64656d6f2f34322e504e47" alt="img"></p><p>在对应的位置，填上服务器ip、服务器端口、密码、加密方式、协议和混淆，最后将浏览器的代理设置为（http）127.0.0.1和1080即可。账号的端口号就是你自己设置的，而要上网的浏览器的端口号是1080，固定的，谷歌浏览器可以通过 SwitchyOmega 插件来设置。</p><p>下载插件：<a href="https://github.com/atrandys/trojan/releases/download/1.0.0/SwitchyOmega_Chromium.crx">switchyomega</a></p><p>安装插件，打开chrome，打开扩展程序，将下载的插件拖动到扩展程序页面，添加到扩展。 <img src="https://user-images.githubusercontent.com/12132898/70548725-0461d000-1bae-11ea-9d1e-4577e36ac46e.png" alt="20181116000534"></p><p>完成添加，会跳转到switchyomega页面，点跳过教程，然后点击proxy，如图填写，最后点击应用选项。</p><p><img src="https://camo.githubusercontent.com/589c30b98af69729b6eef30b83f835d84040662cb65002d03b243400186681da/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f64656d6f2f7373726b7a2e504e47" alt="img"></p><p>启动SSR客户端后，右键SSR客户端图标，选择第一个“系统代理模式”，里面有3个子选项，选择”全局模式“，之后就可以用浏览器设置好了的代理模式（http）127.0.0.1和1080翻墙，此模式下所有的网站都会走SSR代理。</p><p><img src="https://user-images.githubusercontent.com/12132898/32225069-cfe6195a-be7e-11e7-99e0-e2fa98f93b1f.png" alt="ssr9000"></p><hr><p><strong>常见问题及解决方法</strong>：</p><p><strong>1、搭建的账号之前能用，突然不能用了，怎么解决？</strong></p><p><strong>如果ip不能ping通，xshell不能直接连接vps服务器，说明ip被墙了，需要换ip。</strong></p><p><strong>如果ip能ping，xshell能直接连接vps服务器，说明ip没有被墙，多半是端口被封了，优先换端口。协议和混淆推荐用origin和plain。最近RC4加密方式表现较好。</strong></p><p><strong>vultr开通和删除服务器非常方便，新服务器即新ip，为了保证开通的新服务器ip和旧ip不一样，先开新服务器出现ip后再删旧服务器。其它大多数vps服务商换ip都要额为收费。</strong></p><p>2、有的地区需要把混淆参数设置成plain才好用。因为混淆不总是有效果，要看各地区的策略，有时候不混淆（plain）让其看起来像随机数据更好。</p><p>3、电脑能用但手机用不了？</p><p>如果你的手机用的是SS客户端，SS客户端没有填协议和混淆的地方，如果你部署的协议和混淆的时候没有选择兼容原版（SS版），因此手机是用不了的。这个时候你把协议弄成兼容原版、混淆也设置成兼容原版即可。或者直接将协议设置成origin且混淆设置成plain。</p><p>4、vps的服务器操作系统不要用的太高，太高可能会因为系统的防火墙问题导致搭建的SSR账号连不上。如果某个系统不好用，可以选择其它的系统来尝试。</p><p>5、vultr服务商提供的vps服务器是单向流量计算，有的vps服务商是双向流量计算，单向流量计算对于用户来说更实惠。因为我们是在vps服务器上部署SSR服务端后，再用SSR客户端翻墙，所以SSR服务端就相当于中转，比如我们看一个视频，必然会产生流量，假如消耗流量80M，那么VPS服务器会产生上传80M和下载80M流量，vultr服务商只计算单向的80M流量。如果是双向计算流量，那么会计算为160M流量。</p><p>6、如果你想把搭建的账号给多人使用，不用额外设置端口，因为一个账号就可以多人使用。一般5美元的服务器可以同时支持几十人在线使用。</p><p>如果想实现支持每个用户(端口)不同的加密方式/协议/混淆等，并且管理流量使用，可以参考多用户配置脚本：wget -N —no-check-certificate <a href="https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh">https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh</a> &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 安装后管理命令为：bash ssrmu.sh</p><p>注意：这个多用户配置脚本和教程内容的脚本无法共存！要想用这个脚本，把之前的脚本卸载，输入管理命令bash ssr.sh ，选择3，卸载ShadowsocksR即可卸载原脚本。</p><p>7、vultr服务器每月有流量限制，超过限制后服务器不会被停止运行，但是超出的流量会被额外收费。北美和西欧地区的服务器超出流量后，多出的部分收费为0.01美元/G。新加坡和日本东京（日本）为0.025美元/G，悉尼（澳大利亚）为0.05美元/G。把vultr服务器删掉，开通新的服务器，流量会从0开始重新计算。</p><p>8、vultr怎样才能申请退款呢？</p><p>vultr和其他的国外商家一样，都是使用工单的形式与客服联系，如果需要退款，直接在后台点击support，选择open ticket新开一个工单，选择billing question财务问题，简单的在文本框输入你的退款理由。比如：Please refund all the balance in my account。工单提交以后一般很快就可以给你确认退款，若干个工作日后就会退回你的支付方式。（全额退款结束后，账号可能会被删除）</p><p>如果英语水平不好，但是想和客服进行交流，可以用百度在线翻译，自动中文转英文和英文转中文。</p><p>9、路由器也可以配置ss/ssr账号，详见openwrt-ssr项目地址：<a href="https://github.com/ywb94/openwrt-ssr">https://github.com/ywb94/openwrt-ssr</a></p><p>10、如果电脑想用搭建的ss/ssr账号玩游戏，即实现类似VPN全局代理，可以用SSTAP，具体方法可以网上搜索。</p><p>11、配置bbr加速脚本，重启电脑后xshell无法连接服务器。如果你遇到这样的问题，只能把服务器删除了，重新搭建个新的，可以先配置bbr加速脚本再配置ss/ssr脚本。</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSR </tag>
            
            <tag> 服务器搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>next踩坑记录——markdown-it引擎渲染导致标题TOC错误</title>
      <link href="/2021/03/03/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-next%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94markdown-it%E5%BC%95%E6%93%8E%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E6%A0%87%E9%A2%98TOC%E9%94%99%E8%AF%AF/"/>
      <url>/2021/03/03/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-next%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94markdown-it%E5%BC%95%E6%93%8E%E6%B8%B2%E6%9F%93%E5%AF%BC%E8%87%B4%E6%A0%87%E9%A2%98TOC%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言： 博主为了使用emoji🎃将next主题自带的markdown渲染引擎改成了markdown-it渲染引擎，但是导致了文章左侧的目录的跳转功能出现了错误</p><h1 id="TOC定向错误"><a href="#TOC定向错误" class="headerlink" title="TOC定向错误"></a>TOC定向错误</h1></blockquote><p>分析原因： 经过排查，发现原本会被编译为<code>h2 id=&quot;title&quot;&gt;title&lt;/h2&gt;</code>的代码</p><p>现在会被编译为<code>&lt;h2&gt;&lt;span id=&quot;title&quot;&gt;title&lt;/span&gt;&lt;/h2&gt;</code></p><p>因此导致了在hexo生成TOC时，标题的元素的id未定义，以上变更是由于hexo-toc变更导致的</p><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>进入根目录下<code>node_modules\hexo-toc\lib\filter.js</code>脚本将28-31行修改为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$title.<span class="title function_">attr</span>(<span class="string">&#x27;id&#x27;</span>, id);</span><br><span class="line"><span class="comment">// $title.children(&#x27;a&#x27;).remove();</span></span><br><span class="line"><span class="comment">// $title.html( &#x27;&lt;span id=&quot;&#x27; + id + &#x27;&quot;&gt;&#x27; + $title.html() + &#x27;&lt;/span&gt;&#x27; );</span></span><br><span class="line"><span class="comment">// $title.removeAttr(&#x27;id&#x27;);</span></span><br></pre></td></tr></table></figure><p>但是我的hexo中并没有找到这个目录</p><p>所以我找了另外的</p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><span id="more"></span><p>首先安装<code>markdown-it-named-headings</code>插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install markdown-it-named-headings --save</span><br></pre></td></tr></table></figure><p>然后进入你项目的根目录，修改根目录下 <code>node_modules\hexo-renderer-markdown-it\lib\renderer.js</code> 文件，在 <code>renderer.js</code> 中添加一行以使用此插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.<span class="title function_">use</span>(<span class="built_in">require</span>(<span class="string">&#x27;markdown-it-named-headings&#x27;</span>))</span><br></pre></td></tr></table></figure><p>尝试以上两种方法，均未成功</p><p>时间不早了，后面有时间再解决</p><blockquote><p>参考文章:</p><p><a href="https://convivae.top/posts/hexo-bo-ke-cai-keng/#%E6%96%B9%E6%B3%95-2">Hexo 博客踩坑</a>  <a href="https://github.com/hexojs/hexo-renderer-markdown-it/issues/40">Cannot render headings with ids?</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站建设 </tag>
            
            <tag> 个人博客 </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>next主题美化——背景图片、动画</title>
      <link href="/2021/02/21/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
      <url>/2021/02/21/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：NexT 主题本身是没有背景图片的，显得有点单调，博主觉得没有背景图片显得我的博客很丑，于是就想添加一个背景图片</p><p>next版本：8.2.1</p></blockquote><h1 id="添加背景图片"><a href="#添加背景图片" class="headerlink" title="添加背景图片"></a>添加背景图片</h1><p>把想设置的背景放入<code>./themes/next/source/images</code>中，命名为<code>background.jpg</code>。在根目录的<code>source</code>文件夹下新建文件夹<code>_data</code>与style文件<code>source/_data/styles.styl</code>，输入以下代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">     <span class="attribute">background</span>:<span class="built_in">url</span>(/images/background.jpg);</span><br><span class="line">     <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed;</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>background:url</code>为图片路径，也可以直接使用链接。<br><code>background-repeat</code>：若果背景图片不能全屏，那么是否平铺显示，充满屏幕<br><code>background-attachment</code>：背景是否随着网页上下滚动而滚动，fixed为固定<br><code>background-position</code>：图片展示大小这里设置 100%，100% 的意义为：如果背景图片不能全屏，那么是否通过拉伸的方式将背景强制拉伸至全屏显示。</p><p>再在主题<code>_config.yml</code>文件中找到对应的<code>custom_file_path</code></p><span id="more"></span><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="comment">#style: source/_data/styles.styl</span></span><br></pre></td></tr></table></figure><p>再将对应的#去除就可以了</p><h1 id="博客内容透明化"><a href="#博客内容透明化" class="headerlink" title="博客内容透明化"></a>博客内容透明化</h1><p>NexT 主题的博客文章均是不透明的，这样读者就不能好好欣赏背景图片了，在上文中新建的<code>style.styl</code>文件中可以使博客内容透明化：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//博客内容透明化</span></span><br><span class="line"><span class="comment">//文章内容的透明度设置</span></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-inner</span> &#123; </span><br><span class="line">   <span class="comment">// margin-top: 60px;</span></span><br><span class="line">   <span class="comment">// padding: 60px 60px 60px 60px;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单栏的透明度设置</span></span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索框（local-search）的透明度设置</span></span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新：上述做法会导致字体透明度也被改变，很不优雅，解决方案：</p><p>删除<code>.main-inner</code>中的<code>opacity</code>选项，在上述代码后添加如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">post</span>-block &#123;</span><br><span class="line">    <span class="attr">background</span>: <span class="title function_">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.7</span>) none repeat scroll !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，此时的侧边栏头像及站点概览等透明度也被改变了，需要将</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line">.<span class="property">sidebar</span> &#123;</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">sidebar</span>-inner &#123;</span><br><span class="line">  <span class="attr">background</span>: <span class="title function_">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.7</span>) none repeat scroll !important;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>（这个设置就不会改变侧边栏中头像等的透明度了，其它的欢迎自行探索）</p><h2 id="评论区透明度"><a href="#评论区透明度" class="headerlink" title="评论区透明度"></a>评论区透明度</h2><p>在上述代码后添加以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">comments</span> &#123;</span><br><span class="line">    <span class="attr">background</span>: <span class="title function_">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.7</span>) none repeat scroll !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加圆角"><a href="#添加圆角" class="headerlink" title="添加圆角"></a>添加圆角</h1><p>在<code>source/_data/variables.styl</code>中输入以下代码，注意，<code>$</code>并不是多余的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line"><span class="variable">$border</span>-radius-inner     = <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="variable">$border</span>-radius           = <span class="number">20px</span>;</span><br></pre></td></tr></table></figure><p>然后在 NexT 的配置文件 <code>_config.next.yml</code> 中取消 <code>variables.styl</code> 的注释：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  variable: source/_data/variables.styl</span><br></pre></td></tr></table></figure><h1 id="添加阴影效果"><a href="#添加阴影效果" class="headerlink" title="添加阴影效果"></a>添加阴影效果</h1><p>在<code>source/_data/style.styl</code>文件中添加如下代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 主页文章添加阴影效果</span></span><br><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">   -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">120</span>, <span class="number">128</span>, <span class="number">114</span>, <span class="number">1.5</span>);</span><br><span class="line">   -moz-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><p>在主题<code>_config.yml</code>文件中搜索motion，可更改动画效果，参考配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use Animate.css to animate everything.</span></span><br><span class="line"><span class="comment"># Use velocity to animate everything.</span></span><br><span class="line"><span class="attr">motion:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">async:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="comment"># Transition variants:</span></span><br><span class="line">    <span class="comment"># fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut</span></span><br><span class="line">    <span class="comment"># swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut</span></span><br><span class="line">    <span class="comment"># bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut</span></span><br><span class="line">    <span class="comment"># slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut</span></span><br><span class="line">    <span class="comment"># slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut</span></span><br><span class="line">    <span class="comment"># perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut</span></span><br><span class="line">    <span class="attr">post_block:</span> <span class="string">fadeIn</span></span><br><span class="line">    <span class="attr">post_header:</span> <span class="string">slideDownIn</span></span><br><span class="line">    <span class="attr">post_body:</span> <span class="string">slideDownIn</span></span><br><span class="line">    <span class="attr">coll_header:</span> <span class="string">slideLeftIn</span></span><br><span class="line">    <span class="comment"># Only for Pisces | Gemini.</span></span><br><span class="line">    <span class="attr">sidebar:</span> <span class="string">slideDownBigOut</span></span><br></pre></td></tr></table></figure><h2 id="动画的持续速度"><a href="#动画的持续速度" class="headerlink" title="动画的持续速度"></a>动画的持续速度</h2><p>在主题的<code>/source/js</code>文件夹下可找到<code>motion.js</code>文件，搜索duration可更改持续时间</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 个人博客 </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>next主题中超链接颜色的修改</title>
      <link href="/2021/02/21/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-next%E4%B8%BB%E9%A2%98%E4%B8%AD%E8%B6%85%E9%93%BE%E6%8E%A5%E9%A2%9C%E8%89%B2%E7%9A%84%E4%BF%AE%E6%94%B9/"/>
      <url>/2021/02/21/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-next%E4%B8%BB%E9%A2%98%E4%B8%AD%E8%B6%85%E9%93%BE%E6%8E%A5%E9%A2%9C%E8%89%B2%E7%9A%84%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="修改超链接样式"><a href="#修改超链接样式" class="headerlink" title="修改超链接样式"></a>修改超链接样式</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Next主题自带的超链接样式仅仅是将超链接的文字添加了下划线且文字颜色仍未改变，显示效果很差且不明显翻了很多博客发现都让在<code>./themes/next/source/css/_custom/custom.styl</code>文件中添加新的超链接CSS样式，但是我使用的Next主题的文件夹中并没有发现这个文件夹🤷，查阅Next的<a href="https://github.com/next-theme/hexo-theme-next/issues/4">更新说明</a>后发现next已经在7.3.0版本中就已经移除了这个文件，而我的Next主题为8.2.1版本，所以根本不可能有这个文件。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>主题样式是在<code>\hexoBlog\themes\next\source\css</code>,这里面保存了Muse,Mist和Pisces三个主题的css文件,例如,字体的边框的颜色还有字体图片的大小等就保存在<code>next\source\css\_variables</code>里.<br>而我要修改的body超链接的样式在<code>themes\next\source\css\_common\components\post\post-body.styl</code>里,在这里添加条目:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;  </span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#428BCA</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>这样就可以把超链接的样式改为蓝色，粗体</del></p><span id="more"></span><p>然鹅并没有完全成功😠，虽然我们已经成功将超链接颜色修改了，但是阅读全文按钮也被修改成了蓝色加粗，淦，这怎么行，参考别人的代码思考了一下之后魔改了一下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:not</span>(.btn)&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f89fa0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="selector-pseudo">&amp;:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ff7a7a</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>成功将<a href="https://snowmoon.top/2021/02/21/next%E4%B8%BB%E9%A2%98%E4%B8%AD%E8%B6%85%E9%93%BE%E6%8E%A5%E9%A2%9C%E8%89%B2%E7%9A%84%E4%BF%AE%E6%94%B9/">超链接样式</a>修改而不修改阅读全文的按钮🤪</p><p>然鹅，在本地localhost:4000看着实现得好好的功能，部署上线服务器之后就完全没有效果。。。此问题。。。超出了我的知识能力范围，，，尚未解决😭</p><p>睡一觉起来它就好了。。。真是玄学:full_moon_with_face:</p><blockquote><p>PS:可能原因猜测：服务器的同步速度较慢，在deploy之后还尚未更新完</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 个人博客 </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo踩坑记录</title>
      <link href="/2021/02/21/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-hexo%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/02/21/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-hexo%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：本文为我在使用hexo开发个人博客时的踩坑记录，帮助大家解决一些我遇到的坑<br>hexo版本：hexo: 5.3.0<br>hexo-cli: 4.2.0<br>os: Windows_NT 10.0.19042 win32 x64<br>Next主题版本: NexT version 8.2.1</p></blockquote><h1 id="使用了live2d时不蒜子访客统计无法显示"><a href="#使用了live2d时不蒜子访客统计无法显示" class="headerlink" title="使用了live2d时不蒜子访客统计无法显示"></a>使用了live2d时不蒜子访客统计无法显示</h1><p>我使用的不蒜子进行字数统计，但是在启用了live2d时发现在文章底部的字数统计居然特喵的消失了，搜索了hexo的<a href="https://github.com/next-theme/hexo-theme-next/issues/4">更新说明</a>后发现他给的解决方案居然是很扯淡的不用live2d。。。这怎么能忍，我找了一波显示不蒜子统计的的脚本<code>\themes\next\layout\_partials\footer.njk</code> 代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;%- if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> Visitors</span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;site-uv&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;footer.total_visitors&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure><p>发现这个标签<code>&lt;span id=&quot;busuanzi_container_site_pv&quot; style=&quot;display: none;&quot;&gt;</code>中出现了个诡异的<code>style=&quot;display: none;</code>把它删除后，在底部的字数统计结果就又出现了。</p><span id="more"></span><p>但是在文章中的字数统计又不见了，找了半天，没有办法解决，于是我就直接关闭了不蒜子的文章访客启用了valine的visitor统计来代替不蒜子的统计功能</p><h1 id="markdown-it美元符号-无法显示的问题"><a href="#markdown-it美元符号-无法显示的问题" class="headerlink" title="markdown-it美元符号$无法显示的问题"></a>markdown-it美元符号$无法显示的问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用markdown写文章时，美元符号\$在本地能够正常显示，但上传到网站中就被渲染成了数学公式，无法正常显示，在使用了反斜杠\进行转义时也无法正常显示，查了很多资料，甚至改了markdown的渲染引擎，更改了数学公式的渲染引擎也无法显示</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>使用双反斜杠\对美元符号\$进行转义</p></li><li><p>将美元符号<script type="math/tex">`放入代码块中实现`</script>的正常显示</p></li></ol><h1 id="valine评论框中占位符无法换行的问题"><a href="#valine评论框中占位符无法换行的问题" class="headerlink" title="valine评论框中占位符无法换行的问题"></a>valine评论框中占位符无法换行的问题</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>在valine评论系统中设置默认占位符placeholder来提示评论者时无法直接在文本中进行换行，使用\n也无法换行，使用HTML的<code>&lt;br&gt;</code>标签也无法进行换行</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>输入了<code>&amp;#10</code>完成了换行</p><h1 id="字数统计后阅读时间计算参数修改"><a href="#字数统计后阅读时间计算参数修改" class="headerlink" title="字数统计后阅读时间计算参数修改"></a>字数统计后阅读时间计算参数修改</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用了<code>symbols_count_time</code>进行字数统计后发现统计的结果很离谱，中文的文章1800字阅读时间统计为1分钟，参照现有博客想修改<code>symbols_count_time</code>中的<code>awl</code>和<code>wpm</code>使计数更为准确时发现在主题的<code>_config.yml</code>中修改无效，尝试在<code>header</code>文件中修改计算词数和阅读的脚本中的<code>awl</code>和<code>wpm</code>数值无效</p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>在hexo的站点配置文件<code>_config.yml</code>中对<code>symbols_count_time</code>进行初始化的同时对直接<code>awl</code>和<code>wpm</code>进行赋值</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel学习笔记3——函数求和及常见函数</title>
      <link href="/2021/02/17/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-Excel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/"/>
      <url>/2021/02/17/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-Excel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：本文为本人学习B站向天歌出品系列视频——《Excel大神上分攻略》时的学习笔记，希望通过记录的方式强制自己将内容学会并为了方便将来遗忘而创作</p></blockquote><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>输入函数名的前几个字母后若要选择Excel联想的函数需使用小键盘的箭头，然后使用TAB键来选择联想的函数</li></ul><h3 id="相对引用与绝对引用"><a href="#相对引用与绝对引用" class="headerlink" title="相对引用与绝对引用"></a>相对引用与绝对引用</h3><p>  使用<script type="math/tex">`可进行绝对引用，`</script>位于列前则将列进行绝对引用，行前将行绝对引用</p><p><strong>例：</strong><code>$A$2</code>表示只使用A2这个单元格，<code>$A2</code>表示使用A列，但对应的行则使用相对的行，<code>A$2</code>表示使用第二行，对应的行根据相对关系使用</p><p><strong>PS：按下F4可以切换引用的模式</strong></p><h2 id="求和函数"><a href="#求和函数" class="headerlink" title="求和函数"></a>求和函数</h2><p><strong>快速求和</strong>：Alt + = 会直接智能地将求和结果放到选中区域或智能将列区域求和放到列的下方</p><p><strong>定位求和</strong>：Ctrl + G定位空值后进行求和</p><p><strong>合并单元格的求和</strong>：将合计栏选中，在第一格中输入sum(要求和的目标栏第一格:最后一格）-sum(合计栏单元格第二格：最后一格)</p><p><strong>多表求和</strong>：</p><ol><li>输入SUM后选择要求和的目标表格的目标单元格，选择的每个单元格使用英文逗号隔开</li></ol><span id="more"></span><ol><li><p>或者输入SUM后先按住Shift选中要求和的表格，再选择要求和的目标单元格</p></li><li><p>合并计算：数据-合并计算-引用位置-选择好每个表格的数据的位置后点击添加，记得将标签的首行和最左列选中然后进行合并计算</p></li></ol><p><strong>条件求和：</strong> </p><ol><li>SUMIF函数（条件区域，条件，求和区域）</li></ol><ul><li><p>条件注意要加上引号，区域绝对引用</p><ul><li>可用通配符查找：”*“</li><li>条件的目标是中文则需要用英文引号引住</li><li>更好用的方法是将条件(即要求的目标)做成新单元格后当做条件来求和</li></ul></li></ul><ol><li><p>SUMIFS函数</p><p>（求和区域，条件区域1，条件1，条件区域2，条件2，……）</p></li></ol><ul><li>这个函数能使用更多的条件，上一个函数只能使用一个条件</li></ul><ol><li><p>SUMPRODUCT函数</p><p>①求乘积（区域1，区域2，区域3，……）</p></li></ol><ul><li><p>每个区域大小一致</p><p>②多条件求和</p><p>（条件1*条件2*……*条件n*求和区域）</p></li><li><p>区域不能采取整列引用，比如A：A</p></li><li><p>公式拖拽填充时，要考虑绝对引用</p></li></ul><div class="table-container"><table><thead><tr><th>SUBTOTAL函数</th><th></th><th style="text-align:center"></th></tr></thead><tbody><tr><td>包含隐藏值</td><td>不包含隐藏值</td><td style="text-align:center">作用</td></tr><tr><td>1</td><td>101</td><td style="text-align:center">平均值</td></tr><tr><td>2</td><td>102</td><td style="text-align:center">非空数值计算</td></tr><tr><td>3</td><td>103</td><td style="text-align:center">非空单元格计数</td></tr><tr><td>4</td><td>104</td><td style="text-align:center">最大值</td></tr><tr><td>5</td><td>105</td><td style="text-align:center">最小值</td></tr><tr><td>6</td><td>106</td><td style="text-align:center">乘积</td></tr><tr><td>7</td><td>107</td><td style="text-align:center">标准偏差</td></tr><tr><td>8</td><td>108</td><td style="text-align:center">总体标准偏差</td></tr><tr><td>9</td><td>109</td><td style="text-align:center">求和</td></tr><tr><td>10</td><td>110</td><td style="text-align:center">方差</td></tr><tr><td>11</td><td>111</td><td style="text-align:center">总体方差</td></tr></tbody></table></div><h2 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h2><ol><li>【平均值】：<strong>AVERAGE</strong>（数字1，数字2，……，数字n）或者</li></ol><p>AVERAGE（数字区域）</p><ol><li>【条件平均值】：<strong>AVERAGEIF</strong>（条件区域，条件，求平均值区域）</li></ol><ul><li>注意绝对引用</li></ul><h2 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h2><ol><li>【最大值】：MAX（数字1，数字2，……，数字n）或者<br>MAX（数字区域）</li><li>【最小值】：MIN，参数同上<br>MAX常结合数组来使用<br>比如最新的个税公式：<br>=ROUND(MAX((A4-5000)*{0.03;0.1;0.2;0.25;0.3;0.35;0.45}-{0;210;1410;2660;4410;7160;15160},0),2)</li></ol><h2 id="四舍五入、绝对值函数"><a href="#四舍五入、绝对值函数" class="headerlink" title="四舍五入、绝对值函数"></a>四舍五入、绝对值函数</h2><ol><li>【四舍五入】：ROUND（数字，保留小数位数）<blockquote><p>1表示保留小数点后1位，0表示保留整数，-1表示保留到十位，以此类推</p></blockquote></li><li>【直接舍去】：ROUNDDOWN（数字，保留小数位数）</li><li>【向上取整】：ROUNDUP（数字，保留小数位数）</li><li>【只保留整数】：INT（数字）</li><li>【取绝对值】：ABS（数字）</li></ol><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><ol><li>【随机整数】：=RANDBETWEEN（0,100）</li><li>【0-1随机小数】：=RAND()</li><li>【n1~n2随机小数】：公式 =n1+RAND()<em>(n2-n1)<br>例如”3~50随机小数“<br>=3+RAND()</em>(50-3)<br>按F9或者有编辑操作该函数会时时刷新，选择性粘贴为数值可固定数值<h2 id="计数函数"><a href="#计数函数" class="headerlink" title="计数函数"></a>计数函数</h2></li><li>【统计数字个数】：COUNT（区域1，区域2，……）</li><li>【非空单元格数量】：COUNTA（区域1，区域2，……）</li><li>【空单元格数量】：COUNTBLANK（区域1，区域2，……）</li><li>【条件计数】COUNTIF（计数区域，计数条件）<h2 id="求余数："><a href="#求余数：" class="headerlink" title="求余数："></a>求余数：</h2>MOD（被除数，除数）<br>返回结果为余数，例如：<br>=MOD（28,5），结果为3<br>=MOD（3,5），结果仍为3<br>判断奇偶：=IF(MOD(A84,2)=0,”偶数”,”奇数”)</li></ol>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
            <tag> 办公学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel学习笔记2——定位、查找、排序、筛选</title>
      <link href="/2021/02/16/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-Excel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E5%AE%9A%E4%BD%8D%E3%80%81%E6%9F%A5%E6%89%BE%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E7%AD%9B%E9%80%89/"/>
      <url>/2021/02/16/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-Excel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E5%AE%9A%E4%BD%8D%E3%80%81%E6%9F%A5%E6%89%BE%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E7%AD%9B%E9%80%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：本文为本人学习B站向天歌出品系列视频——《Excel大神上分攻略时》的学习笔记，希望通过记录的方式强制自己将内容学会并为了方便将来遗忘而创作</p></blockquote><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h2 id="数据定位"><a href="#数据定位" class="headerlink" title="数据定位"></a>数据定位</h2><ul><li><p><strong>找出两栏中的不同数据</strong>： Ctrl + \</p></li><li><p><strong>快速调出定位功能</strong>：Ctrl + G    或    F5</p></li><li><p><strong>空值充0</strong>：定位后在一个空值格中输入0，然后Ctrl + Enter</p><blockquote><p>在做数据处理的过程中空值会无法处理，所以缺少的值一般用0填充</p></blockquote></li><li><p><strong>选中可见单元格</strong>：选中含有隐藏单元格的区域后按Alt + ;</p></li><li><p><strong>将合并的单元格分开填充（方便检索）</strong>：先选择合并后居中，再定位空格，后输入 = B2(合并后的第一格)，再按Ctrl + Enter</p></li><li><p><strong>批量删除空行</strong>：选中区域，定位空值，选择一个空行右键删除，选择整行</p></li><li><p><strong>定位不同的四个方法：</strong></p><ol><li>Ctrl + \ 定位</li></ol></li></ul><span id="more"></span><ol><li><p>开始 - 条件格式 - 突出显示单元格规则 - 重复值</p></li><li><p>函数COUNTIF</p><blockquote><p>参数有两个，第一个选中查找的单元格（能选一堆），第二个选中查找的值（只能选一个）选择完成后可以显示后值在前述单元格中的数量，若为零即没有该值</p></blockquote></li><li><p>选择性粘贴后选择减（只适用于多行且多列的情况，对比两个表格内容的差距）</p></li></ol><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><ul><li><p><strong>删除每个单元格中的换行符</strong>：查找内容为 Alt + 1 + 0（只能小键盘输入，此为换行符）替换内容不填入。</p></li><li><p><strong>精确查找与模糊查找</strong>： 查找时 ? 是单个字符的通配符，* 是多个字符的通配符<strong><em>若要进行转义则使用  ~</em></strong></p></li><li><p><strong>通过格式查找</strong>：查找 - 格式 - 从单元格选择格式然后吸取想要查找的内容即可查找</p><blockquote><p>若要进行求和等运算则需要在查找完成后在公式 - 名称管理器 -新建名称将这些内容保存为一个名称，在进行计算的时候可以直接输入名称即可</p></blockquote></li></ul><ul><li><p><strong>批量删除某个字</strong>：查找该字并替换为空值</p></li><li><p><strong>批量添加某字</strong>：在旁边的单元格处输入 = 选择原单元格 &amp; “想加入的字”，再复制后粘贴数值</p></li></ul><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="常规排序"><a href="#常规排序" class="headerlink" title="常规排序"></a>常规排序</h2><ol><li>以当前选定区域排序：只会重排当前区域</li><li>拓展的选定区域排序：以当前区域为标的，对所有区域进行重排</li></ol><ul><li><p><strong>按字符数排序</strong>：选择一列添加辅助列，然后使用LEN函数计算要排序的目标列，然后下拉后将排序的条件改为辅助列的字符数</p></li><li><p><strong>自定义排序</strong>：选择目标列排序然后自定义序列输入序列依据（王者 钻石 铂金 黄金 白银 青铜）每一个占一行，后点击排序</p></li></ul><h1 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h1><p>常规筛选逻辑和功能与查找定位十分相似，基本的通配符也是相同的 ? 和 *</p><h2 id="高级筛选"><a href="#高级筛选" class="headerlink" title="高级筛选"></a>高级筛选</h2><p>点击高级筛选，在条件单元格中输入需要的条件，同一行表示需要同时满足，非同一行则只需要满足其中之一</p><h2 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h2><p>筛选里面很好用的功能，数据验证出现了</p><p>数据验证最大的作用为限制输入的数据格式，或者制作下拉菜单</p><p>常规的限制输入格式功能很简单，基本上需要什么功能都可以通过直接看着数据验证的表格即可实现</p><p>需要用函数实现的：</p><ol><li><strong>单行中的数据限定为两种长度：</strong>选择后使用数据验证-文本长度-等于-输入以下代码。</li></ol><p><code>=OR(LEN($F2)=15,LEN($F2)=18)</code></p><blockquote><p>OR表示其中二者之一成立即可，LEN表示判断单元格字符长度，其中，LEN的参数需要自己重新选择</p></blockquote><ol><li><strong>限定输入中不能有空格：</strong>数据验证-自定义-介于-输入以下代码</li></ol><p><code>=LEN(C2)=LEN(SUBSTITUTE(C2,&quot; &quot;,&quot;&quot;))</code></p><blockquote><p>以上代码表示原单元格去除空格后长度仍然等于原单元格，即原单元格不含有空格。<br>在使用时C2需要自己重新选自自己需要的单元格 </p></blockquote><ol><li><strong>限定输入值不能重复：</strong>数据验证-自定义-介于-输入以下代码</li></ol><p><code>=COUNTIF(A:A,A2)=1</code></p><blockquote><p>其中，A:A表示在A列中，COUNTIF函数用于计算该值在A列中是否只含一个值</p></blockquote><h3 id="下拉菜单的制作"><a href="#下拉菜单的制作" class="headerlink" title="下拉菜单的制作"></a>下拉菜单的制作</h3><p><strong>单级下拉菜单</strong></p><p>数据验证-序列-介于-    男,女 </p><p>其中，每个词之间必须要用英文逗号分隔开</p><p>也可以将来源选择为自己输入的一个序列表格</p><p>若要让下拉菜单的内容随自己输入的序列表格改变，需要先选中源数据表，后按下Ctrl + T再创建序列即可</p><p><strong>二级下拉菜单</strong></p><p>用定位选择源数据，然后公式 - 根据所选内容创建 - 首行 - 确定</p><blockquote><p>该步骤的意义为使用首行 的名称创建几个Excel中的 “名称”,名称的意义与C语言中的数组的意义基本一致，此步骤创建的“名称”数组的名称即为首行对每列标注的名称，数组的内容即为各列中的内容</p></blockquote><p>在一列中使用一级下拉菜单需要选择 数据验证-序列-介于- 来源选择刚刚制作名称的表头</p><p>在第二列中使用第二级下拉菜单将来源输入为以下函数</p><p><code>=INDIRECT($A2)</code></p><p>其中，A2为使用了一级下拉菜单的那一列的对应单元格，选择的时候需要先选中，再将A与2之间的$删除</p>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
            <tag> 办公学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel学习笔记1——填充、行列操作、数据格式</title>
      <link href="/2021/02/16/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-Excel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E5%A1%AB%E5%85%85%E3%80%81%E8%A1%8C%E5%88%97%E6%93%8D%E4%BD%9C%E3%80%81%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"/>
      <url>/2021/02/16/SnowMoon%E3%81%AE%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-Excel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E5%A1%AB%E5%85%85%E3%80%81%E8%A1%8C%E5%88%97%E6%93%8D%E4%BD%9C%E3%80%81%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="行列填充"><a href="#行列填充" class="headerlink" title="行列填充"></a>行列填充</h3><ul><li><strong>序列填充</strong>：填充-等差数列 设置步长与终止值后填充</li><li><strong>填充</strong>：</li></ul><ol><li>向右：Ctrl + R</li><li>向下：Ctrl + D</li><li>在选中单元格附近悬停，出现黑色十字后双击</li><li>若要下方单元格填充与上方一样的内容则选择时候选中含有数据的单元格</li></ol><ul><li><p><strong>快速填充</strong>：Ctrl + E</p><blockquote><p>快速填充非常好用，能用来将旁边的内容中你需要的部分提取出来，或者在每行/列对应的数据组合成你想要的目标内容后放到几个目标格子中然后Ctrl + E就能快速的把附近的单元格填充好</p></blockquote></li></ul><h3 id="行列操作"><a href="#行列操作" class="headerlink" title="行列操作"></a>行列操作</h3><ul><li><strong>自动调整列宽/行高</strong>：选中整个行/列（一定要是行/列）后移动到两行/两列之间直至出现双箭头然后双击即可自动调整行列宽</li></ul><span id="more"></span><ul><li><strong>移动并复制列和行</strong>：选中后Ctrl+shift拖动列行</li><li><strong>移动</strong>：选中后按Shift拖动</li><li><strong>添加行/列</strong>：Ctrl + Shift + =</li><li><strong>删除行/列</strong>：Ctrl + -</li></ul><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ul><li><p><strong>设置数据格式的快捷键</strong>：Ctrl + 1</p><blockquote><p>文本默认是左对齐的，数字默认是右对齐的</p><p>当输入数字超过11位时，数字格式默认使用科学计数法，超过15位时，末尾默认补为0</p></blockquote></li><li><strong>将数字直接输入为文本：</strong></li></ul><ol><li>将单元格默认格式改为文本</li><li>输入时在数字前方加入一个英文的’</li><li></li></ol><ul><li><strong>数字各位补0</strong>：设置单元格格式时候选自定义格式，要用几位输入几个0，即1-&gt;0001只需要在自定义格式中输入0000</li><li><strong>在数字后方加单位</strong>：选中单元格，自定义格式，然后在同时格式后面输入”单位”，引号必须用英文的。</li><li><strong>在文本前/后统一加入特定词语</strong>：自定义格式时输入   <em>想添加的字词@</em>  即原本为   <em>好用</em>   ，设置后变为   <em>想添加的字词好用</em>   ，@为原单元格数据的通配符</li><li><strong>转换数据格式方法（万能）</strong>：选中单元格后在菜单栏 数据-分列-下一步-下一步-<em>选择好需要的目标格式</em>-完成</li></ul><ul><li><strong>将单元格设置后为能快速输入男/女等字词的格式</strong>：自定义单元格格式，输入<strong>[=1]”男”;[=0]”女”</strong></li></ul><ul><li><strong>人民币面值转大写公式：</strong></li></ul><p><code>=RIGHT(TEXT(A1*100,&quot;[DBNum2]0仟0佰0拾0万0仟0佰0拾0元0角0分&quot;),(LEN(A1*100))*2)</code></p><h4 id="常用时间代码示例"><a href="#常用时间代码示例" class="headerlink" title="常用时间代码示例"></a>常用时间代码示例</h4><div class="table-container"><table><thead><tr><th>代码1</th><th>示例1</th><th>代码2</th><th>示例3</th><th>代码4</th><th>示例5</th><th>代码6</th><th>示例7</th></tr></thead><tbody><tr><td>Y（年）</td><td>17</td><td>YY</td><td>17</td><td>YYY</td><td>2017</td><td>YYYY</td><td>2017</td></tr><tr><td>M（月）</td><td>1</td><td>MM</td><td>1</td><td>MMM</td><td>Jan</td><td>MMMM</td><td>January</td></tr><tr><td>D（日/星期）</td><td>1</td><td>DD</td><td>1</td><td>DDD</td><td>Sun</td><td>DDDD</td><td>Sunday</td></tr><tr><td>A（星期）</td><td>-</td><td>-</td><td>-</td><td>AAA</td><td>日</td><td>AAAA</td><td>星期日</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>代码</th><th>示例</th></tr></thead><tbody><tr><td>h:mm</td><td>12:34:00</td></tr><tr><td>h:mm:ss</td><td>12:34:56</td></tr><tr><td>mm:ss</td><td>10时56分00秒</td></tr><tr><td>h”时”mm”分”ss”秒”</td><td>12时34分56秒</td></tr><tr><td>yyyy/m/d h:mm</td><td>2017/1/1 12:34</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>代码符号</th><th>符号的含义和作用</th><th>通过示例来理解</th><th>备注</th><th></th></tr></thead><tbody><tr><td>自定义格式代码</td><td>原始数值</td><td>自定义格式后显示值</td><td></td><td></td></tr><tr><td>m</td><td>使用没有前导零的数字来显示月份（1～12）     使用没有前导零的数字来显示分钟（0～59）</td><td>m</td><td>2009/2/2</td><td>2</td></tr><tr><td>m</td><td>0.626793981</td><td>15:2</td><td>注意：要与h或者hh配合设置，否则单独设置m或者mm，会默认为显示为月份</td><td></td></tr><tr><td>mm</td><td>使用有前导零的数字来显示分钟（01～12）     使用有前导零的数字来显示月份（00～59）</td><td>mm</td><td>0.626793981</td><td>15:02</td></tr><tr><td>mm</td><td>2009/2/12</td><td>02</td><td></td><td></td></tr><tr><td>mmm</td><td>使用英文缩写来显示月份（Jan～Dec）</td><td>mmm</td><td>2009/2/12</td><td>Feb</td></tr><tr><td>mmmm</td><td>使用英文全称来显示月份（January～December）</td><td>mmmm</td><td>2009/2/12</td><td>February</td></tr><tr><td>mmmmm</td><td>显示月份的英文首字母（J～D）</td><td>mmmmm</td><td>2009/2/12</td><td>F</td></tr><tr><td>d</td><td>使用没有前导零的数字来显示日期（1～31）</td><td>d</td><td>2009/2/2</td><td>2</td></tr><tr><td>dd</td><td>使用有前导零的数字来显示日期（01～31）</td><td>dd</td><td>2009/2/2</td><td>02</td></tr><tr><td>ddd</td><td>使用英文缩写来显示星期几（Sun～Sat）</td><td>ddd</td><td>2009/2/12</td><td>Thu</td></tr><tr><td>dddd</td><td>使用英文全称来显示星期几（Sunday～Saturday）</td><td>dddd</td><td>2009/2/12</td><td>Thursday</td></tr><tr><td>aaa</td><td>使用中文简称显示星期几（一～日），不显示“星期”两字</td><td>aaa</td><td>2009/2/12</td><td>四</td></tr><tr><td>aaaa</td><td>使用中文全称来显示星期几（星期一～星期日）</td><td>aaaa</td><td>2009/2/12</td><td>星期四</td></tr><tr><td>y/yy</td><td>使用两位数显示年份（00～99）</td><td>y/yy</td><td>2009/2/12</td><td>09</td></tr><tr><td>yyyy</td><td>使用4位数显示年份（1900～9999）</td><td>yyyy</td><td>2009/2/12</td><td>2009</td></tr><tr><td>e</td><td>使用4位数显示年份（1900～10000）</td><td>e</td><td>2009/2/12</td><td>2009</td></tr></tbody></table></div><p><strong>常用格式</strong></p><div class="table-container"><table><thead><tr><th>格式代码</th><th>数字</th><th>TEXT(数字,格式代码)</th><th>说明</th></tr></thead><tbody><tr><td>G/通用格式</td><td>10</td><td>10</td><td>常规格式</td></tr><tr><td>“000.0”</td><td>10.25</td><td>“010.3”</td><td>小数点前面不够三位以0补齐，保留1位小数，不足一位以0补齐</td></tr><tr><td>####</td><td>10.00</td><td>10</td><td>没用的0一律不显示</td></tr><tr><td>00.##</td><td>1.253</td><td>01.25</td><td>小数点前不足两位以0补齐，保留两位，不足两位不补位</td></tr><tr><td>正数；负数；零</td><td>1</td><td>正数</td><td>大于0，显示为“正数”</td></tr><tr><td>正数；负数；零</td><td>0</td><td>零</td><td>等于0，显示为“零”</td></tr><tr><td>正数；负数；零</td><td>-1</td><td>负数</td><td>小于0，显示为“负数”</td></tr><tr><td>0000-00-00</td><td>19820506</td><td>1982-05-06</td><td>按所示形式表示日期</td></tr><tr><td>0000年00月00日</td><td>19820506</td><td>1982年05月06日</td><td></td></tr><tr><td>dddd</td><td>2007/12/31</td><td>Monday</td><td>显示为英文星期几全称</td></tr><tr><td>[&gt;=90]优秀；[&gt;=60]及格；不及格</td><td>90</td><td>优秀</td><td>大于等于90，显示为“优秀”</td></tr><tr><td>[&gt;=90]优秀；[&gt;=60]及格；不及格</td><td>60</td><td>及格</td><td>大于等于60，小于90，显示为“及格”</td></tr><tr><td>[&gt;=90]优秀；[&gt;=60]及格；不及格</td><td>59</td><td>不及格</td><td>小于60，显示为“不及格”</td></tr><tr><td>[DBNum1][$-804]G/通用格式</td><td>125</td><td>一百二十五</td><td>中文小写数字</td></tr><tr><td>[DBNum2][$-804]G/通用格式元整</td><td>125</td><td>壹佰贰拾伍元整</td><td>中文大写数字，并加入“元整”字尾</td></tr><tr><td>[DBNum3][$-804]G/通用格式</td><td>125</td><td>１百２十５</td><td>中文小写数字</td></tr><tr><td>[DBNum1][$-804]G/通用格式</td><td>19</td><td>一十九</td><td>中文小写数字，11-19无设置</td></tr><tr><td>[&gt;20][DBNum1];[DBNum1]d</td><td>19</td><td>十九</td><td>中文小写数字，11-显示为十一而不是一十一</td></tr><tr><td>0.00,K</td><td>12536</td><td>12.54K</td><td>以千为单位</td></tr><tr><td>#!.0000万元</td><td>12536</td><td>1.2536万元</td><td>以万元为单位，保留4位小数</td></tr><tr><td>#!.0,万元</td><td>12536</td><td>1.3万元</td><td>以万元为单位，保留1位小数</td></tr><tr><td>14000</td><td></td><td>1.40万元</td><td>以万元为单位，保留二位小数。只能靠公式的形式解决</td></tr><tr><td>;#[红色]</td><td>1000</td><td>1000</td><td>把负数变成正数并用红色显示，注意用TEXT函数不能实现数字变红，只能放在单元格中用自定义格式来实现目的。TEXT也不支持包含  * 的格式。</td></tr><tr><td>[=1]”男”;[=2]”女”;”录入错误”;</td><td>1</td><td>男</td><td>条件格式一般只可以写三项</td></tr><tr><td>[=1]”男”;[=2]”女”;”录入错误”;</td><td>2</td><td>女</td><td></td></tr><tr><td>“第”[DBNum1][$-804]G/通用格式”中学”</td><td>35</td><td>第三十五中学</td><td></td></tr><tr><td>???,???.???</td><td>2345.789</td><td>2,345.789</td><td>小数点对齐</td></tr><tr><td>???,???.???</td><td>2.4</td><td>2.4</td><td>小数点对齐</td></tr><tr><td>0.00_)”kg”;<a href="0.00">红色</a></td><td>78</td><td>78.00 kg</td><td>_下划线，代表后面加一个和）一样宽度的空格</td></tr><tr><td>0.00_)”kg”;<a href="0.00">红色</a></td><td>(78.00)</td><td>(78.00)</td><td>负数变红并且自动在数字外面套上（）</td></tr><tr><td><a href="mailto:&quot;999999999&quot;@">“999999999”@</a></td><td>999999999785</td><td>785</td><td>必须是以文本形式储存的数字才有效.TEXT不支持文本数值的转换。</td></tr><tr><td>0*-</td><td>785—————-</td><td>785</td><td>TEXT不支持<em> 用</em>把重复的一直显示到列宽</td></tr><tr><td>G/通用格式;-G/通用格式;-</td><td>-</td><td></td><td>把有0的单元格显示为-，其它不变</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> SnowMoonの基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
            <tag> 办公学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
