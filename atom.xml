<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SnowMoon-Haoyu&#39;s Blog</title>
  
  <subtitle>记录成长，变得更强！</subtitle>
  <link href="https://www.snowmoon.top/atom.xml" rel="self"/>
  
  <link href="https://www.snowmoon.top/"/>
  <updated>2024-10-19T15:22:28.153Z</updated>
  <id>https://www.snowmoon.top/</id>
  
  <author>
    <name>雪月</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux I/O调优</title>
    <link href="https://www.snowmoon.top/2024/10/19/Linux_IO%E8%B0%83%E4%BC%98/"/>
    <id>https://www.snowmoon.top/2024/10/19/Linux_IO%E8%B0%83%E4%BC%98/</id>
    <published>2024-10-19T14:40:20.000Z</published>
    <updated>2024-10-19T15:22:28.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h1><h2 id="应用层io操作"><a class="markdownIt-Anchor" href="#应用层io操作"></a> 应用层I/O操作</h2><p>是否利用标准库缓存</p><h3 id="非缓冲io"><a class="markdownIt-Anchor" href="#非缓冲io"></a> 非缓冲I/O</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;0123456789\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd, ret;</span><br><span class="line">    fd = open(<span class="string">&quot;./test.txt&quot;</span>, O_RDWR|O_CREAT|O_APPEND);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">       perror(<span class="string">&quot;ret&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># build</span></span><br><span class="line">gcc -o file file.c</span><br></pre></td></tr></table></figure><p>系统调用提供，如：open, read, write, close等</p><h3 id="缓冲io"><a class="markdownIt-Anchor" href="#缓冲io"></a> 缓冲I/O</h3><p>c语言标准输入输出库提供，如：fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs等</p><p><strong>是否利用内核里的页缓存</strong><br />open(2) O_DIRECT</p><ul><li>直接I/O</li></ul><p>跳过操作系统的文件缓存，直接跟文件系统交互来访问文件</p><ul><li>接I/O</li></ul><p>需要经过操作系统的文件缓存</p><p><strong>阻塞自身运行</strong><br />open(2) O_NONBLOCK</p><ul><li><p>阻塞I/O</p></li><li><p>非阻塞I/O</p></li></ul><p>** 连续IO和随机IO**</p><ul><li>连续IO</li></ul><p>read-&gt;read-&gt;read<br />write-&gt;write-&gt;write</p><ul><li>随机IO</li></ul><p>lseek-&gt;read<br />lseek-&gt;write</p><h2 id="虚拟文件系统"><a class="markdownIt-Anchor" href="#虚拟文件系统"></a> 虚拟文件系统</h2><p>文件缓存</p><p>inode缓存</p><p>dentry缓存</p><p>I/O内核架构</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/Storage%20Stack.webp" alt="Storage Stack" /></p><h3 id="通用块设备层"><a class="markdownIt-Anchor" href="#通用块设备层"></a> 通用块设备层</h3><p>通用块设备层，包括块设备 I/O 队列和 I/O 调度器。它会对文件系统的 I/O 请求进行排队，再通过重新排序和请求合并，然后才要发送给下一级的设备层。</p><p><strong>I/O队列</strong></p><p>对文件系统的 I/O 请求进行排队，再通过【重新排序】和【请求合并】，然后把请求发送到块设备驱动层。</p><p><strong>调度</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. I/O调度指对I/O请求进行排序的过程。Linux 内核支持四种 I/O 调度算法，分别是 NONE、NOOP、CFQ 以及 DeadLine。</span><br><span class="line"></span><br><span class="line">2. 查看和修改某个块设备的IO调度器：</span><br><span class="line">$ cat /sys/block/sda/queue/scheduler </span><br><span class="line">noop deadline [cfq] </span><br><span class="line"></span><br><span class="line">NONE</span><br><span class="line">完全不使用任何 I/O 调度器，常用在虚拟机中。</span><br><span class="line"></span><br><span class="line">NOOP（电梯式调度程序）</span><br><span class="line">它实际上是一个先入先出的队列，只做一些最基本的请求合并（类似电梯算法），常用于闪存、SSD等存储。 NOOP倾向饿死读而利于写！</span><br><span class="line"></span><br><span class="line">CFQ（完全公平排队I/O调度器）</span><br><span class="line">CFQ是现在很多发行版的默认 I/O 调度器，它为【每个进程】维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求。 类似于进程 CPU 调度，CFQ 还支持进程 I/O 的优先级调度。 CFQ试图均匀地分布对I/O带宽的访问,避免进程被饿死并实现较低的延迟。</span><br><span class="line"></span><br><span class="line">DeadLine（截止时间调度程序）</span><br><span class="line">DeadLine 调度算法，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量。DeadLine 调度算法，多用在 I/O 压力比较重的场景，比如数据库等。</span><br></pre></td></tr></table></figure><h3 id="块设备驱动层"><a class="markdownIt-Anchor" href="#块设备驱动层"></a> 块设备驱动层</h3><p>负责最终物理设备的I/O操作</p><p>HDD</p><p><a href="https://blog.csdn.net/qyxls/article/details/117322123">/blog.csdn.net/qyxls/article/details/117322123</a></p><p>寻道时间</p><p>旋转时间</p><p>数据传输时间</p><p>SSD</p><h2 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h2><p><strong>磁盘用量、剩余等</strong></p><p>相关工具</p><p>df -h</p><p><strong>inode节点用量、剩余等</strong></p><p>inode节点空间不足，但是磁盘空间充足，可能是过多小文件造成的！</p><p>相关工具</p><p>df -i</p><p>测试： # mount -t tmpfs -o size=1G tmpfs /tftpboot/minio</p><p><strong>使用率：磁盘处理I/O的时间占比</strong></p><p>相关工具</p><p>iostat -d -x -p sda（%util）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">【指标解释】</span><br><span class="line">r/s:设备每秒完成的读请求数(合并后)；</span><br><span class="line">w/s:设备每秒完成的写请求数(合并后)；</span><br><span class="line">rkB/s:每秒从磁盘读取的数据量；</span><br><span class="line">wkB/s:每秒向磁盘写入的数据量；</span><br><span class="line">rrqm/s:每秒排队到设备上的合并的读请求数；</span><br><span class="line">wrqm/s:每秒排队到设备上的合并的写请求数；</span><br><span class="line">r_await:读请求处理完成等待时间，包括队列中等待时间和设备实际处理所花的时间，单位是毫秒</span><br><span class="line">w_await:写请求处理完成等待时间，包括队列中等待时间和设备实际处理所花的时间，单位是毫秒</span><br><span class="line">aqu-sz:平均请求队列长度</span><br><span class="line">rareq-sz:读请求的平均数据量大小（单位是KB）</span><br><span class="line">wareq-sz：写请求的平均数据量大小（单位是KB）</span><br><span class="line">svctm：处理I/O请求所需的平均时间（单位是毫秒），该指标不准，后续会移除。</span><br><span class="line">%util：磁盘处理I/O的时间百分比</span><br><span class="line"></span><br><span class="line">【几个重要的指标】</span><br><span class="line">磁盘 I/O 使用率 --&gt; %util</span><br><span class="line">每秒I/O读请求数 --&gt; r/s</span><br><span class="line">每秒I/O写请求数　--&gt; w/s </span><br><span class="line">每秒I/O读请求大小　--&gt; rkB/s</span><br><span class="line">每秒I/O写请求大小　--&gt; wkB/s</span><br><span class="line">读响应时间 --&gt; r_await</span><br><span class="line">写响应时间 --&gt; w_await</span><br></pre></td></tr></table></figure><ul><li>局限</li></ul><p>对于RAID和SSD，该指标不能反映其真实性能</p><p><strong>每秒的I/O请求数（读、写）</strong></p><p>iostat -d -x -p sda （r/s, w/s）</p><p>dstat -r</p><p><strong>每秒的I/O请求大小（读、写）</strong></p><p>iostat -d -x -p sda（rkB/s, wkB/s）</p><p>dstat -d</p><p><strong>响应时间：I/O 请求从发出到收到响应的间隔时间（读、写）</strong></p><p>相关工具</p><p>iostat -d -x -p sda（r_await，w_await）</p><p><strong>进程I/O大小或者I/O延迟</strong></p><p>相关工具</p><p>pidstat -d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kB_rd/s：该进程每秒从磁盘读取的数据大小</span><br><span class="line"></span><br><span class="line">kB_wr/s：该进程每秒写入磁盘的数据大小</span><br><span class="line"></span><br><span class="line">kB_ccwr/s：每秒取消的写请求数据大小，当任务截断一些脏页缓存时可能会发生这种情况</span><br><span class="line"></span><br><span class="line">iodelay：块 I/O 延迟，包括等待同步块 I/O 完成时间和换入块 I/O 的时间，单位是时钟周期。</span><br></pre></td></tr></table></figure><p>iotop<br />IO：进程在等待I/O上花费的时间占比(%)；</p><p>biotop<br />AVGms：进程平均I/O时间，单位是ms</p><p><strong>进程每次IO操作的IO延迟</strong></p><p>相关工具</p><p>biosnoop-bpfcc -Q<br />LAT(ms)：磁盘I/O的延迟，包括请求提交给设备到请求完成的时间</p><p>实践</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">１、file.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    char *p = &quot;123456789\n&quot;;</span><br><span class="line">    char file[128];</span><br><span class="line">    sprintf(file, &quot;test-%d.log&quot;, pid);</span><br><span class="line">    int fd, ret;</span><br><span class="line">    fd = open(file, O_RDWR|O_CREAT|O_APPEND);</span><br><span class="line">    if(fd == -1) &#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = write(fd, p, strlen(p));</span><br><span class="line">    if(ret == -1) &#123;</span><br><span class="line">       perror(&quot;ret&quot;);</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    sleep(1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">２、test.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    ./file</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="文件缓存"><a class="markdownIt-Anchor" href="#文件缓存"></a> 文件缓存</h3><p>相关工具</p><p>查看整体：<br />cat /proc/meminfo | grep “^Cached”</p><p>单个文件：<br />pcstat /tftpboot/test</p><p>释放文件缓存：<br />echo 1 &gt; /proc/sys/vm/drop_caches</p><h3 id="dentry和inode缓存"><a class="markdownIt-Anchor" href="#dentry和inode缓存"></a> dentry和inode缓存</h3><p><strong>dentry缓存</strong><br />（dcache）</p><p>相关工具</p><p>cat /proc/slabinfo | grep -E ‘^#|dentry’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name：slab object对象的名称</span><br><span class="line">active_objs：被申请走（正在被使用）的对象个数。</span><br><span class="line">num_objs：总对象（slab object）个数。</span><br><span class="line">objsize：每个对象（slab object）大小，以字节为单位。</span><br><span class="line">objperslab：表示一个slab中包含多少个对象（slab object）。</span><br><span class="line">pagesperslab : 一个slab占用几个page内存页。</span><br><span class="line">active_slabs：活动slab个数。</span><br><span class="line">num_slabs：总slab个数。</span><br></pre></td></tr></table></figure><p><strong>inode缓存</strong><br />（icache）</p><p>相关工具</p><p>cat /proc/slabinfo | grep -E ‘^#|inode’</p><p>释放：echo 2 &gt; /proc/sys/vm/drop_caches<br />前后对比查看：cat /proc/meminfo | grep SReclaimable</p><h1 id="工具汇总"><a class="markdownIt-Anchor" href="#工具汇总"></a> 工具汇总</h1><h2 id="iostat"><a class="markdownIt-Anchor" href="#iostat"></a> iostat</h2><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c：显示cpu指标</span><br><span class="line">-d：显示磁盘使用情况</span><br><span class="line">-k: 以KB为单位显示</span><br><span class="line">-m：以MB为单位显示</span><br><span class="line">-x：显示详细信息</span><br><span class="line">-p：显示某个磁盘或者分区的使用情况</span><br></pre></td></tr></table></figure><h2 id="dstat"><a class="markdownIt-Anchor" href="#dstat"></a> dstat</h2><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-m: 显示内存使用情况</span><br><span class="line">-c：显示cpu使用情况</span><br><span class="line">-n: 显示网络状况</span><br><span class="line">-l：显示系统负载情况</span><br><span class="line">-r：显示I/O请求读写请求数</span><br><span class="line">-d: 磁盘读写情况</span><br><span class="line">-y：显示中断和上下文切换次数等</span><br><span class="line">--socket：显示套接字(tcp,udp等)的个数</span><br><span class="line">--top-io: 显示消耗I/O最大的进程</span><br><span class="line">--top-cpu: 显示消耗cpu最大的进程</span><br><span class="line">--top-cputime: 显示使用cpu时间最大的进程(ms)</span><br><span class="line">--top-latency:  显示总延迟最大的进程(ms)</span><br><span class="line">--top-mem: 显示使用内存最大的进程</span><br></pre></td></tr></table></figure><h2 id="pidstat"><a class="markdownIt-Anchor" href="#pidstat"></a> pidstat</h2><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-d：统计进程的I/O大小及I/O延迟</span><br></pre></td></tr></table></figure><h2 id="iotop"><a class="markdownIt-Anchor" href="#iotop"></a> iotop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写大小总数。</span><br><span class="line"></span><br><span class="line">- TID/PID：线程ID/进程ID；</span><br><span class="line">- PRIO：I/O 优先级；</span><br><span class="line">- USER：用户名；</span><br><span class="line">- DISK READ：每秒读磁盘的大小；</span><br><span class="line">- DISK WRITE：每秒写磁盘的大小；</span><br><span class="line">- SWAPIN：进程在SWAPIN上花费的时间占比；</span><br><span class="line">- IO：进程在等待I/O上花费的时间占比；</span><br></pre></td></tr></table></figure><p>用法</p><p>不加任何参数显示所有【线程】的I/O使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写大小总数。</span><br><span class="line"></span><br><span class="line">- TID/PID：线程ID/进程ID；</span><br><span class="line">- PRIO：I/O 优先级；</span><br><span class="line">- USER：用户名；</span><br><span class="line">- DISK READ：每秒读磁盘的大小；</span><br><span class="line">- DISK WRITE：每秒写磁盘的大小；</span><br><span class="line">- SWAPIN：进程在SWAPIN上花费的时间占比；</span><br><span class="line">- IO：进程在等待I/O上花费的时间占比；</span><br></pre></td></tr></table></figure><h2 id="ionice"><a class="markdownIt-Anchor" href="#ionice"></a> ionice</h2><p>用法</p><p>ionice对进程的IO调度class and priority 的设置只有当调度算法是CFQ时才是有效的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c &#123;class&#125; ：指定调度策略</span><br><span class="line">&#123;class&#125;表示调度策略，其中0 for none, 1 for real time, 2 for best-effort, 3 for idle</span><br><span class="line">-n &#123;classdata&#125;：指定IO优先级别</span><br><span class="line">classdata表示IO优先级级别，对于best effort和real time，classdata可以设置为0~7，0的优先级最高</span><br><span class="line">-p &#123;pid&#125;：指定要查看或设置的进程号或者线程号</span><br></pre></td></tr></table></figure><h2 id="strace"><a class="markdownIt-Anchor" href="#strace"></a> strace</h2><p>用法</p><p>追踪进程的I/O系统调用</p><h2 id="filetop"><a class="markdownIt-Anchor" href="#filetop"></a> filetop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filetop实时追踪文件的读写情况。</span><br><span class="line">TID：线程ID</span><br><span class="line">COMM：线程命令行</span><br><span class="line">READS：读取次数</span><br><span class="line">WRITES：写入次数</span><br><span class="line">R_Kb：读取字节数</span><br><span class="line"></span><br><span class="line">W_Kb：写入字节数</span><br><span class="line">T：文件类型</span><br><span class="line">FILE：文件名称</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-a：包含非常规文件，例如：sockets, FIFOs等</span><br><span class="line">-C：不清屏</span><br><span class="line">-r: 最多打印多少行，默认为20</span><br><span class="line">-s &#123;all,reads,writes,rbytes,wbytes&#125;：按指标排序，默认为rbytes</span><br><span class="line">-p &#123;pid&#125;：只追踪&#123;pid&#125;这个进程的文件读写情况</span><br><span class="line">每隔５秒打印一次，共打印１０次</span><br><span class="line">filetop 5 10</span><br></pre></td></tr></table></figure><h2 id="biotop"><a class="markdownIt-Anchor" href="#biotop"></a> biotop</h2><p><a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu---binary">github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu—binary</a></p><p>用法</p><p><a href="https://github.com/iovisor/bcc/blob/master/tools/biotop_example.txt">github.com/iovisor/bcc/blob/master/tools/biotop_example.txt</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I/O：读或者写的I/O次数</span><br><span class="line"></span><br><span class="line">Kbytes：读或者写的字节数</span><br><span class="line"></span><br><span class="line">AVGms：平均I/O时间，单位是ms （统计的是当前时间周期的数据）</span><br><span class="line"></span><br><span class="line">追踪进程I/O并按I/O吞吐量大小排序，默认每１秒统计一次</span><br><span class="line">-C：不清屏</span><br><span class="line">设置为每5秒打印一次，共打印10次：</span><br><span class="line">biotop 5 10</span><br></pre></td></tr></table></figure><h2 id="biosnoop"><a class="markdownIt-Anchor" href="#biosnoop"></a> biosnoop</h2><p>用法</p><p><a href="https://github.com/iovisor/bcc/blob/master/tools/biosnoop_example.txt">github.com/iovisor/bcc/blob/master/tools/biosnoop_example.txt</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LAT(ms)：磁盘I/O的延迟，包括请求提交给设备到请求完成的时间统计。</span><br><span class="line">追踪并打印进程访问I/O时的内核事件</span><br><span class="line">-Q：include OS queued time</span><br><span class="line">-d &#123;DISK&#125;：Trace this disk only</span><br></pre></td></tr></table></figure><h2 id="biolatency"><a class="markdownIt-Anchor" href="#biolatency"></a> biolatency</h2><p>用法</p><p><a href="https://github.com/iovisor/bcc/blob/master/tools/biolatency_example.txt">github.com/iovisor/bcc/blob/master/tools/biolatency_example.txt</a></p><p>直方图的方式统计系统IO延迟（单位：us）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">直方图的方式统计系统IO延迟（单位：us）</span><br><span class="line">-T: 在输出里包含时间戳</span><br><span class="line">-Q: include OS queued time in I/O time</span><br><span class="line">-m: 按照ms统计系统IO延迟</span><br><span class="line">-D: 分开打印各个磁盘的直方图</span><br><span class="line">输出带时间戳，每秒输出一次，共输出５次：</span><br><span class="line">biolatency -T 1 5</span><br></pre></td></tr></table></figure><h2 id="blktrace"><a class="markdownIt-Anchor" href="#blktrace"></a> blktrace</h2><p>用法</p><p><a href="https://www.cnblogs.com/codelogs/p/16060775.html">www.cnblogs.com/codelogs/p/16060775.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">第一个字段：主、次设备号;</span><br><span class="line">第二个字段：cpu号;</span><br><span class="line">第三个字段：序列号;</span><br><span class="line">第四个字段：时间戳;</span><br><span class="line">第五个字段：本次I/O对应的进程 ID;</span><br><span class="line">第六个字段：Event，这个字段非常重要，反映了 I/O 进行到了哪一步;</span><br><span class="line">第七个字段：R 表示 Read， W 是 Write，S表示sync;</span><br><span class="line">第八个字段：223490+56，表示的是起始 block number 和 number of blocks，即我们常说的Offset 和 Size;</span><br><span class="line">第九个字段：进程名字;</span><br><span class="line"></span><br><span class="line">第六个字段Event:</span><br><span class="line">A:IO被重新映射到不同的设备；</span><br><span class="line">Q:将要被 request 代码处理（即将生成 I/O 请求）；</span><br><span class="line">G: I/O 请求（request）生成，为 I/O 分配一个 request 结构体；</span><br><span class="line">P:插入I/O请求</span><br><span class="line">U:准备向磁盘驱动发送该 I/O</span><br><span class="line">D:IO发给driver去处理</span><br><span class="line">C:IO处理完毕</span><br><span class="line"></span><br><span class="line">采集：</span><br><span class="line">blktrace -d /dev/vda1</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">blkparse -i vda1</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">blktrace -d /dev/vda1 -o - | blkparse -i -</span><br></pre></td></tr></table></figure><p>fio</p><p>IO性能基准测试</p><h1 id="调优实践"><a class="markdownIt-Anchor" href="#调优实践"></a> 调优实践</h1><h2 id="实践一-linux应用遇到io性能问题如何一步一步进行调试"><a class="markdownIt-Anchor" href="#实践一-linux应用遇到io性能问题如何一步一步进行调试"></a> 实践一、linux应用遇到I/O性能问题，如何一步一步进行调试？</h2><p>分析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查看系统总体I/O使用情况：</span><br><span class="line">iostat -d -x -p sda 1</span><br><span class="line">top验证</span><br><span class="line">查看所有进程的I/O使用情况，找到可疑的进程：</span><br><span class="line">pidstat -d 1</span><br><span class="line">追踪可疑进程（子进程）的系统调用情况：</span><br><span class="line">strace -f -p &#123;pid&#125;</span><br><span class="line">show出可疑进程的子进程树：</span><br><span class="line">pstree &#123;pid&#125;</span><br></pre></td></tr></table></figure><p>环境搭建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">１、file.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfd\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> file[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;test-%d.log&quot;</span>, pid);</span><br><span class="line">    <span class="type">int</span> fd, ret;</span><br><span class="line">    fd = open(file, O_RDWR|O_CREAT|O_APPEND);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">       perror(<span class="string">&quot;ret&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc -o file file.c</span><br><span class="line"></span><br><span class="line">２、exfile</span><br><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ./file</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="实践二-如何针对linux应用程序的io访问行为具体分析每一步的时间开销"><a class="markdownIt-Anchor" href="#实践二-如何针对linux应用程序的io访问行为具体分析每一步的时间开销"></a> 实践二、如何针对linux应用程序的I/O访问行为，具体分析每一步的时间开销？</h2><p>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1、file.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    char *p = &quot;0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfd\n&quot;;</span><br><span class="line">    char file[128];</span><br><span class="line">    sprintf(file, &quot;test-%d.log&quot;, pid);</span><br><span class="line">    int fd, ret;</span><br><span class="line">    fd = open(file, O_RDWR|O_CREAT|O_APPEND);</span><br><span class="line">    if(fd == -1) &#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = write(fd, p, strlen(p));</span><br><span class="line">    if(ret == -1) &#123;</span><br><span class="line">       perror(&quot;ret&quot;);</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    ret = write(fd, p, strlen(p));</span><br><span class="line">    if(ret == -1) &#123;</span><br><span class="line">       perror(&quot;ret&quot;);</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、exfile</span><br><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    ./file</span><br><span class="line">    sleep 1</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>分析过程</strong></p><p>查看进程实时读写情况：<br />biosnoop</p><p>blktrace -d /dev/vda1 -o - | blkparse -i -</p><p>Q-&gt;G：生成 I/O 请求所消耗的时间； G-&gt;P：I/O 请求进入 I/O Scheduler 所消耗的时间； P-&gt;D: I/O 请求在 I/O Scheduler 中等待的时间； D-&gt;C：I/O 请求在 Driver 和硬件上所消耗的时间，可以作为硬件性能的指标； Q-&gt;C：整个 I/O 请求所消耗的时间(Q-&gt;G + G-&gt;P + P-&gt;D + D-&gt;C = Q2C)，相当于 iostat 的 await。</p><p>io操作时间戳</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/62dc972cf346fb4e907818ea" alt="img" /></p><h2 id="实践三-rm-删掉的文件还能找回来吗能不过得分情况"><a class="markdownIt-Anchor" href="#实践三-rm-删掉的文件还能找回来吗能不过得分情况"></a> 实践三、rm 删掉的文件还能找回来吗？能，不过得分情况！</h2><p>实践过程</p><ul><li>创建文件：/app/test.c</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vi /app/test.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">    printf(&quot;pid %d\n&quot;, getpid());</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;debug\n&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>删掉文件<br />$ rm /app/test.c</p></li><li><p>恢复过程１</p></li></ul><p>找到正在打开/app/file.c这个文件的进程id(20904)以及该文件在上述进程里的文件描述符(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof | grep /app/test.c filekeep  <span class="number">20904</span>                   root    <span class="number">3</span>r      REG                <span class="number">8</span>,<span class="number">5</span>        <span class="number">449</span>   <span class="number">20731531</span> /app/file.c (deleted)</span><br></pre></td></tr></table></figure><ul><li>恢复过程２</li></ul><p>恢复文件： $ cat /proc/20904/fd/3  &gt; /app/test1.c 即可修复被误删除的文件。</p><ul><li>前提条件：filekeep</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">filekeep.c</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = NULL;</span><br><span class="line"> </span><br><span class="line">   fp = fopen(&quot;/app/test.c&quot;, &quot;r&quot;);</span><br><span class="line">   sleep(600);</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实践总结</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">１、struct dentry</span><br><span class="line">&#123;</span><br><span class="line">  //..</span><br><span class="line">  struct inode *d_inode;//相关联的索引节点</span><br><span class="line">　struct qstr d_name;//目录项名称</span><br><span class="line">　struct dentry *d_parent;//父目录</span><br><span class="line">  //..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">２、struct inode</span><br><span class="line">&#123;</span><br><span class="line">　//...</span><br><span class="line">  unsigned long i_ino;//节点号</span><br><span class="line">  atomic_t i_count;//引用计数</span><br><span class="line">  unsigned int i_nlink;//硬链接数 　</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">３、struct file</span><br><span class="line">&#123;</span><br><span class="line">  //...</span><br><span class="line">  atomic_t f_count;//引用计数</span><br><span class="line">  struct path f_path;//包含目录项 </span><br><span class="line">  struct inode *f_inode;//i节点</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件对象（struct file）是已打开的文件在内存中的表示</span><br><span class="line">由于多个进程可以打开和操作同一个文件，所以同一个文件也可能存在多个文件对象</span><br><span class="line">虽然一个文件对应的文件对象不是唯一的，但是对应的索引节点（struct inode）和目录项（struct dentry）对象是唯一的</span><br><span class="line">rm命令底层调用了unlinkat()函数</span><br><span class="line">unlinkat()：如果该文件对象是对文件的最后一个引用且没有进程正在打开这个文件，才会真正的删除文件；</span><br><span class="line">否则，文件内容会依然保存在内存里，这样的文件就可以被恢复。</span><br></pre></td></tr></table></figure><h2 id="调优方法"><a class="markdownIt-Anchor" href="#调优方法"></a> 调优方法</h2><h3 id="应用程序优化"><a class="markdownIt-Anchor" href="#应用程序优化"></a> 应用程序优化</h3><p>追加写替代随机写</p><p>充分利用缓存（包括系统缓存和标准库缓存），降低实际 I/O 的次数</p><p>可以在应用程序内部构建自己的缓存，或者用 Redis/memcached 这类外部缓存系统</p><p>在需要同步写的场景中，尽量将写请求合并，而不是让每个请求都同步写入磁盘，即可以用 fsync() 取代 O_SYNC</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">wfile.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfd\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fd, len;</span><br><span class="line">    fd = open(<span class="string">&quot;./test.txt&quot;</span>, O_RDWR|O_CREAT|O_APPEND<span class="comment">/*|O_SYNC*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    i++;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 【总结】</h4><p>当文件在open()时指定了O_SYNC选项，则意味着每个write()调用后面都隐含地跟着一个fsync()调用。</p><p>在使用 CFQ 调度器时，使用ionice调整进程的I/O调度优先级</p><p>在使用 CFQ 调度器时，可以用 ionice 来调整进程的 I/O 调度优先级，特别是提高核心应用的 I/O 优先级。 ionice 支持三个优先级类：Idle、Best-effort 和 Realtime。 其中， Best-effort 和 Realtime 还分别支持 0-7 的级别，数值越小，则表示优先级别越高。</p><h3 id="文件系统优化"><a class="markdownIt-Anchor" href="#文件系统优化"></a> 文件系统优化</h3><ul><li>优化文件系统的缓存</li></ul><p>比如，你可以优化 pdflush 脏页的刷新频率（比如设置 dirty_expire_centisecs 和 dirty_writeback_centisecs）以及脏页的限额（比如调整 dirty_background_ratio 和 dirty_ratio 等）。 备注：以上配置都在/proc/sys/vm/目录下。</p><ul><li>优化内核回收目录项缓存和索引节点缓存的倾向</li></ul><p>可以优化内核回收目录项缓存和索引节点缓存的倾向，即调整 vfs_cache_pressure（/proc/sys/vm/vfs_cache_pressure，默认值 100），数值越大，就表示越倾向于回收目录项缓存和索引节点缓存占用的内存。</p><ul><li>使用tmpfs，获得更好的I/O性能</li></ul><p>磁盘文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、建表</span><br><span class="line">spark-sql&gt;</span><br><span class="line">CREATE table diskfile</span><br><span class="line">USING csv</span><br><span class="line">OPTIONS (</span><br><span class="line">  header true,</span><br><span class="line">  path &quot;/app/tools/test-tool/data/test.csv&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">２、查询</span><br><span class="line">spark-sql&gt; </span><br><span class="line">select * from diskfile where name=&quot;name23453&quot;;</span><br></pre></td></tr></table></figure><p>tmpfs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、创建tmpfs</span><br><span class="line">mkdir -p  /tftpboot/tmp</span><br><span class="line">mount -t tmpfs -o size=1G tmpfs /tftpboot/tmp</span><br><span class="line">２、复制csv文件到tmpfs文件系统目录</span><br><span class="line">３、建表</span><br><span class="line">spark-sql&gt;</span><br><span class="line">CREATE table tmpfile</span><br><span class="line">USING csv</span><br><span class="line">OPTIONS (</span><br><span class="line">  header true,</span><br><span class="line">  path &quot;/tftpboot/tmp/test.csv&quot;</span><br><span class="line">);</span><br><span class="line">4、查询</span><br><span class="line">spark-sql&gt; </span><br><span class="line">select * from tmpfile where name=&quot;name23453&quot;;</span><br></pre></td></tr></table></figure><h3 id="磁盘优化"><a class="markdownIt-Anchor" href="#磁盘优化"></a> 磁盘优化</h3><ul><li>SSD替代HDD</li></ul><p>针对磁盘和应用程序 I/O 模式的特征，我们可以选择最适合的 I/O 调度算法</p><p>在顺序读比较多的场景中，我们可以增大磁盘的预读数据</p><p>你可以通过下面的proc文件，调整 /dev/sda 设备的预读大小： $ cat /sys/block/sda/queue/read_ahead_kb 128 默认大小是 128，单位为 KB。</p><p>可以优化内核块设备 I/O 的选项</p><p>比如，可以调整磁盘队列的长度 /sys/block/sda/queue/nr_requests。 适当增大队列长度，可以提升磁盘的吞吐量。</p>]]></content>
    
    
    <summary type="html">Linux IO 占用调优</summary>
    
    
    
    <category term="SnowMoonの嵌入式笔记" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式Linux" scheme="https://www.snowmoon.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    <category term="Linux" scheme="https://www.snowmoon.top/tags/Linux/"/>
    
    <category term="I/O" scheme="https://www.snowmoon.top/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>Linux——网络调优</title>
    <link href="https://www.snowmoon.top/2024/09/06/Linux_%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/"/>
    <id>https://www.snowmoon.top/2024/09/06/Linux_%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/</id>
    <published>2024-09-06T03:13:31.000Z</published>
    <updated>2024-10-19T15:22:28.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-网络调优"><a class="markdownIt-Anchor" href="#linux-网络调优"></a> Linux 网络调优</h1><h2 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h2><h3 id="tcpip五层模型"><a class="markdownIt-Anchor" href="#tcpip五层模型"></a> TCP/IP五层模型</h3><ul><li>应用层</li></ul><p>负责应用程序沟通，常见协议：http/ftp/tftp/snmp/smtp/telnet等，可自定义</p><ul><li>传输层</li></ul><p>提供端到端的通信服务，常见协议：tcp和udp协议</p><ul><li>网络层</li></ul><p>负责数据的分片、寻址和路由，常见协议：ip协议</p><ul><li>数据链路层</li></ul><p>负责硬件设备之间的数据帧的传送和识别，例如帧同步、冲突检测等，常见协议：ethernet协议</p><ul><li>物理层</li></ul><p>透明的传输比特流，常见硬件厂商：<br />- broadcom（博通）<br />- realtek（瑞昱）<br />- intel</p><h4 id="实践一-linux-c实现聊天功能及wireshark抓包分析"><a class="markdownIt-Anchor" href="#实践一-linux-c实现聊天功能及wireshark抓包分析"></a> 实践一、linux c实现聊天功能及wireshark抓包分析</h4><p>案例代码在这里 -&gt;</p><p><a href="https://github.com/simple-tec/linux-driver/tree/main/app/tcp">https://github.com/simple-tec/linux-driver/tree/main/app/tcp</a></p><h3 id="linux网络设备驱动"><a class="markdownIt-Anchor" href="#linux网络设备驱动"></a> linux网络设备驱动</h3><p>(以dm9000芯片为例)</p><p>硬件datasheet在这里 -&gt;</p><p><a href="http://www.davicom.com.tw/pddocs/DM9000A-DS-F01-030311.pdf">http://www.davicom.com.tw/pddocs/DM9000A-DS-F01-030311.pdf</a></p><h4 id="最大传输单元mtu"><a class="markdownIt-Anchor" href="#最大传输单元mtu"></a> 最大传输单元mtu</h4><p>mtu范围：【68, 1500】</p><p>ip报头最小：20 Bytes</p><p>tcp头部最小：20 Bytes</p><p>最大mss = 1500-20-20=1460</p><p>最大报文段长度（MSS）是TCP协议的一个选项，用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度（不包括文段头）。 MSS = MTU - TCP头部大小 - IP头部大小 其中，TCP 头部和 IP 头部的大小是固定的，分别为 20 字节和 20 字节。</p><p>mtu限制了数据链接层上可以传输的数据包的大小，也因此限制了上层（IP层）的数据包大小</p><p>mtu和IP分片的关系</p><p>当要求发送的IP数据包比数据链路层的MTU大时，必把该数据包分割成多个IP数据包才能发送。</p><h4 id="linux网卡驱动发送和接收"><a class="markdownIt-Anchor" href="#linux网卡驱动发送和接收"></a> linux网卡驱动发送和接收</h4><p>参考代码(linux 4.9.229)：drivers/net/ethernet/davicom/dm9000.c</p><p>网卡驱动整体框架</p><ul><li>数据帧发送</li></ul><p>1、dm9000_start_xmit()</p><p>2、 dm9000_interrupt()</p><p>３、dm9000_tx_done</p><ul><li>数据帧接收</li></ul><p>1、 dm9000_interrupt()</p><p>2、dm9000_rx()</p><p>3、netif_rx()</p><ul><li>软中断NET_TX, NET_RX处理</li></ul><p>参考代码(linux 4.9.229)：net/core/dev.c</p><p>网络底半部发送：net_tx_action()</p><p>网络底半部接收：net_rx_action()</p><h2 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h2><h3 id="最大传输单元mtu-2"><a class="markdownIt-Anchor" href="#最大传输单元mtu-2"></a> 最大传输单元mtu</h3><p>相关工具</p><p>查看：<br />ifconfig eth0 | grep mtu</p><p>修改（临时）：<br />ifconfig eth0 mtu 1450</p><p>实践：IP数据包（包含IP头）超过MTU大小，会发生什么情形？</p><p>操作步骤</p><p>【假设】eth0接口的mtu为1500！ 命令１： ping -I eth0 -s 147２ -M do 192.168.0.101 命令２： ping -I eth0 -s 1473 -M do 192.168.0.101</p><h3 id="带宽"><a class="markdownIt-Anchor" href="#带宽"></a> 带宽</h3><p>链路的最大传输速度，单位b/s（比特/s），属于基础设施。</p><p>相关工具</p><p>ethtool eth0 | grep Speed</p><h3 id="pps"><a class="markdownIt-Anchor" href="#pps"></a> PPS</h3><p>Packet Per Second，表示以网络包为单位的传输速率</p><p>相关工具</p><p>sar -n DEV</p><h3 id="吞吐量"><a class="markdownIt-Anchor" href="#吞吐量"></a> 吞吐量</h3><p>单位时间内传输的数据量，单位b/s或者B/s</p><p>相关工具</p><p>sar -n DEV</p><p>rxpck/s 和 txpck/s 分别是接收和发送的 PPS; rxkB/s 和 txkB/s 分别是接收和发送的吞吐量； rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数； %ifutil 是网络接口的使用率，即半双工模式下为 (rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s, txkB/s)/Bandwidth；</p><h3 id="往返延时rtt"><a class="markdownIt-Anchor" href="#往返延时rtt"></a> 往返延时（RTT）</h3><p>RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</p><p>相关工具</p><p>【ICMP】ping -c4 8.8.8.8</p><p>ping命令的输出中的最后一行： rtt min/avg/max/mdev = 58.325/71.634/94.710/14.502 ms mdev全称Mean Deviation，译为平均方差 mdev越大，表示网络越不稳定。</p><p>【TCP】hping3 -c 3 -S -p 80 <a href="http://httpbin.org">httpbin.org</a></p><h3 id="tcp相关性能工具"><a class="markdownIt-Anchor" href="#tcp相关性能工具"></a> TCP相关性能工具</h3><p>tcp半连接队列的大小</p><p>相关工具</p><p>max(64, net.ipv4.tcp_max_syn_backlog)</p><p>tcp全连接队列的大小</p><p>相关工具</p><p>min(backlog, net.core.somaxconn)</p><p>tcp/udp吞吐量</p><p>相关工具</p><p>【tcp】<br />server端：iperf -s -p 10000<br />client端：iperf -c 192.168.0.100 -p 10000</p><p>【udp】<br />server端：iperf -s -p 10000<br />client端：iperf -u -c 192.168.0.100 -p 10000</p><p>tcp缓冲区大小</p><p>相关工具或配置</p><p>tcp发送缓冲区大小：<br />查看：<br />cat /proc/sys/net/ipv4/tcp_wmem<br />该文件包含3个整数值，分别是：min，default，max<br />更改：<br />sysctl -w net.ipv4.tcp_wmem=“XXXX XXXX XXXX”</p><p>tcp接收缓冲区大小：<br />查看：<br />cat /proc/sys/net/ipv4/tcp_rmem<br />该文件包含3个整数值，分别是：min，default，max<br />更改：<br />sysctl -w net.ipv4.tcp_rmem=“XXXX XXXX XXXX”</p><p>socket连接数</p><p>相关工具</p><p>查看tcp状态为SYN_REC的sockets：<br />netstat -n -p -t | grep SYN_REC</p><p>查看tcp状态为SYN_REC的sockets：<br />ss -n -p -t | grep SYN_REC</p><h3 id="udp相关性能工具"><a class="markdownIt-Anchor" href="#udp相关性能工具"></a> UDP相关性能工具</h3><p>udp缓冲区大小</p><p>相关工具或配置</p><p>udp缓冲区大小：<br />查看：<br />cat /proc/sys/net/ipv4/udp_mem<br />该文件包含3个整数值，分别是：min，default，max</p><p>套接字缓冲区大小</p><p>单个套接字缓冲区大小</p><p>相关工具或配置</p><p>setsockopt(,SO_SNDBUF,)配置</p><p>在调用connect或listen之前通过setsockopt设置。</p><p>setsockopt(,SO_RCVBUF,)配置</p><p>在调用connect或listen之前通过setsockopt设置。</p><p>内核全局的套接字缓冲区大小</p><p>相关工具或配置</p><p>套接字接收缓冲区大小：<br />查看：<br />cat /proc/sys/net/core/rmem_max<br />修改：<br />sysctl -w net.core.rmem_max=212993</p><p>套接字发送缓冲区大小：<br />查看：<br />cat /proc/sys/net/core/wmem_max<br />修改：<br />sysctl -w net.core.wmem_max=212993</p><h3 id="工具汇总"><a class="markdownIt-Anchor" href="#工具汇总"></a> 工具汇总</h3><h4 id="wireshark"><a class="markdownIt-Anchor" href="#wireshark"></a> wireshark</h4><p>用法</p><p>过滤器</p><p>捕获过滤器：用于决定捕获什么数据</p><p>显示过滤器：在捕获的结果中进行详细查找</p><p>详细语法：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/631179d61e0853188ea104c4" alt="img" /></p><p>比较运算：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/63117bd11e0853188ea10c9f" alt="img" /></p><p>逻辑运算：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/63117bde1efad41efc4ca3a8" alt="img" /></p><p>例子</p><p>frame.cap_len &gt; 100<br />【备注】cap_len长度包括【以太网头＋ip头＋tcp头＋应用数据】的总长度</p><p>ip.len &gt;= 100<br />【备注】ip.len是ip层以上的（包含ip头）数据的总长度</p><p>tcp.len &gt;= 60<br />【备注】tcp.len即tcp segment len，指的是tcp所承载的应用数据的长度（不包含tcp头部）</p><p>udp.length &gt; 100<br />【备注】udp.length是udp报头和udp载荷数据的总大小</p><p>对多个条件进行过滤：<br />ip.addr==172.16.10.2 and tcp.flag.fin</p><p>按字节位置的内容进行过滤（十六机制）：<br />tcp[0:2]==ac3a（匹配源端口号44090）<br />【备注】tcp[n,m] ：n是起始位置偏移，m是从指定位置的区域长度</p><p>按比特位置的内容进行过滤：<br />tcp[13]&amp;2<br />【备注】用“&amp;2”符号指出要取这个字节中第2位即SYN位置的值</p><p>tcp.segment_data contains 49:27:6d:20:64:61:74:61<br />【备注】49:27:6d:20:64:61:74:61是16进制的内容序列</p><p>Flow Graph</p><p>1, 在选择一个包后，单击右键并选择 “Follow” -&gt; “TCP Stream”； 2，关闭弹出来的对话框，回到 Wireshark 主窗口。这时候，你会发现 Wireshark 已经自动帮你设置了一个过滤表达式，例如：tcp.stream eq 24。 从这里，你可以看到这个 TCP 连接从三次握手开始的每个请求和响应情况。 3，为了更加直观，你可以继续点击菜单栏里的 Statics -&gt; Flow Graph，选中 “Limit to display filter” 并设置 Flow type 为 “TCP Flows”。就可以看到更直观的通信细节。</p><h4 id="tcpdump"><a class="markdownIt-Anchor" href="#tcpdump"></a> tcpdump</h4><p>用法</p><p>-i eth0：指定网络接口</p><p>-nn：不解析ip地址和端口号的名称</p><p>-c {count}：指定要抓取的数据包的个数</p><p>-w {file}：抓包并保存到文件，比如：file.pcap</p><p>[expression] tcpdump的过滤表达式和wireshark是类似的</p><p>tcpdump的过滤表达式</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/63119746079129647b69c738" alt="img" /></p><p>输出格式：时间戳　协议　源IP地址：源端口 &gt; 目的IP地址：目的端口　网络包详细信息</p><p>例子：tcpdump -i eth0 icmp and host 192.168.0.102 -nn</p><h4 id="netstat"><a class="markdownIt-Anchor" href="#netstat"></a> netstat</h4><p>用法</p><p>-a: 显示所有的socket连接（包括listening和non-listening连接）</p><p>-l: 只显示listening状态的socket连接</p><p>-n: 表示显示数字地址和端口(而不是名字)</p><p>-p: 表示显示进程信息</p><p>-t: 只显示tcp连接（若不指定-l，则默认仅显示non-listening连接）</p><p>-u: 只显示udp连接（若不指定-l，则默认仅显示non-listening连接）</p><p>-x: 只显示unix连接</p><p>-i: 显示所有网络接口的状态</p><p>-s：汇总了 ip、icmp、udp、tcp 等各种协议的收发统计信息</p><h4 id="ip"><a class="markdownIt-Anchor" href="#ip"></a> ip</h4><p>Forwarding: 1 //开启转发    8641328 total packets received //总收包数    73 with invalid addresses // 有着错误地址的封包数    0 forwarded //转发包数    0 incoming packets discarded //接收丢包数    8598954 incoming packets delivered //接收的数据包数    5161967 requests sent out //发出的数据包数    160 dropped because of missing route //找不到路由而导致的丢包数    1 fragments dropped after timeout　//超时导致的丢包数    274 reassemblies required　//需要重组的封包数    117 packets reassembled ok//重组成功的封包数    1 packet reassemblies failed　//重组失败的封包数</p><p>-e：显示额外的信息，比如socket path等</p><p>-r：显示内核的路由表，等同于route -e</p><p>Recv-Q 和 Send-Q的解释</p><p>注意，在不同套接字状态下，它们的含义不同： 1、当套接字处于Established状态（Established）时，Recv-Q 表示OS持有的、尚未交付给应用程序的数据的字节数；而 Send-Q 表示已经发送给对端应用，但对端应用尚未ack的字节数。 2、当套接字处于监听状态（Listening）时，Recv-Q 表示当前全连接队列的长度。而 Send-Q 表示全连接队列的最大长度，其值为min(backlog, somaxconn)。 注意，Listening状态时，Recv-Q的最大值为Send-Q+1，即：min(backlog, somaxconn)+1。 之所以加1，是因为OS内核在判断队列是否已满时，用的是&gt;（应该用&gt;=），这导致当已创建成功的连接数量正好等于min(backlog, somaxconn)时，还会再多创建一个tcp连接，最终结果就是：min(backlog, somaxconn)+1。</p><p>场景</p><p>１、列出所有的tcp端口（包含listen和非listen状态）：<br />$ netstat -ta<br />列出处于Listen状态的tcp端口：<br />$ netstat -tl<br />注意：netstat -t会列出处于no-listen状态的tcp连接</p><p>２、显示各个协议的统计信息：<br />$ netstat -s</p><p>３、显示tcp的统计信息<br />$ netstat -st</p><p>４、初步检测你的系统有没有受到DDOS攻击：<br />$ netstat -n -p|grep SYN_REC | wc -l</p><h4 id="ss"><a class="markdownIt-Anchor" href="#ss"></a> ss</h4><p>用法</p><p>-a: 显示所有的sockets（包括LISTEN和非LISTEN）</p><p>-l: 只显示LISTEN状态的sockets</p><p>-n：不解析服务名字，显示数字和端口</p><p>-p：显示进程信息</p><p>-t：只显示tcp连接</p><p>-u：只显示udp连接</p><p>-x：只显示unix连接</p><p>-s：连接信息汇总</p><h4 id="iperf"><a class="markdownIt-Anchor" href="#iperf"></a> iperf</h4><p>用法</p><p>-f [kmKM] ：分别表示以Kbits, Mbits, KBytes, MBytes显示报告</p><p>-s：以server模式启动</p><p>-c：以client模式启动</p><p>-p：指定端口号</p><p>-u：使用udp协议</p><p>-t {sec}：表示测试多久，一般指定在client端（因为client为封包发送方）</p><p>-m：在结果中打印tcp mss的值</p><p>-N：禁止Nagle算法</p><p>场景</p><p>测试tcp的吞吐量：<br />server端：iperf -s -p 10000<br />client端：iperf -c 192.168.0.100 -p 10000</p><p>测试udp的吞吐量：<br />server端：iperf -s -p 10000 -u<br />client端：iperf -c 192.168.0.100 -p 10000 -u</p><h4 id="ab"><a class="markdownIt-Anchor" href="#ab"></a> ab</h4><p>用法</p><p>-c: 并发数</p><p>-n: 总请求数</p><p>-s: 设置每个请求的超时时间</p><p>-r: 套接字接收错误时仍然继续执行</p><p>注意</p><p>测试高并发，需要提前修改进程能打开的最大文件描述符的大小：<br />$ ulimit -n 10240</p><p>场景</p><p>测试某个服务的性能：<br />$ ab -c 100 -n 10000 <a href="http://httpbin.org/ip">http://httpbin.org/ip</a></p><p>Failed requests:　//失败的请求数； Non-2xx responses://非2xx回应的请求数； Requests per second://每秒完成的请求数； Time per request【１】:每个请求的平均处理时间； Time per request【２】:引入并发因素后，每个请求的平均处理时间； Transfer rate: //每秒数据传输量，表示网络吞吐； 备注： 某些情况下Time per request【２】乘以concurrency，约等于Time per request【１】，希望这样有助于你理解这两者的区别。</p><h4 id="hping3"><a class="markdownIt-Anchor" href="#hping3"></a> hping3</h4><p>用法</p><p>模式选择，默认tcp</p><p>–rawip：RAWIP模式</p><p>–icmp：ICMP模式</p><p>–udp：UDP模式</p><p>–scan：SCAN模式，指定扫描对应的端口</p><p>–listen：监听模式</p><p>-S：表示设置TCP协议的SYN（同步序列号）</p><p>-p {port}: 设置端口号</p><p>-c {count}：发送的总封包数</p><p>-i {interval}：u100表示每隔100微秒发送一个网络帧</p><p>-i 1：表示每隔1秒发送一个网络帧； -i u100：表示每隔100微妙发送一个网络帧；</p><p>-a {hostname}：源地址欺骗</p><p>–rand-source：随机化源IP</p><p>–flood：尽量快的发包，无需再指定-i</p><p>场景</p><p>１、端口扫描<br />扫描一个端口：<br />$ hping3 192.168.0.1 --scan 80 -S<br />扫描多个端口：<br />$ hping3 192.168.0.1 --scan 80,8080 -S</p><p>２、模拟DDOS攻击<br />SYN ddos攻击：<br />$ hping3 -S -p 80 -i u10 192.168.0.1<br />flood＋随机源地址SYN攻击：<br />$ hping3 -S -p 80 192.168.0.1 --flood --rand-source</p><p>3、伪造源IP地址<br />伪装源地址为10.0.0.1给192.168.0.1的80端口发送syn包：<br />$ hping3 -S -p 80 -a 10.0.0.1 -S 192.168.0.1</p><h4 id="ping"><a class="markdownIt-Anchor" href="#ping"></a> ping</h4><p>用法</p><p>-n：不会进行名称解析</p><p>-s {packetsize}：指定要发送的封包大小。<br />【注意】{packetsize}+8+20应该小于等于mtu，否则会执行分片策略</p><p>-M {pmtudisc_opt}：选择Path MTU发现策略，可选值如下：<br />- do：禁止分片<br />- want：package太大时执行分片<br />- dont：不设置DF flag</p><p>例子：<br />ping 192.168.0.101 -c 1</p><h4 id="nethogs"><a class="markdownIt-Anchor" href="#nethogs"></a> nethogs</h4><p>用法</p><p>排序显示每个进程所使用的网络带宽，例如：<br />nethogs -d 2 -s</p><p>-d {seconds}：指定刷新频率</p><p>-s：按照网络发送量排序</p><p>交互参数：<br />m：切换byte, kb, mb等<br />r: 按照接收排序<br />s：按照发送量排序</p><h4 id="iftop"><a class="markdownIt-Anchor" href="#iftop"></a> iftop</h4><p>用法</p><p>界面参数说明： =&gt;代表发送数据 &lt;=代表接收数据 TX：发送流量（过去 2s 10s 40s ） RX：接收流量（过去 2s 10s 40s ） TOTAL：总流量 Cumm：运行iftop到目前时间的字节总量 peak：过去40s的流量峰值 rates：分别表示过去 2s 10s 40s 的平均流量 备注：流量的单位是Bytes/s，也就是传输速度。</p><p>-i ${dev}：设定监测的网卡</p><p>-B：以bytes为单位显示流量(默认是bits)</p><p>-n：不使用host信息、而是使用ip地址和端口的方式来显示</p><p>常用组合：<br />iftop -i eth0 -B -n</p><h2 id="调优实践"><a class="markdownIt-Anchor" href="#调优实践"></a> 调优实践</h2><h3 id="实践一-ping不通服务器该从哪些方面去调试"><a class="markdownIt-Anchor" href="#实践一-ping不通服务器该从哪些方面去调试"></a> 实践一、ping不通服务器，该从哪些方面去调试？</h3><p>分析过程</p><p>【物理层】查看网线接口灯的状态是否正常。</p><p>绿灯是链路指示灯,黄灯是信号指示灯。 １、黄灯闪动,绿灯长亮 表示链路正常,正在通信中； ２、黄灯不亮,绿灯长亮 表示链接正常,不过目前没有数据通信； ３、黄灯不亮,绿灯闪动 表示链路不稳定，存在比如线头接触不良等问题</p><p>【数据链路层】ifconfig查看相应的网络接口是否存在RX errors或者TX errors<br />$ watch -d ifconfig eth0</p><p>【arp层】查看本地的arp缓存中关于目标ip的mac地址是否正确？<br />$ arp -e</p><p>【网络层】执行route查看针对目标IP的出口设备是否正常？有时docker bridge就创建它自己的172打头的路由规则，导致路由出错</p><p>【本机的软件防火墙】通过iptables -L查看是否有针对目标服务器地址的可疑规则</p><p>【第三方防火墙】和服务器机器是否直连，中间有没有通过其他设备，该设备有无防火墙规则设定？</p><p>【Tcp层】通过nmap -sS -v 172.21.84.140或则nmap -sT -v 172.21.84.140扫描服务器开关机状态和存活端口号</p><h3 id="实践二-对端socket发出了rst报文导致连接异常关闭该怎么分析"><a class="markdownIt-Anchor" href="#实践二-对端socket发出了rst报文导致连接异常关闭该怎么分析"></a> 实践二、对端socket发出了RST报文，导致连接异常关闭，该怎么分析？</h3><p>分析过程</p><p>通过wireshark或tcpdump分析tcp通信过程</p><p>RST是发生在３次握手过程中吗？是否在向一个未监听的端口发送<br />SYN封包？</p><p>客户端和服务端程序有任何一方发生了异常退出吗？</p><p>是否在已关闭的socket上收到了数据呢？</p><p>客户端和服务端程序有任何一方发生了提前close退出吗？</p><p>案例代码</p><p>在已经关闭的socket上收到了数据，底层协议栈会发RST</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8887</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> listen_fd, real_fd;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">listen_addr</span>, <span class="title">client_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);  </span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(listen_fd == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;socket failed   &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bzero(&amp;listen_addr,<span class="keyword">sizeof</span>(listen_addr));  </span><br><span class="line">    listen_addr.sin_family = AF_INET;  </span><br><span class="line">    listen_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    listen_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    bind(listen_fd,(<span class="keyword">struct</span> sockaddr *)&amp;listen_addr, len);  </span><br><span class="line">    listen(listen_fd, WAIT_COUNT);  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        real_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);  </span><br><span class="line">        <span class="keyword">if</span>(real_fd == <span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            perror(<span class="string">&quot;accpet fail  &quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            close(listen_fd);  </span><br><span class="line">            <span class="type">char</span> pcContent[<span class="number">4096</span>];</span><br><span class="line">            read(real_fd,pcContent,<span class="number">4096</span>);</span><br><span class="line">            close(real_fd);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);              </span><br><span class="line">        &#125;  </span><br><span class="line">        close(real_fd);  </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8887</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> send_sk;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">s_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(s_addr);  </span><br><span class="line">    send_sk = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(send_sk == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;socket failed  &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bzero(&amp;s_addr, <span class="keyword">sizeof</span>(s_addr));  </span><br><span class="line">    s_addr.sin_family = AF_INET;  </span><br><span class="line">    s_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    s_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    <span class="keyword">if</span>(connect(send_sk,(<span class="keyword">struct</span> sockaddr*)&amp;s_addr,len) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;connect fail  &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">char</span> pcContent[<span class="number">4096</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// first send</span></span><br><span class="line">    write(send_sk,pcContent,<span class="number">4096</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// second send</span></span><br><span class="line">    write(send_sk,pcContent,<span class="number">4096</span>);</span><br><span class="line">    close(send_sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wireshark截图</p><p><img src="C:%5CUsers%5CZHY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241019212806209.png" alt="image-20241019212806209" /></p><p>接收方应用程序未接收完接收缓冲区的数据、就提前close退出，底层协议栈会发RST</p><p>Server.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8887</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> listen_fd, real_fd;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">listen_addr</span>, <span class="title">client_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);  </span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(listen_fd == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;socket failed   &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bzero(&amp;listen_addr,<span class="keyword">sizeof</span>(listen_addr));  </span><br><span class="line">    listen_addr.sin_family = AF_INET;  </span><br><span class="line">    listen_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    listen_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    bind(listen_fd,(<span class="keyword">struct</span> sockaddr *)&amp;listen_addr, len);  </span><br><span class="line">    listen(listen_fd, WAIT_COUNT);  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        real_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);  </span><br><span class="line">        <span class="keyword">if</span>(real_fd == <span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            perror(<span class="string">&quot;accpet fail  &quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            close(listen_fd);  </span><br><span class="line">            <span class="type">char</span> pcContent[<span class="number">4096</span>];</span><br><span class="line">            read(real_fd,pcContent,<span class="number">4096</span>);</span><br><span class="line">            close(real_fd);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);              </span><br><span class="line">        &#125;  </span><br><span class="line">        close(real_fd);  </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8887</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> send_sk;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">s_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(s_addr);  </span><br><span class="line">    send_sk = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(send_sk == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;socket failed  &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bzero(&amp;s_addr, <span class="keyword">sizeof</span>(s_addr));  </span><br><span class="line">    s_addr.sin_family = AF_INET;  </span><br><span class="line">    s_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    s_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    <span class="keyword">if</span>(connect(send_sk,(<span class="keyword">struct</span> sockaddr*)&amp;s_addr,len) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;connect fail  &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">char</span> pcContent[<span class="number">5000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(send_sk,pcContent,<span class="number">5000</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    close(send_sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20241019213237649.webp" alt="image-20241019213237649" /></p><h3 id="实践三-压测nginx服务时网络延迟居高不下该如何解决"><a class="markdownIt-Anchor" href="#实践三-压测nginx服务时网络延迟居高不下该如何解决"></a> 实践三、压测nginx服务时网络延迟居高不下，该如何解决？</h3><p>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. nginx打开nagle算法</span><br><span class="line">vi /etc/nginx/nginx.conf</span><br><span class="line">http &#123;</span><br><span class="line">  ...  </span><br><span class="line">  tcp_nodelay off;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 客户端使用ab工具并发压测：</span><br><span class="line">$  ab -c 100 -n 10000 -k http://172.21.84.207:8081/</span><br><span class="line">结果：</span><br><span class="line">Requests per second:    2259.76 [#/sec] (mean)</span><br><span class="line">Time per request:       44.253 [ms] (mean)</span><br><span class="line"></span><br><span class="line">3. nginx关闭nagle算法</span><br><span class="line">vi /etc/nginx/nginx.conf</span><br><span class="line">http &#123;</span><br><span class="line">  ...  </span><br><span class="line">  tcp_nodelay on;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. 再测压测</span><br><span class="line">$  ab -c 100 -n 10000 -k http://172.21.84.207:8081/</span><br><span class="line">结果：</span><br><span class="line">Requests per second:    20316.37 [#/sec] (mean)</span><br><span class="line">Time per request:       4.922 [ms] (mean)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【附】本例使用的完整的nginx.conf文件如下：</span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8081;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">           root  /var/www/html;             #html访问路径</span><br><span class="line">           index index.html index2.htm;     #html文件名称</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析过程</p><p>[Nagle算法和tcp延迟确认](<a href="https://shimo.im/docs/nPixnamNKxQiG7dQ/">https://shimo.im/docs/nPixnamNKxQiG7dQ/</a> 《Nagle算法和tcp延迟确认-public》，可复制链接后用石墨文档 App 打开)</p><p>调优方法</p><p>数据链路层</p><p>网卡驱动优化</p><p>NAPI：中断+轮询</p><p>为网卡中断配置cpu亲和性（smp_affinity），将这些中断处理程序调度到不同的 CPU 上执行</p><p>DPDK</p><p>跳过逻辑复杂的linux网络协议栈，直接由用户态进程用轮询的方式，来处理网络请求</p><p>传输层</p><h4 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> tcp</h4><p>tcp TIME_WAIT优化</p><p>增大处于 TIME_WAIT 状态的连接数量： net.ipv4.tcp_max_tw_buckets</p><p>tcp_max_tw_buckets控制kernel中最多存在的TIME_WAIT数量。</p><p>减小 net.ipv4.tcp_fin_timeout，让处于FIN状态的tcp连接尽早释放</p><p>开启端口复用 net.ipv4.tcp_tw_reuse，这样被 TIME_WAIT 状态占用的端口，能很快被用于新的连接</p><p>增加可用端口号或者文件数</p><p>增大本地端口的范围 net.ipv4.ip_local_port_range ，这样就可以支持更多连接，提高服务并发能力</p><p>linux里，一切皆是文件，socket连接也是，可增加最大文件描述符的数量（ulimit -n 10240）</p><p>SYN相关优化</p><p>增大 TCP 半连接的最大数量：net.ipv4.tcp_max_syn_backlog</p><p>减少 SYN_RECV 状态的连接重传 SYN+ACK 包的次数 ：net.ipv4.tcp_synack_retries。</p><p>其他优化</p><p>tcp nagle算法</p><p>启用时可提高小封包场景下的网络利用率，但同时也增加了网络延迟</p><p>tcp延迟确认</p><p>提高某些场景下的网络利用率</p><h4 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> udp</h4><p>增大UDP的缓冲区大小</p><p>跟前面 TCP 部分提到的一样，增大本地端口号的范围</p><p>根据 MTU 大小，调整 UDP 数据包的大小，减少或者避免分片的发生</p><p>配置套接字缓冲区大小<br />参考出处：<br />linux-4.9.229/Documentation/sysctl/net.txt</p><p>net.core.optmem_max：每个套接字允许的最大辅助缓冲区大小</p><p>net.core.rmem_max：最大接收套接字缓冲区大小(以字节为单位)</p><p>net.core.wmem_max：最大发送套接字缓冲区大小(以字节为单位)</p><p>应用程序</p><p>使用epoll取代select和poll</p><p>尽量使用连接池，比如postgres和redis编程都支持连接池方式，可避免每次请求的时候都要建立3次握手</p><p>为socket配置较大的套接字的缓冲区SO_SNDBUF和SO_RCVBUF</p><p>使用缓存技术，缓存一部分实时性没那么高的数据，减少不必要的网络访问</p>]]></content>
    
    
    <summary type="html">Linux 网络相关功能调试工具汇总</summary>
    
    
    
    <category term="SnowMoonの嵌入式笔记" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式Linux" scheme="https://www.snowmoon.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    <category term="Linux" scheme="https://www.snowmoon.top/tags/Linux/"/>
    
    <category term="CPU" scheme="https://www.snowmoon.top/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.snowmoon.top/2024/06/01/%E4%B9%A6%E7%B1%8D%E5%AD%98%E6%A1%A3-Linux-kernel-notes-master-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.snowmoon.top/2024/06/01/%E4%B9%A6%E7%B1%8D%E5%AD%98%E6%A1%A3-Linux-kernel-notes-master-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</id>
    <published>2024-06-01T05:46:44.949Z</published>
    <updated>2024-10-19T15:22:29.418Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="linuxunix系统编程"><a class="markdownIt-Anchor" href="#linuxunix系统编程"></a> Linux/Unix系统编程</h1><h2 id="第12章-系统和进程信息"><a class="markdownIt-Anchor" href="#第12章-系统和进程信息"></a> 第12章 系统和进程信息</h2><h3 id="121-proc文件系统"><a class="markdownIt-Anchor" href="#121-proc文件系统"></a> 12.1 /proc文件系统</h3><p>许多UNIX系统提供/proc虚拟文件系统，驻留在/proc目录中，包含了各种用于查看内核信息的文件，允许进程通过常规文件I/O调用来查看</p><blockquote><p>/proc称为虚拟文件系统：其中包含的文件和子目录并未存储在磁盘，是由内核在进程访问此类信息时动态创建</p></blockquote><h4 id="1211-进程相关的信息procpid"><a class="markdownIt-Anchor" href="#1211-进程相关的信息procpid"></a> 12.1.1 进程相关的信息：/proc/PID</h4><table><thead><tr><th style="text-align:center">文件</th><th style="text-align:center">描述 （进程属性）</th></tr></thead><tbody><tr><td style="text-align:center">cmdline</td><td style="text-align:center">以\0分隔的命令行参数</td></tr><tr><td style="text-align:center">cwd</td><td style="text-align:center">指向当前工作目录的符号链接</td></tr><tr><td style="text-align:center">environ</td><td style="text-align:center">键值对形式的环境变量列表</td></tr><tr><td style="text-align:center">fd</td><td style="text-align:center">目录，包含指向进程所打开文件的符号链接</td></tr><tr><td style="text-align:center">root</td><td style="text-align:center">指向根目录的符号链接</td></tr><tr><td style="text-align:center">status</td><td style="text-align:center">文件，包含进程的各种信息（进程ID，内存使用，信号）</td></tr><tr><td style="text-align:center">task</td><td style="text-align:center">目录，包含进程内每个线程的相关信息</td></tr><tr><td style="text-align:center">maps</td><td style="text-align:center">进程的内存映射</td></tr><tr><td style="text-align:center">mounts</td><td style="text-align:center">进程的挂载点</td></tr><tr><td style="text-align:center">exe</td><td style="text-align:center">符号链接，指向正在执行的文件</td></tr><tr><td style="text-align:center">mem</td><td style="text-align:center">进程的虚拟内存</td></tr></tbody></table><h4 id="1212-proc目录下的系统信息"><a class="markdownIt-Anchor" href="#1212-proc目录下的系统信息"></a> 12.1.2 /proc目录下的系统信息</h4><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:center">目录中的信息</th></tr></thead><tbody><tr><td style="text-align:center">/proc/net</td><td style="text-align:center">有关网络和套接字的状态信息</td></tr><tr><td style="text-align:center">/proc/sys/fs</td><td style="text-align:center">文件系统的相关设置</td></tr><tr><td style="text-align:center">/proc/sys/kernel</td><td style="text-align:center">内核相关的设置</td></tr><tr><td style="text-align:center">/proc/sys/net</td><td style="text-align:center">网络和套接字的设置</td></tr><tr><td style="text-align:center">/proc/sys/vm</td><td style="text-align:center">内存管理设置</td></tr><tr><td style="text-align:center">/proc/sysvipc</td><td style="text-align:center">有关system V IPC对象的信息</td></tr></tbody></table><h2 id="第14章-系统编程概念"><a class="markdownIt-Anchor" href="#第14章-系统编程概念"></a> 第14章 系统编程概念</h2><h3 id="141-设备专用文件"><a class="markdownIt-Anchor" href="#141-设备专用文件"></a> 14.1 设备（专用）文件</h3><p>设备专用文件与系统的某一设备相对应。在内核中，每种<strong>设备类型</strong>都有与之对应的<strong>驱动程序</strong>，用于处理设备的所有I/O请求。</p><p>设备分类：</p><ul><li>字符型设备，基于每个字符处理数据（如 终端和键盘）</li><li>块设备，每次处理一块数据，块的大小取决于设备类型，磁盘和磁带都属于块设备</li></ul><p>设备文件一般位于/dev目录下，可使用<code>mknod</code>命令创建设备文件</p><h4 id="设备id"><a class="markdownIt-Anchor" href="#设备id"></a> 设备ID</h4><p>每个设备文件主ID和辅ID各一个，主ID标识一般的设备等级（<strong>同一类型</strong>设备），辅ID在一般等级中唯一标识特定设备（<code>ls -l</code>命令可以查看主、辅ID）</p><p>设备文件的inode节点记录了设备文件的主、辅ID，每个<strong>设备驱动程序</strong>将自己与<strong>特定主设备号</strong>的关联关系向内核注册，从而建立设备文件与设备驱动程序之间的关系。</p><h3 id="142-磁盘和分区"><a class="markdownIt-Anchor" href="#142-磁盘和分区"></a> 14.2 磁盘和分区</h3><blockquote><p>普通文件和目录通常放在硬盘设备（磁盘）</p></blockquote><h4 id="磁盘驱动器"><a class="markdownIt-Anchor" href="#磁盘驱动器"></a> 磁盘驱动器</h4><p>磁盘驱动器是一种机械设备，组成部分：</p><ol><li>多个同心圆组成的<strong>磁道</strong>，同一个磁道分为多个<strong>扇区</strong>，每个扇区包含一系列<strong>物理块</strong>（一般为512字节）</li><li>磁头，在磁盘上快速移动，可<strong>获取/修改</strong>磁盘表面的<strong>磁性编码信息</strong></li></ol><p><strong>物理块</strong>代表磁盘驱动器读写的<strong>最小单元</strong></p><p>磁盘读写的过程：</p><ul><li>磁盘移动到相应的磁道（<strong>寻道时间</strong>）</li><li>在相应扇区旋转到磁头下面之前，驱动器会一直等待（<strong>旋转延迟</strong>）</li><li>最后，从所请求的块上传输数据（<strong>传输时间</strong>）</li></ul><p>执行上述<strong>磁盘</strong>操作的时间，可供CPU执行<strong>数百万条</strong>指令</p><h4 id="磁盘分区"><a class="markdownIt-Anchor" href="#磁盘分区"></a> 磁盘分区</h4><blockquote><p>fdisk -l  可以列出磁盘的所有分区</p><p>/proc/partitions 文件记录了每个磁盘分区的主辅设备号、大小和名称</p></blockquote><p>每块磁盘分为一个或多个分区，一般包括：</p><ul><li>文件系统，用于存放常规文件</li><li>数据区域，用作裸设备对其进行访问</li><li>交换区域：供内存管理使用</li></ul><h3 id="143-文件系统"><a class="markdownIt-Anchor" href="#143-文件系统"></a> 14.3 文件系统</h3><blockquote><p>文件系统是对常规文件和目录的组织集合，mkfs用于创建文件系统</p><p>最常见的文件系统是ext2</p><p>/proc/filesystems中可以查看当前内核所知的所有文件系统类型</p></blockquote><h4 id="文件系统结构"><a class="markdownIt-Anchor" href="#文件系统结构"></a> 文件系统结构</h4><blockquote><p>文件系统中分配的基本单元是<strong>逻辑块</strong>，对应文件系统所在磁盘设备上若干个<strong>连续的物理块</strong></p><p>在ext2文件系统中，逻辑块的大小为1024、2048或者4096字节</p></blockquote><p><strong>文件系统包含在磁盘分区</strong>中，主要组成为：</p><ul><li><strong>引导块</strong>，文件系统的<strong>首块</strong>，它不为文件系统所用，其中包含的信息用来<strong>引导操作系统</strong>（操作系统只需要一个引导块，但是所有文件系统都设有引导块）</li><li><strong>超级块</strong>，<strong>引导块之后</strong>的一个独立块，包含文件系统有关的信息，包括：<ul><li>inode节点表的容量</li><li>文件系统中逻辑块的大小</li><li>文件系统中<strong>逻辑块的数量</strong></li></ul></li><li><strong>inode</strong>节点表，文件系统的每个文件或者目录都对应inode节点表中的一条记录，其中记录了文件的元数据信息</li><li><strong>数据块</strong>，用于存放文件中实际的数据</li></ul><h3 id="144-inode节点"><a class="markdownIt-Anchor" href="#144-inode节点"></a> 14.4 inode节点</h3><blockquote><p>驻留在文件系统的每个文件，在inode表中都会对应一个inode（<code>ls -li</code>可查看inode信息）</p></blockquote><p><strong>inode节点</strong>包含的信息包括：</p><ul><li>文件类型（常规文件、目录、符号链接或者字符设备等）</li><li>用户，用户组（UID，GID）</li><li>三类用户的访问权限（user,group,others）</li><li>三个时间戳<ul><li>文件最后访问时间（<code>ls -lu</code>显示）</li><li>文件最后修改时间（<code>ls -l</code>显示）</li><li>文件状态的最后改变时间（<code>ls -lc</code>显示）</li><li>大部分文件系统不会记录文件的<strong>创建时间</strong></li></ul></li><li>指向文件的硬链接数量</li><li>文件大小（字节为单位）</li><li>实际分配给文件的<strong>块数量</strong>（512字节为一个快），不一定完全等于文件字节大小（由于<strong>文件黑洞</strong>，实际分配给文件的块数可能会低于根据文件正常字节大小所计算出来的块数）</li><li>执行文件数据块的指针</li></ul><h4 id="ext2中的inode和数据块指针"><a class="markdownIt-Anchor" href="#ext2中的inode和数据块指针"></a> ext2中的inode和数据块指针</h4><p>ext2在存储文件时，数据块不一定连续，也可能不按照顺序存放。</p><p>内核在inode节点中维护了一组指针，用于定位文件数据块。每个inode包含15个指针，其中前12个指针是直接指向文件的前12个数据块，接着还有一个<strong>间接指针</strong>，一个<strong>双重间接指针</strong>，一个<strong>三重间接指针</strong>。</p><p>间接指针不直接指向数据块，而是指向<strong>指针块</strong>，其中指针的数量取决于文件系统中逻辑块的大小，由于指针大小为4字节，因此指针的数量在256（块大小1024字节）~1024（块大小4096字节）之间。</p><p><img src="https://img-blog.csdn.net/20160701230843587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" /></p><p>inode指针设计：</p><ul><li><p>在维护inode节点大小固定的同时，支持任意大小的文件</p></li><li><p>文件的数据块可以不连续，可以通过<code>lseek()</code>随机访问文件</p></li><li><p>对于大多数小文件，可以通过直接指针快速访问数据块</p></li><li><p>允许文件可以有<strong>黑洞</strong>（将inode节点和间接指针块的相应指针打上标记0，表名并未指向实际的磁盘块，这部分文件黑洞不会分配数据块空间）</p></li></ul><h3 id="145-虚拟文件系统vfs"><a class="markdownIt-Anchor" href="#145-虚拟文件系统vfs"></a> 14.5 虚拟文件系统（VFS）</h3><p>VFS设计原理：</p><ol><li>定义一套通用接口，所有与文件交互的程序按照这些统一接口操作</li><li>每种实际的文件系统根据自己的实际情况，提供不同VFS接口的实现</li></ol><p>底层文件系统会将错误代码传回VFS层，VFS会将错误代码传回应用程序</p><h3 id="146-日志文件系统"><a class="markdownIt-Anchor" href="#146-日志文件系统"></a> 14.6 日志文件系统</h3><blockquote><p>文件的一致性检查：系统崩溃时，文件的更新可能只完成了一部分，文件系统元数据（目录项、inode信息、数据块指针）处于不一致的状态，系统重启时，需要遍及整个文件系统进行检查，过程比较耗时</p></blockquote><p>日志文件系统避免了漫长的一致性检查</p><ul><li>在实际更新元数据之前，会先将更新操作记录与专用的磁盘日志文件中，对元数据的更新以<strong>事务</strong>的方式进行</li><li>一旦系统崩溃，系统重启后利用日志重做（redo）任何不完整的更新</li><li>文件状态很快恢复，但是<strong>增加了文件更新的时间</strong></li></ul><p>常见的日志文件系统：</p><ol><li>Reiserfs</li><li>ext3</li><li>JFS</li><li>XFS</li><li>ext4</li><li>Btrfs</li></ol><h3 id="147-单根目录层级和挂载点"><a class="markdownIt-Anchor" href="#147-单根目录层级和挂载点"></a> 14.7 单根目录层级和挂载点</h3><blockquote><p>Linux中所有文件系统的文件都位于单根目录树下，树根为根目录&quot;/&quot;。其他文件系统都挂载到根目录之下，视为整个目录层级的子树</p></blockquote><p>挂载命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount device directory</span><br></pre></td></tr></table></figure><h3 id="1410-虚拟内存文件系统tmpfs"><a class="markdownIt-Anchor" href="#1410-虚拟内存文件系统tmpfs"></a> 14.10 虚拟内存文件系统：tmpfs</h3><p>普通的文件系统都驻留在磁盘上，同时Linux也支持驻留在内存中的虚拟文件系统</p><p>最复杂的为<strong>tmpfs</strong>，和其他内存文件系统不同在于它属于<strong>虚拟内存文件系统</strong>，它不仅使用RAM，在RAM耗尽的情况下，还会使用<strong>交换空间</strong>。</p><p>创建tmpfs的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount -t tmpfs <span class="built_in">source</span> target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">mount -t tmpfs newtmp /tmp</span><br></pre></td></tr></table></figure><ul><li>source：可以为任意名称</li><li>target：该文件系统的挂载点</li></ul><p>除了用于用户应用程序之外，tmpfs还有两个特殊用途：</p><ul><li>内核<strong>内部挂载</strong>的隐形tmpfs，用于<strong>实现System V共享内存和共享匿名内存映射</strong></li><li>挂载与**/tmp/shm<strong>的tmpfs，为glibc用于</strong>实现POSIX共享内存和POSIX信号量**</li></ul><h2 id="第18章-目录和链接"><a class="markdownIt-Anchor" href="#第18章-目录和链接"></a> 第18章 目录和链接</h2><h2 id="第34章-进程组-会话和作业控制"><a class="markdownIt-Anchor" href="#第34章-进程组-会话和作业控制"></a> 第34章 进程组、会话和作业控制</h2><h2 id="第37章-daemon守护进程"><a class="markdownIt-Anchor" href="#第37章-daemon守护进程"></a> 第37章 DAEMON守护进程</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;linuxunix系统编程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linuxunix系统编程&quot;&gt;&lt;/a&gt; Linux/Unix系统编程&lt;/h1&gt;
&lt;h2 id=&quot;第12章-系统和进程信息&quot;&gt;&lt;a cla</summary>
      
    
    
    
    <category term="书籍存档" scheme="https://www.snowmoon.top/categories/%E4%B9%A6%E7%B1%8D%E5%AD%98%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.snowmoon.top/2024/06/01/%E4%B9%A6%E7%B1%8D%E5%AD%98%E6%A1%A3-Linux-kernel-notes-master-Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.snowmoon.top/2024/06/01/%E4%B9%A6%E7%B1%8D%E5%AD%98%E6%A1%A3-Linux-kernel-notes-master-Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-06-01T05:46:44.947Z</published>
    <updated>2024-10-19T15:22:29.418Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="linux内核设计与实现"><a class="markdownIt-Anchor" href="#linux内核设计与实现"></a> Linux内核设计与实现</h1><h2 id="第3章-进程管理"><a class="markdownIt-Anchor" href="#第3章-进程管理"></a> 第3章 进程管理</h2><h3 id="31-进程"><a class="markdownIt-Anchor" href="#31-进程"></a> 3.1 进程</h3><blockquote><p>进程：处于执行期的程序以及相关资源（打开的文件、挂起的信号、内核内部数据、处理器状态等）的总称</p><p>线程：是在进程中活动的对象，每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，不是进程</p><p>Linux不区分进程和线程，对它来说，线程只不过是一种特殊的进程而已</p></blockquote><p>现代操作系统的两种<strong>虚拟机制</strong>：</p><ul><li>虚拟处理器：给进程一种假象，让它觉得自己在独享处理器</li><li>虚拟内存：让进程在分配和管理内存时觉得自己拥有整个系统的内存资源</li></ul><p><strong>注意</strong>：线程之间可以共享虚拟内存，但是都拥有自己的虚拟处理器</p><h3 id="32-进程描述"><a class="markdownIt-Anchor" href="#32-进程描述"></a> 3.2 进程描述</h3><p>内核把进程的列表存放在叫做<strong>任务队列</strong>的双向循环链表中。链表中的每一项类型为<code>task_struct</code>，称为<strong>进程描述符</strong>的结构，描述了一个具体进程的所有信息</p><h4 id="321-分配进程描述符"><a class="markdownIt-Anchor" href="#321-分配进程描述符"></a> 3.2.1 分配进程描述符</h4><p>Linux通过slab分配器分配<code>task_struct</code>结构，这样能够<strong>对象复用</strong>和<strong>缓存着色</strong>。</p><p>每个任务的<code>thread_info</code>结构在它的内核栈尾端分配，其中<code>task</code>域存放的是指向该任务实际<code>task_struct</code>的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span> *<span class="title">exec_domain</span>;</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="322-进程描述符的存放"><a class="markdownIt-Anchor" href="#322-进程描述符的存放"></a> 3.2.2 进程描述符的存放</h4><p>在内核中，访问任务需要获取指向<code>task_struct</code>结构的指针，通过<code>current</code>宏查找到当前进程的进程描述符，这个查找的<strong>速度</strong>很重要</p><p>有的硬件体系结构拿出一个专门的寄存器存放当前进程的<code>task_struct</code>指针，而有些像x86的体系结构（寄存器不太富余），就只能在<strong>内核栈的尾部</strong>创建<code>thread_info</code>结构，通过计算偏移量间接找到<code>task_struct</code>结构</p><h4 id="323-进程状态"><a class="markdownIt-Anchor" href="#323-进程状态"></a> 3.2.3 进程状态</h4><p>进程描述符中的<code>state</code>域描述了进程的当前状态。系统中进程的状态包括：</p><ul><li><strong>TASK_RUNNING</strong>(运行或就绪)：进程是可执行的</li><li><strong>TASK_INTERRUPTIBLE</strong>(可中断睡眠)</li><li><strong>TASK_UNINTERRUPTIBLE</strong>(不可中断睡眠)</li><li><strong>__TASK_TRACED</strong>：被其他进程跟踪的进程，例如ptrace调试的程序</li><li><strong>__TASK_STOPPED</strong>：被暂停执行的任务，通常在接收到<strong>SIGSTOP</strong>,<strong>SIGTSTP</strong>,<strong>SIGTTIN</strong>,<strong>SIGTTOU</strong>等信号时</li></ul><h4 id="324-设置当前状态"><a class="markdownIt-Anchor" href="#324-设置当前状态"></a> 3.2.4 设置当前状态</h4><p>使用<code>set_task_state(task,state)</code>函数</p><h4 id="326-进程家族树"><a class="markdownIt-Anchor" href="#326-进程家族树"></a> 3.2.6 进程家族树</h4><p>所有的进程都是PID为1的init进程的后代，内核在系统启动的最后阶段启动init进程，该进程读取系统的初始化脚本（initsctript）并执行其他的相关程序，最终完成系统启动的整个过程</p><p>每个<code>task_struct</code>结构都包含一个指向其父进程<code>task_struct</code>结构的<code>parent</code>指针，还包含一个<code>children</code>的子进程链表</p><h3 id="33-进程创建"><a class="markdownIt-Anchor" href="#33-进程创建"></a> 3.3 进程创建</h3><p>Unix将进程的创建分解到两个单独的函数中去执行：fork()和exec()</p><p>首先，fork()通过拷贝当前进程创建一个子进程，exec()负责读取可执行文件并将其载入地址空间开始运行</p><h4 id="331-写时拷贝"><a class="markdownIt-Anchor" href="#331-写时拷贝"></a> 3.3.1 写时拷贝</h4><p>Linux的fork()使用<strong>写时拷贝</strong>页实现，是一种推迟甚至免除拷贝数据的技术，在创建子进程时，内核并不复制整个进程地址空间，而是让父子进程共享一个拷贝，只有在写入的时候，数据才会被复制。在页根本不会被写入的情况下，例如fork()之后马上exec()，进程的地址空间就不用复制了</p><p>fork()的实际开销：复制父进程的页表以及给子进程创建唯一的进程描述符</p><h4 id="332-fork"><a class="markdownIt-Anchor" href="#332-fork"></a> 3.3.2 fork()</h4><p>Linux通过clone()实现fork()，clone()通过一系列参数指明父子进程需要共享的资源。fork(),vfork()和__clone()库函数都根据各自需要的参数标志去调用clone()，然后在clone()中调用do_fork()</p><p>do_fork()调用copy_process()函数，然后让进程运行。copy_process()函数的过程：</p><ul><li>调用<code>dup_task_struct()</code>为进程创建一个内核栈、thread_info结构和task_struct，与父进程的值相同，此时父子进程的描述符是相同的</li><li>检查创建子进程后，当前用户拥有的进程数不超过分配资源限制</li><li>子进程开始将自己与父进程区分开：进程描述符内的很多成员清0或者初始化，大部分的数据未被修改</li><li>子进程状态设置为UNINTERRUPTIBAL，保证它不会投入运行</li><li>copy_process()调用copy_flags()更新task_struct的flags成员：其中代表进程是否拥有超级用户权限的PF_SUPERPRIV标志清0，代表进程还没有调用exec()函数的PF_FORKNOEXEC的标志被设置</li><li>调用alloc_pid()为子进程分配PID</li><li>根据clone()传递进来的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。（一般这些资源会被进程的<strong>所有线程共享</strong>）</li><li>最后，copy_process()做扫尾工作并返回一个指向子进程的指针</li></ul><p>copy_process()返回到do_fork()函数，如果copy_process()返回成功，新创建的子进程被唤醒并投入运行</p><p><strong>注意</strong>：内核有意选择子进程首先执行，因为一般子进程会调用exec()函数，这样可以避免写时拷贝的额外开销</p><h4 id="333-vfork"><a class="markdownIt-Anchor" href="#333-vfork"></a> 3.3.3 vfork()</h4><p>除了<strong>不拷贝父进程的页表项</strong>，vfork()和fork()的功能相同</p><h3 id="34-线程在linux中的实现"><a class="markdownIt-Anchor" href="#34-线程在linux中的实现"></a> 3.4 线程在Linux中的实现</h3><p>Linux实现线程的机制非常独特，从内核的角度来说，并没有线程这个概念，Linux把所有的<strong>线程当做进程</strong>来实现。线程仅仅被视为一个与其他进程共享某些资源的进程，拥有唯一隶属于自己的<code>task_struct</code>。</p><p>Windows和Sun Solaris等系统都提供了专门支持线程的机制（将线程称为<strong>轻量级进程</strong>），相较于重量级的进程，线程被抽象成一种耗费较少资源，运行迅速的执行单元。而对于Linux，线程只是<strong>进程间共享资源的一种手段</strong>。</p><p>举例说明：对于一个包含四个线程的进程，在提供专门线程支持的系统，通常会有一个包含指向四个不同线程的指针的进程描述符，该描述符负责描述像地址空间、打开的文件等共享资源。而Linux只是创建四个进程并分配四个普通的<code>task_struct</code>结构，并指定它们共享某些资源。</p><h4 id="341-创建线程"><a class="markdownIt-Anchor" href="#341-创建线程"></a> 3.4.1 创建线程</h4><p>线程的创建和普通进程类似，只是需要在调用clone()时传递一些参数标志来指明共享的资源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>调用的结果和fork()差不多，只是父子进程<strong>共享地址空间、文件系统资源、打开的文件描述符和信号处理程序</strong></p><p>传递给clone()的参数标志决定了<strong>新创建进程的行为方式和父子进程之间共享的资源种类</strong>，详见<strong>P29 表3-1</strong></p><h4 id="342-内核线程"><a class="markdownIt-Anchor" href="#342-内核线程"></a> 3.4.2 内核线程</h4><blockquote><p>内核线程用于内核在后台执行一些任务，他们是独立运行在内核空间的标准进程</p><p>内核线程和普通进程的区别是：<strong>内核线程没有独立的地址空间</strong>（指向地址空间的mm指针为NULL），它们只在内核空间运行，不切换到用户空间。</p></blockquote><p>例如软中断ksoftirqd和flush都是内核线程的例子</p><p>内核是通过从kthreadd内核进程衍生出所有新的内核线程，从现有内核线程创建一个新的内核线程的方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">thread_create</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data), <span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> namefmt[], ...)</span></span><br></pre></td></tr></table></figure><p>新的内核线程是由kthreadd进程通过clone()系统调用创建，它们将运行threadfn函数，传递的参数是data，进程命名为namefmt。</p><p>新创建的进程处于不可运行状态，需要通过wake_up_process()唤醒来运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">thread_run</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data), <span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> namefmt[], ...)</span></span><br></pre></td></tr></table></figure><p><code>thread_run</code>方法先调用<code>thread_run</code>方法，然后调用<code>wake_up_process()</code></p><p>内核线程启动后一直运行直到调用<code>do_exit()</code>退出，或者内核的其他部分调用<code>kthread_stop()</code>退出（传递给kthread_stop()的参数是kthread_create()返回的task_struct结构地址）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthread_stop</span><span class="params">(<span class="keyword">struct</span> task_struct *k)</span></span><br></pre></td></tr></table></figure><h3 id="35-进程终结"><a class="markdownIt-Anchor" href="#35-进程终结"></a> 3.5 进程终结</h3><p>进程终结的几种情况：</p><ul><li>显式的调用<code>exit()</code></li><li>隐式地在某个程序的主函数返回（C语言在main(）函数的返回点防止调用exit()的代码）</li><li>接收到不能处理也不能忽略的信号或者异常时，被动地终结</li></ul><p>不管进程如何终结，大部分都是靠<code>do_exit()</code>（定义在kernel/exit.c）来完成，它的主要工作包括：</p><ul><li>将task_struct的标志成员设置为PF_EXITING</li><li>调用<code>del_timer_sync()</code>删除任一内核定时器，确保没有定时器在排队，且没有定时器处理程序在运行</li><li>如果BSD记账功能开启，调用<code>acct_update_intergrals()</code>来输出记账信息</li><li>调用<code>exit_mm()</code>函数释放进程占用的mm_struct，如果没有别的进程在使用它（没有被共享），就彻底释放它们</li><li>调用<code>sem__exit()</code>函数，如果进程排队等候IPC信号，则它离开队列</li><li>调用<code>exit_files()</code>和<code>exit_fs()</code>来分别递减文件描述符和文件系统数据的引用计数，如果引用计数降为0，就可以直接释放</li><li>接着将存放在task_struct的exit_code成员中的任务退出代码置为<code>exit()</code>提供的退出代码。<strong>退出代码存放在这里供父进程检索</strong></li><li>调用<code>exit_notify()</code>向父进程发送信号，给自己的子进程重新找<strong>养父</strong>（为进程组的其他线程或者init进程），并把进程的状态（task_struct中的exit_state）设置为EXIT_ZOMBIE</li><li>调用<code>schedule()</code>切换到新的进程，因为EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程执行的最后一段代码。<code>do_exit()</code>永不返回</li></ul><p>至此，与进程相关联的所有资源都释放掉了（假设该进程是这些资源的唯一使用者），进程不可运行且处于EXIT_ZOMBIE状态，他占用的所有内存包括<strong>内核栈、thread_info结构和task_struct结构</strong>。此时存在的唯一目的就是向它的父进程提供信息用于检索，父进程通知内核都是无关的信息后，进程所持有的剩余内存被释放，归还给系统使用</p><h4 id="351-删除进程描述符"><a class="markdownIt-Anchor" href="#351-删除进程描述符"></a> 3.5.1 删除进程描述符</h4><p>在调用<code>do_exit()</code>后，进程处于僵死状态不再运行，但是系统保留了它的进程描述符，这样可以<strong>让系统能在进程中杰后仍能获取它的信息</strong>。可以看到，<strong>进程终结时所做的清理工作和进程描述符的删除是分开执行的</strong>，在父进程获得已终结的子进程信息后，通知内核它不关注这些信息后，子进程的task_struct结构被释放</p><p>回收子进程状态是通过wait()一族函数实现，他们都是通过唯一的系统调用<code>wait4()</code>来实现，它首先会挂起调用它的进程，直到有一个子进程退出，此时函数返回子进程的PID，调用<strong>该函数提供的指针指向子进程的退出代码</strong></p><p>当需要释放进程描述符时，会调用<code>release_task()</code>函数，它的工作包括：</p><ul><li>调用<code>__exit_signal()</code>，该函数调用<code>_unhash_process()</code>，后者再调用<code>detach_pid()</code>从pidhash上删除该进程，同时从任务列表中删除该进程</li><li><code>__exit_signal()</code>函数释放目前僵死进程所使用的所有剩余资源，进行最终统计和记录</li><li>如果这个进程是进程组的最后一个进程，且领头进程（进程组首进程）已经死掉，那么<code>release_task()</code>就通知僵死的领头进程的父进程</li><li><code>release_task()</code>调用<code>put_task_struct()</code>释放进程内核栈和thread_info结构所占的内存页，并释放task_struct占用的slab高速缓存</li></ul><p>至此，进程描述符和所有进程独享的资源全部释放</p><h4 id="352-孤儿进程造成的进退维谷"><a class="markdownIt-Anchor" href="#352-孤儿进程造成的进退维谷"></a> 3.5.2 孤儿进程造成的进退维谷</h4><p>当父进程在子进程之前推出时，需要保证子进程找到一个新的父进程，否则这些孤儿进程就会在退出时一直处于僵死状态。</p><p>解决方法是：给子进程在当前进程组找一个进程作为父亲，如果不行，就让init进程作为父进程</p><p>在<code>do_exit()</code>中会调用<code>exit_nodify()</code>，该函数调用<code>forget_original_parent()</code>，后者再调用<code>find_new_reaper()</code>进程寻父过程。</p><p>代码中会遍历两个链表：<strong>子进程链表和ptrace子进程链表</strong>，给每个子进程设置新的父进程。</p><p><strong>注意</strong>：当一个进程被跟踪时，它的临时父亲被设置为调试进程，如果他们真正的父进程退出，系统会为它及其兄弟进程找一个父进程。以前的内核版本中需要遍历系统所有的进程来找到这些子进程，现在只需要遍历这个单独ptrace的子进程链表，减轻了遍历的时间消耗</p><h2 id="第4章-进程调度"><a class="markdownIt-Anchor" href="#第4章-进程调度"></a> 第4章 进程调度</h2><blockquote><p>进程调度程序：在可运行态进程之间分配有限处理器时间资源的<strong>内核子系统</strong>。</p></blockquote><h3 id="41-多任务"><a class="markdownIt-Anchor" href="#41-多任务"></a> 4.1 多任务</h3><blockquote><p>多任务操作系统是同时并发地交互执行多个进程的操作系统，能使多个进程处于阻塞或者睡眠状态，这些任务位于内存中，但是并不处于可运行状态，他们利用内核阻塞自己，直到某一时间（键盘输入、网络数据等）发生。</p></blockquote><p>多任务系统分为两类：</p><ul><li>非抢占式多任务</li><li>抢占式多任务</li></ul><p>Linux提供了抢占式的多任务模式，由调度程序决定什么时候停止一个进程的运行，以便其他进程得到运行机会，这个强制的挂起动作叫做抢占。</p><p>时间片：可运行进程在被抢占之前预先设置好的处理器时间段。</p><p>非抢占任务模式下，除非进程自己主动停止运行，否则他会一直运行。进程主动挂起自己的操作称为<strong>让步</strong>（yielding）</p><p>非抢占任务模式的缺点：调度程序无法对每个进程该执行多长时间做出统一规定，进程独占的CPU时间可能超出预期，另外，一个绝不做出让步的悬挂进程就能使系统崩溃</p><h3 id="42-linux的进程调度"><a class="markdownIt-Anchor" href="#42-linux的进程调度"></a> 4.2 Linux的进程调度</h3><p>2.6内核系统开发初期，为了提供对交互程序的调度性能，引入新的调度算法，最为著名的是<strong>反转电梯最后期限调度算法</strong>（RSDL），在2.6.3版本替代了<strong>O(1)调度算法</strong>，最后被称为<strong>完全公平调度算法(CFS)</strong></p><h3 id="43-策略"><a class="markdownIt-Anchor" href="#43-策略"></a> 4.3 策略</h3><h4 id="431-io消耗型和cpu消耗型的进程"><a class="markdownIt-Anchor" href="#431-io消耗型和cpu消耗型的进程"></a> 4.3.1 I/O消耗型和CPU消耗型的进程</h4><p>CPU消耗型进程把时间大多用在了执行代码上，不属于I/O驱动类型，从系统响应速度考虑，调度策略往往是降低它们的调度频率，而延长其运行时间</p><p>调度策略的主要矛盾是：<strong>进程响应迅速和最大系统利用率（高吞吐量）</strong></p><p>Unix系统的调度程序更倾向于I/O消耗型程序，以提供更好的响应速度。Linux为了保证交互式应用和桌面系统的性能，对进程的响应做了优化（缩短响应时间），更倾向于调度I/O消耗型进程。</p><h4 id="432-进程优先级"><a class="markdownIt-Anchor" href="#432-进程优先级"></a> 4.3.2 进程优先级</h4><p>调度程序总是选择时间片为用尽而且优先级最高的进程运行</p><p>Linux采用了两种不同的优先级范围：</p><ul><li>第一种用nice值，范围-20~+19，默认值0；越大的nice值优先级越低。相比高nice值（低优先级）的进程，低nice值（高优先级）的进程可以获得更多的处理器时间</li><li>第二种是实时优先级，数值可配置，默认范围是0~99，数值越大优先级越高。任何实时进程的优先级都比普通进程高，实时优先级和nice优先级处于互不相交的范畴</li></ul><h4 id="433-时间片"><a class="markdownIt-Anchor" href="#433-时间片"></a> 4.3.3 时间片</h4><p>调度策略选择合适的时间片并不简单，时间片太短会增加进程切换的处理器消耗，太长会导致系统的交互响应变差</p><p>Linux的CFS调度器没有直接分配时间片到进程，它是将<strong>处理器的使用比</strong>划分给进程，所以进程所获得的时间片时间是和**系统负载（系统活跃的进程数）**密切相关的</p><p>Linux中新的CFS调度器，它的进程抢占时机取决于<strong>新的可运行程序消耗了多少处理器使用比</strong>。如果消耗的处理器使用比比当前进程小，则新进程投入运行（当前进程被强占），否则，推迟运行。</p><p><strong>总而言之，CFS会先根据进程的nice值预期设定每个进程的cpu使用比，而在进程调度时，需要将新的被唤醒进程实际消耗的cpu使用比和当前进程比较，如果更小，则抢占当前进程，投入运行，否则，推迟运行</strong></p><h3 id="44-linux调度算法"><a class="markdownIt-Anchor" href="#44-linux调度算法"></a> 4.4 Linux调度算法</h3><h4 id="441-调度器类"><a class="markdownIt-Anchor" href="#441-调度器类"></a> 4.4.1 调度器类</h4><p>Linux调度器以模块提供，允许不同类型的进程针对性地选择调度算法，这种模块化结构成为<strong>调度器类</strong>，它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。</p><p>完全公平调度(CFS)是一个针对普通进程的调度类，称为<strong>SCHED_NORMAL</strong>，具体算法实现定义在文件kernel/sched_fair.c中</p><h4 id="442-unix系统中的进程调度"><a class="markdownIt-Anchor" href="#442-unix系统中的进程调度"></a> 4.4.2 Unix系统中的进程调度</h4><p>传统Unix系统调度：进程启动会有默认的时间片，具有高优先级的进程将运行的更频繁，而且被赋予更多的时间片。存在的问题如下：</p><ul><li>nice映射到时间片，就会将nice单位值对应到处理器的绝对时间，这样将会导致进程切换无法最优化进行，同时会导致进程获得的处理器时间很大程度上取决于其nice初始值。场景实例详见<strong>P40</strong></li><li>时间片一般为系统定时器节拍的整数倍，它会随着定时器节拍改变</li></ul><p>CFS采用的方法是：<strong>完全摒弃时间片而是分配给进程一个处理器使用比重</strong>，确保了调度中恒定的公平性，切换频率是在动态变化中</p><h4 id="443-公平调度"><a class="markdownIt-Anchor" href="#443-公平调度"></a> 4.4.3 公平调度</h4><blockquote><p>完美的多任务系统：每个进程获得1/<em>n</em>的处理器时间（<em>n</em>是指可运行进程的数量），同时调度给他们无限小的时间周期（交互性会很好）</p></blockquote><p>CFS的做法：<strong>允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程</strong>，在所有进程总数基础上计算一个进程应该运行多久，不在依靠nice值计算绝对的时间片，而是作为<strong>进程获得的处理器运行比的权重</strong>，越高的nice值获得更低的处理器使用权重。</p><p>每个进程按照其权重在全部可运行进程中所占比例的“时间片”来运行，由于越小的调度周期（重新调度所有可运行进程所花的时间）交互性会越好，也就更接近完美的所任务，CFS为调度周期设定一个目标（无限小的调度周期近似值）。</p><p>当可运行任务数量区域无限大时，他们所获得的处理器使用比和时间片将趋近于0（这会增加CPU的切换消耗）。因此，CFS引入每个进程获得的时间片底线，称为最小粒度。而当进程数非常多时，由于这个最小粒度的存在，调度周期会比较长，因此CFS并非完美的多任务。</p><p><strong>总之，在CFS中任何进程所获得的的处理器时间是由它自己和其他所有可运行进程nice值的相对差值决定的，nice值对时间片的作用不再是算数加权，而是几何加权，CFS是近乎完美的多任务</strong></p><h3 id="45-linux调度的实现"><a class="markdownIt-Anchor" href="#45-linux调度的实现"></a> 4.5  Linux调度的实现</h3><p>Linux调度主要关注四个部分：</p><ul><li>时间记账</li><li>进程选择</li><li>调度器入口</li><li>睡眠和唤醒</li></ul><h4 id="451-时间记账"><a class="markdownIt-Anchor" href="#451-时间记账"></a> 4.5.1 时间记账</h4><ol><li><p>调度器实体结构</p><p>CFS不再有时间片的概念，但是它会维护每个进程运行的时间记账，需要确保每个进程在分配给它的处理器时间内运行。CFS使用<strong>调度器实体</strong>（文件&lt;linux/sched.h&gt;中的struct_sched_entity中）来追踪进程运行记账</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">run_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">group_node</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    u64 vruntime;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调度器实体结构作为一个名为se的成员变量，嵌入在进程描述符task_struct内</p></li><li><p>虚拟实时</p><p>vruntime变量存放进程的虚拟运行时间，这个数值的计算是经过所有可运行进程总数的标准化，以ns为单位，与定时器节拍无关</p><p>定义在kernel/sched_fair.h文件中的update_curr()函数实现记账功能，它是系统定时器周期性调用，无论进程是在可运行态还是阻塞状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_curr</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    __update_curr(cfs_rq, curr, delta_exec)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="452-进程选择"><a class="markdownIt-Anchor" href="#452-进程选择"></a> 4.5.2 进程选择</h4><p><strong>CFS</strong>算法调度核心：<strong>当CFS需要选择下一个运行进程时，选择具有最小vruntime的进程</strong></p><p><strong>CFS</strong>使用红黑树组织可运行进程队列，红黑树的键值为vruntime，检索对应节点的时间复杂度为对数级别</p><ol><li><p>挑选下一个任务</p><p>CFS选择进程的算法为：运行rbtree中最左边叶子结点代表的那个进程。实现的函数是<code>__pick_next_entity()</code>，定义在kernel/sched_fair.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *__<span class="title">pick_next_entity</span>(<span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">left</span> =</span> cfs_rq-&gt;rb_leftmost;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rb_entry(left, <span class="keyword">struct</span> sched_entity, run_node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果该函数返回值为NULL，说明树中没有任何节点，代表没有可运行进程，CFS调度器选择idle任务运行</p></li><li><p>向树中加入进程</p><p>当<strong>进程变为可运行状态（被唤醒）或者通过fork()调用第一次创建进程时</strong>，会将进程加入到rbtree。<code>enqueue_entity()</code>函数实现了这个过程，代码详见P45</p></li><li><p>从树中删除进程</p><p>删除动作发生在<strong>进程阻塞（变为不可运行状态）或者终止（结束运行）</strong>，是由函数<code>dequeue_entity()</code>函数完成</p></li></ol><h4 id="453-调度器入口"><a class="markdownIt-Anchor" href="#453-调度器入口"></a> 4.5.3 调度器入口</h4><p>进程调度的入口函数是<code>schedule()</code>，定义在kernel/sched.c文件，<strong>它是内核其他部分调用进程调度器的入口</strong>。</p><p><code>schedule()</code>通常需要和一个调度类相关联，它会先找到一个最高优先级的调度类，后者要有自己的可运行进程队列，然后这个调度类决定下一个可运行的进程。</p><p>因此，<code>schedule()</code>函数的逻辑比较简单，它的主要逻辑就是调用<code>pick_next_task()</code>，这个函数会以优先级为序，从高到低一次检查每个调度器类，从最高优先级的调度类中选择下一个运行的进程。详细代码见<strong>P48</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> <span class="title class_">task_struct</span> *<span class="built_in">pick_next_task</span>(<span class="keyword">struct</span> rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个调度类都实现了<code>pick_next_task()</code>函数，它会返回指向下一个可运行进程的指针，在CFS中<code>pick_next_task()</code>会调用<code>pick_next_entity()</code>，该函数会调用 [4.5.2节](#4.5.2 进程选择) 提到的<code>__pick_next_entity()</code></p><p><strong>函数优化</strong>：由于CFS是普通进程的调度类，而系统绝大多数进程是普通进程。函数使用了一个小技巧，当所有可运行进程数等于CFS类对应的可运行进程数时，直接返回CFS调度类的下一个运行进程</p><h4 id="454-睡眠和唤醒"><a class="markdownIt-Anchor" href="#454-睡眠和唤醒"></a> 4.5.4 睡眠和唤醒</h4><p>睡眠（或阻塞）的进程处于一个特殊的不可运行状态。</p><p>进程睡眠时，进程把自己标记为休眠状态，从可执行进程对应的红黑树中移出，放入等待队列，然后调用<code>schedule()</code>调度下一个进程；唤醒的过程相反：进程被设置成可执行状态，然后从等待队列移到可执行红黑树中</p><ol><li><p>等待队列</p><p>等待队列是由<strong>等待某些事件发生的进程组成的简单链表</strong>，内核用<code>wake_queue_head_t</code>代表等待队列</p><p>进程加入等待队列的详细过程和代码详见<strong>P50</strong></p></li><li><p>唤醒</p><p>唤醒操作通过函数<code>wake_up()</code>进行，它会唤醒等待队列上的所有进程，它调用函数<code>tey_to_wake_up()</code>将进程状态设置为<strong>TASK_RUNNING</strong>，调用<code>enqueue_task()</code>将此进程放入红黑树，如果被唤醒的进程比当前正在执行的进程优先级高（这里不是指nice值，而是根据CFS调度的cpu使用比规则得出的结果），还要设置进程的need_resched标志。</p><p><strong>注意</strong>：通常哪段代码促使等待条件达成，它就要负责调用<code>wake_up()</code>函数。例如，当磁盘数据到来时，VFS需要负责对等待队列调用<code>wake_upe()</code>。</p></li></ol><h3 id="46-抢占和上下文切换"><a class="markdownIt-Anchor" href="#46-抢占和上下文切换"></a> 4.6 抢占和上下文切换</h3><p>上下文切换由定义在kernel/sched.c中的context_switch()函数负责处理。每当一个新的进程被选出来投入运行的时候，schedule()会调用函数context_switch()，后者完成两项工作：</p><ul><li>调用声明在&lt;asm/mmu_context.h&gt;中的switch_mm()函数，它负责将虚拟内存从上一个进程映射切换到新进程中</li><li>调用声明在&lt;asm/system.h&gt;的switch_to()，负责从上一个进程的处理器状态切换到新进程的处理器状态，其中包括<strong>保存、恢复栈信息和寄存器信息</strong></li></ul><p>内核提供一个<code>need_resched</code>标志标明是否需要重新执行一次调度，2.2以前放在全局变量，2.2~2.4在每个进程的进程描述符中（由于current宏速度很快并且进程描述符通常是在高速缓存中，访问<code>task_struct</code>内的数值比全局变量更快），而在2.6版本中，它放在thread_info结构体中，用一个特别的标志变量的一位来表示。</p><p><code>need_resched</code>标志被设置的时机：</p><ul><li>当某个进程应该被抢占时，scheduler_tick()函数会设置这个标志</li><li>当一个优先级更高的进程进入可运行状态时，try_to_wake_up()也会设置这个标志</li></ul><p>然后内核检查该标志，确认被设置后，会调用schedule()切换到一个新进程</p><h4 id="461-用户抢占"><a class="markdownIt-Anchor" href="#461-用户抢占"></a> 4.6.1 用户抢占</h4><p>内核在中断处理程序或者系统调用返回后，都会检查<code>need_resched</code>标志。从中断处理程序或者系统调用返回的返回路径都是跟体系结构相关，在entry.S(包含内核入口和退出的代码)文件通过汇编实现</p><p>当内核将返回用户空间的时候，如果<code>need_resched</code>标志被设置，会导致schedule()调用，会发生用户抢占</p><p>因此，用户抢占发生在以下情况：</p><ul><li>系统调用返回用户空间时</li><li>中断处理程序返回用户空间时</li></ul><h4 id="462-内核抢占"><a class="markdownIt-Anchor" href="#462-内核抢占"></a> 4.6.2 内核抢占</h4><blockquote><p>在没有内核抢占的系统中，调度程序没有办法在一个内核级的任务正在执行时重新调度，内核中的任务以协作方式调度，不具备抢占性，内核代码一直执行到完成（返回用户空间）或者阻塞为止</p></blockquote><p>在2.6版本，Linux内核引入抢占能力，只要重新调度是<strong>安全的</strong>（没有持有锁的情况），内核可以在任何时间抢占正在执行的任务。</p><p>在每个进程的thread_info结构中加入preempt_count计数，代表进程使用锁的个数。</p><ul><li>在中断返回内核空间的时候，会检查need_resched和preempt_count，如果need_resched被设置且preempt_count为0，则可以进行安全的抢占，调度程序schedule()会被调用，否则，中断直接返回当前进程</li><li>如果进程持有的所有锁被释放，preempt_count会减为0，此时释放锁的代码会检查need_resched标志，如果被设置，则调用schedule()</li></ul><p>因此，内核抢占发生在：</p><ul><li>中断处理程序正在执行，且返回内核空间之前</li><li>进程在内核空间释放锁的时候</li><li>内核任务显式的调用schedule()</li><li>内核中的任务阻塞</li></ul><h3 id="47-实时调度策略"><a class="markdownIt-Anchor" href="#47-实时调度策略"></a> 4.7 实时调度策略</h3><blockquote><p>Linux提供了一种软实时的工作方式</p><p>软实时的定义：内核调度进程尽力使进程在规定时间到来前运行，但是内核不能总是满足这些进程的要求</p><p>硬实时的定义：保证在一定条件下，可以完全满足进程在规定的时间内完成操作</p></blockquote><p>Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR，普通的、非实时的调度策略是SCHED_NORMAL。实时策略不被CFS调度器管理，而是被一个特殊的实时调度器管理</p><p>SCHED_FIFO实现了<strong>简单的、先入先出的调度算法</strong>，它不使用时间片，SCHED_RR和前者大致相同，不同点在于它使用时间片，是一种<strong>实时轮转调度算法</strong></p><h2 id="第5章-系统调用"><a class="markdownIt-Anchor" href="#第5章-系统调用"></a> 第5章 系统调用</h2><h2 id="第6章-内核数据结构"><a class="markdownIt-Anchor" href="#第6章-内核数据结构"></a> 第6章 内核数据结构</h2><h2 id="第7章-中断和中断处理"><a class="markdownIt-Anchor" href="#第7章-中断和中断处理"></a> 第7章 中断和中断处理</h2><h2 id="第8章-下半部和推后执行的工作"><a class="markdownIt-Anchor" href="#第8章-下半部和推后执行的工作"></a> 第8章 下半部和推后执行的工作</h2><h2 id="第12章-内存管理"><a class="markdownIt-Anchor" href="#第12章-内存管理"></a> 第12章 内存管理</h2><blockquote><p>内核不能像用户空间那样奢侈的使用内存，获取内存币用户空间复杂很多</p></blockquote><h3 id="121-页"><a class="markdownIt-Anchor" href="#121-页"></a> 12.1 页</h3><p>内核把物理页作为内核管理的基本单元，内存管理单元（MMU）是管理内存并将虚拟内存转换为物理内存的硬件，它以页为单位来管理系统中的页表</p><p>结构体struct page表示系统中的每个物理页</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        flags,</span><br><span class="line">    <span class="type">atomic_t</span>             _count,</span><br><span class="line">    <span class="type">atomic_t</span>             _mapcount,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        private,</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>,</span></span><br><span class="line"><span class="class">    <span class="title">pgoff_t</span>              <span class="title">index</span>,</span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">list_head</span>     <span class="title">lru</span>,</span></span><br><span class="line"><span class="class">    <span class="title">void</span>                 *<span class="title">virtual</span></span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>flags</code>域，用来存放页的状态（包括是不是脏的，是不是锁定在内存），每一位单独表示一种状态，至少可以表示32中不同的状态</li><li><code>_count</code>域，存放页的引用计数，-1时内核没有引用该页，在新的内存分配中可以使用。内核调用<code>page_count()</code>检查该域，返回0表示页空闲，返回正整数表示正在使用</li><li>页可以由页缓存使用（此时，mapping域指向页关联的address_space对象），或者作为私有数据（<code>private</code>指向），或者作为进程页表中的映射</li><li><code>virtual</code>域，页的虚拟地址，当页在高端内存（不会永久映射到内核空间）中时，这个域为<code>NULL</code></li></ul><p><strong>注意</strong>：</p><ol><li><code>page</code>结构与物理页相关，并非与虚拟页相关，它仅仅描述当前时刻在相关物理中存放的数据（由于交换等原因，关联的数据继续存在，但是和当前物理页不再关联），它对于页的描述是短暂的</li><li>页的拥有者可能是用户空间进程、动态分配的内核数据，静态内核数据或者页高速缓存等</li></ol><h3 id="122-区"><a class="markdownIt-Anchor" href="#122-区"></a> 12.2 区</h3><p>Linux主要使用四种区：</p><ul><li>ZONE_DMA，其中包含的页只能进行DMA操作（直接内存访问）</li><li>ZONE_DMA32，和ZONE_DMA类似，不同之处是只能被32位设备访问</li><li>ZONE_NORMAL，包含能够正常映射的页</li><li>ZONE_HIGHMEM，包含“高端内存”，其中的页不能永久地映射到内核空间</li></ul><blockquote><p>高端内存，由于一些体系结构的物理内存比虚拟内存大的多，为了充分利用物理内存，将物理内存中的部分区域划分为高端内存，他们不能永久地映射到内核空间，而是动态的映射</p><p>在32位x86体系中，ZONE_HIGHMEM为高于896MB的所有物理内存，其余内存为低端内存，其中ZONE_NORMAL为16MB到896MB的物理内存，ZONE_DMA为小于16MB的物理内存</p><p>x86-64系统没有高端内存区</p></blockquote><table><thead><tr><th style="text-align:center">区</th><th style="text-align:center">描述</th><th style="text-align:center">物理内存</th></tr></thead><tbody><tr><td style="text-align:center">ZONE_DMA</td><td style="text-align:center">DMA使用的页</td><td style="text-align:center">&lt; 16MB</td></tr><tr><td style="text-align:center">ZONE_NORMAL</td><td style="text-align:center">正常可寻址的页</td><td style="text-align:center">16~896MB</td></tr><tr><td style="text-align:center">ZONE_HIGHMEM</td><td style="text-align:center">动态映射的页</td><td style="text-align:center">&gt; 896MB</td></tr></tbody></table><p>每个区使用结构体<code>zone</code>表示，具体结构详见<strong>P206</strong></p><p>域说明：</p><ul><li><code>lock</code>域，是一个自旋锁，防止结构被并发访问，这个域只保护结构，不保护驻留在这个区中的页</li><li><code>watermark</code>域，水位值，为每个内存区设置合理的内存消耗基准</li><li><code>name</code>域，表示区的名字，三个区的名字分别为&quot;DMA&quot;,“Normal”,“HighMem”</li></ul><h3 id="123-获得页"><a class="markdownIt-Anchor" href="#123-获得页"></a> 12.3 获得页</h3><ul><li>分配2<sup>order</sup>(1&lt;&lt;order)个<strong>连续</strong>的物理内存页，返回的指针指向第一个页的page结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br></pre></td></tr></table></figure><ul><li>将指定的物理页转换为它的逻辑地址（虚拟内存地址），返回的指针指向物理页所在的逻辑地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">page_address</span><span class="params">(<span class="keyword">struct</span> page *page)</span>;</span><br></pre></td></tr></table></figure><ul><li>和<code>alloc_pages()</code>功能类似，不过它直接返回请求的第一个页的逻辑地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __get_free_pages(<span class="type">gfp_t</span> fp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span><br></pre></td></tr></table></figure><ul><li>只分配一页的函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">alloc_page</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __get_free_page(<span class="type">gfp_t</span> fp_mask)</span><br></pre></td></tr></table></figure><h4 id="1231-获得填充为0的页"><a class="markdownIt-Anchor" href="#1231-获得填充为0的页"></a> 12.3.1 获得填充为0的页</h4><ul><li>分配的所有页内容全为0，返回执行逻辑地址的指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_zeroed_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gfp_mask)</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：为了防止页中留下一般随机的垃圾信息包含一些敏感信息，一般用户空间在获取页的时候，内容最好全部填充为0</p><h4 id="1232-释放页"><a class="markdownIt-Anchor" href="#1232-释放页"></a> 12.3.2 释放页</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __free_pages(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order);</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：传递了错误的struct page、地址或者order参数，都可能导致系统崩溃，因为内核是完全相信自己的</p><h3 id="124-kmalloc"><a class="markdownIt-Anchor" href="#124-kmalloc"></a> 12.4 kmalloc()</h3><ul><li>以字节为单位分配内存</li><li>可以获得以字节为单位的一块内核内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br></pre></td></tr></table></figure><h4 id="1241-gfp_mask标志"><a class="markdownIt-Anchor" href="#1241-gfp_mask标志"></a> 12.4.1 gfp_mask标志</h4><p>标志分为三类：</p><ul><li>行为修饰符</li><li>区修饰符</li><li>类型修饰符</li></ul><p>标志具体说明详见<strong>P209</strong></p><h4 id="1242-kfree"><a class="markdownIt-Anchor" href="#1242-kfree"></a> 12.4.2 kfree()</h4><ul><li>释放由<code>kmalloc()</code>分配的内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><h3 id="125-vmalloc"><a class="markdownIt-Anchor" href="#125-vmalloc"></a> 12.5 vmalloc()</h3><p>和<code>kmalloc()</code>类似，不同之处在于<code>vmalloc()</code>分配的内存虚拟内存连续，但是物理内存不一定连续，而<code>kmalloc()</code>分配的物理内存也是连续的</p><p><code>vmalloc()</code>正是用户空间分配内存的方式：有<code>malloc()</code>分配的内存页在进程的虚拟内存中是连续的，但是物理内存不保证连续。大多情况下，只有硬件设备才需要连续的物理内存，他们不理解什么是虚拟内存</p><h3 id="126-slab层"><a class="markdownIt-Anchor" href="#126-slab层"></a> 12.6 slab层</h3><blockquote><p>Linux内核提供slab层（即slab分配器），作为通用数据结构缓存层</p></blockquote><h4 id="1261-slab的设计"><a class="markdownIt-Anchor" href="#1261-slab的设计"></a> 12.6.1 slab的设计</h4><blockquote><p>slab层将不同的对象划分为<strong>高速缓存组</strong>，每个高速缓存组存放不同类型的对象，例如，分别存放进程描述符(task_struct结构的空闲链表)，索引节点对象(struct inode)</p></blockquote><ul><li><code>kmalloc()</code>建立在slab层之上，使用了一组通用高速缓存</li><li>一般slab仅仅由一页组成，每个高速缓存由多个slab组成</li><li>每个slab包含一些对象成员，对象指的是被缓存的数据结构</li><li>slab包含三种状态：满、部分满或空</li></ul><p>高速缓存使用结构体<code>kmem_cache</code>表示，这个结构包括三个链表：<code>slabs_full</code>, <code>slabs_partial</code>和<code>slabs_empty</code>，这些链表包含高速缓存中的所有slab</p><p>slab使用slab描述符表示，详见<strong>P216</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>slab分配器使用<code>__get_free_pages()</code>创建新的slab</p><h4 id="1262-slab分配器的接口"><a class="markdownIt-Anchor" href="#1262-slab分配器的接口"></a> 12.6.2 slab分配器的接口</h4><ul><li>创建一个新的高速缓存<ul><li><code>name</code>：高速缓存的名字</li><li><code>size</code>：高速缓存中每个元素的大小</li><li><code>align</code>：slab内第一个对象的偏移量，用来确保在页内进行特定的对齐</li><li><code>flags</code>：可选的设置项，控制高速缓存的行为，详见<strong>P218</strong></li><li><code>ctor</code>：高速缓存的构造函数（Linux的高速缓存不使用构造函数）</li><li>返回指向高速缓存的指针</li><li>函数调用可能会睡眠，不能再中断上下文使用</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kmem_cache *<span class="title function_">kmem_cache_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, </span></span><br><span class="line"><span class="params">                                    <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">                                    <span class="type">size_t</span> align,</span></span><br><span class="line"><span class="params">                                    <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">                                    <span class="type">void</span> (*ctor)(<span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure><ul><li>撤销一个高速缓存（可能睡眠，不能再中断上下文使用）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kmem_cache_destroy</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep)</span>;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：调用<code>kmem_cache_destroy</code>之前要确保两个条件：</p><ol><li>高速缓存中的所有slab为空</li><li>在调用此函数过程中不在访问这个高速缓存</li></ol><ul><li>从已经创建的缓存中分配释放对象，使用示例详见<strong>P219</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp)</span>;</span><br></pre></td></tr></table></figure><h3 id="127-栈上的静态分配"><a class="markdownIt-Anchor" href="#127-栈上的静态分配"></a> 12.7 栈上的静态分配</h3><blockquote><p>不同于用户栈，内核栈小而且固定，内核栈一般是两个页大小</p></blockquote><h4 id="1271-单页内核栈"><a class="markdownIt-Anchor" href="#1271-单页内核栈"></a> 12.7.1 单页内核栈</h4><p>2.6内核之后，引入选项可以设置<strong>单页内核栈</strong>，激活这个选项，每个进程的内核栈只有一页大小</p><p>引入的原因有两点：</p><ol><li>可以让每个进程减少内存消耗，另外随着机器运行时间增加，寻找两个连续的物理页变得越来越困难</li><li>当内核栈使用两页时，中断处理程序使用它所中断进程的内核栈，而当进程使用单页的内核栈时，中断处理程序不放在进程内核栈中，而是放在<strong>中段栈</strong>中。</li></ol><blockquote><p>中断栈：为每个进程提供运行中断处理程序的栈，一页大小。</p></blockquote><p>总之，历史上，进程和中断处理程序共享一个栈空间，当1页栈的选项激活之后，中断处理程序获得了自己的栈。</p><h4 id="1272-在栈上工作"><a class="markdownIt-Anchor" href="#1272-在栈上工作"></a> 12.7.2 在栈上工作</h4><p>在任何函数，都要尽量节省内核栈的使用，让所有局部变量大小不要超过几百字节。栈溢出非常危险，所出的数据会直接覆盖紧邻堆栈末端的数据（例如<code>thread_info</code>结构就是紧邻进程堆栈末端）。</p><p>因此，推荐使用动态分配。</p><h3 id="128-高端内存的映射"><a class="markdownIt-Anchor" href="#128-高端内存的映射"></a> 12.8 高端内存的映射</h3><h4 id="1281-永久映射"><a class="markdownIt-Anchor" href="#1281-永久映射"></a> 12.8.1 永久映射</h4><p>映射给定的page结构到内核地址空间，使用如下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmap</span><span class="params">(<span class="keyword">struct</span> page *page)</span>;</span><br></pre></td></tr></table></figure><p>函数在对于高端内存或者低端内存都能使用：</p><ol><li>如果page对应低端内存的一页，函数会单纯返回该物理页对应的虚拟地址</li><li>如果page对应高端内存页，函数会建立一个永久映射，在返回对应的虚拟地址</li><li>函数可以睡眠，只能在进程上下文中使用</li></ol><p>当不再需要高端内存中的这一个页时，使用如下函数解除映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kunmap</span><span class="params">(<span class="keyword">struct</span> page *page)</span>;</span><br></pre></td></tr></table></figure><h4 id="1282-临时映射"><a class="markdownIt-Anchor" href="#1282-临时映射"></a> 12.8.2 临时映射</h4><blockquote><p>当必须创建映射而上下文不能睡眠是，内核提供了临时映射（原子映射）</p></blockquote><p>临时映射可以用在像中断上下文一样的不能睡眠的地方，使用如下函数建立心是映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmap_atomic</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="keyword">enum</span> km_type type)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数禁止了内核抢占（因为映射对每个处理器都是唯一的？？？）</li></ul><h3 id="129-每个cpu的分配"><a class="markdownIt-Anchor" href="#129-每个cpu的分配"></a> 12.9 每个CPU的分配</h3><blockquote><p>SMP定义：一个操作系统的实例可以同时管理所有CPU内核，且应用并不绑定某一个内核。</p><p>支持SMP的操作系统使用每个CPU上的数据，对于给定的处理器其数据是唯一的，每个CPU的数据存放在一个数组中，数组的每一个元素对应一个存在的处理器</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> my_percpu[NR_CPUS];</span><br></pre></td></tr></table></figure><p>访问cpu数据过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">cpu = get_cpu();  <span class="comment">//获取当前CPU，并且禁止内核抢占</span></span><br><span class="line">data = my_percpu[cpu];</span><br><span class="line">....       <span class="comment">// 使用data的过程</span></span><br><span class="line">put_cpu();</span><br></pre></td></tr></table></figure><p>代码中没有出现锁，因为数据对当前处理器是唯一的，没有其他处理器可以接触这个数据，没有多个处理器并发访问的问题，但是会有内核抢占的问题：</p><ol><li>如果代码被其他处理器抢占并重新调度，这是cpu变量data会变成无效，因为它对应了错误的处理器</li><li>如果另一个进程抢占了代码，有可能在一个处理器上并发访问data数据的问题</li></ol><p>因此，在获取当前cpu时，就已经禁止了内核抢占。</p><h3 id="1210-新的每个cpu接口"><a class="markdownIt-Anchor" href="#1210-新的每个cpu接口"></a> 12.10 新的每个CPU接口</h3><blockquote><p>描述了一些为每个CPU分配内存的接口，详见<strong>P223</strong></p></blockquote><h3 id="1211-使用每个cpu数据的原因"><a class="markdownIt-Anchor" href="#1211-使用每个cpu数据的原因"></a> 12.11 使用每个CPU数据的原因</h3><p>使用每个CPU的好处有：</p><ol><li>减少数据锁定，每个处理器访问每个CPU数据，不用加锁</li><li>使用每个CPU数据大大减少了缓存失效，失效发生在处理器试图使他们的缓存保持同步时，如果一个处理器操作数据时，该数据又存放在其他处理器缓存中，那么存放该数据的那个处理器必须刷新或者清理自己的缓存，频繁的缓存失效会造成<strong>缓存抖动</strong></li></ol><p>而使用每个CPU数据唯一的要求是需要<strong>禁止内核抢占</strong></p><h2 id="第13章-虚拟文件系统"><a class="markdownIt-Anchor" href="#第13章-虚拟文件系统"></a> 第13章 虚拟文件系统</h2><blockquote><p>虚拟文件系统（VFS）： 作为内核子系统，为用户空间程序提供了文件和文件系统相关的接口</p></blockquote><h3 id="131-通用文件系统接口"><a class="markdownIt-Anchor" href="#131-通用文件系统接口"></a> 13.1 通用文件系统接口</h3><blockquote><p>VFS使得用户可以直接使用统一的系统调用，无需考虑具体的文件系统和物理介质</p></blockquote><h3 id="132-文件系统抽象层"><a class="markdownIt-Anchor" href="#132-文件系统抽象层"></a> 13.2 文件系统抽象层</h3><blockquote><p>内核在底层文件系统接口上建立了一个抽象层，使得Linux能够支持各种文件系统。</p><p>实际文件系统的代码在统一的接口和数据结构下隐藏各自具体的实现细节，它们通过编程提供VFS所期望的抽象接口和数据结构</p></blockquote><h3 id="133-unix文件系统"><a class="markdownIt-Anchor" href="#133-unix文件系统"></a> 13.3 Unix文件系统</h3><blockquote><p>四个基本要素：文件、目录项、索引节点和安装点（挂载点）</p></blockquote><ul><li>目录项：路径中的每一部分都被称为目录条目，统称为目录项</li><li>索引节点：Unix系统将文件的相关信息和文件本身这两个概念加以区分（如访问控制权限、大小、创建时间等），文件的相关信息（文件的元数据信息）被存储在一个单独的数据结构，称为索引节点（inode）</li><li>超级块：是一种包含文件系统控制信息的数据结构，这些信息称为文件系统数据元</li></ul><p><img src="https://static001.geekbang.org/resource/image/32/47/328d942a38230a973f11bae67307be47.png" alt="img" /></p><h3 id="134-vfs对象及数据结构"><a class="markdownIt-Anchor" href="#134-vfs对象及数据结构"></a> 13.4 VFS对象及数据结构</h3><h4 id="对象类型"><a class="markdownIt-Anchor" href="#对象类型"></a> 对象类型</h4><p>VFS的四个对象类型：</p><ul><li>超级块对象：代表具体的文件系统</li><li>索引节点对象：代表具体文件</li><li>目录项对象：代表目录项，是路径的一个组成部分</li><li>文件对象：代表进程打开的文件</li></ul><p><strong>注意</strong>：VFS将目录作为一个文件来处理，不存在目录对象；目录项不同于目录</p><h4 id="操作对象"><a class="markdownIt-Anchor" href="#操作对象"></a> 操作对象</h4><blockquote><p>每个对象中都包含一个操作对象，其中描述了内核针对主要对象可以使用的方法</p></blockquote><ul><li><code>super_operations</code>对象：内核针对特定文件系统调用的方法，如<code>write_inode(), sync_fs()</code></li><li><code>inode_operations</code>对象：内核针对特定文件调用的方法，如<code>create(), link()</code></li><li><code>dentry_operations</code>对象：内核针对特定目录项所能调用的方法，如<code>d_compare(), d_delete()</code></li><li><code>file_operations</code>对象：进程针对已打开文件所能调用的方法，如<code>read(), write()</code></li></ul><p><strong>注意</strong>：操作对象作为结构体，其中包含操作父对象的函数指针，实际的文件系统可以继承VFS提供的通用函数。</p><h3 id="135-超级块对象"><a class="markdownIt-Anchor" href="#135-超级块对象"></a> 13.5 超级块对象</h3><blockquote><p>各种文件系统都必须实现超级块对象，该对象存储特定文件系统的信息，对应于存放在磁盘<strong>特定扇区</strong>中文件系统超级块或者文件系统控制块。（非基于磁盘的文件系统，会在使用现场创建超级块并保存在内存中）</p></blockquote><ul><li>超级块对象有<code>super_block</code>结构体表示，详见<strong>P231</strong></li></ul><p><strong>注意</strong>：超级块对象通过<code>alloc_super()</code>函数创建并初始化，在安装文件系统时，文件系统会调用这个函数从<strong>磁盘</strong>读取文件系统超级块，并将其中的数据<strong>填充到内存中的超级块对象对应的结构体</strong>中。</p><h3 id="136-超级块操作"><a class="markdownIt-Anchor" href="#136-超级块操作"></a> 13.6 超级块操作</h3><blockquote><p>超级块对象中s_op指针，指向超级块的操作函数表，由<code>super_operations()</code>表示</p></blockquote><p><strong>详见P233</strong></p><h3 id="137-索引节点对象"><a class="markdownIt-Anchor" href="#137-索引节点对象"></a> 13.7 索引节点对象</h3><blockquote><p>索引节点对象：包含内核在操作文件系统或者目录时需要的全部信息（对于Unix风格的系统，直接从磁盘的索引节点读入），索引节点对象必须在<strong>内存</strong>中创建。</p></blockquote><ul><li>结构体<code>inode</code>表示，<strong>详见P235</strong></li><li>索引节点代表<strong>普通文件</strong>或者<strong>设备、管道</strong>等特殊文件</li></ul><h3 id="138-索引节点操作"><a class="markdownIt-Anchor" href="#138-索引节点操作"></a> 13.8 索引节点操作</h3><p><code>inode_operation</code>结构体，<strong>详见P239</strong></p><h3 id="139-目录项对象"><a class="markdownIt-Anchor" href="#139-目录项对象"></a> 13.9 目录项对象</h3><blockquote><p>每个dentry代表路径中的一个特定部分，比如路径/bin/vi，其中/,bin,vi都是目录项，前两个是<strong>目录</strong>，最后一个是<strong>普通文件</strong>。</p><p><strong>注意</strong>：在路径中，包含普通文件在内，每一项都是目录项对象。</p></blockquote><ul><li><p>结构体<code>dentry</code>表示，详见<strong>P239</strong></p></li><li><p>VFS在执行目录项操作时，会现场创建目录项对象</p></li></ul><p><strong>注意</strong>：目录项对象没有对应的磁盘数据结构，并非保存在磁盘上，<code>dentry</code>结构体中没有是否被修改的标志（是否为脏、是否需要写会磁盘）</p><h4 id="1391-目录项状态"><a class="markdownIt-Anchor" href="#1391-目录项状态"></a> 13.9.1 目录项状态</h4><blockquote><p>三种状态：被使用、未使用和负状态</p></blockquote><ul><li>被使用的目录项：对应一个有效的索引节点，<code>d_node</code>指向相应的索引节点，<code>d_count</code>代表使用者的数量；不能被丢弃</li><li>未被使用的目录项：对应有效的索引节点，但是<code>d_count</code>为0，仍然指向一个有效对象，被保存在缓存中</li><li>负状态的目录项：没有对应的有效索引节点，<code>d_node</code>为NULL，索引节点已被删除，或者路径不不再正确</li></ul><p><strong>注意</strong>：目录项释放后也可以保存在<strong>slab缓存</strong>中。</p><h4 id="1392-目录项缓存"><a class="markdownIt-Anchor" href="#1392-目录项缓存"></a> 13.9.2 目录项缓存</h4><blockquote><p>内核将目录项对象缓存在目录项缓存dcache中</p></blockquote><p>目录项分为三个部分：</p><ul><li><strong>“被使用的”</strong> 目录项链表：索引节点中<code>i_dentry</code>链接相关的目录项（一个索引节点可能有多个链接，对应多个目录项），因此用一个链表连接他们</li><li><strong>“最近被使用的”</strong> 双向链表：包含未被使用和负状态的目录项对象（总是在头部插入新的目录项，需要回收内存时，会再尾部删除旧的目录项）</li><li><strong>散列表</strong>和相应的<strong>散列函数</strong>：快速将给定路径解析（哈希）成相关的目录项对象</li></ul><p>散列表由数组<code>dentry_hashtable</code>表示，每个元素指向具有相同键值的目录项组成的链表头指针；散列值有<code>d_hash</code>计算（内核系统提供给文件系统<strong>唯一</strong>的散列函数）</p><p><strong>注意</strong>：</p><ol><li><code>dcache</code>一定意义上提供了对于索引节点的缓存（<code>icache</code>），和目录项相关的索引节点对象不会被释放（因为索引节点的使用计数&gt;0），这样确保了索引节点留在内存中</li><li>文件访问呈现空间和时间的局部性：时间局部性体现在程序在一段时间内可能会访问相同的文件；空间局部性体现在同一个目录下的文件很可能都被访问。</li></ol><h3 id="1310-目录项操作"><a class="markdownIt-Anchor" href="#1310-目录项操作"></a> 13.10 目录项操作</h3><p><code>dentry_operation</code>结构体，<strong>详见P241</strong></p><h3 id="1311-文件对象"><a class="markdownIt-Anchor" href="#1311-文件对象"></a> 13.11 文件对象</h3><blockquote><p>文件对象是已打开的文件在内存中的表示</p></blockquote><ul><li><p>结构体<code>file</code>表示</p></li><li><p>由<code>open()</code>系统调用创建，<code>close()撤销</code></p></li><li><p>多个进程可以打开同一个文件，所以同一个文件存在多个对应的文件对象</p></li><li><p>文件对象仅仅在观点上代表已打开文件，它反过来指向目录项对象，而目录项对象反过来指向索引节点</p></li></ul><p><strong>注意</strong>：类似于目录项对象，文件对象没有对应的磁盘数据，通过<code>file</code>结构体中<code>f_dentry</code>指针指向相关的目录项对象，而目录项对象指向相关的索引节点，索引节点会记录文件是否为脏</p><h3 id="1312-文件操作"><a class="markdownIt-Anchor" href="#1312-文件操作"></a> 13.12 文件操作</h3><p>结构体<code>file_operation</code>，详见<strong>P242</strong>，文件相关的操作方法和<strong>系统调用</strong>很类似</p><ul><li>具体的文件系统可以为每一种操作方法实现各自的代码，如果存在通用操作，则使用通用操作</li></ul><h3 id="1313-和文件系统相关的数据结构"><a class="markdownIt-Anchor" href="#1313-和文件系统相关的数据结构"></a> 13.13 和文件系统相关的数据结构</h3><h4 id="结构体-file_system_type"><a class="markdownIt-Anchor" href="#结构体-file_system_type"></a> 结构体 file_system_type</h4><blockquote><p>描述特定文件系统类型，详见<strong>P248</strong></p></blockquote><ul><li>主要方法<code>get_sb()</code>：从磁盘读取超级块，在文件系统安装时，在内存中组装超级块对象</li><li>剩余的函数描述文件系统的属性</li><li>每种文件系统，不管有多少实例，都只有一个<code>file_system_type</code>结构体</li></ul><h4 id="结构体-vfsmount"><a class="markdownIt-Anchor" href="#结构体-vfsmount"></a> 结构体 vfsmount</h4><blockquote><p>描述安装的文件系统的实例，详见<strong>P248</strong></p></blockquote><ul><li>在文件系统实际被安装时，会有一个<code>vfsmount</code>结构体在安装点创建，它代表文件系统的<strong>实例</strong>（也代表一个<strong>安装点</strong>）</li><li><code>vfsmount</code>结构体中维护了各种链表，用于跟踪文件系统和所有安装点之间的关系</li></ul><h3 id="1314-和进程相关的数据结构"><a class="markdownIt-Anchor" href="#1314-和进程相关的数据结构"></a> 13.14 和进程相关的数据结构</h3><blockquote><p>三种结构体：<code>file_struct</code>, <code>fs_struct</code>, <code>namespace</code></p></blockquote><h4 id="结构体-file_struct"><a class="markdownIt-Anchor" href="#结构体-file_struct"></a> 结构体 file_struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_struct</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span> <span class="comment">/*缺省的文件对象数组*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>    /*指向其他<span class="title">fd</span>的指针*/</span></span><br><span class="line"><span class="class">    ...</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>由进程描述符中的<code>files</code>指向</li><li><code>fd_array</code>数组指针：指向已打开的文件对象，<code>NR_OPEN_DEFAULT</code>默认64，如果进程打开的文件超过64，内核将分配一个新数组，并且将<code>fdt</code>指针指向它</li><li>当访问的文件对象的数量小于64时，执行比较快，因为是对静态数组的操作；如果大于64，内核需要建立新数组，访问速度相对慢一些</li><li>管理员可以增大<code>NR_OPEN_DEFAULT</code>选项优化性能</li></ul><h4 id="结构体-fs_struct"><a class="markdownIt-Anchor" href="#结构体-fs_struct"></a> 结构体 fs_struct</h4><ul><li>由进程描述符的<code>fs</code>域指向，包含文件系统和进程相关的信息</li><li>包含进程的当前工作目录（<code>pwd</code>）和根目录</li></ul><h4 id="结构体-namespace"><a class="markdownIt-Anchor" href="#结构体-namespace"></a> 结构体 namespace</h4><ul><li>进程描述符的<code>mmt_namespace</code>域指向，它使得每个进程在系统中看到唯一的文件系统（唯一的根目录和文件系统结构层次）</li></ul><p><strong>注意</strong>：</p><ol><li>对于多数进程，它们的描述符都指向自己独有的<code>file_struct</code>和<code>fs_struct</code>，除非使用克隆标志<code>CLONE_FILES</code>或者<code>CLONE_FS</code>创建的进程会共享这两个结构体</li><li><code>namespace</code>结构体使用方法和前两种结构完全不同，默认情况下，所有进程共享同样的命名空间（都从相同的挂载表中看到同一个文件系统层次结构，除非在<code>cloen()</code>操作时使用<code>CLONE_NEWS</code>标志，才会给进程一个命名空间结构体的拷贝）</li></ol><h2 id="第14章-块io层"><a class="markdownIt-Anchor" href="#第14章-块io层"></a> 第14章 块I/O层</h2><h2 id="第15章-进程地址空间"><a class="markdownIt-Anchor" href="#第15章-进程地址空间"></a> 第15章 进程地址空间</h2><h2 id="第16章-页高速缓存和页回写"><a class="markdownIt-Anchor" href="#第16章-页高速缓存和页回写"></a> 第16章 页高速缓存和页回写</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;linux内核设计与实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux内核设计与实现&quot;&gt;&lt;/a&gt; Linux内核设计与实现&lt;/h1&gt;
&lt;h2 id=&quot;第3章-进程管理&quot;&gt;&lt;a class=&quot;mark</summary>
      
    
    
    
    <category term="书籍存档" scheme="https://www.snowmoon.top/categories/%E4%B9%A6%E7%B1%8D%E5%AD%98%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.snowmoon.top/2024/06/01/%E4%B9%A6%E7%B1%8D%E5%AD%98%E6%A1%A3-Linux-kernel-notes-master-Linux%E5%86%85%E6%A0%B8/"/>
    <id>https://www.snowmoon.top/2024/06/01/%E4%B9%A6%E7%B1%8D%E5%AD%98%E6%A1%A3-Linux-kernel-notes-master-Linux%E5%86%85%E6%A0%B8/</id>
    <published>2024-06-01T05:46:44.946Z</published>
    <updated>2024-10-19T15:22:29.418Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="linux内核"><a class="markdownIt-Anchor" href="#linux内核"></a> Linux内核</h1><h2 id="3-进程管理"><a class="markdownIt-Anchor" href="#3-进程管理"></a> 3 进程管理</h2><h3 id="31-进程"><a class="markdownIt-Anchor" href="#31-进程"></a> 3.1 进程</h3><blockquote><p>进程：处于执行期的程序以及相关资源（打开的文件、挂起的信号、内核内部数据、处理器状态等）的总称</p><p>线程：是在进程中活动的对象，每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，不是进程</p><p>Linux不区分进程和线程，对它来说，线程只不过是一种特殊的进程而已</p></blockquote><p>现代操作系统的两种<strong>虚拟机制</strong>：</p><ul><li>虚拟处理器：给进程一种假象，让它觉得自己在独享处理器</li><li>虚拟内存：让进程在分配和管理内存时觉得自己拥有整个系统的内存资源</li></ul><p><strong>注意</strong>：线程之间可以共享虚拟内存，但是都拥有自己的虚拟处理器</p><h3 id="32-进程描述"><a class="markdownIt-Anchor" href="#32-进程描述"></a> 3.2 进程描述</h3><p>内核把进程的列表存放在叫做<strong>任务队列</strong>的双向循环链表中。链表中的每一项类型为<code>task_struct</code>，称为<strong>进程描述符</strong>的结构，描述了一个具体进程的所有信息</p><h4 id="321-分配进程描述符"><a class="markdownIt-Anchor" href="#321-分配进程描述符"></a> 3.2.1 分配进程描述符</h4><p>Linux通过slab分配器分配<code>task_struct</code>结构，这样能够<strong>对象复用</strong>和<strong>缓存着色</strong>。</p><p>每个任务的<code>thread_info</code>结构在它的内核栈尾端分配，其中<code>task</code>域存放的是指向该任务实际<code>task_struct</code>的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span> *<span class="title">exec_domain</span>;</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200531162345047.png" width="600"><h4 id="322-进程描述符的存放"><a class="markdownIt-Anchor" href="#322-进程描述符的存放"></a> 3.2.2 进程描述符的存放</h4><p>在内核中，访问任务需要获取指向<code>task_struct</code>结构的指针，通过<code>current</code>宏查找到当前进程的进程描述符，这个查找的<strong>速度</strong>很重要</p><p>有的硬件体系结构拿出一个专门的寄存器存放当前进程的<code>task_struct</code>指针，而有些像x86的体系结构（寄存器不太富余），就只能在<strong>内核栈的尾部</strong>创建<code>thread_info</code>结构，通过计算偏移量间接找到<code>task_struct</code>结构</p><h4 id="323-进程状态"><a class="markdownIt-Anchor" href="#323-进程状态"></a> 3.2.3 进程状态</h4><p>进程描述符中的<code>state</code>域描述了进程的当前状态。系统中进程的状态包括：</p><ul><li><strong>TASK_RUNNING</strong>(运行或就绪)：进程是可执行的</li><li><strong>TASK_INTERRUPTIBLE</strong>(可中断睡眠)</li><li><strong>TASK_UNINTERRUPTIBLE</strong>(不可中断睡眠)</li><li><strong>__TASK_TRACED</strong>：被其他进程跟踪的进程，例如ptrace调试的程序</li><li><strong>__TASK_STOPPED</strong>：被暂停执行的任务，通常在接收到<strong>SIGSTOP</strong>,<strong>SIGTSTP</strong>,<strong>SIGTTIN</strong>,<strong>SIGTTOU</strong>等信号时</li></ul><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200531162554050.png" width="700"><h4 id="324-设置当前状态"><a class="markdownIt-Anchor" href="#324-设置当前状态"></a> 3.2.4 设置当前状态</h4><p>使用<code>set_task_state(task,state)</code>函数</p><h4 id="326-进程家族树"><a class="markdownIt-Anchor" href="#326-进程家族树"></a> 3.2.6 进程家族树</h4><p>所有的进程都是PID为1的init进程的后代，内核在系统启动的最后阶段启动init进程，该进程读取系统的初始化脚本（initsctript）并执行其他的相关程序，最终完成系统启动的整个过程</p><p>每个<code>task_struct</code>结构都包含一个指向其父进程<code>task_struct</code>结构的<code>parent</code>指针，还包含一个<code>children</code>的子进程链表</p><h3 id="33-进程创建"><a class="markdownIt-Anchor" href="#33-进程创建"></a> 3.3 进程创建</h3><p>Unix将进程的创建分解到两个单独的函数中去执行：fork()和exec()</p><p>首先，fork()通过拷贝当前进程创建一个子进程，exec()负责读取可执行文件并将其载入地址空间开始运行</p><h4 id="331-写时拷贝"><a class="markdownIt-Anchor" href="#331-写时拷贝"></a> 3.3.1 写时拷贝</h4><p>Linux的fork()使用<strong>写时拷贝</strong>页实现，是一种推迟甚至免除拷贝数据的技术，在创建子进程时，内核并不复制整个进程地址空间，而是让父子进程共享一个拷贝，只有在写入的时候，数据才会被复制。在页根本不会被写入的情况下，例如fork()之后马上exec()，进程的地址空间就不用复制了</p><p>fork()的实际开销：复制父进程的页表以及给子进程创建唯一的进程描述符</p><h4 id="332-fork"><a class="markdownIt-Anchor" href="#332-fork"></a> 3.3.2 fork()</h4><p>Linux通过clone()实现fork()，clone()通过一系列参数指明父子进程需要共享的资源。fork(),vfork()和__clone()库函数都根据各自需要的参数标志去调用clone()，然后在clone()中调用do_fork()</p><p>do_fork()调用copy_process()函数，然后让进程运行。copy_process()函数的过程：</p><ul><li>调用<code>dup_task_struct()</code>为进程创建一个内核栈、thread_info结构和task_struct，与父进程的值相同，此时父子进程的描述符是相同的</li><li>检查创建子进程后，当前用户拥有的进程数不超过分配资源限制</li><li>子进程开始将自己与父进程区分开：进程描述符内的很多成员清0或者初始化，大部分的数据未被修改</li><li>子进程状态设置为UNINTERRUPTIBAL，保证它不会投入运行</li><li>copy_process()调用copy_flags()更新task_struct的flags成员：其中代表进程是否拥有超级用户权限的PF_SUPERPRIV标志清0，代表进程还没有调用exec()函数的PF_FORKNOEXEC的标志被设置</li><li>调用alloc_pid()为子进程分配PID</li><li>根据clone()传递进来的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。（一般这些资源会被进程的<strong>所有线程共享</strong>）</li><li>最后，copy_process()做扫尾工作并返回一个指向子进程的指针</li></ul><p>copy_process()返回到do_fork()函数，如果copy_process()返回成功，新创建的子进程被唤醒并投入运行</p><p><strong>注意</strong>：内核有意选择子进程首先执行，因为一般子进程会调用exec()函数，这样可以避免写时拷贝的额外开销</p><h4 id="333-vfork"><a class="markdownIt-Anchor" href="#333-vfork"></a> 3.3.3 vfork()</h4><p>除了<strong>不拷贝父进程的页表项</strong>，vfork()和fork()的功能相同</p><h3 id="34-线程在linux中的实现"><a class="markdownIt-Anchor" href="#34-线程在linux中的实现"></a> 3.4 线程在Linux中的实现</h3><p>Linux实现线程的机制非常独特，从内核的角度来说，并没有线程这个概念，Linux把所有的<strong>线程当做进程</strong>来实现。线程仅仅被视为一个与其他进程共享某些资源的进程，拥有唯一隶属于自己的<code>task_struct</code>。</p><p>Windows和Sun Solaris等系统都提供了专门支持线程的机制（将线程称为<strong>轻量级进程</strong>），相较于重量级的进程，线程被抽象成一种耗费较少资源，运行迅速的执行单元。而对于Linux，线程只是<strong>进程间共享资源的一种手段</strong>。</p><p>举例说明：对于一个包含四个线程的进程，在提供专门线程支持的系统，通常会有一个包含指向四个不同线程的指针的进程描述符，该描述符负责描述像地址空间、打开的文件等共享资源。而Linux只是创建四个进程并分配四个普通的<code>task_struct</code>结构，并指定它们共享某些资源。</p><h4 id="341-创建线程"><a class="markdownIt-Anchor" href="#341-创建线程"></a> 3.4.1 创建线程</h4><p>线程的创建和普通进程类似，只是需要在调用clone()时传递一些参数标志来指明共享的资源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>调用的结果和fork()差不多，只是父子进程<strong>共享地址空间、文件系统资源、打开的文件描述符和信号处理程序</strong></p><p>传递给clone()的参数标志决定了<strong>新创建进程的行为方式和父子进程之间共享的资源种类</strong>，详见<strong>P29 表3-1</strong></p><h4 id="342-内核线程"><a class="markdownIt-Anchor" href="#342-内核线程"></a> 3.4.2 内核线程</h4><blockquote><p>内核线程用于内核在后台执行一些任务，他们是独立运行在内核空间的标准进程</p><p>内核线程和普通进程的区别是：<strong>内核线程没有独立的地址空间</strong>（指向地址空间的mm指针为NULL），它们只在内核空间运行，不切换到用户空间。</p></blockquote><p>例如软中断ksoftirqd和flush都是内核线程的例子</p><p>内核是通过从kthreadd内核进程衍生出所有新的内核线程，从现有内核线程创建一个新的内核线程的方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">thread_create</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data), <span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> namefmt[], ...)</span></span><br></pre></td></tr></table></figure><p>新的内核线程是由kthreadd进程通过clone()系统调用创建，它们将运行threadfn函数，传递的参数是data，进程命名为namefmt。</p><p>新创建的进程处于不可运行状态，需要通过wake_up_process()唤醒来运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">thread_run</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data), <span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> namefmt[], ...)</span></span><br></pre></td></tr></table></figure><p><code>thread_run</code>方法先调用<code>thread_run</code>方法，然后调用<code>wake_up_process()</code></p><p>内核线程启动后一直运行直到调用<code>do_exit()</code>退出，或者内核的其他部分调用<code>kthread_stop()</code>退出（传递给kthread_stop()的参数是kthread_create()返回的task_struct结构地址）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthread_stop</span><span class="params">(<span class="keyword">struct</span> task_struct *k)</span></span><br></pre></td></tr></table></figure><h3 id="35-进程终结"><a class="markdownIt-Anchor" href="#35-进程终结"></a> 3.5 进程终结</h3><p>进程终结的几种情况：</p><ul><li>显式的调用<code>exit()</code></li><li>隐式地在某个程序的主函数返回（C语言在main(）函数的返回点防止调用exit()的代码）</li><li>接收到不能处理也不能忽略的信号或者异常时，被动地终结</li></ul><p>不管进程如何终结，大部分都是靠<code>do_exit()</code>（定义在kernel/exit.c）来完成，它的主要工作包括：</p><ul><li>将task_struct的标志成员设置为PF_EXITING</li><li>调用<code>del_timer_sync()</code>删除任一内核定时器，确保没有定时器在排队，且没有定时器处理程序在运行</li><li>如果BSD记账功能开启，调用<code>acct_update_intergrals()</code>来输出记账信息</li><li>调用<code>exit_mm()</code>函数释放进程占用的mm_struct，如果没有别的进程在使用它（没有被共享），就彻底释放它们</li><li>调用<code>sem__exit()</code>函数，如果进程排队等候IPC信号，则它离开队列</li><li>调用<code>exit_files()</code>和<code>exit_fs()</code>来分别递减文件描述符和文件系统数据的引用计数，如果引用计数降为0，就可以直接释放</li><li>接着将存放在task_struct的exit_code成员中的任务退出代码置为<code>exit()</code>提供的退出代码。<strong>退出代码存放在这里供父进程检索</strong></li><li>调用<code>exit_notify()</code>向父进程发送信号，给自己的子进程重新找<strong>养父</strong>（为进程组的其他线程或者init进程），并把进程的状态（task_struct中的exit_state）设置为EXIT_ZOMBIE</li><li>调用<code>schedule()</code>切换到新的进程，因为EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程执行的最后一段代码。<code>do_exit()</code>永不返回</li></ul><p>至此，与进程相关联的所有资源都释放掉了（假设该进程是这些资源的唯一使用者），进程不可运行且处于EXIT_ZOMBIE状态，他占用的所有内存包括<strong>内核栈、thread_info结构和task_struct结构</strong>。此时存在的唯一目的就是向它的父进程提供信息用于检索，父进程通知内核都是无关的信息后，进程所持有的剩余内存被释放，归还给系统使用</p><h4 id="351-删除进程描述符"><a class="markdownIt-Anchor" href="#351-删除进程描述符"></a> 3.5.1 删除进程描述符</h4><p>在调用<code>do_exit()</code>后，进程处于僵死状态不再运行，但是系统保留了它的进程描述符，这样可以<strong>让系统能在进程中杰后仍能获取它的信息</strong>。可以看到，<strong>进程终结时所做的清理工作和进程描述符的删除是分开执行的</strong>，在父进程获得已终结的子进程信息后，通知内核它不关注这些信息后，子进程的task_struct结构被释放</p><p>回收子进程状态是通过wait()一族函数实现，他们都是通过唯一的系统调用<code>wait4()</code>来实现，它首先会挂起调用它的进程，直到有一个子进程退出，此时函数返回子进程的PID，调用<strong>该函数提供的指针指向子进程的退出代码</strong></p><p>当需要释放进程描述符时，会调用<code>release_task()</code>函数，它的工作包括：</p><ul><li>调用<code>__exit_signal()</code>，该函数调用<code>_unhash_process()</code>，后者再调用<code>detach_pid()</code>从pidhash上删除该进程，同时从任务列表中删除该进程</li><li><code>__exit_signal()</code>函数释放目前僵死进程所使用的所有剩余资源，进行最终统计和记录</li><li>如果这个进程是进程组的最后一个进程，且领头进程（进程组首进程）已经死掉，那么<code>release_task()</code>就通知僵死的领头进程的父进程</li><li><code>release_task()</code>调用<code>put_task_struct()</code>释放进程内核栈和thread_info结构所占的内存页，并释放task_struct占用的slab高速缓存</li></ul><p>至此，进程描述符和所有进程独享的资源全部释放</p><h4 id="352-孤儿进程造成的进退维谷"><a class="markdownIt-Anchor" href="#352-孤儿进程造成的进退维谷"></a> 3.5.2 孤儿进程造成的进退维谷</h4><p>当父进程在子进程之前推出时，需要保证子进程找到一个新的父进程，否则这些孤儿进程就会在退出时一直处于僵死状态。</p><p>解决方法是：给子进程在当前进程组找一个进程作为父亲，如果不行，就让init进程作为父进程</p><p>在<code>do_exit()</code>中会调用<code>exit_nodify()</code>，该函数调用<code>forget_original_parent()</code>，后者再调用<code>find_new_reaper()</code>进程寻父过程。</p><p>代码中会遍历两个链表：<strong>子进程链表和ptrace子进程链表</strong>，给每个子进程设置新的父进程。</p><p><strong>注意</strong>：当一个进程被跟踪时，它的临时父亲被设置为调试进程，如果他们真正的父进程退出，系统会为它及其兄弟进程找一个父进程。以前的内核版本中需要遍历系统所有的进程来找到这些子进程，现在只需要遍历这个单独ptrace的子进程链表，减轻了遍历的时间消耗</p><h2 id="4-进程调度"><a class="markdownIt-Anchor" href="#4-进程调度"></a> 4 进程调度</h2><blockquote><p>进程调度程序：在可运行态进程之间分配有限处理器时间资源的<strong>内核子系统</strong>。</p></blockquote><h3 id="41-多任务"><a class="markdownIt-Anchor" href="#41-多任务"></a> 4.1 多任务</h3><blockquote><p>多任务操作系统是同时并发地交互执行多个进程的操作系统，能使多个进程处于阻塞或者睡眠状态，这些任务位于内存中，但是并不处于可运行状态，他们利用内核阻塞自己，直到某一时间（键盘输入、网络数据等）发生。</p></blockquote><p>多任务系统分为两类：</p><ul><li>非抢占式多任务</li><li>抢占式多任务</li></ul><p>Linux提供了抢占式的多任务模式，由调度程序决定什么时候停止一个进程的运行，以便其他进程得到运行机会，这个强制的挂起动作叫做抢占。</p><p>时间片：可运行进程在被抢占之前预先设置好的处理器时间段。</p><p>非抢占任务模式下，除非进程自己主动停止运行，否则他会一直运行。进程主动挂起自己的操作称为<strong>让步</strong>（yielding）</p><p>非抢占任务模式的缺点：调度程序无法对每个进程该执行多长时间做出统一规定，进程独占的CPU时间可能超出预期，另外，一个绝不做出让步的悬挂进程就能使系统崩溃</p><h3 id="42-linux的进程调度"><a class="markdownIt-Anchor" href="#42-linux的进程调度"></a> 4.2 Linux的进程调度</h3><p>2.6内核系统开发初期，为了提供对交互程序的调度性能，引入新的调度算法，最为著名的是<strong>反转电梯最后期限调度算法</strong>（RSDL），在2.6.3版本替代了<strong>O(1)调度算法</strong>，最后被称为<strong>完全公平调度算法(CFS)</strong></p><h3 id="43-策略"><a class="markdownIt-Anchor" href="#43-策略"></a> 4.3 策略</h3><h4 id="431-io消耗型和cpu消耗型的进程"><a class="markdownIt-Anchor" href="#431-io消耗型和cpu消耗型的进程"></a> 4.3.1 I/O消耗型和CPU消耗型的进程</h4><p>CPU消耗型进程把时间大多用在了执行代码上，不属于I/O驱动类型，从系统响应速度考虑，调度策略往往是降低它们的调度频率，而延长其运行时间</p><p>调度策略的主要矛盾是：<strong>进程响应迅速和最大系统利用率（高吞吐量）</strong></p><p>Unix系统的调度程序更倾向于I/O消耗型程序，以提供更好的响应速度。Linux为了保证交互式应用和桌面系统的性能，对进程的响应做了优化（缩短响应时间），更倾向于调度I/O消耗型进程。</p><h4 id="432-进程优先级"><a class="markdownIt-Anchor" href="#432-进程优先级"></a> 4.3.2 进程优先级</h4><p>调度程序总是选择时间片为用尽而且优先级最高的进程运行</p><p>Linux采用了两种不同的优先级范围：</p><ul><li>第一种用nice值，范围-20~+19，默认值0；越大的nice值优先级越低。相比高nice值（低优先级）的进程，低nice值（高优先级）的进程可以获得更多的处理器时间</li><li>第二种是实时优先级，数值可配置，默认范围是0~99，数值越大优先级越高。任何实时进程的优先级都比普通进程高，实时优先级和nice优先级处于互不相交的范畴</li></ul><h4 id="433-时间片"><a class="markdownIt-Anchor" href="#433-时间片"></a> 4.3.3 时间片</h4><p>调度策略选择合适的时间片并不简单，时间片太短会增加进程切换的处理器消耗，太长会导致系统的交互响应变差</p><p>Linux的CFS调度器没有直接分配时间片到进程，它是将<strong>处理器的使用比</strong>划分给进程，所以进程所获得的时间片时间是和**系统负载（系统活跃的进程数）**密切相关的</p><p>Linux中新的CFS调度器，它的进程抢占时机取决于<strong>新的可运行程序消耗了多少处理器使用比</strong>。如果消耗的处理器使用比比当前进程小，则新进程投入运行（当前进程被强占），否则，推迟运行。</p><p><strong>总而言之，CFS会先根据进程的nice值预期设定每个进程的cpu使用比，而在进程调度时，需要将新的被唤醒进程实际消耗的cpu使用比和当前进程比较，如果更小，则抢占当前进程，投入运行，否则，推迟运行</strong></p><h3 id="44-linux调度算法"><a class="markdownIt-Anchor" href="#44-linux调度算法"></a> 4.4 Linux调度算法</h3><h4 id="441-调度器类"><a class="markdownIt-Anchor" href="#441-调度器类"></a> 4.4.1 调度器类</h4><p>Linux调度器以模块提供，允许不同类型的进程针对性地选择调度算法，这种模块化结构成为<strong>调度器类</strong>，它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。</p><p>完全公平调度(CFS)是一个针对普通进程的调度类，称为<strong>SCHED_NORMAL</strong>，具体算法实现定义在文件kernel/sched_fair.c中</p><h4 id="442-unix系统中的进程调度"><a class="markdownIt-Anchor" href="#442-unix系统中的进程调度"></a> 4.4.2 Unix系统中的进程调度</h4><p>传统Unix系统调度：进程启动会有默认的时间片，具有高优先级的进程将运行的更频繁，而且被赋予更多的时间片。存在的问题如下：</p><ul><li>nice映射到时间片，就会将nice单位值对应到处理器的绝对时间，这样将会导致进程切换无法最优化进行，同时会导致进程获得的处理器时间很大程度上取决于其nice初始值。场景实例详见<strong>P40</strong></li><li>时间片一般为系统定时器节拍的整数倍，它会随着定时器节拍改变</li></ul><p>CFS采用的方法是：<strong>完全摒弃时间片而是分配给进程一个处理器使用比重</strong>，确保了调度中恒定的公平性，切换频率是在动态变化中</p><h4 id="443-公平调度"><a class="markdownIt-Anchor" href="#443-公平调度"></a> 4.4.3 公平调度</h4><blockquote><p>完美的多任务系统：每个进程获得1/<em>n</em>的处理器时间（<em>n</em>是指可运行进程的数量），同时调度给他们无限小的时间周期（交互性会很好）</p></blockquote><p>CFS的做法：<strong>允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程</strong>，在所有进程总数基础上计算一个进程应该运行多久，不在依靠nice值计算绝对的时间片，而是作为<strong>进程获得的处理器运行比的权重</strong>，越高的nice值获得更低的处理器使用权重。</p><p>每个进程按照其权重在全部可运行进程中所占比例的“时间片”来运行，由于越小的调度周期（重新调度所有可运行进程所花的时间）交互性会越好，也就更接近完美的所任务，CFS为调度周期设定一个目标（无限小的调度周期近似值）。</p><p>当可运行任务数量区域无限大时，他们所获得的处理器使用比和时间片将趋近于0（这会增加CPU的切换消耗）。因此，CFS引入每个进程获得的时间片底线，称为最小粒度。而当进程数非常多时，由于这个最小粒度的存在，调度周期会比较长，因此CFS并非完美的多任务。</p><p><strong>总之，在CFS中任何进程所获得的的处理器时间是由它自己和其他所有可运行进程nice值的相对差值决定的，nice值对时间片的作用不再是算数加权，而是几何加权，CFS是近乎完美的多任务</strong></p><h3 id="45-linux调度的实现"><a class="markdownIt-Anchor" href="#45-linux调度的实现"></a> 4.5  Linux调度的实现</h3><p>Linux调度主要关注四个部分：</p><ul><li>时间记账</li><li>进程选择</li><li>调度器入口</li><li>睡眠和唤醒</li></ul><h4 id="451-时间记账"><a class="markdownIt-Anchor" href="#451-时间记账"></a> 4.5.1 时间记账</h4><ol><li><p>调度器实体结构</p><p>CFS不再有时间片的概念，但是它会维护每个进程运行的时间记账，需要确保每个进程在分配给它的处理器时间内运行。CFS使用<strong>调度器实体</strong>（文件&lt;linux/sched.h&gt;中的struct_sched_entity中）来追踪进程运行记账</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">run_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">group_node</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    u64 vruntime;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调度器实体结构作为一个名为se的成员变量，嵌入在进程描述符task_struct内</p></li><li><p>虚拟实时</p><p>vruntime变量存放进程的虚拟运行时间，这个数值的计算是经过所有可运行进程总数的标准化，以ns为单位，与定时器节拍无关</p><p>定义在kernel/sched_fair.h文件中的update_curr()函数实现记账功能，它是系统定时器周期性调用，无论进程是在可运行态还是阻塞状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_curr</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    __update_curr(cfs_rq, curr, delta_exec)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="452-进程选择"><a class="markdownIt-Anchor" href="#452-进程选择"></a> 4.5.2 进程选择</h4><p><strong>CFS</strong>算法调度核心：<strong>当CFS需要选择下一个运行进程时，选择具有最小vruntime的进程</strong></p><p><strong>CFS</strong>使用红黑树组织可运行进程队列，红黑树的键值为vruntime，检索对应节点的时间复杂度为对数级别</p><ol><li><p>挑选下一个任务</p><p>CFS选择进程的算法为：运行rbtree中最左边叶子结点代表的那个进程。实现的函数是<code>__pick_next_entity()</code>，定义在kernel/sched_fair.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *__<span class="title">pick_next_entity</span>(<span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">left</span> =</span> cfs_rq-&gt;rb_leftmost;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rb_entry(left, <span class="keyword">struct</span> sched_entity, run_node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果该函数返回值为NULL，说明树中没有任何节点，代表没有可运行进程，CFS调度器选择idle任务运行</p></li><li><p>向树中加入进程</p><p>当<strong>进程变为可运行状态（被唤醒）或者通过fork()调用第一次创建进程时</strong>，会将进程加入到rbtree。<code>enqueue_entity()</code>函数实现了这个过程，代码详见P45</p></li><li><p>从树中删除进程</p><p>删除动作发生在<strong>进程阻塞（变为不可运行状态）或者终止（结束运行）</strong>，是由函数<code>dequeue_entity()</code>函数完成</p></li></ol><h4 id="453-调度器入口"><a class="markdownIt-Anchor" href="#453-调度器入口"></a> 4.5.3 调度器入口</h4><p>进程调度的入口函数是<code>schedule()</code>，定义在kernel/sched.c文件，<strong>它是内核其他部分调用进程调度器的入口</strong>。</p><p><code>schedule()</code>通常需要和一个调度类相关联，它会先找到一个最高优先级的调度类，后者要有自己的可运行进程队列，然后这个调度类决定下一个可运行的进程。</p><p>因此，<code>schedule()</code>函数的逻辑比较简单，它的主要逻辑就是调用<code>pick_next_task()</code>，这个函数会以优先级为序，从高到低一次检查每个调度器类，从最高优先级的调度类中选择下一个运行的进程。详细代码如下图</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200531163630230.png" width="600"><p>每个调度类都实现了<code>pick_next_task()</code>函数，它会返回指向下一个可运行进程的指针，在CFS中<code>pick_next_task()</code>会调用<code>pick_next_entity()</code>，该函数会调用 [4.5.2节](#4.5.2 进程选择) 提到的<code>__pick_next_entity()</code></p><p><strong>函数优化</strong>：由于CFS是普通进程的调度类，而系统绝大多数进程是普通进程。函数使用了一个小技巧，当所有可运行进程数等于CFS类对应的可运行进程数时，直接返回CFS调度类的下一个运行进程</p><h4 id="454-睡眠和唤醒"><a class="markdownIt-Anchor" href="#454-睡眠和唤醒"></a> 4.5.4 睡眠和唤醒</h4><p>睡眠（或阻塞）的进程处于一个特殊的不可运行状态。</p><p>进程睡眠时，进程把自己标记为休眠状态，从可执行进程对应的红黑树中移出，放入等待队列，然后调用<code>schedule()</code>调度下一个进程；唤醒的过程相反：进程被设置成可执行状态，然后从等待队列移到可执行红黑树中</p><ol><li><p>等待队列</p><p>等待队列是由<strong>等待某些事件发生的进程组成的简单链表</strong>，内核用<code>wake_queue_head_t</code>代表等待队列</p><p>进程加入等待队列的详细过程和代码详见<strong>P50</strong></p></li><li><p>唤醒</p><p>唤醒操作通过函数<code>wake_up()</code>进行，它会唤醒等待队列上的所有进程，它调用函数<code>try_to_wake_up()</code>将进程状态设置为<strong>TASK_RUNNING</strong>，调用<code>enqueue_task()</code>将此进程放入红黑树，如果被唤醒的进程比当前正在执行的进程优先级高（这里不是指nice值，而是根据CFS调度的cpu使用比规则得出的结果），还要设置进程的need_resched标志。</p><p><strong>注意</strong>：通常哪段代码促使等待条件达成，它就要负责调用<code>wake_up()</code>函数。例如，当磁盘数据到来时，VFS需要负责对等待队列调用<code>wake_upe()</code>。</p></li></ol><p>如下图是每个调度程序状态之间的关系</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200531163039995.png" width="600"><h3 id="46-抢占和上下文切换"><a class="markdownIt-Anchor" href="#46-抢占和上下文切换"></a> 4.6 抢占和上下文切换</h3><p>上下文切换由定义在kernel/sched.c中的context_switch()函数负责处理。每当一个新的进程被选出来投入运行的时候，schedule()会调用函数context_switch()，后者完成两项工作：</p><ul><li>调用声明在&lt;asm/mmu_context.h&gt;中的switch_mm()函数，它负责将虚拟内存从上一个进程映射切换到新进程中</li><li>调用声明在&lt;asm/system.h&gt;的switch_to()，负责从上一个进程的处理器状态切换到新进程的处理器状态，其中包括<strong>保存、恢复栈信息和寄存器信息</strong></li></ul><p>内核提供一个<code>need_resched</code>标志标明是否需要重新执行一次调度，2.2以前放在全局变量，2.2~2.4在每个进程的进程描述符中（由于current宏速度很快并且进程描述符通常是在高速缓存中，访问<code>task_struct</code>内的数值比全局变量更快），而在2.6版本中，它放在thread_info结构体中，用一个特别的标志变量的一位来表示。</p><p><code>need_resched</code>标志被设置的时机：</p><ul><li>当某个进程应该被抢占时，scheduler_tick()函数会设置这个标志</li><li>当一个优先级更高的进程进入可运行状态时，try_to_wake_up()也会设置这个标志</li></ul><p>然后内核检查该标志，确认被设置后，会调用schedule()切换到一个新进程</p><h4 id="461-用户抢占"><a class="markdownIt-Anchor" href="#461-用户抢占"></a> 4.6.1 用户抢占</h4><p>内核在中断处理程序或者系统调用返回后，都会检查<code>need_resched</code>标志。从中断处理程序或者系统调用返回的返回路径都是跟体系结构相关，在entry.S(包含内核入口和退出的代码)文件通过汇编实现</p><p>当内核将返回用户空间的时候，如果<code>need_resched</code>标志被设置，会导致schedule()调用，会发生用户抢占</p><p>因此，用户抢占发生在以下情况：</p><ul><li>系统调用返回用户空间时</li><li>中断处理程序返回用户空间时</li></ul><h4 id="462-内核抢占"><a class="markdownIt-Anchor" href="#462-内核抢占"></a> 4.6.2 内核抢占</h4><blockquote><p>在没有内核抢占的系统中，调度程序没有办法在一个内核级的任务正在执行时重新调度，内核中的任务以协作方式调度，不具备抢占性，内核代码一直执行到完成（返回用户空间）或者阻塞为止</p></blockquote><p>在2.6版本，Linux内核引入抢占能力，只要重新调度是<strong>安全的</strong>（没有持有锁的情况），内核可以在任何时间抢占正在执行的任务。</p><p>在每个进程的thread_info结构中加入preempt_count计数，代表进程使用锁的个数。</p><ul><li>在中断返回内核空间的时候，会检查need_resched和preempt_count，如果need_resched被设置且preempt_count为0，则可以进行安全的抢占，调度程序schedule()会被调用，否则，中断直接返回当前进程</li><li>如果进程持有的所有锁被释放，preempt_count会减为0，此时释放锁的代码会检查need_resched标志，如果被设置，则调用schedule()</li></ul><p>因此，内核抢占发生在：</p><ul><li>中断处理程序正在执行，且返回内核空间之前</li><li>进程在内核空间释放锁的时候</li><li>内核任务显式的调用schedule()</li><li>内核中的任务阻塞</li></ul><h3 id="47-实时调度策略"><a class="markdownIt-Anchor" href="#47-实时调度策略"></a> 4.7 实时调度策略</h3><blockquote><p>Linux提供了一种软实时的工作方式</p><p>软实时的定义：内核调度进程尽力使进程在规定时间到来前运行，但是内核不能总是满足这些进程的要求</p><p>硬实时的定义：保证在一定条件下，可以完全满足进程在规定的时间内完成操作</p></blockquote><p>Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR，普通的、非实时的调度策略是SCHED_NORMAL。实时策略不被CFS调度器管理，而是被一个特殊的实时调度器管理</p><p>SCHED_FIFO实现了<strong>简单的、先入先出的调度算法</strong>，它不使用时间片，SCHED_RR和前者大致相同，不同点在于它使用时间片，是一种<strong>实时轮转调度算法</strong></p><h2 id="5-系统调用"><a class="markdownIt-Anchor" href="#5-系统调用"></a> 5 系统调用</h2><h3 id="51-与内核通信"><a class="markdownIt-Anchor" href="#51-与内核通信"></a> 5.1 与内核通信</h3><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层，主要作用是：</p><ul><li>为用户空间提供了硬件的抽象接口</li><li>保证了系统的稳定和安全，可以基于权限、用户类型和其他一些规则对需要进行的访问进行裁决</li></ul><p>系统调用是用户空间访问内核的<strong>唯一手段</strong>，除了<strong>异常和陷入</strong>之外，它是内核唯一的合法入口</p><h3 id="52-api-posix和c库"><a class="markdownIt-Anchor" href="#52-api-posix和c库"></a> 5.2 API、POSIX和C库</h3><p>应用程序通过在用户空间实现的应用编程接口（API）而不是直接通过系统调用来变成，一个API定义了一组应用程序使用的编程接口，可以实现为一个或多个系统调用，或者完全不使用任何系统调用</p><p>POSIX、API、C库以及系统调用的关系如下图</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200531102311595.png" width=800><h3 id="53-系统调用"><a class="markdownIt-Anchor" href="#53-系统调用"></a> 5.3 系统调用</h3><h4 id="531-系统调用号"><a class="markdownIt-Anchor" href="#531-系统调用号"></a> 5.3.1 系统调用号</h4><p>在Linux中，每个系统调用被赋予了一个系统调用号。</p><p>系统调用号的特点：</p><ul><li>系统调用号一旦分配就不能再有变更，否则编译好的程序有可能崩溃</li><li>如果系统调用被删除，所占用的系统调用号不允许被回收利用，否则以前编译过的代码会调用这个系统调用，但是却调用的另一个系统调用，Linux使用“未实现”系统调用<code>sys_ni_syscall()</code>来填补这种空缺，它除了返回<code>-ENOSYS</code>外不做任何工作</li></ul><p>系统调用表sys_call_table，为每一个有效的系统调用指定了唯一的系统调用号</p><h4 id="532-系统调用的性能"><a class="markdownIt-Anchor" href="#532-系统调用的性能"></a> 5.3.2 系统调用的性能</h4><p>Linux系统调用比其他许多操作系统都要快，原因是：</p><ul><li>Linux很短的上下文切换时间，进出内核被优化的很简洁</li><li>系统调用处理程序和每个系统调用本身也很简洁</li></ul><h3 id="54-系统调用处理程序"><a class="markdownIt-Anchor" href="#54-系统调用处理程序"></a> 5.4 系统调用处理程序</h3><p>通知内核的机制通过软中断实现：通过引发一个异常来促使系统切换到内核态去执行异常处理程序</p><p>在x86系统上预定义的软中断是中断号128，通过int $0x80指令触发中断，这条指令触发一个异常导致系统切换到内核态并执行第128号异常处理程序（这个异常处理程序就是系统调用处理程序），它的名字是system_call()</p><h4 id="541-指定恰当的系统调用"><a class="markdownIt-Anchor" href="#541-指定恰当的系统调用"></a> 5.4.1 指定恰当的系统调用</h4><p>因为所有系统调用陷入内核的方式都一样，所以需要把系统调用号传给内核用于区分每种系统调用。</p><p>在x86上，系统调用号通过eax寄存器传递给内核，在陷入内核之前，用户空间把相应系统调用号放入eax中，system_call()函数将给定的系统调用号与NR_syscalls作比较来检查其有效性，如果大于或等于NR_syscalls，就返回-ENOSYS，否则，执行相应的系统调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call *sys_call_table(, %rax, 8)</span><br></pre></td></tr></table></figure><h4 id="542-参数传递"><a class="markdownIt-Anchor" href="#542-参数传递"></a> 5.4.2 参数传递</h4><p>系统调用额外的参数也是存放在寄存器传递给内核。在x86-32系统上，ebx、ecx、edx、esi和edi按照顺序存放前5个参数，如果超过5个参数，需要用单独的寄存器存放<strong>所有指向这些参数在用户空间地址的指针</strong></p><p>给用户空间的返回值也通过寄存机传递，在x86系统中，它存放在eax寄存器</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200531110908683.png" width="800"><h3 id="55-系统调用的实现"><a class="markdownIt-Anchor" href="#55-系统调用的实现"></a> 5.5 系统调用的实现</h3><h4 id="551-实现系统调用"><a class="markdownIt-Anchor" href="#551-实现系统调用"></a> 5.5.1 实现系统调用</h4><p>实现的几个原则：</p><ul><li>尽量提供单一功能</li><li>系统调用应该提供标志参数以确保<strong>向前兼容</strong>，扩展了功能和选项</li><li>系统调用要考虑通用性，<strong>提供机制而不是策略</strong></li></ul><h4 id="552-参数验证"><a class="markdownIt-Anchor" href="#552-参数验证"></a> 5.5.2 参数验证</h4><p>由于系统调用在内核空间执行，为了保证系统的安全和稳定，系统调用必须仔细检查所有的参数是否合法</p><p>其中，最重要的一项就是<strong>检查用户提供的指针是否有效</strong>。在接收一个用户空间的指针之前，内核必须保证：</p><ul><li>指针指向的内存区域属于用户空间，进程决不能哄骗内核去读内核空间的数据</li><li>指针指向的内存区域在进程的地址空间中，进程决不能哄骗内核去读其他进程的数据</li><li>内存应该标记为对应的读、写或者可执行的权限，进程决不能绕过内存访问权限</li></ul><p>内核提供两个方法完成<strong>必须的检查和内核空间与用户空间之间数据的来回拷贝</strong>，分别为<code>copy_to_user()</code>和<code>copy_from_user()</code></p><p>如果执行失败，这两个函数返回没能完成拷贝的数据的字节数；如果成功，返回0。两个方法都有可能<strong>阻塞</strong>，当包含用户数据的页被换出到磁盘而不再物理内存上时，就可能发生，此时进程休眠，知道缺页异常程序将改页换入物理内存</p><p><strong>注意</strong>：内核无论何时都不能轻率地接受来自用户空间的指针！</p><p><strong>最后一项检查</strong>：进程是否有对应系统调用的合法权限，如<code>reboot()</code>系统调用，需要确保进程拥有CAP_SYS_REBOOT功能</p><h3 id="56-系统调用上下文"><a class="markdownIt-Anchor" href="#56-系统调用上下文"></a> 5.6 系统调用上下文</h3><p>内核在执行系统调用事处于进程上下文，current指针指向当前任务，即引发系统调用的那个进程</p><p>在进程上下文中，内核可以休眠（比如在系统调用阻塞或者调用schedule()时），这说明了：</p><ul><li>系统调用可以使用内核提供的绝大多数功能</li><li>系统调用的进程可以被其他进程抢占，新的进程可以使用相同的系统调用，因此需要保证系统调用是可重入的</li></ul><h4 id="561-绑定一个系统调用的最后步骤"><a class="markdownIt-Anchor" href="#561-绑定一个系统调用的最后步骤"></a> 5.6.1 绑定一个系统调用的最后步骤</h4><p>注册一个正式的系统调用的过程为：</p><ul><li>在系统调用表的最后加入一个表项，从0开始递增</li><li>对于所支持的各种体系结构，系统调用号都必须定义于&lt;asm/unistd.h&gt;中</li><li>系统调用必须被编译进内核映像（不能被编译成模块），只需要将它放进kernel/下的相关文件就可以</li></ul><p>例如，一个虚构的系统调用foo()注册的过程：</p><ol><li>将sys_foo加入到系统调用表中，对于大多数体系结构，该表位于entry.s文件，形式如下图，将新的系统调用<code>.long sys_foo</code>加入表的末尾</li></ol><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200531123204686.png" width="600"><ol start="2"><li>将系统调用号加入到&lt;asm/unistd.h&gt;，格式如下图：</li></ol><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200531123538872.png" width="600"><p>然后在该表中加入一行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_foo 338</span></span><br></pre></td></tr></table></figure><ol start="3"><li>最后，实现foo()系统调用，把实现代码放进kernel/sys.c文件中（asmlinkage限定词是一个编译指令，通知编译器仅从栈中提取该函数的参数）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> THREAD_SIZE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="562-从用户空间访问系统调用"><a class="markdownIt-Anchor" href="#562-从用户空间访问系统调用"></a> 5.6.2 从用户空间访问系统调用</h4><p>用户程序除了通过标准头文件和C库链接来使用系统调用之外，Linux本身提供了一组宏，用于直接访问系统调用，它会设置好寄存器并调用陷入指令，这些宏的形式为_syscall<em>n()</em>（n的范围是0~6，代表传递给系统调用的参数个数）</p><p>例如，<code>open()</code>系统调用的定义是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flags, <span class="type">int</span> mode)</span></span><br></pre></td></tr></table></figure><p>不依靠库的支持，直接调用此系统调用的宏形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> NR_open 5</span></span><br><span class="line">_syscall3(<span class="type">long</span>, open, <span class="type">const</span> <span class="type">char</span>*, filename, <span class="type">int</span>, flags, <span class="type">int</span>, mode)</span><br></pre></td></tr></table></figure><p>每个宏都有2+2*n个参数，第一个参数对应系统调用的返回类型，第二个参数是系统调用的名称，之后就是系统调用参数顺序排列的每个参数的类型和名称。该宏会扩展成内嵌汇编的C函数，汇编语言执行将系统调用号压入寄存器并触发软中断陷入内核的过程</p><h2 id="6-内核数据结构"><a class="markdownIt-Anchor" href="#6-内核数据结构"></a> 6 内核数据结构</h2><h2 id="7-中断和中断处理"><a class="markdownIt-Anchor" href="#7-中断和中断处理"></a> 7 中断和中断处理</h2><h2 id="8-下半部和推后执行的工作"><a class="markdownIt-Anchor" href="#8-下半部和推后执行的工作"></a> 8 下半部和推后执行的工作</h2><h2 id="9-网络"><a class="markdownIt-Anchor" href="#9-网络"></a> 9 网络</h2><h3 id="91-网络实现的分层模型"><a class="markdownIt-Anchor" href="#91-网络实现的分层模型"></a> 9.1 网络实现的分层模型</h3><p>内核网络子系统的实现与TCP/IP模型很相似，相关的C语言代码划分为不同层次，各层次都有明确定义的任务，各个层次只能通过明确定义的接口与上下紧邻的层次通信（这样设计的优点：可以组合使用各种设备、传输机制和协议），如下图是内核对于分层结构的实现</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200720194433868.png" alt="image-20200720194433868" /></p><p>该子系统处理了大量特定于协议的细节，穿越各层的代码路径中有大量的函数指针，没有直接的函数调用（因为各个层次存在多个组合关系）。</p><h3 id="92-网络命名空间"><a class="markdownIt-Anchor" href="#92-网络命名空间"></a> 9.2 网络命名空间</h3><h3 id="93-套接字缓冲区"><a class="markdownIt-Anchor" href="#93-套接字缓冲区"></a> 9.3 套接字缓冲区</h3><p>内核采用<strong>套接字缓冲区</strong>用于在网络实现的各个层次之间交换数据，无须来回复制分组数据，提高了性能</p><p>其结构定义如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200720195417684.png" alt="image-20200720195417684" /><br /><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200720195445895.png" alt="image-20200720195445895" /></p><h4 id="931-使用套接字缓冲区管理数据"><a class="markdownIt-Anchor" href="#931-使用套接字缓冲区管理数据"></a> 9.3.1 使用套接字缓冲区管理数据</h4><p>套接字缓冲区通过其中包含的各种指针与一个内存区域相关联，网络分组的数据位于该区域。</p><p>套接字缓冲区的基本思想是：通过操作指针来增删协议首部</p><ul><li><p>head和end指向数据在内存中的起始和结束位置</p></li><li><p>data和tail指向协议数据区域的起始和结束位置</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200720200359909.png" alt="image-20200720200359909" /></p></li><li><p>mac_header指向MAC协议首部的起始，network_header和transport_header分别指向网络层和传输层协议首部的起始；在字长32位的系统上，数据类型sk_buff_data_t表示各种类型为简单指针的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="type">sk_buff_data_t</span>;</span><br></pre></td></tr></table></figure></li><li><p>data和tail使得在不同协议层之间传递数据时，无须显式地复制操作，如下图展示了分组的合成方式</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200721082112889.png" alt="image-20200721082112889" /></p></li></ul><p>在一个新分组产生时，TCP层首先在<strong>用户空间</strong>分配内存来容纳该分组数据（首部和净荷），分配的空间大于数据实际需要的长度，因此较低的协议层可以进一步增加首部</p><p>然后分配一个套接字缓冲区，使得head和end分别指向上述内存区的起始和结束地址，而TCP数据位于data和tail之间</p><p>在套接字缓冲区传递到互联网络层时，必须增加一个新层，只需要向已经分配但尚未占用的那部分内存写入数据即可，除了data之外所有的指针都不变，data现在指向IP首部的起始处，下面的各层会重复这样的操作，直至分组完成通过网络发送</p><p>为了保证套接字缓冲区的长度尽可能小，在64位CPU上，将sk_buff_data_t改为整型变量，由于整型变量占用的内存只有指针变量的一半（前者4字节，后者8字节），该结构的长度缩减了20字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">sk_buff_data_t</span>;</span><br></pre></td></tr></table></figure><p>其中data和head仍然是常规的指针，而所有sk_buff_data_t类型的成员是前两者的偏移，如指向传输层的首部指针计算如下：</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200721083726563.png" alt="image-20200721083726563" /></p><h4 id="932-管理套接字缓冲区数据"><a class="markdownIt-Anchor" href="#932-管理套接字缓冲区数据"></a> 9.3.2 管理套接字缓冲区数据</h4><p>除了前述的指针外，套接字缓冲区还包括用于处理相关的数据和管理套接字缓冲区自身的其他成员，主要成员如下：</p><ul><li>tstamp：保存了分组到达的时间</li><li>dev指定了分组的网络设备</li><li>iif：输入设备的接口索引号</li><li>sk：指向处理该分组套接字对应的socket实例的指针</li><li>dst：改分组接下来通过内核网络实现的路由</li><li>next和prev：将套接字缓冲区保存在一个双链表中（没有用内核标准链表实现，使用了手工实现的版本）</li><li>qlen：指定了等待的长度</li></ul><p>sk_buff_head和sk_buff的next和prev用于创建一个循环链表，套接字缓冲区的list成员指向表头，如下图</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200721084613884.png" alt="image-20200721084613884" /></p><h3 id="94-网络访问层"><a class="markdownIt-Anchor" href="#94-网络访问层"></a> 9.4 网络访问层</h3><p>网络访问层主要负责在计算机之间传输信息，与网卡的设备驱动程序直接协作</p><h3 id="941-网络设备的表示"><a class="markdownIt-Anchor" href="#941-网络设备的表示"></a> 9.4.1 网络设备的表示</h3><p>在内核中，每个网络设备都表示为net_device结构的实例，在分配并填充该实例之后，必须用net/dev.c中的register_device函数将其注册到内核。该函数完成一些初始化任务，并将该设备注册到通用设备机制内，这会创建一个sysfs项/sys/class/net/<device>，关联到该设备对应的目录</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200721085534908.png" alt="image-20200721085534908" /></p><p>网络设备不是全局的，是按照命名空间进行管理，每个命名空间（net实例）有如下3个实例可用：</p><ul><li>所有的网络设备都保存在一个单链表中，表头为dev_base</li><li>按设备名散列：辅助函数dev_get_by_name(struct net *net, const char *name)根据设备名在该散列表上查找网络设备</li><li>按接口索引散列：辅助函数dev_get_by_index(struct net *net, int ifindex)根据给定的接口索引查找net_device的实例</li></ul><p>net_device结构包含了与特定设备相关的所有信息，该结构非常复杂，如下图为部分成员</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200721090550123.png" alt="image-20200721090550123" /></p><p>一些成员定义了与网络层和网络访问层相关的设备属性：</p><ul><li>mtu指定了一个传输帧的最大长度</li><li>type保存了设备的硬件类型</li><li>dev_addr存储了设备的硬件地址（如以太网的MAC地址），addr_len指向该地址的长度，broadcast是广播地址</li><li>ip_ptr、ip6_ptr、atalk_ptr等指针指向特定于协议的数据</li></ul><p>net_device的大多数成员都是函数指针，执行与网卡相关的典型任务，这些成员表示了与下一个协议层的抽象接口，实现同一组接口访问所有的网卡，而网卡的驱动程序负责实现细节</p><h4 id="942-接收分组"><a class="markdownIt-Anchor" href="#942-接收分组"></a> 9.4.2 接收分组</h4><p>所有现代的设备驱动程序都使用中断来通知内核有分组到达。网卡驱动程序对特定于设备的中断设置了一个处理例程，每当中断被引发时，内核都会调用中断处理程序，将数据从网卡传输到物理内存（通过DMA方式能够将数据从网卡传输到物理内存），或者通知内核在一定时间后进行处理</p><p>如下图是一个分组到达网络适配器之后，该分组穿过内核到达网络层函数的路径</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200727084714720.png" alt="image-20200727084714720" /></p><p>分组是在中断上下文中接收的，处理例程只能执行一些基本任务，避免系统其他任务延迟太长时间</p><p>在中断上下文中，数据由3个短函数处理，执行下列任务：</p><ul><li>net_interrupt是设备驱动程序设置的中断处理程序，它用于确定中断是否真的由接收到的分组所引发的，如果确实如此，则控制转到net_rx</li><li>net_rx函数也是特定于网卡，首先创建一个套接字缓冲区，并指向一块物理内存，分组的内容接下来从网卡传输到缓冲区（也就是物理内存），然后分析首部数据，确定分组数据所使用的网络层协议</li><li>接下来调用netif_rx，与前两个方法不同，netif_rx不是特定于网络驱动程序的，该函数位于net/core/dev.c函数中，调用该函数，标志着控制由特定于网卡的代码转到<strong>网络层的通用接口部分</strong>。该函数的作用在于，将接收的分组放置到一个特定于CPU的等待队列上，并退出中断上下文</li></ul><p>内核在全局定义的softnet_data数组中管理进出分组的等待队列，数组类型为softnet_data，为提高多处理器系统的性能，对每个CPU都会创建等待队列，支持分组的并行处理。不需要显式的使用锁机制，因为每个CPU只会处理自身的队列，不会干扰其他CPU的工作</p><p>softnet_data结构如下，inpput_pkt_queue使用前面提到的sk_buff_head表头，对所有进入的分组建立一个链表</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200727085803749.png" alt="image-20200727085803749" /></p><p>netif_rx在结束之前将软中断NET_RX_SOFTIRQ标记为即将执行，然后退出中断上下文，接下来net_rx_action用于该软中断的处理程序，其代码流程图如下（这里是简化版本）</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200727090201863.png" alt="image-20200727090201863" /></p><p>在一些准备工作之后，工作转移到process_backlog，该函数在循环中处理下列步骤</p><ul><li>__skb_dequeue从等待队列中移除一个套接字缓冲区，该缓冲区管理着一个接收到的分组</li><li>由netif_receive_skb函数分析分组类型，以便根据分组类型将分组传递到网络层的接收函数（即传输到网络系统的更高一层），该函数遍历可能负责当前分组类型的所有网络层函数，逐个调用deliver_skb函数</li><li>接下来deliver_skb函数使用特定于分组类型的处理程序func，承担对分组更高一层的处理</li></ul><p>新的协议通过dev_add_pack增加，各个数组项的类型为struct packet_type，定义如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200729082148633.png" alt="image-20200729082148633" /></p><p>func是该结构的主要成员，指向网络层函数的指针，如果分组的类型合适，则将其传递给该函数</p><h4 id="943-发送分组"><a class="markdownIt-Anchor" href="#943-发送分组"></a> 9.4.3 发送分组</h4><p>net/core/dev.c中的dev_queue_xmit用于将分组放置到发出分组的队列上，在分组放置到等待队列上一定时间后，分组将发出，这是由特定于适配器的函数hard_start_xmit完成，在每个net_device结构中都以函数指针出现</p><h3 id="95-网络层"><a class="markdownIt-Anchor" href="#95-网络层"></a> 9.5 网络层</h3><h4 id="951-ipv4"><a class="markdownIt-Anchor" href="#951-ipv4"></a> 9.5.1 IPv4</h4><p>IP分组使用的协议首部如下图</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200729083424801.png" alt="image-20200729083424801" /></p><p>在内核源码中，该首部由iphdr结构实现</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200729083533669.png" alt="image-20200729083533669" /></p><p>ip_rcv函数是网络层的入口点，分组向上传过内核的路线如下图</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200729083648597.png" alt="image-20200729083648597" /></p><h4 id="952-接收分组"><a class="markdownIt-Anchor" href="#952-接收分组"></a> 9.5.2 接收分组</h4><p>在分组转发到ip_rcv（packet_type -&gt; func）时，必须检查接收到的信息，主要是检查计算的校验和与首部中的校验和是否一致，还会检查分组是否达到了IP首部的最小长度，协议是否是IPv4（IPv6的例程是另一个）</p><p>在进行一些检查之后，内核并不立即继续对分组的处理。而是调用一个netfilter挂钩，使用户可以对分组进行操作，当内核到达一个挂钩位置时，将在用户空间调用对该标记支持的例程，接着在另一个内核函数继续内核端的处理</p><p>下一步，需要判断分组目的地是本地还是远程计算机，从而判断需要将分组转发到更高层或是转到互联网络层的输出路径上</p><p>ip_route_input负责选择路由，判断路由的结果是选择一个函数，进行进一步的处理，可用的函数分别是ip_local_deliver和ip_forward，分别对应向更高一层传递和转发到另一台计算机</p><h4 id="953-交付到本地传输层"><a class="markdownIt-Anchor" href="#953-交付到本地传输层"></a> 9.5.3 交付到本地传输层</h4><p>如果分组的目的地是本地计算机，ip_local_deliver会找到一个合适的传输层函数，将分组转发过去</p><ol><li><strong>分片合并</strong></li></ol><p>该函数的第一项任务是通过ip_defrag重新组合分片分组的各个部分，对应的代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200729084944972.png" alt="image-20200729084944972" /></p><p>内核在一个独立的缓存中管理一个分组的各个分片，改缓存称为<strong>分片缓存</strong>。在缓存中，属于同一个分组的各个分片保存在一个独立的等待队列中，直至改分组的所有分片都到达</p><p>接下来调用ip_find函数，它使用基于分片ID、源地址、目标地址、分组协议标识的散列值，检查是否为对应的分组创建了等待队列。如果没有，则建立一个新的队列，并将当前处理的分组置于其上，否则返回现存队列的地址，以便ip_frag_queue将分组置于队列上</p><p>在分组的所有分片都进入缓存，ip_frag_reasm将各个分片组合起来；如果分片尚未全部到达，ip_defrag返回NULL指针，终止互联网络层的分组处理，在所有分组都到达后，将恢复处理</p><ol start="2"><li><p><strong>交付到传输层</strong></p><p>接下来返回到ip_local_deliver，在分片合并完成后，调用netfilter挂钩NF_IP_LOCAL_IN，恢复在ip_local_deliver_finish函数中的处理，会根据分组的协议标识符确定一个传输层的函数，将分组传递到该函数，所有基于互联网络层的协议都有一个net_protocol结构的实例，该结构定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> (*handler)(<span class="keyword">struct</span> sk_buff *skb);</span><br><span class="line">  <span class="type">void</span> (*err_handler)(<span class="keyword">struct</span> sk_buff *skb, u32 info);</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>handler是协议例程</li><li>在接收到ICMP错误信息并需要传递到更高层时，需要调用err_handler</li></ul><p>inet_add_protocol标准函数将上述结构的实例指针存储到inet_protos数组，通过散列的方法确定存储具体协议的索引位置</p><p>在套接字缓冲区中通过指针移动“删除”IP首部后，剩下的工作就是调用传输层对应的接收例程，其函数指针存储在inet_protocol的handler字段中。例如接收TCP分组的tcp_v4_rcv例程</p></li></ol><h4 id="954-分组转发"><a class="markdownIt-Anchor" href="#954-分组转发"></a> 9.5.4 分组转发</h4><p>当需要将分组转发到其他计算机时，分组的目标地址分为两类：</p><ul><li>目标计算机在某个本地网络中，发送计算机与该网络有连接</li><li>目标计算机是远程计算机，不连接本地网络，只能通过网关访问</li></ul><p>第二种情况会复杂很多，需要找到剩余路由中的第一个站点，将分组转发到该站点，不仅需要计算机所属本地网络结构的相关信息，还需要相邻网络和相关的外出路径的信息。该信息由<strong>路由表</strong>提供，由内核通过多种数据结构管理，会在[9.5.5](####9.5.5 发送分组)节讨论</p><p>在接收分组时，调用的ip_route_input函数充当路由实现的接口，它能够识别出分组是交付到本地还是转发出去，同时能找到通向目标地址的路由（目标地址存储在套接字缓冲区的dst字段）</p><p>ip_forward函数的处理流程如下图</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200730083703350.png" alt="image-20200730083703350" /></p><ul><li>首先，根据TTL字段检查是否允许传输到下一跳，如果TTL&lt;=1，则丢弃该分组，否则，将TTL减一，ip_decrease_ttl负责该工作，修改TTL的同时分组校验和也会修改</li><li>接下来调用netfilter挂钩NF_IP_FORWARD，之后在ip_forward_finish中恢复处理，接下来的工作委托给两个函数<ul><li>如果分组包含额外的选项，则在ip_forward_options函数中处理</li><li>dst_output函数将分组传递到在路由期间选择并保存在skb-&gt;dst-&gt;output的发送函数，通常使用ip_output，该函数将分组传递到与目标地址匹配的网络适配器</li></ul></li></ul><h4 id="955-发送分组"><a class="markdownIt-Anchor" href="#955-发送分组"></a> 9.5.5 发送分组</h4><p>内核会提供通过互联网络层发送分数据的函数给较高层的协议（传输层）使用，其中ip_queue_xmit是比较常见的一个，代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200730085816908.png" alt="image-20200730085816908" /></p><ul><li>首先查找可用于该分组的路由，在发送第一个分组时，内核需要查找一个新的路由（在下文讨论）</li><li>接下来ip_send_check为分组生成校验和</li><li>内核调用netfilter挂钩NF_IP_LOCAL_OUT</li><li>接下来调用dst_output函数，还函数基于调用skb-&gt;dst-&gt;output函数（在确定路由期间找到），后者位于套接字缓冲区中，与目标地址无关，通常该函数指向ip_output，本地产生和转发的分组将在该函数汇总</li></ul><ol><li><p><strong>转移到网络访问层</strong></p><p>ip_output函数的代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200730090512169.png" alt="image-20200730090512169" /></p><ul><li>首先调用netfilter挂钩NF_IP_POST_ROUTING</li><li>接下来是ip_finish_output</li><li>如果分组长度不大于MTU，则无须分片，直接调用ip_funish_output2，该函数检查套接字缓冲区是否有足够空间容纳产生的硬件首部，如果不够，则使用skb_realloc_headroom分配额外的空间;否则调用ip_fragment实现分组的分片</li><li>最后调用路由层设置的函数dst-&gt;neighbour-&gt;output，该函数指针通常指向dev_queue_xmit</li></ul></li><li><p><strong>分组分片</strong></p><p>ip_fragment将IP分组划分为更小的单位，如下图</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200730091212221.png" alt="image-20200730091212221" /></p></li><li><p><strong>路由</strong></p><p>每个接收到的分组分为3类：</p><ul><li>目标是本地主机</li><li>目标是当前主机连接的计算机</li><li>目标是远程计算机，只能经由中间系统到达</li></ul><p>对于第3种情况，必须根据路由选择信息来查找网关系统，分组需要通过网关发送</p><p>内核使用散列表来加速路由的工作，路由的起始点是ip_route_input函数，它首先会在路由缓存中查找路由</p><p>ip_route_input_slow用于根据内核的数据结构建立一个新的路由，它调用fib_lookup函数，后者的隐式返回值（一个用作参数的指针）指向一个fib_result结构的实例。fib代表信息转发库，是一个表，用于管理内核保存的路由选择信息</p><p>路由结果关联到一个套接字缓冲区，其中的dst成员指向一个dst_entry结构的实例，该实例的内容在路由期间查找，其结构定义如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200731081843643.png" alt="image-20200731081843643" /></p><ul><li><p>Input和output分别用于处理进入和外出的分组，根据分组类型，会将input和output指向不同的函数:</p><ul><li>对需要交付到本地的分组，input设置为ip_local_deliver，而output设置为ip_rt_bug（该函数只会向内核日志输出一个错误信息）</li></ul></li></ul></li></ol><ul><li><p>对于需要转发的分组，input设置为ip_forward，output设置为ip_output函数</p></li><li><p>dev指定了用于处理该分组的网络设备</p></li><li><p>neighbour成员存储了计算机在本地网络的IP和硬件地址，可以通过网络访问层直接到达</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200731082550667.png" alt="image-20200731082550667" /></p><p>dev保存了网络设备的数据结构而ha是设备的硬件地址，output是指向适当的内核函数的指针，在通过网络适配器传递分组时调用</p><p>neighbour实例由内核中实现ARP的ARP层创建，ARP协议负责将IP地址转换为硬件地址，由于dst_dentry实例有一个成员指向neighbour，网络访问层的代码在分组通过网络适配器离开当前系统时可以调用output函数</p></li></ul><h4 id="956-netfilter"><a class="markdownIt-Anchor" href="#956-netfilter"></a> 9.5.6 netfilter</h4><p>netfilter是一个Linux内核框架，可以根据动态定义的条件来过滤和操作分组</p><ol><li><p><strong>扩展网络功能</strong></p><p>netfilter框架向内核添加了下列能力：</p><ul><li>根据状态及其他条件，对不同数据流方向（进入、外出、转发）进行<strong>分组过滤</strong></li><li><strong>NAT（网络地址转换）</strong>，根据某些规则来转换源地址和目标地址</li><li>分组处理和操作，根据特定的规则拆分和修改分组</li></ul><p>可以在运行时向内核载入模块来增强netfilter功能，一个定义好的规则集，告诉内核在何时使用各个模块的代码</p><p>netfilter实现由两部分组成：</p><ul><li>内核代码中的挂钩，位于网络实现的核心，用于调用netfilter代码</li><li>netfilter模块，其代码挂钩内核调用，但独立于其余的网络代码</li></ul><p>iptables由网络管理员用来配置防火墙、分组过滤器和类似功能，这些是定义在neifilter框架上的模块</p></li><li><p><strong>调用挂钩函数</strong></p><p>在通过挂钩执行netfilter代码时，网络层的函数将会中断。挂钩将一个函数分为两部分，前一部分在netfilter代码调用前运行，后一部分在其后执行</p><p>netfilter挂钩通过&lt;netfilter.h&gt;中的NF_HOOK宏调用，如果内核启用的netfilter支持，该宏定义如下：</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200731090358996.png" alt="image-20200731090358996" /></p><ul><li>pf是指调用的netfilter挂钩源自哪个协议族（IPv4层的所有调用都使用PF_INET）</li><li>hook是挂钩编号，如NF_IP_FOREARD和NF_IP_LOCAL_OUT，定义在&lt;netfilter_ipv4.h&gt;中</li><li>skb代表所处理的套接字缓冲区</li><li>indev和outdev是指向网络设备的net_device实例的指针，分别通过二者进入和离开内核（值可以为NULL）</li><li>okfn是一个函数指针，在netfilter挂钩结束时执行</li></ul><p>该宏在展开时，首先迂回到NF_HOOK_THRESH和nf_hook_thresh，然后执行nf_look_slow来处理netfilter挂钩，最后调用结束netfilter处理的okfn函数；其中的nf_hook_slow函数会遍历所有注册的netfilter挂钩并调用它们</p><p>以IP转发为例，挂钩调用的代码如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200731091121429.png" alt="image-20200731091121429" /><br /><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200731091142602.png" alt="image-20200731091142602" /></p><p>其中指向的okfn是ip_forward_finish，如果没有为PF_INET和NF_IP_FORWARD注册netfilter挂钩，那么控制直接传递到该函数，否则，执行相关的netfilter代码，控制转入ip_forward_finish</p></li><li><p><strong>扫描挂钩表</strong></p><p>如果注册了挂钩函数，则会调用nf_hook_slow函数，所有挂钩都保存在二维数组nf_hooks中</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802092331057.png" alt="image-20200802092331057" /></p><p>NPPOTO指定了系统支持的协议族的最大数目（各个协议族的符号常数，例如PF_INET和PF_DECnet，保存在include/linux/socket.h），每个协议可以定义NF_MAX_HOOKS个挂钩链表，默认值是8个</p><p>该表的list_head元素作为双链表表头，双链表可容纳nf_hooks_ops实例</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802092849165.png" alt="image-20200802092849165" /></p><p>主要成员：</p><ul><li><p>list：将结构连接到双链表</p></li><li><p>owner：指向所属模块的module数据结构的指针</p></li><li><p>hook：一个指向挂钩函数的指针，需要的参数和NF_HOOK宏相同</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802093257426.png" alt="image-20200802093257426" /></p></li><li><p>pf和hooknum指定了协议族和与挂钩相关的编号</p></li><li><p>链表中的挂钩是按照优先级升序排列（比如，可以确保分组数据的处理总是在过滤器操作之前进行）</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802093500875.png" alt="image-20200802093500875" /></p></li></ul><p>可以根据协议族和挂钩编号从nf_hook数组中选择适当的链表，接下来的工作委托给of_iterate，该函数会保存所有链表元素，并调用hook函数</p></li><li><p><strong>激活挂钩函数</strong></p><p>每个hook函数都返回下列值之一：</p><ul><li>NF_ACCEPT：表示接受分组</li><li>NF_STOLEN：表示挂钩函数“窃取”了一个分组并处理该分组，此时分组已与内核无关，不必在调用其他挂钩，还需要取消其他协议层的处理</li><li>NF_DROP：通知内核丢弃该分组，和CF_STOLEN一洋，其他挂钩和协议层也不需要处理，同时套接字缓冲区占用的内存空间可以释放，其中包含的数据可以被丢弃</li><li>NF_QUEUE：将分组置于一个等待队列上，以便其数据可以由用户空间代码处理，不会执行其他挂钩函数</li><li>NF_REPEAT：表示再次调用该挂钩</li></ul><p>最后，除非所有挂钩函数都返回NF_ACCEPT，否则分组不会在网络子系统进一步处理</p><p>内核提供了一个挂钩函数的集合，它们称为iptables，用于分组的高层处理（可以使用用户工具iptables来配置）</p></li></ol><h3 id="96-传输层"><a class="markdownIt-Anchor" href="#96-传输层"></a> 9.6 传输层</h3><h4 id="961-udp"><a class="markdownIt-Anchor" href="#961-udp"></a> 9.6.1 UDP</h4><p>经过前面[9.5.2节](# 9.5.2 接收分组) 介绍，ip_local_deliver负责分发IP分组传输的数据内容，net/core/udp.c中的udp_rcv用于进一步处理UDP数据报，其代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802095755049.png" alt="image-20200802095755049" /></p><p>udp_rcv函数是 __udp4_lib_rcv的包装器，而后者的输入参数是一个套接字缓冲区，在确认分组未经篡改之后，调用__udp4_lib_lookup查找与之匹配的监听套接字，连接参数从UDP首部中获取，其结构如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802100106115.png" alt="image-20200802100106115" /></p><p>__udp4_lib_rcv用于查找与分组目标匹配的内核内部的套接字，在有某个监听进程对分组感兴趣时，在udphash全局数组中会有与分组目标端口匹配的sock结构实例，__udp_lib_lookup采用散列方法查找并返回该实例；如果找不到，则向源系统发送一个“目标不可达”的消息，并丢弃分组内容</p><p>内核中有两种数据结构表示套接字，sock是到网络访问层的接口，socket是到用户空间的接口</p><p>sock结构简化版如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802101629272.png" alt="image-20200802101629272" /></p><p>在udp_rcv找到适当的sock实例后，控制转移到udp_queue_rcv_skb，然后立即调用sock_queue_rcv_skb，它会执行两个重要的操作，完成到应用层的数据交付</p><ul><li>等待通过套接字交付数据的进程，会再sk_sleep等待队列上睡眠</li><li>调用skb_queue_tail将包含分组数据的套接字缓冲区插入到sk_receive_queue链表末端，其表头保存在sock结构中</li><li>调用sk_data_ready指向的函数，通知套接字有新数据到达，这会唤醒sk_sleep队列上睡眠、等待数据到达的所有进程</li></ul><h4 id="962-tcp"><a class="markdownIt-Anchor" href="#962-tcp"></a> 9.6.2 TCP</h4><p>下面主要讨论TCP协议的3个主要部分：连接建立、连接终止和数据流的按序传输</p><p>TCP的状态转换如下图</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200803084218092.png" alt="image-20200803084218092" /></p><ol><li><p><strong>TCP首部</strong></p><p>TCP分组的首部包含了状态数据和其他连接信息，如下图所示</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200803084315826.png" alt="image-20200803084315826" /></p></li><li><p><strong>接收TCP数据</strong></p><p>在互联网络层处理过分组之后，tcp_v4_rcv是TCP的入口函数，其代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200803084515122.png" alt="image-20200803084515122" /></p><p>系统中的每个TCP套接字都归入3个散列表之一，分别对应下列状态：</p><ul><li>完全连接的套接字</li><li>等待连接（监听状态）的套接字</li><li>处于建立连接过程中的套接字</li></ul><p>在对分组数据进行各种检查并将首部中的信息复制到套接字缓冲区的控制块之后，内核将查找等待该分组的工作委托给__inet_lookup函数，它会调用两个函数，分别扫描各种散列表，其中__inet_lookup_established函数寻找一个已连接的套接字，如果没有找到合适的结构，则调用inet_lookup_listener函数检查所有的监听套接字</p><p>与UDP相比，在找到对应该连接适当的sock结构之后，工作尚未结束，必须根据连接的状态进行相应的状态迁移，tcp_v4_do_rcv是一个多路分解器，会基于套接字的状态将代码控制流划分到不同的分支</p></li><li><p><strong>被动连接建立</strong></p><p>被动连接是在接收到一个连接请求的SYN分组后出发的，它的起点是tcp_v4_rcv函数，其代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200803085509088.png" alt="image-20200803085509088" /></p><p>调用tcp_v4_hnd_req执行网络层中建立连接的各种初始化任务，实际的状态迁移是在tcp_rcv_state_process函数，它由一个长的switch/case语句组成，区分各种可能的套接字状态来调用适当的传输函数</p><p>可能的套接字状态定义在一个枚举中</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200803085745108.png" alt="image-20200803085745108" /><br /><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200803085807606.png" alt="image-20200803085807606" />如果套接字的状态是TCP_LISTEN，则调用tcp_v4_conn_request，该函数结束前发送确认分组，其中包含了设置的ACK标志和接受到的分组序列号，还包含新生成的序列号和SYN标志，此时服务端的套接字状态变为TCP_SYN_RECV；下一步，发送ACK分组给客户端，客户端返回确认分组，此时套接字状态由TCP_SYN_RECV变为TCP_ESTABLISHED</p></li><li><p><strong>主动连接建立</strong></p><p>主动连接发起是，是通过用户空间应用程序调用open库函数，发出socketcall系统调用到达内核函数tcp_v4_connect，其代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200803090535044.png" alt="image-20200803090535044" /></p><p>该函数开始于查找目标主机的IP路由，在产生TCP首部并将相关的值设置到套接字缓冲区之后，套接字状态从CLOSED变为SYN_SENT，接下来tcp_connect讲一个SYN分组发送到互联网络层，接下来发送到服务端。同时，会在内核创建一个定时器，确保如果在一定时间内没有接收到确认，将重新发送分组</p><p>接下来客户端等待服务端对SYN分组的确认以及确认连接请求的SYN分组，这回通向tcp_rcv_state_process分配器，然后控制流转到tcp_rcv_synsent_state_process函数，然后套接字状态设为ESTABLISHED，同时tcp_send_ack向服务器发送一个ACK分组，完成连接建立</p></li><li><p><strong>接收分组</strong></p><p>如下代码流程图是接收分组时的代码流程图，从tcp_v4_rcv函数开始</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200803101934382.png" alt="image-20200803101934382" /></p><p>在控制传递到tcp_v4_do_rcv后，在确定目标套接字的状态为TCP_ESTABLISHED之后，调用tcp_rcv_established函数，判断分组是否易于处理，如果是，在<strong>快速路径</strong>中处理，否则，在<strong>低速路径</strong>中处理</p><p>分组符合下列条件之一，归入易于分析：</p><ul><li>分组必须只包含对上一次发送数据的确认</li><li>分组必须只包含预期接收的数据</li></ul><p><strong>快速路径</strong>：</p><ul><li>会进行分组的检查，找到更为复杂的分组返回到低速路径</li><li>接下来分析分组的长度，确认分组的内容是数据还是确认</li><li>快速路径并不处理ACK部分，会调用tcp_ack函数，该函数最重要的功能是分析有关连接的新信息，同时从重传队列中删除确认数据（该队列包含所有发送的分组，如果在一定时间限制内没有收到ACK确认，则需要重传）</li><li>由于进入快速路径的数据是紧接着前一部分的，无须进行进一步检查，最后调用套接字中的sk_data_ready函数指针，通知用户进程数据可用</li></ul><p><strong>低速路径</strong>：要处理更多TCP选项，其中的代码要牵涉更广泛的内容，在低速路径中，数据保护能直接发送到套接字，需要对分组选项进行复杂的检查，然后是TCP子系统的响应，不按序到达的数据放置到一个专门的等待队列上，直至形成一个连续的数据段，才能将完整的数据传递到套接字</p></li><li><p><strong>发送分组</strong></p><p>TCP分组的发送，由更高层网络协议实例对tcp_sendmsg函数的调用开始，代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200803125215783.png" alt="image-20200803125215783" /></p><ul><li><p>首先，内核会等待直至连接建立，此时套接字状态是TCP_ESTABLISHED</p></li><li><p>数据从用户空间进程的地址空间复制到内核空间，用于建立一个TCP分组</p></li><li><p>接下来内核到达tcp_push_one，它执行下列3个任务：</p><ul><li><p>tcp_snd_test检查目前是否可以发送数据，比如接收方是否过载积压</p></li><li><p>tcp_transmit使用协议族相关的af_specific-&gt;queue_xmit函数（IPv4使用ip_queue_xmit函数），将数据转发到互联网络层</p></li><li><p>update_send_head处理对统计量的更新，初始化发送TCP信息段的重传定时器</p></li></ul></li></ul><p>发送TCP分组的过程需要满足下列需求：</p><ul><li>接收方等待队列上必须有足够的空间可用于该数据</li><li>必须实现防止连接拥塞的ECN机制</li><li>必须检测某一方出现失效的情况</li><li>TCP慢启动机制</li><li>发送但未得到确认的分组，需要超时重传</li></ul></li><li><p><strong>连接终止</strong></p><p>连接终止的状态迁移在分配器函数tcp_rcv_state_process进行，代码路径可能包含tcp_rcv_established和tcp_close函数</p><p>主动关闭的一方，会在用户进程调用close关闭连接，调用tcp_close函数</p><ul><li>如果套接字的状态为LISTEN，则将套接字的状态改为CLOSED；否则，控制转到tcp_close_state，其中调用tcp_set_state将套接字状态设置为FIN_WAIT_1，tcp_send_fin向另一方发送FIN分组</li><li>收到带有ACK标志的分组，触发FIN_WAIT_1到FIN_WAIT_2的迁移（在tcp_set_state中进行）</li><li>最后收到另一方发送过来的FIN分组，则将套接字的状态改为TIME_WAIT状态（之后会自动切换到CLOSED状态）</li></ul><p>被动关闭的一方状态迁移过程是类似的</p><ul><li>在收到第一个FIN分组时状态是TCP_ESTABLISHED，处理由tcp_rcv_established的低速路径进行，向主动关闭一方发送ACK分组，并将套接字状态改为TCP_CLOSING</li><li>然后发送FIN分组，状态变为LAST_ACK，是通过调用close库函数（调用内核的rcp_close_state函数）进行的</li><li>最后接收到主动关闭方发送的ACK分组，即可终止连接，通过tcp_rcv_state_process函数将套接字状态改为CLOSED（tcp_done函数处理），释放套接字占用的内存空间，并最终终止连接</li></ul></li></ol><h3 id="97-应用层"><a class="markdownIt-Anchor" href="#97-应用层"></a> 9.7 应用层</h3><p>内核与用户空间套接字之间的接口实现在C标准库中实现，使用了socketcall系统调用，它充当一个多路分解器，将各种任务分配由不同的过程执行</p><p>对程序使用的每个套接字来说，都对应于一个socket结构和sock结构的实例，二者分别充当向下（内核）和向上（用户空间）的接口</p><h4 id="971-socket数据结构"><a class="markdownIt-Anchor" href="#971-socket数据结构"></a> 9.7.1 socket数据结构</h4><p>socket结构定义如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802103414354.png" alt="image-20200802103414354" /></p><ul><li><p>type：指定所用协议类型的数字标识符</p></li><li><p>state：表示套接字的连接状态，可使用下列值</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802103603545.png" alt="image-20200802103603545" /></p><p>这里的枚举值，与传输层协议在建立和关闭连接的状态值没有关系，他们表示与外界（用户程序）相关的一般性状态</p></li><li><p>file：指向一个伪文件file实例的指针，用于与套接字通信</p></li><li><p>ops：指向proto_ops结构的指针，其中包含处理套接字的特定于协议的函数</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802104015706.png" alt="image-20200802104015706" /></p><p>其中的需要函数指针与C标准库的函数同名，因为C库函数会通过socketcall系统调用导向上述的函数指针</p></li><li><p>sk：指向sock结构的指针，它包含了对内核有意义的附加的套接字管理数据，其中最重要的成员放置到了sock_common结构中，并将该结构嵌入到struct sock中</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802104445502.png" alt="image-20200802104445502" /></p><p>系统的各个sock结构实例组织在一个协议相关的散列表中，skc_node用作散列表的表元，而skc_hash表示散列值</p><p>在接收和发送数据时，需要将数据放置到包含套接字缓冲区的等待队列上（skb_receive_queue和sk_write_queue）</p><p>每个sock结构都关联了一组回调函数，由内核引起用户程序对特定事件的关注或进行状态改变，例如前面提到的sk_data_ready函数指针，在数据到达时，将调用它指向的函数，通常是指向sock_def_readable函数</p></li></ul><p>socket结构的ops成员类型为struct proto_ops，而sock的prot成员类型为struct proto，二者容易混淆，后者定义如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802111837958.png" alt="image-20200802111837958" /><br /><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802111902259.png" alt="image-20200802111902259" /></p><p>sock结构中的操作用于套接字层和传输层之间的通信，而socket结构的ops成员包含的函数指针则用于与系统调用通信</p><h4 id="972-套接字和文件"><a class="markdownIt-Anchor" href="#972-套接字和文件"></a> 9.7.2 套接字和文件</h4><p>在连接建立后，用户空间使用普通的文件操作来访问套接字，这个实现是基于VFS结构，每个套接字都分配了一个inode，inode又关联到另一个与普通文件相关的结构，用于操作文件的函数保存在一个单独的指针表i_fop中</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802112524577.png" alt="image-20200802112524577" /></p><p>对套接字文件描述符的文件操作，可以透明的重定向到网络子系统的代码</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802112647741.png" alt="image-20200802112647741" /></p><p>inode和套接字的关联，是通过下列辅助结构，将对应的两个结构实例分配到内存中的连续位置</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802112815989.png" alt="image-20200802112815989" /></p><p>内核提供了两个宏来进行运算，SOCKET_I根据inode找到相关的socket实例，SOCK_INODE根据socket找到inode实例</p><h4 id="973-socketcall系统调用"><a class="markdownIt-Anchor" href="#973-socketcall系统调用"></a> 9.7.3 socketcall系统调用</h4><p>对于套接字的部分操作，如文件的读写操作，可以通过虚拟文件系统相关系统调用进入内核，然后重定向到socket_file_ops结构的函数指针，除此之外，还需要对套接字执行其他操作，如创建套接字、bind、listen等</p><p>因此内核提供了socketcall系统调用，它充当一个分派器，将系统调用转到其他函数并传递相关参数</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802113302644.png" alt="image-20200802113302644" /><br /><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802113325385.png" alt="image-20200802113325385" /></p><p>下列表格对应socketcall的各个“子调用”</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802113445670.png" alt="image-20200802113445670" /></p><h4 id="974-创建套接字"><a class="markdownIt-Anchor" href="#974-创建套接字"></a> 9.7.4 创建套接字</h4><p>sys_socket是创建套接字的起点，代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802113750230.png" alt="image-20200802113750230" /></p><ul><li><p>首先，使用sock_create创建一个新的套接字数据结构，该函数调用__sock_create，其中sock_alloc为socket实例和inode实例分配内存，这使得两个对象联合起来</p></li><li><p>数组static net_proto_family* net_families[NPROTO]包含所有传输协议，各个数组项都提供特定于协议的初始化函数create，它会创建一个内部的sock实例</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802114225988.png" alt="image-20200802114225988" /></p></li><li><p>map_sock_fd为套接字创建一个伪文件，然后分配一个文件描述符，将其作为系统调用的结果返回</p></li></ul><h4 id="975-接收数据"><a class="markdownIt-Anchor" href="#975-接收数据"></a> 9.7.5 接收数据</h4><p>使用recvfrom和recv以及文件相关的readv和read函数来接收数据，这些函数的控制流在内核的特定位置会合并，这里只讨论recv_form对应的sys_recvfrom，期待吗流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802114732166.png" alt="image-20200802114732166" /></p><ul><li>套接字对应的文件描述符作为参数传递到该系统调用</li><li>fget_light根据task_struct的描述符表查找对应的file实例</li><li>sock_from_file确定与之关联的inode，并通过SOCKET_I找到相关的套接字</li><li>sock_recvmsg调用特定于协议的接收例程sock-&gt;ops-&gt;recvmsg（例如UDP使用udp_recvmsg，TCP使用tcp_recvmsg），其中UDP的实现过程为：<ul><li>如果接收队列（sock结构的receive_queue成员实现）上至少有一个分组，则移除并返回该分组</li><li>如果接收队列是空的，进程使用wait_for_packet使自身睡眠，直至数据到达</li><li>在新数据到达时总是调用sock结构的data_ready函数，此时进程被唤醒</li></ul></li><li>最后，move_addr_to_user将数据从内核空间复制到用户空间</li></ul><h4 id="976-发送数据"><a class="markdownIt-Anchor" href="#976-发送数据"></a> 9.7.6 发送数据</h4><p>用户空间程序发送数据时，可以使用两个网络相关的库函数（sendto和send）或文件层的write和writev函数，他们也会在内核的某个位置合并，这里只讨论sendto对应的sys_sendto，其代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200802120202420.png" alt="image-20200802120202420" /></p><h2 id="12-内存管理"><a class="markdownIt-Anchor" href="#12-内存管理"></a> 12 内存管理</h2><blockquote><p>内核不能像用户空间那样奢侈的使用内存，获取内存币用户空间复杂很多</p></blockquote><h3 id="121-概述"><a class="markdownIt-Anchor" href="#121-概述"></a> 12.1 概述</h3><p>内存管理的实现涵盖：</p><ul><li>内存中物理内存页的管理</li><li>分配大块内存的伙伴系统</li><li>分配较小内存的slab、slub和slob分配器</li><li>分配非连续内存块的vmalloc机制</li><li>进程的地址空间</li></ul><p>有两种类型计算机，分别以不同的方法管理物理内存：</p><ul><li>UMA计算机（一致内存访问，uniform memory access）将可用内存已连续方式组织起来（可能有小的缺口）。SMP系统中的每个处理器访问各个内存块都是同样快</li><li>NUMA计算机（非一致内存访问，non-uniform memory access），总是多处理器计算机。系统的各个CPU都有本地内存，可支持特别快速的访问，而各个处理器之间通过总线连接起来，以支持对其他CPU本地内存的访问，比访问本地内存会慢一些</li></ul><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200604082129145.png" alt="image-20200604082129145" /></p><p><strong>分配阶</strong>：表示内存中页的数目（取以2为底对应阶数的数量），例如阶1分配2<sup>1</sup>=2个页帧。</p><h3 id="122-numa模型中的内存组织"><a class="markdownIt-Anchor" href="#122-numa模型中的内存组织"></a> 12.2 (N)UMA模型中的内存组织</h3><h4 id="1221-概述"><a class="markdownIt-Anchor" href="#1221-概述"></a> 12.2.1 概述</h4><p>如下图为内存划分的图示，内存划分为<strong>结点</strong>，每个结点关联到系统的一个处理器，对应数据结构为<code>pg_data_t</code>的实例。各个结点划分为<strong>内存域</strong>，分别为：</p><ul><li>ZONE_DMA：标识适合DMA的内存域</li><li>ZONE_DMA32：标记了使用32位地址可寻址，适合DMA的内存域，在64位系统两种DMA内存域才有区别，而在32位计算机上，本内存域是空的，长度为0M</li><li>ZONE_NORMAL：标记了可直接映射到内核段的普通内存域，所有体系结构都会保证这一区域的存在，但是不保证该地址对应了实际的物理内存</li><li>ZONE_HIGHMEM：标记了超出内核段的物理内存</li></ul><p>各个内存域都关联一个数组，组织改内存域的物理内存页（页帧），每个页帧对应结构<code>page</code>的实例。各个内存节点保存在单链表中，供内核遍历</p><p><strong>注意</strong>：处于性能考虑，在为进程分配内存时，内核总是试图在当前运行的CPU相关联的NUMA节点上进行，如果当前节点的内存用尽，会使用节点<strong>备用列表</strong>的内存（借助于zone_list），该列表包含了其他结点</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200604082802402.png" alt="image-20200604082802402" /></p><h4 id="1222-数据结构"><a class="markdownIt-Anchor" href="#1222-数据结构"></a> 12.2.2 数据结构</h4><ol><li><p>结点管理</p><p>pg_data_t用于节点的基本元素，定义如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200604084503749.png" alt="image-20200604084503749" /></p><ul><li><p>node_zones：是一个数组，包含节点中各内存域的数据结构</p></li><li><p>node_zonelists：指定了备用结点及其内存域的列表</p></li><li><p>nr_zones：节点中不同内存域的数目</p></li><li><p>node_mem_map：指向page实例数组的指针，用于描述结点的所有物理内存页</p></li><li><p>bdata：指向<strong>自举内存分配器</strong>数据结构的实例（系统启动期间，内存管理子系统初始化之前，内核也需要内存，会使用到自举内存分配器）</p></li><li><p>node_start_pfn：该结点第一个页帧的逻辑编号，系统中所有结点的页帧依次编号，每个页帧的号码全局唯一（在UMA系统中总是为0，因为其中只有一个结点）</p></li><li><p>node_id：全局结点id，系统中NUMA结点都从0开始编号</p></li><li><p>pgdat_next：连接到下一个内存结点（系统中所有结点使用单链表，结尾通过空指针标记）</p></li><li><p>kswapd_wait：交换守护进程的等待队列，在将页帧换出结点时会用到</p></li><li><p>kswapd：指向负责该节点的交换守护进程的的task_struct</p></li><li><p>kswapd_max_order：用于也交换子系统的实现，代表需要释放的区域的长度</p></li></ul></li><li><p>结点状态管理</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200604090111563.png" alt="image-20200604090111563" /></p></li></ol><h3 id="123-页"><a class="markdownIt-Anchor" href="#123-页"></a> 12.3 页</h3><p>内核把物理页作为内核管理的基本单元，内存管理单元（MMU）是管理内存并将虚拟内存转换为物理内存的硬件，它以页为单位来管理系统中的页表</p><p>结构体struct page表示系统中的每个物理页</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        flags,</span><br><span class="line">    <span class="type">atomic_t</span>             _count,</span><br><span class="line">    <span class="type">atomic_t</span>             _mapcount,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        private,</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>,</span></span><br><span class="line"><span class="class">    <span class="title">pgoff_t</span>              <span class="title">index</span>,</span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">list_head</span>     <span class="title">lru</span>,</span></span><br><span class="line"><span class="class">    <span class="title">void</span>                 *<span class="title">virtual</span></span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>flags</code>域，用来存放页的状态（包括是不是脏的，是不是锁定在内存），每一位单独表示一种状态，至少可以表示32中不同的状态</li><li><code>_count</code>域，存放页的引用计数，-1时内核没有引用该页，在新的内存分配中可以使用。内核调用<code>page_count()</code>检查该域，返回0表示页空闲，返回正整数表示正在使用</li><li>页可以由页缓存使用（此时，mapping域指向页关联的address_space对象），或者作为私有数据（<code>private</code>指向），或者作为进程页表中的映射</li><li><code>virtual</code>域，页的虚拟地址，当页在高端内存（不会永久映射到内核空间）中时，这个域为<code>NULL</code></li></ul><p><strong>注意</strong>：</p><ol><li><code>page</code>结构与物理页相关，并非与虚拟页相关，它仅仅描述当前时刻在相关物理中存放的数据（由于交换等原因，关联的数据继续存在，但是和当前物理页不再关联），它对于页的描述是短暂的</li><li>页的拥有者可能是用户空间进程、动态分配的内核数据，静态内核数据或者页高速缓存等</li></ol><h3 id="124-页表"><a class="markdownIt-Anchor" href="#124-页表"></a> 12.4 页表</h3><h3 id="125-区"><a class="markdownIt-Anchor" href="#125-区"></a> 12.5 区</h3><p>Linux主要使用四种区：</p><ul><li>ZONE_DMA，其中包含的页只能进行DMA操作（直接内存访问）</li><li>ZONE_DMA32，和ZONE_DMA类似，不同之处是只能被32位设备访问</li><li>ZONE_NORMAL，包含能够正常映射的页</li><li>ZONE_HIGHMEM，包含“高端内存”，其中的页不能永久地映射到内核空间</li></ul><blockquote><p>高端内存，由于一些体系结构的物理内存比虚拟内存大的多，为了充分利用物理内存，将物理内存中的部分区域划分为高端内存，他们不能永久地映射到内核空间，而是动态的映射</p><p>在32位x86体系中，ZONE_HIGHMEM为高于896MB的所有物理内存，其余内存为低端内存，其中ZONE_NORMAL为16MB到896MB的物理内存，ZONE_DMA为小于16MB的物理内存</p><p>x86-64系统没有高端内存区</p></blockquote><table><thead><tr><th style="text-align:center">区</th><th style="text-align:center">描述</th><th style="text-align:center">物理内存</th></tr></thead><tbody><tr><td style="text-align:center">ZONE_DMA</td><td style="text-align:center">DMA使用的页</td><td style="text-align:center">&lt; 16MB</td></tr><tr><td style="text-align:center">ZONE_NORMAL</td><td style="text-align:center">正常可寻址的页</td><td style="text-align:center">16~896MB</td></tr><tr><td style="text-align:center">ZONE_HIGHMEM</td><td style="text-align:center">动态映射的页</td><td style="text-align:center">&gt; 896MB</td></tr></tbody></table><p>每个区使用结构体<code>zone</code>表示，具体结构如下图</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200531164328810.png" width="800"><p>结构体中域的说明：</p><ul><li><code>lock</code>域，是一个自旋锁，防止结构被并发访问，这个域只保护结构，不保护驻留在这个区中的页</li><li><code>watermark</code>域，水位值，为每个内存区设置合理的内存消耗基准</li><li><code>name</code>域，表示区的名字，三个区的名字分别为&quot;DMA&quot;,“Normal”,“HighMem”</li></ul><h3 id="126-物理内存的管理"><a class="markdownIt-Anchor" href="#126-物理内存的管理"></a> 12.6 物理内存的管理</h3><h4 id="1261-伙伴系统结构"><a class="markdownIt-Anchor" href="#1261-伙伴系统结构"></a> 12.6.1 伙伴系统结构</h4><h3 id="127-获得页"><a class="markdownIt-Anchor" href="#127-获得页"></a> 12.7 获得页</h3><ul><li>分配2<sup>order</sup>(1&lt;&lt;order)个<strong>连续</strong>的物理内存页，返回的指针指向第一个页的page结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br></pre></td></tr></table></figure><ul><li>将指定的物理页转换为它的逻辑地址（虚拟内存地址），返回的指针指向物理页所在的逻辑地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">page_address</span><span class="params">(<span class="keyword">struct</span> page *page)</span>;</span><br></pre></td></tr></table></figure><ul><li>和<code>alloc_pages()</code>功能类似，不过它直接返回请求的第一个页的逻辑地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __get_free_pages(<span class="type">gfp_t</span> fp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span><br></pre></td></tr></table></figure><ul><li>只分配一页的函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">alloc_page</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __get_free_page(<span class="type">gfp_t</span> fp_mask)</span><br></pre></td></tr></table></figure><h4 id="1271-获得填充为0的页"><a class="markdownIt-Anchor" href="#1271-获得填充为0的页"></a> 12.7.1 获得填充为0的页</h4><ul><li>分配的所有页内容全为0，返回执行逻辑地址的指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_zeroed_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gfp_mask)</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：为了防止页中留下一般随机的垃圾信息包含一些敏感信息，一般用户空间在获取页的时候，内容最好全部填充为0</p><h4 id="1272-释放页"><a class="markdownIt-Anchor" href="#1272-释放页"></a> 12.7.2 释放页</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __free_pages(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order);</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：传递了错误的struct page、地址或者order参数，都可能导致系统崩溃，因为内核是完全相信自己的</p><h3 id="128-kmalloc"><a class="markdownIt-Anchor" href="#128-kmalloc"></a> 12.8 kmalloc()</h3><ul><li>以字节为单位分配内存</li><li>可以获得以字节为单位的一块内核内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br></pre></td></tr></table></figure><h4 id="1281-gfp_mask标志"><a class="markdownIt-Anchor" href="#1281-gfp_mask标志"></a> 12.8.1 gfp_mask标志</h4><p>标志分为三类：</p><ul><li>行为修饰符</li><li>区修饰符</li><li>类型修饰符</li></ul><p>标志具体说明详见<strong>P209</strong></p><h4 id="1282-kfree"><a class="markdownIt-Anchor" href="#1282-kfree"></a> 12.8.2 kfree()</h4><ul><li>释放由<code>kmalloc()</code>分配的内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><h3 id="129-vmalloc"><a class="markdownIt-Anchor" href="#129-vmalloc"></a> 12.9 vmalloc()</h3><p>和<code>kmalloc()</code>类似，不同之处在于<code>vmalloc()</code>分配的内存虚拟内存连续，但是物理内存不一定连续，而<code>kmalloc()</code>分配的物理内存也是连续的</p><p><code>vmalloc()</code>正是用户空间分配内存的方式：有<code>malloc()</code>分配的内存页在进程的虚拟内存中是连续的，但是物理内存不保证连续。大多情况下，只有硬件设备才需要连续的物理内存，他们不理解什么是虚拟内存</p><h3 id="1210-slab分配器"><a class="markdownIt-Anchor" href="#1210-slab分配器"></a> 12.10 slab分配器</h3><blockquote><p>Linux内核提供slab层（即slab分配器），作为通用数据结构缓存层</p></blockquote><h4 id="12101-slab的设计"><a class="markdownIt-Anchor" href="#12101-slab的设计"></a> 12.10.1 slab的设计</h4><blockquote><p>slab层将不同的对象划分为<strong>高速缓存组</strong>，每个高速缓存组存放不同类型的对象，例如，分别存放进程描述符(task_struct结构的空闲链表)，索引节点对象(struct inode)</p></blockquote><ul><li><code>kmalloc()</code>建立在slab层之上，使用了一组通用高速缓存</li><li>一般slab仅仅由一页组成，每个高速缓存由多个slab组成</li><li>每个slab包含一些对象成员，对象指的是被缓存的数据结构</li><li>slab包含三种状态：满、部分满或空</li></ul><p>高速缓存使用结构体<code>kmem_cache</code>表示，这个结构包括三个链表：<code>slabs_full</code>, <code>slabs_partial</code>和<code>slabs_empty</code>，这些链表包含高速缓存中的所有slab</p><p>slab使用slab描述符表示，详见<strong>P216</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>slab分配器使用<code>__get_free_pages()</code>创建新的slab</p><h4 id="12102-slab分配器的接口"><a class="markdownIt-Anchor" href="#12102-slab分配器的接口"></a> 12.10.2 slab分配器的接口</h4><ul><li>创建一个新的高速缓存<ul><li><code>name</code>：高速缓存的名字</li><li><code>size</code>：高速缓存中每个元素的大小</li><li><code>align</code>：slab内第一个对象的偏移量，用来确保在页内进行特定的对齐</li><li><code>flags</code>：可选的设置项，控制高速缓存的行为，详见<strong>P218</strong></li><li><code>ctor</code>：高速缓存的构造函数（Linux的高速缓存不使用构造函数）</li><li>返回指向高速缓存的指针</li><li>函数调用可能会睡眠，不能再中断上下文使用</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kmem_cache *<span class="title function_">kmem_cache_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, </span></span><br><span class="line"><span class="params">                                    <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">                                    <span class="type">size_t</span> align,</span></span><br><span class="line"><span class="params">                                    <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">                                    <span class="type">void</span> (*ctor)(<span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure><ul><li>撤销一个高速缓存（可能睡眠，不能再中断上下文使用）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kmem_cache_destroy</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep)</span>;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：调用<code>kmem_cache_destroy</code>之前要确保两个条件：</p><ol><li>高速缓存中的所有slab为空</li><li>在调用此函数过程中不在访问这个高速缓存</li></ol><ul><li>从已经创建的缓存中分配释放对象，使用示例详见<strong>P219</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp)</span>;</span><br></pre></td></tr></table></figure><h4 id="12103-slab分配的原理"><a class="markdownIt-Anchor" href="#12103-slab分配的原理"></a> 12.10.3 slab分配的原理</h4><h3 id="1211-栈上的静态分配"><a class="markdownIt-Anchor" href="#1211-栈上的静态分配"></a> 12.11 栈上的静态分配</h3><blockquote><p>不同于用户栈，内核栈小而且固定，内核栈一般是两个页大小</p></blockquote><h4 id="12111-单页内核栈"><a class="markdownIt-Anchor" href="#12111-单页内核栈"></a> 12.11.1 单页内核栈</h4><p>2.6内核之后，引入选项可以设置<strong>单页内核栈</strong>，激活这个选项，每个进程的内核栈只有一页大小</p><p>引入的原因有两点：</p><ol><li>可以让每个进程减少内存消耗，另外随着机器运行时间增加，寻找两个连续的物理页变得越来越困难</li><li>当内核栈使用两页时，中断处理程序使用它所中断进程的内核栈，而当进程使用单页的内核栈时，中断处理程序不放在进程内核栈中，而是放在<strong>中段栈</strong>中。</li></ol><blockquote><p>中断栈：为每个进程提供运行中断处理程序的栈，一页大小。</p></blockquote><p>总之，历史上，进程和中断处理程序共享一个栈空间，当1页栈的选项激活之后，中断处理程序获得了自己的栈。</p><h4 id="12112-在栈上工作"><a class="markdownIt-Anchor" href="#12112-在栈上工作"></a> 12.11.2 在栈上工作</h4><p>在任何函数，都要尽量节省内核栈的使用，让所有局部变量大小不要超过几百字节。栈溢出非常危险，所出的数据会直接覆盖紧邻堆栈末端的数据（例如<code>thread_info</code>结构就是紧邻进程堆栈末端）。</p><p>因此，推荐使用动态分配。</p><h3 id="1212-高端内存的映射"><a class="markdownIt-Anchor" href="#1212-高端内存的映射"></a> 12.12 高端内存的映射</h3><h4 id="12121-永久映射"><a class="markdownIt-Anchor" href="#12121-永久映射"></a> 12.12.1 永久映射</h4><p>映射给定的page结构到内核地址空间，使用如下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmap</span><span class="params">(<span class="keyword">struct</span> page *page)</span>;</span><br></pre></td></tr></table></figure><p>函数在对于高端内存或者低端内存都能使用：</p><ol><li>如果page对应低端内存的一页，函数会单纯返回该物理页对应的虚拟地址</li><li>如果page对应高端内存页，函数会建立一个永久映射，在返回对应的虚拟地址</li><li>函数可以睡眠，只能在进程上下文中使用</li></ol><p>当不再需要高端内存中的这一个页时，使用如下函数解除映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kunmap</span><span class="params">(<span class="keyword">struct</span> page *page)</span>;</span><br></pre></td></tr></table></figure><h4 id="12122-临时映射"><a class="markdownIt-Anchor" href="#12122-临时映射"></a> 12.12.2 临时映射</h4><blockquote><p>当必须创建映射而上下文不能睡眠是，内核提供了临时映射（原子映射）</p></blockquote><p>临时映射可以用在像中断上下文一样的不能睡眠的地方，使用如下函数建立心是映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmap_atomic</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="keyword">enum</span> km_type type)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数禁止了内核抢占（因为映射对每个处理器都是唯一的？？？）</li></ul><h3 id="1213-每个cpu的分配"><a class="markdownIt-Anchor" href="#1213-每个cpu的分配"></a> 12.13 每个CPU的分配</h3><blockquote><p>SMP定义：一个操作系统的实例可以同时管理所有CPU内核，且应用并不绑定某一个内核。</p><p>支持SMP的操作系统使用每个CPU上的数据，对于给定的处理器其数据是唯一的，每个CPU的数据存放在一个数组中，数组的每一个元素对应一个存在的处理器</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> my_percpu[NR_CPUS];</span><br></pre></td></tr></table></figure><p>访问cpu数据过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">cpu = get_cpu();  <span class="comment">//获取当前CPU，并且禁止内核抢占</span></span><br><span class="line">data = my_percpu[cpu];</span><br><span class="line">....       <span class="comment">// 使用data的过程</span></span><br><span class="line">put_cpu();</span><br></pre></td></tr></table></figure><p>代码中没有出现锁，因为数据对当前处理器是唯一的，没有其他处理器可以接触这个数据，没有多个处理器并发访问的问题，但是会有内核抢占的问题：</p><ol><li>如果代码被其他处理器抢占并重新调度，这是cpu变量data会变成无效，因为它对应了错误的处理器</li><li>如果另一个进程抢占了代码，有可能在一个处理器上并发访问data数据的问题</li></ol><p>因此，在获取当前cpu时，就已经禁止了内核抢占。</p><h3 id="1214-新的每个cpu接口"><a class="markdownIt-Anchor" href="#1214-新的每个cpu接口"></a> 12.14 新的每个CPU接口</h3><blockquote><p>描述了一些为每个CPU分配内存的接口，详见<strong>P223</strong></p></blockquote><h3 id="1215-使用每个cpu数据的原因"><a class="markdownIt-Anchor" href="#1215-使用每个cpu数据的原因"></a> 12.15 使用每个CPU数据的原因</h3><p>使用每个CPU的好处有：</p><ol><li>减少数据锁定，每个处理器访问每个CPU数据，不用加锁</li><li>使用每个CPU数据大大减少了缓存失效，失效发生在处理器试图使他们的缓存保持同步时，如果一个处理器操作数据时，该数据又存放在其他处理器缓存中，那么存放该数据的那个处理器必须刷新或者清理自己的缓存，频繁的缓存失效会造成<strong>缓存抖动</strong></li></ol><p>而使用每个CPU数据唯一的要求是需要<strong>禁止内核抢占</strong></p><h2 id="13-虚拟文件系统"><a class="markdownIt-Anchor" href="#13-虚拟文件系统"></a> 13 虚拟文件系统</h2><blockquote><p>虚拟文件系统（VFS）： 作为内核子系统，为用户空间程序提供了文件和文件系统相关的接口</p></blockquote><h3 id="131-通用文件模型"><a class="markdownIt-Anchor" href="#131-通用文件模型"></a> 13.1 通用文件模型</h3><p>在处理文件时，内核空间和用户空间使用的主要对象是不同的。在用户空间，一个文件由一个<strong>文件描述符</strong>标识，在打开文件时由内核分配，只在一个<strong>进程内部有效</strong>；内核空间中处理文件的关键是<strong>inode</strong>，每个文件或目录有且只有一个对应的inode，其中包含元数据（如访问权限、修改日期等）和指向文件数据的指针，但<strong>inode不包含文件名</strong></p><h4 id="1311-inode"><a class="markdownIt-Anchor" href="#1311-inode"></a> 13.1.1 inode</h4><blockquote><p>目录可看做一种特殊的文件</p></blockquote><p>inode的成员分为两类：</p><ul><li>描述文件状态的元数据</li><li>保存实际文件内容的数据段（或指向数据的指针）</li></ul><p>举例说明，内核查找/usr/bin/emacs的过程：</p><ul><li>查找起始于inode，对应于/目录，它对应一个inode，其数据段包含根目录下的各个目录项（这些目录项可能代表文件或目录），每个项由两个成员组成：<ol><li>该目录项数据所在的inode编号</li><li>文件或目录的名称（文件名和inode之间的关联通过inode编号建立）</li></ol></li><li>在/目录的inode数据段中查找名为usr的目录项，根据对应的inode编号定位/usr目录的inode；重复相同的步骤查找bin目录、emacs文件的inode</li><li>最后，emacs的inode数据段包含实际文件的内容</li></ul><p><strong>注意</strong>：VFS实际的文件查找过程和以上基本一致，但会有些细节差异，如实际的实现使用了缓存加速查找操作，另外VFS需要和提供实际信息的底层文件系统通信</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200618083457485.png" width="800"><h4 id="1312-通用文件系统接口"><a class="markdownIt-Anchor" href="#1312-通用文件系统接口"></a> 13.1.2 通用文件系统接口</h4><blockquote><p>在UNIX系统中，<strong>万物皆文件</strong></p><p>VFS使得用户可以直接使用统一的系统调用，无需考虑具体的文件系统和物理介质</p></blockquote><p>大多数设备都通过VFS定义的文件接口访问：</p><ul><li>字符和块设备</li><li>进程之间的管道</li><li>用于所有网络协议的套接字</li><li>用于交互式输入和输出的终端</li></ul><blockquote><p>内核在底层文件系统接口上建立了一个抽象层，使得Linux能够支持各种文件系统。</p><p>实际文件系统的代码在统一的接口和数据结构下隐藏各自具体的实现细节，它们通过编程提供VFS所期望的抽象接口和数据结构</p></blockquote><h3 id="132-vfs结构"><a class="markdownIt-Anchor" href="#132-vfs结构"></a> 13.2 VFS结构</h3><blockquote><p>VFS由<strong>文件和文件系统</strong>两部分组成</p></blockquote><h4 id="1321-结构概观"><a class="markdownIt-Anchor" href="#1321-结构概观"></a> 13.2.1 结构概观</h4><ol><li><p><strong>文件的表示</strong></p><p>对底层文件系统的操作使用<strong>函数指针</strong>来实现，他们保存在两个结构中：</p><ul><li>inode操作：创建链接、文件重命名、在目录创建文件、删除文件</li><li>文件操作：文件读写、设置文件位置指针、创建内存映射之类的操作</li></ul><p>每个inode包含一个指向底层文件系统超级块对象的指针，用于执行inode本身的一些操作</p><p>文件和进程的联系：<code>task_struct</code>结构中的files数组，包含所有的打开文件（file结构），文件描述符作为数组的索引，同时file对象总包含一个指针指向用于<strong>加速查找操作的目录项缓存dentry对象</strong></p></li></ol><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200618084630339.png" width="800"><ol start="2"><li><p><strong>文件系统和超级块信息</strong></p><p>超级块包含了文件系统的关键信息（块长度、最大文件长度等），还有读、写、操作inode的函数指针</p><p>内核建立了一个链表，包含了<strong>所有活动的文件系统超级块实例</strong></p><p>超级块结构中包含一个列表，包含相关文件系统<strong>所有修改过的inode</strong>（<em>脏inode</em>），用于回写到存储介质（磁盘等）</p></li></ol><h4 id="1322-unix文件系统"><a class="markdownIt-Anchor" href="#1322-unix文件系统"></a> 13.2.2 Unix文件系统</h4><blockquote><p>四个基本要素：文件、目录项、索引节点和安装点（挂载点）</p></blockquote><ul><li>目录项：路径中的每一部分都被称为目录条目，统称为目录项</li><li>索引节点：Unix系统将文件的相关信息和文件本身这两个概念加以区分（如访问控制权限、大小、创建时间等），文件的相关信息（文件的元数据信息）被存储在一个单独的数据结构，称为索引节点（inode）</li><li>超级块：是一种包含文件系统控制信息的数据结构，这些信息称为文件系统数据元</li></ul><p><img src="https://static001.geekbang.org/resource/image/32/47/328d942a38230a973f11bae67307be47.png" alt="img" /></p><h3 id="133-vfs对象及数据结构"><a class="markdownIt-Anchor" href="#133-vfs对象及数据结构"></a> 13.3 VFS对象及数据结构</h3><p>VFS的四个对象类型：</p><ul><li>超级块对象：代表具体的文件系统</li><li>索引节点对象：代表具体文件</li><li>目录项对象：代表目录项，是路径的一个组成部分</li><li>文件对象：代表进程打开的文件</li></ul><p><strong>注意</strong>：VFS将目录作为一个文件来处理，不存在目录对象；目录项不同于目录</p><blockquote><p>每个对象中都包含一个操作对象，其中描述了内核针对主要对象可以使用的方法</p></blockquote><ul><li><code>super_operations</code>对象：内核针对特定文件系统调用的方法，如<code>write_inode(), sync_fs()</code></li><li><code>inode_operations</code>对象：内核针对特定文件调用的方法，如<code>create(), link()</code></li><li><code>dentry_operations</code>对象：内核针对特定目录项所能调用的方法，如<code>d_compare(), d_delete()</code></li><li><code>file_operations</code>对象：进程针对已打开文件所能调用的方法，如<code>read(), write()</code></li></ul><p><strong>注意</strong>：操作对象作为结构体，其中包含操作父对象的函数指针，实际的文件系统可以继承VFS提供的通用函数。</p><h4 id="1331-超级块"><a class="markdownIt-Anchor" href="#1331-超级块"></a> 13.3.1 超级块</h4><blockquote><p>各种文件系统都必须实现超级块对象，该对象存储特定文件系统的信息，对应于存放在磁盘<strong>特定扇区</strong>中文件系统超级块或者文件系统控制块。（非基于磁盘的文件系统，会在使用现场创建超级块并保存在内存中）</p></blockquote><ol><li><strong>超级块结构super_block</strong></li></ol><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200619145306992.png"><p>主要成员：</p><ul><li>s_dirty：脏inode的链表，在同步内存数据和底层存储介质时，使用该链表更加高效</li><li>s_files：包含一系列file结构，列出了该超级块表示的文件系统所有打开的文件，内核在卸载文件系统时会参考该链表</li><li>s_dev和s_bdev指定了底层文件系统的数据所在的块设备，前者使用了内核内部编号，后者指向block_device结构</li><li>s_root：用于检查文件系统是否装载，如果为NULL，该文件系统是一个伪文件系统，只在内核可见，否则，在用户空间可见</li></ul><p><strong>注意</strong>：超级块对象通过<code>alloc_super()</code>函数创建并初始化，在安装文件系统时，文件系统会调用这个函数从<strong>磁盘</strong>读取文件系统超级块，并将其中的数据<strong>填充到内存中的超级块对象对应的结构体</strong>中。</p><ol start="2"><li><p><strong>超级块操作</strong></p><p>超级块对象中s_op指针，指向超级块的操作函数表，由<code>super_operations()</code>表示，如下图：</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200619145720447.png" alt="image-20200619145720447" /></p></li></ol><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200619145815123.png" alt="image-20200619145815123" /></p><p>该结构中的操作会控制<strong>底层文件系统实现获取和返回inode的方法</strong>，不会改变inode的内容</p><h4 id="1332-inode对象"><a class="markdownIt-Anchor" href="#1332-inode对象"></a> 13.3.2 inode对象</h4><blockquote><p>索引节点对象：包含内核在操作文件系统或者目录时需要的全部信息（对于Unix风格的系统，直接从磁盘的索引节点读入），索引节点对象必须在<strong>内存</strong>中创建</p></blockquote><p>inode的结构如下：</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200619135204831.png" alt="image-20200619135204831" /></p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200619135129369.png" alt="image-20200619135129369" /></p><p>上述的inode结构是在<strong>内存</strong>进行管理，其中包含实际介质中存储的inode没有的成员</p><p>inode结构主要成员：</p><ul><li>i_ino：唯一标识inode的编号</li><li>i_count：访问该inode结构的进程数</li><li>i_nlink：使用该inode的硬链接数目</li><li>i_mode、i_uid和i_gid：文件访问权限和所有权</li><li>i_rdev：设备号，用于找到struct block_device的一个实例</li><li>联合体<ul><li>i_bdev：指向块设备结构block_device</li><li>i_pipe：实现管道的inode相关信息pipe_inode_info</li><li>i_cdev：指向字符设备结构cdev</li></ul></li><li>i_devices：这个成员作为链表元素，使得块设备或者字符设备维护一个inode的链表</li></ul><ol><li><p><strong>索引节点操作</strong></p><p>inode结构包含两个指针：i_op和i_fop，前者指向inode_operation结构，提供了inode相关的操作，后者指向file_operations，提供了文件操作（inode和file结构都包含了指向file_operations结构的指针）</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200619140433905.png"></li><li><p><strong>inode链表</strong></p><p>每个inode都有一个ilist成员，将inode存储到一个链表中</p><p>根据状态，inode分为三种：</p><ul><li><p>inode存在于内存中，未关联到任何文件，不处于活动状态</p></li><li><p>inode存在于内存中，正在由一个或多个进程使用，两个计数器i_nlink和i_count都大于0，且文件内容和inode元数据和底层块设备相同</p></li><li><p>inode处于使用活动状态，内容已经改变，与存储介质上内容不同，inode是<strong>脏的</strong></p></li></ul><p>在fs/inode.c文件中内核定义了两个全局变量表头，inode_unused用于有效但非活动的inode，inode_in_use用于正在使用但是未改变的inode。<strong>脏的inode</strong>保存在一个特定于超级块的链表中</p></li></ol><h4 id="1333-目录项缓存"><a class="markdownIt-Anchor" href="#1333-目录项缓存"></a> 13.3.3 目录项缓存</h4><blockquote><p>Linux使用<strong>目录项缓存</strong>（dentry缓存）来快速访问文件的查找结果</p></blockquote><p>VFS在执行目录项操作时，会现场创建dentry实例，dentry实例没有对应的磁盘数据结构，并非保存在磁盘上，<code>dentry</code>结构体中没有是否被修改的标志（是否为脏、是否需要写会磁盘）</p><ol><li><p><strong>dentry结构</strong></p><p>dentry结构定义如下：</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200619090453579.png" width="800"><p>每个dentry代表路径中的一个特定部分，比如路径/bin/vi，其中/,bin,vi都是目录项，前两个是<strong>目录</strong>，最后一个是<strong>普通文件</strong>。在路径中，包含普通文件在内，每一项都是目录项对象。给定目录下的所有文件和子目录相关联的dentry实例，都归入到d_subdirs链表中，子目录节点的d_child作为链表元素</p><p>dentry结构的<strong>主要作用</strong>：建立<strong>文件名到inode之间映射关系的缓存</strong>，涉及的结构有三个成员：</p><ul><li>d_inode：指向inode实例的指针</li><li>d_name：指定文件的名称，qstr结构存储了<strong>实际的文件名、文件长度和散列值</strong></li><li>d_iname：如果文件名由少量字符组成，保存在d_iname中（不是d_name），以加速访问</li></ul><p>内存中所有活动的dentry实例保存在一个散列表中，使用fs/dcache.c中的全局变量dentry_hashtable实现，d_hash实现溢出链，用于解决哈希冲突，每个元素指向具有相同键值的目录项组成的链表头指针，这个散列表称为<strong>全局dentry散列表</strong>(内核系统提供给文件系统<strong>唯一</strong>的散列函数)</p><p><strong>注意</strong>：dentry对象不是表示文件的主要对象，这一职责分配给inode</p></li><li><p><strong>dentry缓存的组织</strong></p><p>每个由VFS发送到底层实现的请求，都会导致创建一个新的dentry对象，并保存请求结果</p><p>dentry的<strong>三种状态</strong>：被使用、未使用和负状态</p><ul><li>被使用的目录项：对应一个有效的索引节点，<code>d_node</code>指向相应的索引节点，<code>d_count</code>代表使用者的数量；不能被丢弃</li><li>未被使用的目录项：对应有效的索引节点，但是<code>d_count</code>为0，仍然指向一个有效对象，被保存在缓存中</li><li>负状态的目录项：没有对应的有效索引节点，<code>d_node</code>为NULL，索引节点已被删除，或者路径不不再正确</li></ul><p>dentry对象<strong>在内存中的组织</strong>，涉及三个部分：</p><ul><li><p>一个全局散列表（dentry_hashtable）包含的所有dentry对象</p></li><li><p><strong>“被使用的”</strong> 目录项链表：索引节点中<code>i_dentry</code>链接相关的目录项（一个索引节点可能有多个链接，对应多个目录项），因此用一个链表连接他们</p></li><li><p><strong>“最近被使用的”</strong> 双向链表：包含未被使用和负状态的目录项对象（总是在头部插入新的目录项，需要回收内存时，会再尾部删除旧的目录项）</p></li></ul><p><strong>注意</strong>：目录项释放后也可以保存在<strong>slab缓存</strong>中。</p><ul><li><code>dcache</code>一定意义上提供了对于索引节点的缓存（<code>icache</code>），和目录项相关的索引节点对象不会被释放（因为索引节点的使用计数&gt;0），这样确保了索引节点留在内存中</li><li>文件访问呈现空间和时间的局部性：时间局部性体现在程序在一段时间内可能会访问相同的文件；空间局部性体现在同一个目录下的文件很可能都被访问。</li></ul></li><li><p><strong>dentry操作</strong></p><p>dentry_operations结构中保存了一些对dentry对象执行的函数指针，在不同的文件系统中可以各自实现</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200619114904496.png" alt="image-20200619114904496" /></p></li></ol><h4 id="1334-特定于进程的信息"><a class="markdownIt-Anchor" href="#1334-特定于进程的信息"></a> 13.3.4 特定于进程的信息</h4><blockquote><p>三种结构体：<code>file_struct</code>, <code>fs_struct</code>, <code>namespace</code></p></blockquote><p>主要成员包括：</p><ul><li>fs指向的<code>fs_struct</code>结构，保存进程的文件系统相关数据</li><li>files指向的<code>files_struct</code>结构，包含当前进程的各个文件描述符</li><li>mnt_ns指向的<code>namespace</code>结构，包含命名空间相关信息</li></ul><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200619103702377.png" width="600"><ol><li><p><strong>结构体 files_struct</strong></p><p>结构定义如下：</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200619104102379.png" width="800"><p>主要成员：</p><ul><li><code>fd_array</code>数组指针：指向已打开的文件对象，<code>NR_OPEN_DEFAULT</code>默认64，如果进程打开的文件超过64，内核将分配一个新数组，并且将<code>fdt</code>指针指向它</li><li>当访问的文件对象的数量小于64时，执行比较快，因为是对静态数组的操作；如果大于64，内核需要建立新数组，访问速度相对慢一些</li><li>管理员可以增大<code>NR_OPEN_DEFAULT</code>选项优化性能</li><li>fdtable结构定义如下：</li></ul></li></ol><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200619104457849.png" width="800"><ol start="2"><li><p><strong>结构体 fs_struct</strong></p><p>由进程描述符的<code>fs</code>域指向，包含<strong>文件系统和进程相关的信息</strong>，包含进程的当前工作目录（<code>pwd</code>）和根目录</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200619111413066.png"><p>其中dentry类型的成员指向目录名称，vfsmount类型成员表示已经装载的文件系统，成员如下：</p><ul><li>umask成员：标准掩码，用于设置文件的权限</li><li>root和rootmnt指定相关进程的根目录和文件系统</li><li>pwd和pwdmnt指定<strong>当前目录</strong>和文件系统的vfsmount结构，在进程改变当前目录时，二者会动态改变（仅当进入一个新的挂载点的时候，pwdmnt才会变化）</li></ul></li><li><p><strong>VFS命名空间</strong></p><p>单一的系统可以提供多个容器，容器彼此相互独立，从VFS角度来看，需要<strong>针对每个容器分别跟踪装载的文件系统</strong></p><p><strong>VFS命名空间</strong>是所有已经装载、构成某个容器目录树的文件系统集合。通过fork或clone建立的进程会继承父进程的命名空间，可以通过设置CLONE_NEWS标志，建立新的命名空间</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200619113142088.png"><p>进程描述符中的<code>nsproxy</code>成员管理命名空间的处理，其主要成员是<code>mmt_namespace</code>域，它使得<strong>每个进程在系统中看到唯一的文件系统</strong>（唯一的根目录和文件系统结构层次）</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200619112545758.png"><ul><li>count：使用计数器，指定了使用该命名空间的进程数</li><li>root：指向根目录挂载的vfsmount实例</li><li>list：一个双向链表的表头，保存了命名空间中所有文件系统的vfsmount实例，链表元素是vfsmount中的mnt_list成员</li></ul><p>对于容器来说，命名空间的操作（如mount和umount）并不作用于内核的全局vfsmount结构，只操作当前容器中进程的命名空间实例。同时，改变<strong>会影响共享同一个命名空间实例的所有进程（容器）</strong></p></li></ol><p><strong>注意</strong>：</p><ul><li><p>对于多数进程，它们的描述符都指向自己独有的<code>files_struct</code>和<code>fs_struct</code>，除非使用克隆标志<code>CLONE_FILES</code>或者<code>CLONE_FS</code>创建的进程会共享这两个结构体</p><ul><li><code>namespace</code>结构体使用方法和前两种结构完全不同，默认情况下，所有进程共享同样的命名空间（都从相同的挂载表中看到同一个文件系统层次结构，除非在<code>cloen()</code>操作时使用<code>CLONE_NEWS</code>标志，才会给进程一个命名空间结构体的拷贝）</li></ul></li></ul><h4 id="1335-文件"><a class="markdownIt-Anchor" href="#1335-文件"></a> 13.3.5 文件</h4><blockquote><p>文件对象是已打开的文件在内存中的表示</p></blockquote><ul><li><p>结构体<code>file</code>表示</p></li><li><p>由<code>open()</code>系统调用创建，<code>close()</code>撤销</p></li><li><p>多个进程可以打开同一个文件，所以同一个文件存在多个对应的file实例</p></li><li><p>file对象仅仅在观点上代表已打开文件，它反过来指向dentry对象，而dentry对象反过来指向inode</p></li></ul><p>类似于目录项对象，文件对象没有对应的磁盘数据，通过<code>file</code>结构体中<code>f_dentry</code>指针指向相关的目录项对象，而目录项对象指向相关的索引节点，索引节点会记录文件是否为脏</p><p>结构体<code>file_operation</code>定义如下：</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200619111240263.png" width="1000"><p>文件相关的操作方法和<strong>系统调用</strong>很类似，具体的文件系统可以为每一种操作方法实现各自的代码，如果存在通用操作，则使用通用操作</p><h4 id="1336-文件系统"><a class="markdownIt-Anchor" href="#1336-文件系统"></a> 13.3.6 文件系统</h4><p>所有文件系统都保存在一个<strong>单链表</strong>中，每个文件系统的名字存储为字符串。在文件系统注册到内核时，将逐个元素扫描该链表，直至到达尾部或者找到指定的文件系统</p><ol><li><p><strong>结构体 file_system_type</strong></p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200619142443132.png"><p>主要成员：</p><ul><li><p>name：文件系统的名称，字符串</p></li><li><p>fs_flags：使用的标志，标明只读装载等</p></li><li><p>next：指向下一个file_system_type结构</p></li><li><p>get_sb函数：从磁盘读取超级块，在文件系统安装时，在内存中组装超级块对象</p></li><li><p>kill_sb函数：在不在需要某个文件系统类型时执行清理工作</p></li><li><p>fs_supers：同一类型文件系统的所有超级块结构存储在一个链表中，fs_supers是这个链表的表头</p></li></ul><p><strong>注意</strong>：相同类型的多个文件系统实例，都只有一个对应的<code>file_system_type</code>实例</p></li><li><p><strong>结构体 vfsmount</strong></p><p>在文件系统实际被安装时，会有一个<code>vfsmount</code>结构体在安装点创建，每个装载的文件系统对应一个vfs_mount实例（代表一个<strong>安装点</strong>），<code>vfsmount</code>结构体中维护了各种链表，用于跟踪文件系统和所有安装点之间的关系</p><p>系统使用了散列表mount_hashtable（定义在fs/namespace.c中），链表元素是vfs_mount类型，<strong>vfs_mount实例的地址和相关的dentry实例的地址</strong>用来计算散列和（哈希值）</p><img src="D:\Tech\学习笔记\Linux学习笔记\image-20200619144135833.png"></li></ol><h3 id="134-处理vfs对象"><a class="markdownIt-Anchor" href="#134-处理vfs对象"></a> 13.4 处理VFS对象</h3><h4 id="1341-文件系统操作"><a class="markdownIt-Anchor" href="#1341-文件系统操作"></a> 13.4.1 文件系统操作</h4><ol><li><p><strong>注册文件系统</strong></p><p>文件系统注册到内核时，是编译为模块，或者持久编译到内核。fs/super.c中的register_filesystem函数用来向内核注册文件系统，该函数扫描文件系统结构组成的单链表，直至到达链表尾部然后添加新的元素或者找到所需的文件系统</p></li><li><p><strong>装载和卸载</strong></p><p>装载操作开始于<strong>超级块</strong>的读取，file_system_type中保存的read_super函数指针返回一个类型为super_block的对象，用来在内存中表示超级块</p><p><strong>mount系统调用</strong></p><p>入口点是sys_mount函数，在fs/namespace.c定义，代码流程如下图</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200622083824843.png" alt="image-20200622083824843" /></p><p>首先将装载选项（类型、设备和选项）从用户空间复制到内核空间，内核将控制权转给do_mount函数，该函数调用path_lookup找到装载点所在的dentry项</p><p>do_mount充当一个多路分解器，将需要完成的工作委派给装载类型对应的各个函数，其中do_new_mount处理普通装载操作，它分为两部分：do_kern_mount和do_add_mount</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200622085138977.png" alt="image-20200622085138977" /></p><ul><li><p>do_kern_mount首先使用get_fs_type找到对应的file_system_type实例，并扫描已注册文件系统的链表，返回正确的项，然后调用特定于文件系统类型的get_sb函数读取相关的超级块，返回struct super_block的实例</p></li><li><p>do_add_mount首先处理一些必须的锁定操作，确保同一个文件系统不会重复装载到同一位置，然后主要工作是在graft_tree函数，新装载的文件系统通过attach_recursive_mnt函数添加到父文件系统的命名空间</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200622090154215.png" alt="image-20200622090154215" /></p><ul><li><p>nameidata用于将vfsmount实例和denrty实例聚集起来，该结构保存了装载点的dentry实例和装载之前该目录对应的vfsmount实例</p></li><li><p>mnt_set_mount确保新的vfsmount实例中的mnt_parent成员指向父文件系统的vfsmount实例，以及mnt_mountpoint成员指向装载点在父文件系统中的dentry实例，旧的dentry实例d_mounted值加一</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200622090919581.png" alt="image-20200622090919581" /></p></li><li><p>函数commit_tree将新的vfsmount实例添加到<strong>全局散列表</strong>以及<strong>父文件系统vfsmount实例中的子文件系统链表</strong></p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200622091237024.png" alt="image-20200622091237024" /></p></li></ul></li></ul><p><strong>umount</strong>系统调用</p><p>umount系统调用的入口点是fs/namespace.c中的sys_umount，如下图</p></li></ol><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200623100711987.png" alt="image-20200623100711987" /></p><ul><li>首先，__user_walk找到装载点的dentry和vfsmount实例，主要的工作委派给do_umount函数</li><li>如果定义了特定于超级块的umount_begin函数，则调用它。例如，网络文件系统在卸载前，需要终止与远程文件系统的通信</li><li>如果装在的文件系统不再需要（通过使用计数判断），或者指定了MNT_DETACH来强制卸载文件系统，则调用umount_tree和release_mounts函数，前者将d_mounted减一，后者使用保存在mnt_mountpoints和mnt_parent中的数据，将环境恢复到文件系统装在之前的状态。同时被卸载的文件系统对应的数据结构，会从内核链表中移除</li></ul><h4 id="1342-文件操作过程"><a class="markdownIt-Anchor" href="#1342-文件操作过程"></a> 13.4.2 文件操作过程</h4><ol><li><p><strong>查找inode</strong></p><p>主要操作是根据给定的文件名查找inode，nameidata结构用于向查找函数传递参数，并保存查找结果，该结构定义如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200623102542286.png" alt="image-20200623102542286" /></p><p>主要成员：</p><ul><li>查找完成后，dentry和mnt包含了找到的文件系统项的数据</li><li>last包含了查找的名称，包含字符串和散列值</li><li>flags保存了相关标志</li></ul><p>内核使用path_lookup函数查找路径和文件名，该函数需要一个nameidata类型的指针，用作临时结果的“暂存器”</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200623191143202.png" alt="image-20200623191143202" /></p><p>内核使用nameidata实例规定查找的起点，如果名称以/开头，使用当前根目录的dentry实例和vfsmount实例；否则，从当前进程的task_struct获得当前工作目录的数据</p><p>主要处理在link_path_walk函数，它调用__link_path_walk函数，该函数代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200623191624065.png" alt="image-20200623191624065" /></p><p>该函数由一个大的循环组成，逐分量处理文件或路径名（路径根据/被分解为多个分量），每个循环的主要逻辑为：</p><ul><li>将nameidata实例的mnt和dentry成员设置为根目录或工作目录对应的数据项</li><li>对目录进行权限检查，判断进程是否允许进入该目录、</li><li>路径名称是逐字母扫描，根据/将路径分为多个路径分量，每个循环处理一个路径分量；路径分量的每个字符传给partial_name_hash函数，用于计算散列和，将他保存到qstr实例中</li><li>处理(<strong>.</strong>)，直接跳过</li><li>处理(<strong>…</strong>)，委派给follow_dotdot函数，当前目录为进程的根目录时，没有效果，否则，分两种情况：<ul><li>如果当前目录不是一个<strong>装载点</strong>的根目录时，将当前dentry对象的d_parent成员作为新的目录</li><li>如果是已装载文件系统的根目录，利用保存在mnt_mountpoint和mnt_parent中的信息定义下一个dentry和vfsmount对象。follow_mount和lookup_mnt用于取得所需的信息</li></ul></li><li>如果路径分量是一个普通文件，需要区分两种情况进行处理，数据位于dentry缓存 或者 需要文件系统底层实现进行查找，函数do_lookup负责区分两种情况，返回所需的dentry实例</li><li>最后一步：判断该分量是否为符号链接（方法：只有勇于符号链接的inode，其inode_operations中才包含lookup函数，否则为NULL）</li></ul><p>最后一个分量对应的dentry作为函数link_path_walk的返回结果</p></li><li><p><strong>打开文件</strong></p><p>标准库的open函数用于打开文件，该函数使用同名的open系统调用，调用了fs/open.c中的sys_open函数，代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200623193750366.png" alt="image-20200623193750366" /></p><ul><li>force_o_largefile检查是否应该不考虑用户层传递的标志</li><li>接下来的主要处理是在do_sys_open函数<ul><li>调用get_unused_fd_flags查找未使用的文件描述符</li><li>根据open参数中的文件路径名称，查找对应的inode，主要是在do_file_open函数<ul><li>open_namei函数调用path_lookup函数查找inode并执行几个额外检查</li><li>nameidata_to_filp初始化预读结构，将新创建的file实例放置到超级块的sfiles链表中，并调用底层文件系统随影file_operations中的open函数</li></ul></li></ul></li><li>fd_install函数将file实例放置到进程task_struct结构的files-&gt;fd数组中</li><li>最后控制权转到用户进程，返回进程描述符</li></ul></li><li><p><strong>读取和写入</strong></p><p>文件打开之后，使用read和write系统调用进行读写，入口函数是sys_read和sys_write（都是在fs/read_write.c实现）</p><ul><li><p>read</p><p>函数需要三个参数：文件描述符、保存数据的缓冲区和指定读取字符数的长度参数，代码流程如下图</p><ul><li>根据文件描述符，fget_light函数（fs/file_table.c中）从task_struct结构中找到相关的file实例</li><li>file_pos_read找到文件当前的读写位置（返回file-&gt;f_pos的值）</li><li>vfs_read函数调用特定于文件的读取函数file-&gt;f_op-&gt;read，如果该函数没有实现，则调用一般的辅助函数do_sync_read</li><li>file_pos_write函数记录文件内部新的读写位置</li></ul><p><strong>注意</strong>：读取数据涉及到复杂的缓冲区和缓存系统，详见<a href="">文件系统操作</a></p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200623194904111.png" alt="image-20200623194904111" /></p></li></ul></li></ol><h3 id="135-vfs通用标准函数"><a class="markdownIt-Anchor" href="#135-vfs通用标准函数"></a> 13.5 VFS通用标准函数</h3><p>对于文件读写的操作对于所有文件系统来说大同小异：如果数据所在的块是已知的，则首先查询页缓存；如果未保存在其中，则相对应的块设备发出请求。</p><p>为了防止每个文件系统在这部分的代码冗余，大多数文件系统将file_operations中的read和write分别指向do_sync_read和do_sync_write标准例程</p><h4 id="1351-通用读取例程"><a class="markdownIt-Anchor" href="#1351-通用读取例程"></a> 13.5.1 通用读取例程</h4><p>do_sync_read例程同步地读取数据，保证在函数返回时，所需数据已经在内存中，实际的读取操作委托给一个异步例程。简化后函数如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713164051426.png" alt="image-20200713164051426" /></p><p>init_sync_kiocb函数初始化一个kiocb实例，用于控制异步输入/输出操作</p><p>实际工作委托给特定于文件系统的异步读取操作，保存在struct file_operations的aio_read成员，它指向generic_file_aio_read，该函数是异步的，无法保证返回时数据已经读取完毕</p><p>返回值-EIOCBQUEUED表示读请求正在排队，尚未处理，此时。wait_on_sync_kiocb将一直等待，直至数据进入内存。该函数根据创建的控制块，来检查请求的完成情况；在等待时，进程将进入睡眠状态，使得其他进程可以利用CPU</p><ol><li><p><strong>异步读取</strong></p><p>mm/filemap.c中的generic_file_aio_read异步读取数据，代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713165518219.png" alt="image-20200713165518219" /></p><p>在generic_segment_checks中确保读请求包含的参数有效之后，需要区分两种不同的读模式：</p><ul><li>如果设置了O_DIRECT标志，则直接读取数据，不使用页缓存，此时调用generic_file_direct_IO</li><li>否则调用do_generic_file_read，然后调用do_generic_mapping_read函数，该函数将<strong>对文件的读操作转换为对映射的读操作</strong></li></ul></li><li><p><strong>对映射读取</strong></p><p>do_generic_mapping_read代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713174143283.png" alt="image-20200713174143283" /></p><p>该函数使用映射机制，将文件中需要读取的部分映射到内存中，它由一个大的无限循环组成，持续向内存页读入数据，直至所有文件数据（不在任何缓存中的数据）都传输到内存中</p><p>每个循环执行过程为：</p><ul><li>find_get_page检查页是否在页缓存中<ul><li>如果没有，调用page_cache_sync_readahead发出同步预读请求，然后再次调用find_get_page保证数据已经进入缓存，如果此次调用还是没有进入缓存，则调用no_cached_page函数</li><li>否则，如果设置了页标志PG_readahead，则发出异步预读请求，调用page_cache_async_readahead</li></ul></li><li>虽然页是在页缓存中，但数据不一定是最新的，需要调用Page_Uptodate检查，如果页不是最新的，必须使用mapping-&gt;a_ops-&gt;readpage再次读取，该函数指针通常指向mpage_readpage，调用之后，可以确保页中填充的数据是最新的</li><li>接下来使用mark_page_accessed标记对该页的访问（在需要从物理内存换出数据时，这个标记会用于判断页的活动程度）</li><li>最后，actor例程将适当的页映射到用户地址空间</li></ul><p>如果预读机制没有将所需的页读入内存，需要调用do_generic_mapping_read的no_cached_page函数，其代码流程图如下</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713185213374.png" alt="image-20200713185213374" /></p><p>其中，page_cache_alloc_cold分配了一个缓存冷页，通过add_to_page_cache_lru将该页插入页缓存的LRU链表中，详见 [分配页](# 16.4.1 分配页)，映射提供的mapping -&gt; a_ops -&gt; readpage用于读取数据，通常该函数指向mpage_readpage，详见 [对整页的操作](# 16.4.4 对整页的操作)。最后，mark_page_accessed告诉统计系统该页已经访问过</p></li></ol><h4 id="1352-缺页异常处理"><a class="markdownIt-Anchor" href="#1352-缺页异常处理"></a> 13.5.2 缺页异常处理</h4><p>内存映射通常调用VFS提供的filemap_fault标准例程来读取未保存在缓存中的页，如下图是该函数的代码流程图</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713192813123.png" alt="image-20200713192813123" /></p><h2 id="14-块io层"><a class="markdownIt-Anchor" href="#14-块io层"></a> 14 块I/O层</h2><h2 id="15-进程地址空间"><a class="markdownIt-Anchor" href="#15-进程地址空间"></a> 15 进程地址空间</h2><h2 id="16-页缓存和块缓存"><a class="markdownIt-Anchor" href="#16-页缓存和块缓存"></a> 16 页缓存和块缓存</h2><p>内核为块设备提供了两种通用的缓存方案：</p><ul><li>页缓存：针对以页为单位的所有操作，例如<strong>内存映射技术</strong>，负责了<strong>块设备的大部分工作</strong></li><li>块缓存：以块为操作单位，存取的单位是设备的各个块，由于块长度取决于特定的文件系统，块缓存能处理不通长度的块</li></ul><p>缓冲区曾经是块设备进行I/O操作的传统方法，目前只用于支持很小的读取操作，对于块传输的标准数据结构变为struct bio，这种方式可以合并统一请求中后续的块，加速处理，但是对于<strong>单个块的操作</strong>，缓冲区仍然是首选，例如经常按块读取元数据的系统。</p><p>很多场合下，页缓存和块缓存结合使用（一个缓存的页在写操作期间划分为不同的缓冲区，在更细的粒度识别出被修改的部分，在数据写回时，只需要回写被修改的部分，不需要整页传输）</p><h3 id="161-页缓存的结构"><a class="markdownIt-Anchor" href="#161-页缓存的结构"></a> 16.1 页缓存的结构</h3><h4 id="1611-管理和查找缓存的页"><a class="markdownIt-Anchor" href="#1611-管理和查找缓存的页"></a> 16.1.1 管理和查找缓存的页</h4><p>Linux采用<strong>基数树</strong>的数据结构管理页缓存中的页，如下图</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200703193455046.png" alt="image-20200703193455046" /></p><p>树的根有一个简单的数据结构表示，包含了树的高度（所包含节点的最大层次数目）和一个指针，指向组成树的第一个节点的数据结构</p><p>树的节点具备两种<strong>搜索标记</strong>，二者用于指定给定页当前是否为脏（即页的内容和后备存储器的数据不同）或该页是否正在向底层块设备回写。标记会一直向上设置到根节点，如果某个层次 <em>n+1</em> 的节点设置了某个标记，那么 <em>n</em> 层次的父节点也会设置该标记。好处是<strong>内核可以判断在某个范围内是否有一页或多页设置了某个标记位</strong></p><h4 id="1612-回写修改的数据"><a class="markdownIt-Anchor" href="#1612-回写修改的数据"></a> 16.1.2 回写修改的数据</h4><p>由于页缓存的存在，写操作不是直接对块设备进行，而是在内存中进行，修改的数据首先被收集起来，然后被传输到更低的内核层，在那里对写操作进一步优化，具体的优化过程详见 [块I/O层](##14 块I/O层)。这里从页缓存的视角来看，需要确定何时回写？</p><p>内核提供如下几种同步方案：</p><ul><li>内核守护进程pdflush周期性地同步，他们扫描缓存中的页，将超出一定时间没有与底层块设备同步的页写回</li><li>如果缓存中修改的数据项数目在短期内内明显增加，内核会主动激活pdflush进程</li><li>提供了系统调用给用户调用来写回未同步的数据，常用的有sync调用</li></ul><p>为管理可以按整页处理和缓存各种不同对象，内核使用了**“地址空间”**抽象，将内存中的页和特定的块设备关联起来，每个地址空间都有一个“宿主”，所谓其数据来源，一般用inode表示</p><p>一般修改文件或者按页缓存的对象时，只会修改页的一部分，为节约时间，在写操作期间，会将缓存中的每一页划分为较小的单位，称为<strong>缓冲区</strong>，回写过程中以缓冲区为单位来操作</p><h3 id="162-块缓存的结构"><a class="markdownIt-Anchor" href="#162-块缓存的结构"></a> 16.2 块缓存的结构</h3><p>Linux早期版本只包含块缓存，用于加速文件操作和系统性能，底层块设备的块缓存存在内存的缓冲区中，可以加速读写（实现部分包含在fs/buffers.c中）</p><p>与内存页相比，块比较小而且长度可变（依赖于使用的块设备或者文件系统）</p><p>文件系统在处理元数据时，一般会使用块缓存；而裸数据的传输则按页进行</p><p>缓冲区的实现基于页缓存，Linux 2.6之前，缓冲区使用缓冲区头buffer head结构实现，在2.6之后，不再使用缓冲区头结构，而是使用bio结构</p><h3 id="163-地址空间"><a class="markdownIt-Anchor" href="#163-地址空间"></a> 16.3 地址空间</h3><p>地址空间建立了缓存数据与后备存储器之间的关联，实现了两个单元之间的转换机制</p><ul><li><p>内存中的页关联到每个地址空间，这些页表示缓存的内容</p></li><li><p>后备存储器指定了填充地址空间中页的数据的来源，它是虚拟内存中区域到后备存储器（块设备）上对应位置的映射</p></li></ul><h4 id="1631-数据结构"><a class="markdownIt-Anchor" href="#1631-数据结构"></a> 16.3.1 数据结构</h4><p>地址空间的基础是address_struct结构，定义如下：</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200707091245724.png" alt="image-20200707091245724" /><br /><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200707091319282.png" alt="image-20200707091319282" /></p><p>主要成员：</p><ul><li>与地址空间管理的区域之间的关联，通过两个成员建立：host指向inode实例，指定了后备存储器；一个基数树的根page_tree列出了地址空间中所有的物理内存页</li><li>i_mmap是一棵树的根节点，包含了与该inode相关的所有普通内存映射，该树的作用在于，支持查找给定区间至少一页的所有内存区域</li></ul><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200707091505999.png" alt="image-20200707091505999" /></p><ul><li>backing_dev_info是一个指针，指向另一个结构，包含了与地址空间相关的后备存储器的有关信息（后备存储器是指与地址空间相关的外部设备，用作地址空间中信息的来源，通常为<strong>块设备</strong>）</li><li>aps指针指向address_space_operation结构，其中包含了一组函数指针，指向用于处理地址空间的特定操作</li></ul><p>地址空间与内核其他部分的关联如下图</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200707092746157.png" alt="image-20200707092746157" /></p><h4 id="1632-页树"><a class="markdownIt-Anchor" href="#1632-页树"></a> 16.3.2 页树</h4><h3 id="164-页缓存的实现"><a class="markdownIt-Anchor" href="#164-页缓存的实现"></a> 16.4 页缓存的实现</h3><h4 id="1641-分配页"><a class="markdownIt-Anchor" href="#1641-分配页"></a> 16.4.1 分配页</h4><p>page_cache_alloc用于为一个即将加入页缓存的新页分配数据结构，加上后缀_cold的函数是获取一个冷页</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200707093319597.png" alt="image-20200707093319597" /></p><ul><li><p>首先page_cache_alloc将工作委托给alloc_pages，它从<strong>伙伴系统</strong>获得一个页帧</p></li><li><p>接下来将新页添加到页缓存，这是在add_to_page_cache函数中实现，如下所示，radix_tree_insert将与页相关的page实例插入到地址空间的基数树，在页缓存中的索引和指向所属地址空间的指针保存在page的成员index和mapping中</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200707093832701.png" alt="image-20200707093832701" /></p></li></ul><p>内核还提供了另一个可选的参数add_to_page_cache_lru，他首先调用add_to_page_cache向地址空间的页缓存添加一页，然后使用lru_cache_add函数将该页加入到系统的LRU缓存</p><h4 id="1642-查找页"><a class="markdownIt-Anchor" href="#1642-查找页"></a> 16.4.2 查找页</h4><p>使用基数树判断给定页是否已经缓存，使用find_get_page实现该功能</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200707094443166.png" alt="image-20200707094443166" /></p><p>其中radix_tree_lookup用于查找位于给定偏移量的页，在找到页之后，page_cache_get将页的引用计数加1</p><h4 id="1643-在页上等待"><a class="markdownIt-Anchor" href="#1643-在页上等待"></a> 16.4.3 在页上等待</h4><p>内核经常要在页上等待，直至其状态改变为预期值。例如，数据同步时需要确保对于某页的回写已经结束，此时内存页的内容和底层块设备是相同的。处于回写过程中的页会设置PG_writeback标志位</p><p>内核提供了wait_on_page_writeback函数，用于等待页的该标志位清除</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200707095202477.png" alt="image-20200707095202477" /><br /><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200707095225496.png" alt="image-20200707095225496" /></p><p>wait_on_cahe_bit安装一个等待队列，进程可以在上面睡眠，直至PG_writeback标志位清除</p><p>另外也有等待页解锁的需求，使用函数wait_on_page_locked实现</p><h4 id="1644-对整页的操作"><a class="markdownIt-Anchor" href="#1644-对整页的操作"></a> 16.4.4 对整页的操作</h4><p>内核在块设备和内存之间传输数据时，相关的算法和数据结构都是以页为基本单位，而逐个缓冲区/块的传输会对性能产生负面影响。因此，在再重新设计块层的过程中，内核版本2.5引入<strong>BIO</strong>，来替代缓冲区，用于处理与块设备的数据传输。内核添加了4个函数，来支持读写一页或多页</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713152306980.png" alt="image-20200713152306980" /></p><p>其中，writeback_control用于精确控制回写操作的选项</p><p>这4个函数共同之处：都是构建一个BIO实例，用于对块层进行传输</p><p>以mpage_readpages为例，该函数需要nr_pages个page实例，以链表的形式通过参数pages传递进去，mapping是相关的地址空间，get_block用于查找匹配的块地址</p><p>该函数首先遍历所有的page实例，在循环的每一遍，首先将该页添加到地址空间相关的页缓存中，然后创建一个bio请求，从块层读取所需的数据</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713153304300.png" alt="image-20200713153304300" /><br /><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713153412875.png" alt="image-20200713153412875" /><br /><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713153434116.png" alt="image-20200713153434116" /></p><p>在do_mpage_readpage建立bio请求时，会包含此前各页的BIO数据，以构造一个合并的请求（将几页的读取合并到一个请求，而不是每页一个请求）</p><p>如果在循环结束时，do_mpage_readpage留下一个未处理的BIO请求，则提交该请求</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713153535101.png" alt="image-20200713153535101" /></p><h4 id="1645-页缓存预读"><a class="markdownIt-Anchor" href="#1645-页缓存预读"></a> 16.4.5 页缓存预读</h4><p>页缓存预读不是由页缓存独立完成的，还需要VFS和内存管理层的支持</p><p>预读在内核的几处都有涉及</p><ul><li>do_generic_mapping_read：一个内核通用的读取例程</li><li>filemap_fault函数：缺页异常处理程序，负责为内存映射读取缺页</li></ul><p>下面以do_generic_mapping_read为例，来考察预读的具体过程</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713154924924.png" alt="image-20200713154924924" /></p><p>假定进程已经打开了一个文件，准备读取第一页，该页尚未读入页缓存，此时不会只读入一页，而是顺序读取多页，内核调用page_cache_sync_readahead读取一行中的8页（数字8是具体说明），第一页对于do_generic_mapping_read来说是立即可用的，而在实际需要之前就被读入页缓存的页，处于<strong>预读窗口</strong>中</p><p>之后进程继续读取接下来的页，在访问第6页（6是举例说明）时，内核检测到在该页设置了PG_Readahead标志。此时触发了一个异步操作，会在后台读取若干页（由于还有两页可用，所以不需要同步读取，但在后台进行的I/O操作需要确保进一步读取文件时，相关页已经读入页缓存）。page_cache_async_read函数负责发出异步读请求，它又会将窗口中的一页标记为PG_Readahead，在进程遇到该页时，又会触发异步读取，以此类推</p><p>最重要的问题在于<strong>预测预读窗口的最优长度</strong>。因此，内核会记录每个文件上一次的设置，使用file_ra_state关联到每个file实例</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713160800427.png" alt="image-20200713160800427" /></p><p>主要成员：</p><ul><li>start：表示页缓存开始预读的位置</li><li>size：表示预读窗口的长度</li><li>async_size：表示剩余预读页的最小值，如果预读窗口中的页数等于这个值，则会触发异步预读</li><li>ra_pages：表示预读窗口的最大长度，内核读入的页数可以小于这个值，但是不能超过</li><li>prev_pos：表示前一次读取时，最后访问的位置</li></ul><p>预读机制的实现涉及如下几个函数</p><p><img src="D:%5CTech%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200713160114414.png" alt="image-20200713160114414" /></p><p>其中，ondemand_readahead例程负责实现预读策略（即判断预读多少当前不需要的页），在确定预读窗口的长度之后，调用ra_submit，将技术性问题委托给__do_page_cache_readhead函数，其中页是在页缓存中分配的，而后由块层填充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;linux内核&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux内核&quot;&gt;&lt;/a&gt; Linux内核&lt;/h1&gt;
&lt;h2 id=&quot;3-进程管理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr</summary>
      
    
    
    
    <category term="书籍存档" scheme="https://www.snowmoon.top/categories/%E4%B9%A6%E7%B1%8D%E5%AD%98%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux调试原理及方法2——内存占用调优</title>
    <link href="https://www.snowmoon.top/2024/06/01/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-Linux-Memory%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98-Processing/"/>
    <id>https://www.snowmoon.top/2024/06/01/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-Linux-Memory%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98-Processing/</id>
    <published>2024-06-01T05:16:28.000Z</published>
    <updated>2024-10-19T14:16:33.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-调试系列文章"><a class="markdownIt-Anchor" href="#linux-调试系列文章"></a> Linux 调试系列文章</h1><p>[[Linux CPU 占用调优]]<br />[[Linux Memory占用调优(Processing)]]</p><h1 id="调试工具总览"><a class="markdownIt-Anchor" href="#调试工具总览"></a> 调试工具总览</h1><p>Brendan D. Gregg 维护了一份Linux性能调优工具的蓝图<a href="http://www.brendangregg.com/linuxperf.html">Linux Performance Tools</a>，针对Linux系统的各个组件都有相应的分析工具，一目了然。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/202406012053732.webp" alt="image.png" /></p><h1 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h1><h2 id="linux内核内存管理"><a class="markdownIt-Anchor" href="#linux内核内存管理"></a> linux内核内存管理</h2><ul><li><p>【批发】linux内核基于伙伴算法管理物理内存页</p></li><li><p>【零售】linux内核基于slab管理内存</p></li><li><p>linux内核所用物理内存大小统计</p></li></ul><h2 id="linux进程内存管理"><a class="markdownIt-Anchor" href="#linux进程内存管理"></a> linux进程内存管理</h2><p>malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()</p><p>对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。</p><p>对大块内存（大于 128K），则直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去</p><p>各自的<strong>优缺点</strong>：</p><ul><li><p>brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率；不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片</p></li><li><p>mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大</p></li></ul><p>整体来说，Linux 使用<strong>伙伴系统</strong>来管理内存分配。前面我们提到过，这些内存在 MMU 中以页为单位进行管理，伙伴系统也一样，以页为单位来管理内存，并且会通过相邻页的合并，减少内存碎片化（比如 brk 方式造成的内存碎片）</p><h3 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h3><blockquote><ul><li>进程独享虚拟地址空间（32位）  ０～３Ｇ</li><li>进程内分段管理内存空间</li></ul><blockquote><p>代码段<br />数据段<br />heap<br />malloc()<br />stack<br />文件映射，匿名映射 mmap()</p></blockquote></blockquote><p>进程内存按照用途分类</p><p><img src="http://cdn.processon.com/62c842730e3e740a4750ac02?e=1657294979&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:QcniUfzyckg6p1p7BtzFkoetjOY=" alt="" /></p><h3 id="物理内存"><a class="markdownIt-Anchor" href="#物理内存"></a> 物理内存</h3><h4 id="进程所用物理内存大小统计"><a class="markdownIt-Anchor" href="#进程所用物理内存大小统计"></a> 进程所用物理内存大小统计</h4><ul><li>PSS</li></ul><blockquote><p>一个进程所使用的内存可通过PSS和RSS来衡量。 计算进程的Pss: $ cat /proc/1/smaps | grep Pss | awk ‘{total+=$2}; END {print total}’<br />把一个共享库占用的内存，分摊到使用了这个共享库的各个进程头上</p></blockquote><ul><li>RSS(不合理)</li></ul><blockquote><p>把共享库占用的内存直接加到每个进程头上</p></blockquote><ul><li>USS</li></ul><blockquote><p>进程独自占用的物理内存（不包含共享库占用的内存）</p></blockquote><h2 id="内存回收"><a class="markdownIt-Anchor" href="#内存回收"></a> 内存回收</h2><p>在用户空间，malloc 通过 brk() 分配的内存，在释放时并不立即归还系统，而是缓存起来重复利用。在内核空间，Linux 通过 slab 分配器来管理小内存，可以把 slab 看成构建在<strong>伙伴系统上的一个缓存</strong>，主要作用就是分配并释放内核中的小对象</p><p>系统也不会任由某个进程用完所有内存。在发现内存紧张时，系统就会通过一系列机制来回收内存：</p><ul><li><p>回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面</p></li><li><p>回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中（会用到交换分区）</p></li><li><p>杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程</p></li></ul><p>OOM是内核的一种保护机制。它监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：</p><ul><li><p>进程消耗的内存越大，oom_score 就越大</p></li><li><p>进程运行占用的 CPU 越多，oom_score 就越小</p></li></ul><p>可以手动设置进程的oom_adj来调整oom_score。oom_adj的范围是[-17, 15]，数值越大，进程越容易被OOM杀死；反之，越不容易被OOM杀死</p><h3 id="回收时机"><a class="markdownIt-Anchor" href="#回收时机"></a> 回收时机</h3><ul><li>内存紧缺回收(alloc_pages的时候)</li><li>周期性内存回收：linux内存回收总结：<a href="https://cfn2lv4v46.feishu.cn/docx/P914dlXpro6CHnxErshcFuaNnYg">从swapd触发到回收3部曲</a></li><li>手动回收</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/vm/drop_caches   # &quot;clean&quot; page cache</span><br><span class="line">echo 2 &gt; /proc/sys/vm/drop_caches # shrink slab(dentry &amp; inode)</span><br><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><h3 id="回收方式"><a class="markdownIt-Anchor" href="#回收方式"></a> 回收方式</h3><ul><li>页回写 直接释放物理页面</li><li>页交换 回写到swap分区，然后释放物理页面</li><li>OOM Killer （较为暴力，应尽量避免）</li></ul><h2 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h2><h3 id="系统内存使用量"><a class="markdownIt-Anchor" href="#系统内存使用量"></a> 系统内存使用量</h3><p>buffer, cache, used</p><h4 id="相关工具"><a class="markdownIt-Anchor" href="#相关工具"></a> 相关工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/proc/meminfo</span><br><span class="line"></span><br><span class="line">free</span><br><span class="line"></span><br><span class="line">sar -r 1</span><br><span class="line"></span><br><span class="line">vmstat </span><br></pre></td></tr></table></figure><p><strong>系统内存余量</strong><br />free, available</p><p>available等于“空闲内存减去所有zones的lowmem reserve和high watermark，再加上page cache和slab中可以回收的部分“</p><h3 id="进程虚拟内存"><a class="markdownIt-Anchor" href="#进程虚拟内存"></a> 进程虚拟内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/proc/{id}/maps</p><p>pmap -p 1</p><p>进程内存使用量</p><h4 id="相关工具-2"><a class="markdownIt-Anchor" href="#相关工具-2"></a> 相关工具</h4><p>ps -aux</p><p>top</p><p>RES：常驻内存大小<br />RES=RSan+RSfd+RSsh</p><p>RSan：常驻匿名内存大小</p><p>RSfd：常驻文件映射内存大小</p><p>RSsh：常驻被锁定内存大小</p><p>SHR：共享内存大小</p><p>/proc/{pid}/status</p><p>smem -k -s rss| more</p><h3 id="缓存与缓冲区命中率"><a class="markdownIt-Anchor" href="#缓存与缓冲区命中率"></a> 缓存与缓冲区命中率</h3><p>缓存命中率，是指直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。</p><h4 id="相关工具-3"><a class="markdownIt-Anchor" href="#相关工具-3"></a> 相关工具</h4><p>cachestat/cachestat-bpfcc（系统整体）</p><p>HITS ，表示page cache命中的次数； MISSES ，表示page caceh未命中的次数； DIRTIES， Number of dirty pages added to the page cache； BUFFERS_MB，表示 Buffers 的大小，以 MB 为单位； CACHED_MB，表示 Cache 的大小，以 MB 为单位； HITRATIO，表示 page cache 命中率；</p><p>cachetop/cachetop-bpfcc（进程）</p><p>pcstat （进程&amp;文件）</p><h3 id="swap分区使用量"><a class="markdownIt-Anchor" href="#swap分区使用量"></a> swap分区使用量</h3><p>swap分区的作用是在系统物理内存不足时,将一部分物理内存中的数据交换到swap分区（磁盘上），从而把这部分物理内存释放出来给需要的程序来使用。 一、哪部分内存会被交换到swap分区？ １、匿名页(AnonPages)； ２、Shmem(基于tmpfs实现)虽然未统计在AnonPages里，但它们背后没有硬盘文件，所以也是需要交换区的。 二、从进程角度看，以下的函数或者机制分配的内存在物理内存不足时会被交换到swap分区，包括： - stack - malloc() - brk()/sbrk()  - mmap(PRIVATE, ANON) - POSIX shm* - mmap(SHARED, ANON) - tmpfs</p><h4 id="相关工具-4"><a class="markdownIt-Anchor" href="#相关工具-4"></a> 相关工具</h4><p>free（系统整体）</p><p>sar -S 1（系统整体）</p><p>smem -k（进程）</p><p>计算所有进程的swap总的大小： $ smem | awk ‘{if(NR&gt;1) total+=$(NF-3)}; END{printf total}’</p><h3 id="内存泄露情况"><a class="markdownIt-Anchor" href="#内存泄露情况"></a> 内存泄露情况</h3><h4 id="相关工具-5"><a class="markdownIt-Anchor" href="#相关工具-5"></a> 相关工具</h4><p>memleak -a -p {pid}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">leak.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">128</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">64</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺页异常主-次"><a class="markdownIt-Anchor" href="#缺页异常主-次"></a> 缺页异常（主、次）</h3><p>缺页异常：cpu拿到虚拟地址，让MMU进行地址转换的时候，MMU找不到虚拟地址的页表映射关系。 主缺页：需要从磁盘加载 memory page； 次缺页：不需要从磁盘加载 memory page；</p><h4 id="相关工具-6"><a class="markdownIt-Anchor" href="#相关工具-6"></a> 相关工具</h4><p>进程自启动以来发生的缺页事件的总和：<br />ps -eo min_flt,maj_flt,cmd | more</p><p>进程每秒缺页错误次数：<br />pidstat -r</p><h2 id="工具汇总"><a class="markdownIt-Anchor" href="#工具汇总"></a> 工具汇总</h2><h3 id="free命令"><a class="markdownIt-Anchor" href="#free命令"></a> free命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意不同版本的free输出可能会有所不同</span></span><br><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        8169348      263524     6875352         668     1030472     7611064</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><ul><li>第一列，total 是总内存大小；</li><li>第二列，used 是已使用内存的大小，包含了共享内存；</li><li>第三列，free 是未使用内存的大小；</li><li>第四列，shared 是共享内存的大小；</li><li>第五列，buff/cache 是缓存和缓冲区的大小；</li><li>最后一列，available 是新进程可用内存的大小</li></ul><p><strong>注意</strong>：available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中</p><h3 id="top命令"><a class="markdownIt-Anchor" href="#top命令"></a> top命令</h3><p>可以查看每个进程的内存使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按下M切换到内存排序</span></span><br><span class="line">$ top</span><br><span class="line">...</span><br><span class="line">KiB Mem :  8169348 total,  6871440 free,   267096 used,  1030812 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  7607492 avail Mem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">  430 root      19  -1  122360  35588  23748 S   0.0  0.4   0:32.17 systemd-journal</span><br><span class="line"> 1075 root      20   0  771860  22744  11368 S   0.0  0.3   0:38.89 snapd</span><br><span class="line"> 1048 root      20   0  170904  17292   9488 S   0.0  0.2   0:00.24 networkd-dispat</span><br><span class="line">    1 root      20   0   78020   9156   6644 S   0.0  0.1   0:22.92 systemd</span><br><span class="line">12376 azure     20   0   76632   7456   6420 S   0.0  0.1   0:00.01 systemd</span><br><span class="line">12374 root      20   0  107984   7312   6304 S   0.0  0.1   0:00.00 sshd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>主要的几个信息：</p><ul><li>VIRT 是<strong>进程虚拟内存</strong>的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内</li><li>RES 是<strong>常驻内存</strong>的大小，也就是进程<strong>实际使用的物理内存</strong>大小，但<strong>不包括 Swap 和共享内存</strong></li><li>SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等</li><li>%MEM 是进程使用物理内存占系统总内存的百分比</li></ul><p><strong>注意</strong>：</p><ul><li>虚拟内存通常并不会全部分配物理内存。从上面的输出，你可以发现每个进程的虚拟内存都比常驻内存大得多</li><li>共享内存 SHR 并不一定是共享的，比方说，<strong>程序的代码段、非共享的动态链接库</strong>，也都算在 SHR 里。SHR 也包括了<strong>进程间真正共享的内存</strong>。所以在计算多个进程的内存使用时，不要把所有进程的 SHR 直接相加得出结果</li></ul><h3 id="sar"><a class="markdownIt-Anchor" href="#sar"></a> sar</h3><p>用法： sar -r -S 1</p><p>-r: 表示显示内存使用情况</p><p>kbcommit，表示当前系统负载需要的内存。它实际上是为了保证系统内存不溢出（不超出），对需要内存的估计值。 %commit，就是这个值相对总内存的百分比，因为commit统计的是RAM+swap，所以%commit可能会大于100%</p><p>-S: 表示显示Swap使用情况</p><p>kbswpcad：其实就是swap文件的file cache。 kbswpcad = SwapCached(来自/proc/meminfo)</p><h3 id="vmstat"><a class="markdownIt-Anchor" href="#vmstat"></a> vmstat</h3><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-f: 显示系统启动到今创建的所有的进程数</span><br><span class="line"></span><br><span class="line">-S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）。默认单位为K（1024 bytes）</span><br><span class="line"></span><br><span class="line">-a: 显示活跃和非活跃内存</span><br><span class="line"></span><br><span class="line">-s：内存使用详情</span><br><span class="line"></span><br><span class="line">-m: 显示slab详情</span><br><span class="line"></span><br><span class="line">-d：磁盘读写的详情</span><br><span class="line"></span><br><span class="line">-p：显示指定磁盘分区统计信息</span><br></pre></td></tr></table></figure><h3 id="cachestatcachestat-bpfcc"><a class="markdownIt-Anchor" href="#cachestatcachestat-bpfcc"></a> cachestat/cachestat-bpfcc</h3><p>安装方法： $ sudo apt-key adv --keyserver <a href="http://keyserver.ubuntu.com">keyserver.ubuntu.com</a> --recv-keys 4052245BD4284CDD $ echo “deb <a href="https://repo.iovisor.org/apt/xenial">https://repo.iovisor.org/apt/xenial</a> xenial main” | sudo tee /etc/apt/sources.list.d/iovisor.list $ sudo apt-get update $ sudo apt-get install -y bcc-tools libbcc-examples linux-headers-$(uname -r) $ export PATH=$PATH:/usr/share/bcc/tools</p><p>用法</p><p>HITS ，表示page cache命中的次数； MISSES ，表示page caceh未命中的次数； DIRTIES， Number of dirty pages added to the page cache； BUFFERS_MB，表示 Buffers 的大小，以 MB 为单位； CACHED_MB，表示 Cache 的大小，以 MB 为单位； HITRATIO，表示 page cache 命中率；</p><p>提供了整个系统的 page cache 的读写命中情况</p><p>cachetop/cachetop-bpfcc</p><p>用法</p><p>提供了每个进程的 page cache 的读写命中情况</p><h3 id="pcstat"><a class="markdownIt-Anchor" href="#pcstat"></a> pcstat</h3><p>安装方法： $ export GOPATH=~/go $ go get <a href="http://github.com/tobert/pcstat">github.com/tobert/pcstat</a> $ cp -rfa $GOPATH/bin/pcstat /bin</p><p>用法</p><p>查看文件的缓存大小以及缓存比例：<br />$ pcstat /tftpboot/hello</p><p>查看进程打开的所有文件的缓存大小以及缓存比例：<br />$ pcstat -pid {pid}</p><h3 id="hcache"><a class="markdownIt-Anchor" href="#hcache"></a> hcache</h3><p>go version &gt; 1.12 【安装】 git clone <a href="https://github.com/silenceshell/hcache.git">https://github.com/silenceshell/hcache.git</a> cd hcache make build sudo cp hcache /usr/local/bin/</p><p>用法</p><p>输出系统中前10大使用缓存最多的文件：<br />hcache --top 10</p><p>只显示基本名字：<br />hcache --top 10 -basename</p><h3 id="memleak"><a class="markdownIt-Anchor" href="#memleak"></a> memleak</h3><p>memleak跟踪内存申请和释放请求。 【实现原理】 在跟踪某个进程时，memleak会追踪libc中的分配函数，具体来说包括：malloc、calloc、realloc、valloc、memalign、pvalloc、aligned d_alloc和free； 当跟踪所有进程时，memleak追踪包括kmalloc/kfree、kmem_cache_alloc/kmem_cache_free，以及get_free_pages/free_pages所分配的页面。</p><p>用法</p><p>-a: 表示显示每个内存分配请求的大小以及地址</p><p>-p {pid}：指定要检测的进程</p><p>-c {command}：运行指定的命令并只跟踪其分配，这会跟踪libc分配器。</p><p>-z ｛MIN_SIZE｝：只捕获大于等于MIN_SIZE字节的内存泄露</p><p>-Z {MAX_SIZE}：只捕获小于等于MAX_SIZE字节的内存泄露</p><p>INTERVAL：每隔INTERVAL秒打印未释放的申请及其调用堆栈的摘要。缺省值为5秒。</p><p>每隔１秒打印一次进程31826的内存泄露统计：<br />memleak -a -p 31826 1</p><p>限制</p><p>当追踪的进程快速申请和释放内存时，memleak可能会带来很大的开销</p><p>此工具仅适用于Linux 4.6+</p><h3 id="smem"><a class="markdownIt-Anchor" href="#smem"></a> smem</h3><p>用法</p><p>统计物理内存用量，支持的维度：process, user, mapping, systemwide</p><p>-k：显示单位后缀</p><p>-p：用百分比显示</p><p>-u：显示用户占用内存信息swap/rss/uss/pss大小</p><p>-w：显示系统内存用量，包括内核空间和用户空间</p><p>-m：统计mapping所用的物理内存</p><p>$ smem -m -k  Map  PIDs   AVGPSS      PSS  /lib/x86_64-linux-gnu/libc-2.27.so         173    29.0K     5.1M  第一列(Map)： 表示被共享的文件名字； 第二列(PIDs)： 表示上述文件被几个进程共享； 第三列(AVGPSS)： 各个进程平均分摊的内存，AVGPSS＝PSS/PIDs 第四列(PSS)： 文件加载后，占用的物理内存；</p><p>-s {swap/pss/uss/rss}：按照进程对swap/rss/pss/uss的使用量排序</p><h2 id="调优实践"><a class="markdownIt-Anchor" href="#调优实践"></a> 调优实践</h2><h3 id="实践一linux-c语言开发遇到的最常见的内存问题该如何定位解决"><a class="markdownIt-Anchor" href="#实践一linux-c语言开发遇到的最常见的内存问题该如何定位解决"></a> 实践一：linux c语言开发遇到的最常见的内存问题，该如何定位解决？</h3><p><strong>分析过程</strong></p><p>查看系统总体内存用量，确定大致问题：<br />vmstat -S K 1</p><p>对使用物理内存最多的20个进程进行监控（间隔１ｓ），确定进程是否存在内存异常：<br />watch -n 1 -d “smem -s rss |tail -n 20”</p><p>如果进程使用内存持续增加，进行内存泄露监控：<br />memleak -a -p {pid} 1</p><p>对其他内存使用量较高的进程代码进行review，主要关注如下部分：<br />- malloc<br />- brk()/sbrk()<br />- mmap()<br />- shmem等</p><p>进行代码层面的性能优化</p><p><strong>环境搭建</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">main.c</span><br><span class="line"><span class="comment">// 斐波那契数列（Fibonacci sequence）</span></span><br><span class="line"><span class="comment">// 1、1、2、3、5、8、13、21、34</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_SIZE 256000</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">fibo</span><span class="params">(<span class="type">int</span> *n0, <span class="type">int</span> *n1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *v = (<span class="type">int</span> *) <span class="built_in">malloc</span>(MALLOC_SIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, MALLOC_SIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *v = *n0 + *n1;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n0 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *v = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">2</span>; n &gt; <span class="number">0</span>; n++) &#123;</span><br><span class="line">        v = fibo(&amp;n0, &amp;n1);</span><br><span class="line">        n0 = n1;</span><br><span class="line">        n1 = *v;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dth =&gt; %lld\n&quot;</span>, n, *v);</span><br><span class="line">        <span class="comment">//free(v)</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    do_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实践二spark处理200w笔数据有时候需要几秒有时候需要几十秒原因何在"><a class="markdownIt-Anchor" href="#实践二spark处理200w笔数据有时候需要几秒有时候需要几十秒原因何在"></a> 实践二：spark处理200w笔数据，有时候需要几秒，有时候需要几十秒，原因何在？</h3><p>分析过程</p><p>检查程序执行过程中有没有涉及到文件的操作？<br />lsof -p 28161| grep test.csv</p><p>查看文件的缓存命中情况<br />pcstat /app/tools/test-tool/data/test.csv</p><p>记录测试结果</p><p>清除文件缓存<br />echo 1 &gt; /proc/sys/vm/drop_caches</p><p>查看缓存命中情况</p><p>记录测试结果</p><p>结论：由于文件缓存的作用，性能提升了10倍左右！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spark-sql&gt; </span><br><span class="line">CREATE table csv</span><br><span class="line">USING csv</span><br><span class="line">OPTIONS (</span><br><span class="line"> header true,</span><br><span class="line">  path &quot;/app/tools/test-tool/data/test.csv&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">spark-sql&gt;</span><br><span class="line">select * from csv where name=&#x27;nam9876&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在另一个terminal执行：</span><br><span class="line"># echo 1 &gt; /proc/sys/vm/drop_caches </span><br></pre></td></tr></table></figure><h3 id="调优方法"><a class="markdownIt-Anchor" href="#调优方法"></a> 调优方法</h3><p>应用层面</p><p>尽量使用缓存或者缓冲区来缓存数据</p><p>fluent-bit; flume; spark等</p><p>考虑使用tmpfs替代磁盘目录<br />mount -t tmpfs -o size=1G tmpfs /tftpboot/spark</p><p>系统层面</p><p>减少swap使用，比如减少swappiness大小</p><p>限制进程内存资源</p><p>使用HugePage（大页内存，4k-&gt;2M, 1G等），提高TLB的命中率</p><p>通过 /proc/pid/oom_adj ，调整核心应用的 oom_score<br />范围 【-17，+15】，值越大越被容易杀死</p>]]></content>
    
    
    <summary type="html">记录关于Linux Memory性能调试的白皮书</summary>
    
    
    
    <category term="SnowMoonの嵌入式笔记" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.snowmoon.top/tags/Linux/"/>
    
    <category term="Memory" scheme="https://www.snowmoon.top/tags/Memory/"/>
    
    <category term="Cache" scheme="https://www.snowmoon.top/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能调优1——CPU</title>
    <link href="https://www.snowmoon.top/2024/04/20/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-Linux-CPU-%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98/"/>
    <id>https://www.snowmoon.top/2024/04/20/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-Linux-CPU-%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98/</id>
    <published>2024-04-20T14:40:20.000Z</published>
    <updated>2024-06-02T11:52:00.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：最近的工作中涉及到了太多Linux相关调试方法与原理性的问题，但是前期工作太忙一直没来得及好好学习，仔细钻研，最近项目算是告一段落，因此希望能借此机会精进一下技术并好好总结一些方法与原理</p></blockquote><h1 id="cpu相关性能调试基本原理"><a class="markdownIt-Anchor" href="#cpu相关性能调试基本原理"></a> CPU相关性能调试基本原理</h1><p>在Linux系统中，影响性能的指标主要为CPU、内存、IO、网络，每个模块都有其特定的调试方式和工具。与CPU相关的主要调试方向为进程和线程、软硬件的中断、和上下文的切换情况。</p><h2 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h2><p>进程是资源拥有的基本单位，线程是调度的基本单位。进程与线程在内核中使用的结构体都为task_struct，二者间区别主要是进程的pid=tgid，线程的pid！=tgid。</p><p>进程状态：</p><ol><li>TASK_RUNNING 并不是说进程正在运行，而是表示进程在时刻准备运行的状态</li><li>TASK_INTERRUPTIBLE 因等待事件（比如IO事件）而进入睡眠</li><li>TASK_UNINTERRUPTIBLE 因等待事件（比如IO事件）而进入睡眠，不可以被信号唤醒</li></ol><h3 id="调度"><a class="markdownIt-Anchor" href="#调度"></a> 调度</h3><h4 id="调度策略"><a class="markdownIt-Anchor" href="#调度策略"></a> 调度策略</h4><p>普通调度策略</p><blockquote><p>SCHED_NORMAL：普通进程<br />SCHED_BATCH：后台进程<br />SCHED_IDLE：空闲进程</p></blockquote><p>实时调度策略</p><blockquote><p>SCHED_FIFO：高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，先到先得<br />SCHED_RR：高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，轮换着来<br />SCHED_DEADLIN7E</p></blockquote><h4 id="调度优先级"><a class="markdownIt-Anchor" href="#调度优先级"></a> 调度优先级</h4><p>实时进程：0 ~ 99</p><p>普通进程：100 ~ 139</p><h4 id="调度器类"><a class="markdownIt-Anchor" href="#调度器类"></a> 调度器类</h4><p>Fair</p><blockquote><p>常用的策略为：SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE</p></blockquote><p>完全公平算法 – CFS</p><blockquote><p>CFS对应的调度策略：SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE。 CFS 会为每一个进程安排一个虚拟运行时间 vruntime。如果一个进程在运行，随着时间的增加，进程的 vruntime 将不断增大。没有得到执行的进程 vruntime 不变。 显然，那些 vruntime 少的，原来受到了不公平的对待，需要给它补上，所以会优先运行这样的进程。 你可能会说，不还有优先级呢？如何给优先级高的进程多分时间呢？按比例！</p></blockquote><p>Real_Time</p><blockquote><p>常用的策略为：SCHED<em>FIFO 和 SCHED</em>RR</p></blockquote><h2 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h2><p>硬件中断的处理目前都算比较快，所以目前的调试都不会特别关注硬件中断的过程，主要关注的是软件中断的过程，因为会占用比较大量的时间</p><h2 id="上下文切换"><a class="markdownIt-Anchor" href="#上下文切换"></a> 上下文切换</h2><h3 id="cpu上下文"><a class="markdownIt-Anchor" href="#cpu上下文"></a> CPU上下文</h3><p>包括CPU寄存器和程序计数器</p><blockquote><p>CPU寄存器：是 CPU 内置的容量小、但速度极快的内存<br />程序计数器：是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置(PC指针)</p></blockquote><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/98ac9df2593a193d6a7f1767cd68eb5f.webp.webp" alt="img" /></p><ul><li>CPU上下文切换：是先把前一个任务的 CPU 上下文（也就是<strong>CPU 寄存器和程序计数器</strong>）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务</li><li>这些这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来</li></ul><p>根据任务的不同，CPU的上下文切换分为进程上下文切换、线程上下文切换和中断下文切换</p><h3 id="进程上下文切换"><a class="markdownIt-Anchor" href="#进程上下文切换"></a> 进程上下文切换</h3><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</li></ul><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/4d3f622f272c49132ecb9760310ce1a7.webp.webp" alt="img" /></p><p>从进程用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成，系统调用的过程中会发生<strong>两次CPU上下文切换</strong>。CPU里原来用户态指令的执行位置需要先保存起来，然后更新为内核态执行的指令位置，最后跳转到内核态运行内核任务。在系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。</p><p><strong>注意</strong>：</p><ol><li><p>系统调用的过程中，不会涉及到虚拟内存等进程态的资源，不会切换进程，系统调用过程和进程上下文切换不一样，整个过程都是同一个进程</p></li><li><p>系统调用称为特权模式切换，不是上下文切换</p></li></ol><p>进程上下文切换和系统调用的区别：</p><p>进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的<strong>虚拟内存、栈</strong>等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/395666667d77e718da63261be478a96b.webp.webp" alt="img" /></p><p><strong>保存上下文和恢复上下文的过程需要内核在CPU上运行才能完成</strong>（上下文切换过程是CPU密集型），每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。</p><p>在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在<strong>寄存器、内核栈以及虚拟内存</strong>等资源的保存和恢复上，进而大大缩短了真正运行进程的时间，从而导致系统平均负载升高。</p><p>Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在<strong>多处理器系统</strong>上，缓存是被多个处理器<strong>共享</strong>的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p><p>Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是<strong>优先级最高和等待 CPU 时间最长</strong>的进程来运行。</p><p>进程被CPU重新调度的时机：</p><ol><li>进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行</li><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行</li><li>进程在系统<strong>资源</strong>不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行</li><li>进程通过睡眠函数  sleep 这样的方法将自己主动挂起时，自然也会重新调度</li><li>有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序</li></ol><h3 id="线程上下文切换"><a class="markdownIt-Anchor" href="#线程上下文切换"></a> 线程上下文切换</h3><p>线程和进程的区别：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</p><p>所谓内核中的任务调度，实际上的调度对象是<strong>线程</strong>；而进程只是给线程提供了虚拟内存、全局变量等资源。</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的</li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的</li></ul><p>因此，线程的上下文切换分为两种情况：</p><ol><li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样</li><li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的<strong>私有数据、寄存器</strong>等不共享的数据</li></ol><p><strong>注意</strong>：同进程的线程切换要比进程间的切换消耗更少的资源，更加轻量级</p><h3 id="中断上下文切换"><a class="markdownIt-Anchor" href="#中断上下文切换"></a> 中断上下文切换</h3><p>为了响应硬件事件，<strong>中断处理会打断进程的正常调度和执行</strong>，转而调用中断处理程序，响应设备事件。</p><p>中断上下文切换不会涉及到进程的用户态，它其实只包括内核态中断服务程序执行所必需的状态，包括<strong>CPU 寄存器、内核堆栈、硬件中断参数</strong>等</p><p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以<strong>中断上下文切换并不会与进程上下文切换同时发生</strong></p><p>大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能</p><h1 id="性能指标1cpu使用率"><a class="markdownIt-Anchor" href="#性能指标1cpu使用率"></a> 性能指标1——CPU使用率</h1><p>CPU的使用率，就是一段时间内有进程在CPU上运行的时间占总时间的比例，包含：用户CPU、系统CPU、iowait、硬件中断、软件中断等。</p><h2 id="相关工具"><a class="markdownIt-Anchor" href="#相关工具"></a> 相关工具</h2><h3 id="top"><a class="markdownIt-Anchor" href="#top"></a> top</h3><p>top工具的输出一般像下面这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line">top - 23:50:38 up  5:13,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 355 total,   1 running, 257 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  0.1 us,  0.0 sy,  0.0 ni, 99.9 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem : 16350296 total, 12577212 free,  1452916 used,  2320168 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2097148 free,        0 used. 14469300 avail Mem </span><br><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR  S  %CPU %MEM     TIME+ COMMAND    </span><br><span class="line">1477 embedfi+  20   0  897564 268572  90336 S   0.7  1.6   0:06.02 Xorg  </span><br></pre></td></tr></table></figure><blockquote><p>top的输出：<br />us: un-niced用户进程使用的cpu时间；<br />sy：系统的内核进程<br />ni: 被调整过nice值的进程占用的CPU使用率；<br />wa:就是IO-wait；<br />hi:hardware Interrupt<br />si:software interrupt</p></blockquote><h3 id="mpstat"><a class="markdownIt-Anchor" href="#mpstat"></a> mpstat</h3><blockquote><p>mpstat的输出和top不一样：<br />%usr: 用户进程使用的cpu时间（包含un-niced和niced）；<br />%nice: niced用户进程使用的cpu时间</p></blockquote><p>显示所有CPU的指标，每秒一次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 1</span><br></pre></td></tr></table></figure><h3 id="pidstat"><a class="markdownIt-Anchor" href="#pidstat"></a> pidstat</h3><blockquote><p>pidstat输出:<br />%user表示用户进程使用的cpu时间（包含un-niced和niced）；<br />%wait表示任务等待运行时所占用的CPU百分比。</p></blockquote><p>显示所有进程的CPU指标，每秒一次:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u 1</span><br></pre></td></tr></table></figure><h3 id="gdb"><a class="markdownIt-Anchor" href="#gdb"></a> gdb</h3><h3 id="perf"><a class="markdownIt-Anchor" href="#perf"></a> perf</h3><p>实时显示CPU时钟占用最多的函数或指令</p><p>平均负载最理想的指标值是等于CPU的个数。</p><h2 id="调试技巧"><a class="markdownIt-Anchor" href="#调试技巧"></a> 调试技巧</h2><ol><li>us cpu 占用高，说明用户态进程占用了较多cpu，着重排查应用程序本身的代码逻辑问题；</li><li>sy cpu占用高，说明内核态代码占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题；</li><li>wa cpu占用高，说明等待 I/O 完成所花的时间比较长，所以应该着重排查linux系统是不是存在IO相关的性能瓶颈；</li><li>hi和si占用高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重排查内核中的中断服务程序，一般是网络；</li><li>系统整体cpu使用较高，而实际的单个进程的cpu使用都不高，要考虑短时进程是否被频繁创建和销毁；</li></ol><h1 id="性能指标2平均负载"><a class="markdownIt-Anchor" href="#性能指标2平均负载"></a> 性能指标2——平均负载</h1><p>平均负载是指单位时间内，系统处于可运行状态（Running）和不可中断等待状态（uninterruptible）的平均进程数</p><p>平均负载为3，意味着：<br />１、在只有3个CPU 的系统上，意味着所有的CPU都刚好被进程完全占用；<br />２、在6个CPU的系统上，意味着CPU有50% 的空闲；<br />３、在只有1个CPU 的系统中，则意味着2/3的进程竞争不到CPU；</p><p>平均负载是一个综合性的指标，需要通过整体变化趋势来看系统是否有压力</p><h2 id="相关工具-2"><a class="markdownIt-Anchor" href="#相关工具-2"></a> 相关工具</h2><p>uptime</p><p>top</p><p>dstat -y</p><h2 id="调优技巧"><a class="markdownIt-Anchor" href="#调优技巧"></a> 调优技巧</h2><ol><li>平均负载高可能是cpu密集型进程导致的；</li><li>平均负载高并不一定代表 CPU 使用率高，还有可能是等待I/O的进程变多了；</li><li>平均负载高的时候，需要辅助其他的工具来做进一步的分析；</li></ol><h1 id="性能指标3上下文切换"><a class="markdownIt-Anchor" href="#性能指标3上下文切换"></a> 性能指标3——上下文切换</h1><p>如果系统的上下文切换次数比较稳定，那么理想数据是１万以内</p><h2 id="相关工具-3"><a class="markdownIt-Anchor" href="#相关工具-3"></a> 相关工具</h2><h3 id="vmstat"><a class="markdownIt-Anchor" href="#vmstat"></a> vmstat</h3><blockquote><p>cs列：系统每秒上下文切换的次数。<br />r列：处于可运行态的进程数量<br />b列：处于不可中断睡眠状态的进程数量</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔5s输出一组数据</span></span><br><span class="line">[root@VM_194_74_centos ~]<span class="comment"># vmstat 5 5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy <span class="built_in">id</span> wa st</span><br><span class="line"> 1  0      0 118120 1188128 13137072    0    0     0    10    0    0  3  1 97  0  0</span><br><span class="line"> 1  0      0 117040 1188128 13137080    0    0     0    22 1071 1311  1  0 99  0  0</span><br><span class="line"> 0  0      0 116824 1188128 13137092    0    0     0    13 1181 1421  1  0 99  0  0</span><br><span class="line"> 0  0      0 117328 1188128 13137100    0    0     0    12 1165 1374  1  0 99  0  0</span><br><span class="line"> 1  0      0 117168 1188128 13137112    0    0     0    22 1148 1391  1  0 99  0  0</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>cs</code>：context switch，每秒上下文切换的次数</li><li><code>in</code>：interrupt ，每秒中断的次数</li><li><code>r</code>：就绪队列的长度（正在运行和等待CPU的进程数）</li><li><code>b</code>：blocked，处于不可中断睡眠状态的进程数</li></ul><h3 id="pidstat-2"><a class="markdownIt-Anchor" href="#pidstat-2"></a> pidstat</h3><p>显示进程的每秒自愿和非自愿上下文切换次数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pidstat -w</span></span><br></pre></td></tr></table></figure><p>命令：pidstat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ [root@VM_194_74_centos ~]<span class="comment"># pidstat -w 5</span></span><br><span class="line">Linux 3.10.107-1-tlinux2_kvm_guest-0049 (VM_194_74_centos)      05/07/20        _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">08:20:54      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:20:59        0         1      0.80      0.00  systemd</span><br><span class="line">08:20:59        0         7      0.80      0.00  migration/0</span><br><span class="line">08:20:59        0         9     90.40      0.00  rcu_sched</span><br><span class="line">08:20:59        0        10      0.20      0.00  watchdog/0</span><br><span class="line">08:20:59        0        11      0.20      0.00  watchdog/1</span><br><span class="line">08:20:59        0        12      2.00      0.00  migration/1</span><br><span class="line">08:20:59        0        16      0.20      0.00  watchdog/2</span><br><span class="line">08:20:59        0        17      1.00      0.00  migration/2</span><br><span class="line">08:20:59        0        18      0.20      0.00  ksoftirqd/2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>cswch：每秒自愿上下文切换的次数（voluntary context switch）</li><li>nvcswch：每秒非自愿上下文切换的次数(non voluntary context switch)</li></ul><blockquote><p>自愿上下文切换：进程无法获取所需资源导致的上下文切换，比如I/O，内存等<strong>系统资源不足</strong>时发生的上下文切换</p><p>非自愿上下文切换：进程因<strong>时间片</strong>已到等原因，被系统强制<strong>调度</strong>发生的上下文切换，比如多个进程<strong>竞争</strong>CPU是发生的上下文切换</p></blockquote><p>/proc/interrupts</p><p>/proc/softirqs</p><h2 id="调优技巧-2"><a class="markdownIt-Anchor" href="#调优技巧-2"></a> 调优技巧</h2><blockquote><p>如果进程的自愿上下文切换多了，表示进程在等待资源；<br />如果进程的非自愿上下文切换多了，说明进程在被强制调度（被实时性更高的进程抢占）；<br />如果中断次数多了，说明中断处理程序在占用大量的cpu;<br />如果软中断次数多了，说明下半部处理程序在占用大量的cpu，一般是网络；</p></blockquote><h1 id="调优工具"><a class="markdownIt-Anchor" href="#调优工具"></a> 调优工具</h1><h2 id="top-2"><a class="markdownIt-Anchor" href="#top-2"></a> top</h2><p>数据及指标</p><blockquote><p>us: 代表用户态cpu时间，不包含被调 整过nice值的进程所占的cpu时间；<br />ni: 代表被调整过nice值的进程占用的cpu时间；　<br />sy: 代表内核态cpu时间<br />id: 空闲时间，注意，它不包括等待 I/O 的时间（iowait）<br />wa: 代表等待I/O的cpu时间<br />hi: 代表硬件中断占据的cpu时间<br />si: 代表软件中断占据的cpu时间</p></blockquote><p>[例子]</p><blockquote><p>１、stress命令起1个进程：<br />stress -c 1<br />2、top查看<br />3、renice<br />renice -n 5 -p 26205<br />4、top查看可见进程26205的cpu用量由原来的统计到us变成了统计到ni上</p></blockquote><h3 id="可添加的参数"><a class="markdownIt-Anchor" href="#可添加的参数"></a> 可添加的参数</h3><blockquote><p>-p {pid}：只显示某个进程的状态</p><p>以下内容中【交互】表示使用top命令实时显示数据时输入对应的选项会将实时显示的数据进行对应的变化</p><p>【交互】h: 显示帮助<br />【交互】c: 切换显示完整的命令行<br />【交互】M：根据常驻内存(RES)用量进行排序<br />【交互】P: 根据CPU使用百分比大小进行排序<br />【交互】S：切换到累加模式<br />【交互】T：根据时间或者累计时间进行排序(TIME+列)<br />【交互】s：改变两次刷新的延迟时间，默认是3s<br />【交互】r：修改某个进程的nice值（对应top的NI列）</p></blockquote><h2 id="ps"><a class="markdownIt-Anchor" href="#ps"></a> ps</h2><p>显示所有进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><p>显示所有线程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf或ps -eTf</span><br></pre></td></tr></table></figure><p>ps统计的是进程的整个生命周期，top是实时的消耗，默认是三秒内</p><p>ps的可选项：</p><blockquote><p>-e：选择所有进程</p><p>-o：用于设定输出格式<br />例如： -o stat,ppid,pid,cmd 表示只输出进程的stat(状态信息)、ppid(父进程pid)、pid（当前进程的pid)，cmd(即进程的可执行文件）<br />-L Show threads, possibly with LWP and NLWP columns<br />-T Show threads, possibly with SPID column<br />-m Show threads after processes.<br />-f 全格式输出<br />-a 选择所有进程，除了session leader(见getsid(2))和与terminal不相关的进程。<br />-A, 选择所有进程（同-e）</p></blockquote><h2 id="mpstat-2"><a class="markdownIt-Anchor" href="#mpstat-2"></a> mpstat</h2><h3 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法：</h3><h3 id="mpstat-p-all-1"><a class="markdownIt-Anchor" href="#mpstat-p-all-1"></a> mpstat -P ALL 1</h3><h2 id="sar"><a class="markdownIt-Anchor" href="#sar"></a> sar</h2><h3 id="用法-2"><a class="markdownIt-Anchor" href="#用法-2"></a> 用法</h3><p>前提条件： 1. sudo vi /etc/default/sysstat　　//把false修改为true 2. sudo service sysstat restart　　//重启sysstat服务</p><h2 id="pidstat-3"><a class="markdownIt-Anchor" href="#pidstat-3"></a> pidstat</h2><blockquote><p>％usr: 进程在用户态执行的cpu时间 %system: 进程在内核态执行的cpu时间 %wait: 进程等待运行时所花费的CPU时间</p></blockquote><h3 id="用法-3"><a class="markdownIt-Anchor" href="#用法-3"></a> 用法</h3><p>每隔１秒输出一组进程的cpu数据： <code>$ pidstat -u 1</code></p><blockquote><p>-p {pid} 指定查看某个进程的信息<br />-U {usrname} 显示属于这个用户的进程<br />-r：内存</p><p>-d: IO<br />kB_rd/s：该进程每秒从磁盘读取的数据大小<br />kB_wr/s：该进程每秒写入磁盘的数据大小<br />kB_ccwr/s：每秒取消的写请求数据大小</p><p>iodelay：块 I/O 延迟，包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期。</p><p>-u: cpu（默认）</p><p>-R: 进程的realtime priority and scheduling policy</p><p>-w：进程的上下文切换信息</p><p>cswch/s：每秒自愿进行上下文切换的次数</p><p>１、所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换； ２、而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。<br />nvcswch/s：表示每秒非自愿上下文切换的次数</p><p>-v：进程相关的线程数和文件描述符数量</p><p>-s：进程stack所用内存信息</p></blockquote><h2 id="perf-2"><a class="markdownIt-Anchor" href="#perf-2"></a> perf</h2><h3 id="用法-4"><a class="markdownIt-Anchor" href="#用法-4"></a> 用法</h3><p>perf list：<br />列出所有能够触发perf采样点的事件，类似/sys/kernel/debug/tracing/available_events的输出<br />实测发现，perf 支持的事件要比ftrace多一倍左右。</p><p>perf probe：<br />定义新的动态tracepoint</p><blockquote><p>–add：添加一个probe event</p><p>例如：perf probe --add do_sys_open<br />–del：删除probe event<br />例如：perf probe --del probe:do_sys_open<br />例子：perf record -e probe:do_sys_open -aR sleep 10</p></blockquote><p>perf trace：<br />类似strace，不过性能更佳，例如：perf trace ls</p><p>perf stat：<br />运行命令并收集性能统计信息</p><p>perf top：<br />可以实时查看当前系统进程函数占用率情况</p><p>perf record：<br />运行命令并保存profile到perf.data</p><blockquote><p>-p {pid} 记录进程的events<br />-a：从所有cpu上进行采集<br />-e {event}：指定PMU（处理器监控单元） event ，默认是cycles:ppp（CPU周期数）<br />-g：启用调用图(堆栈链/回溯)记录<br />-F {freq}：采样频率</p><p>例如：<br />perf record -p 12069 -a -g -F 99 – sleep 10<br />perf record -p 12069 -a -g -F 999 – sleep 10<br />perf record -g -e cpu-clock ./perftest</p></blockquote><p>perf report：<br />从perf.data读取并显示profile</p><blockquote><p>–no-children：不统计Children开销</p><blockquote><p>Self：Self 记录的是最后一列的符号（可以理解为函数）本身的采样数占总采样数的百分比<br />目的：找到最底层的热点函数</p><p>Children：记录的是这个符号调用的其他符号（理解为子函数，包括直接调用和间接调用）的采样数之和占总采样数的百分比<br />目的：找到较高层的热点函数</p></blockquote></blockquote><p>perf script：<br />从perf.data读取并显示详细的采样数据</p><p>perf kmem：<br />跟踪/测量内核内存属性</p><blockquote><p>record：记录kmem events</p><blockquote><p>–slab：记录slab申请器的events</p><p>–page：记录page 申请器的events</p></blockquote><p>stat：报告内核内存统计信息</p><blockquote><p>–slab：统计slab申请器的events</p><p>–page：统计page 申请器的events</p></blockquote></blockquote><p>perf mem：<br />分析内存访问</p><p>perf lock：<br />分析锁性能</p><p>perf kvm：<br />针对kvm虚拟化分析</p><p>perf sched：<br />分析内核调度器性能</p><blockquote><p>record：采集和记录scheduling events</p><blockquote><p>例如（全局）：perf sched record – sleep 10<br />例如（进程）：perf sched record -p 752 – sleep 10</p></blockquote><p>script：报告采集到的事件</p><p>latency：报告每个任务的调度延迟和进程的其他调度属性</p><p>timehist：提供调度事件的分析报告</p></blockquote><p>火焰图</p><p>火焰图的横轴和纵轴的含义： - 横轴表示采样数和采样比例。一个函数占用的横轴越宽，就代表它的执行时间越长。同一层的多个函数，则是按照字母来排序。 - 纵轴表示调用栈，由下往上根据调用关系逐个展开。换句话说，上下相邻的两个函数中，下面的函数，是上面函数的父函数。这样，调用栈越深，纵轴就越高。 火焰图不包含任何时间的因素，所以并不能看出横向各个函数的执行次序。</p><h3 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 场景</h3><p>寻找热点函数，定位性能瓶颈</p><p>具体实现是对事件进行采样，然后再根据采样数，评估各个函数的调用频率，</p><p>perf 可以用来分析 CPU cache、CPU 迁移、分支预测、指令周期等各种硬件事件</p><p>perf 也可以只对感兴趣的事件进行动态追踪</p><p>实践过程</p><p>寻找热点函数，定位性能瓶颈</p><p>自定义追踪函数</p><p>1、添加 do_sys_open 探针 $ perf probe --add do_sys_open 2、采样和追踪 $ perf record -e probe:do_sys_open -aR sleep 1 3、查看采样结果 $ perf script 4、删除探针 $ perf probe --del probe:do_sys_open</p><h2 id="pstree"><a class="markdownIt-Anchor" href="#pstree"></a> pstree</h2><h3 id="用法-5"><a class="markdownIt-Anchor" href="#用法-5"></a> 用法</h3><p>经典用法： $ pstree -p 5638 显示5638这个进程的进程树（包含线程） $ pstree -T -p 5638 显示5638这个进程的进程树（不包含线程）</p><blockquote><p>-a 显示命令行参数  If the command line of a process is swapped out，则该进程将显示在括号中，例如类似这样： -{kubeensaas}(8)</p><p>-c 禁止压缩子树（压缩后不显示子树信息）</p><p>-n 通过pid而不是name对相同祖先的进程排序</p><p>-g 显示PGIDs</p><p>-p 显示某个进程的进程树（包含线程）</p><p>-T 隐藏线程、只显示进程</p></blockquote><h2 id="taskset"><a class="markdownIt-Anchor" href="#taskset"></a> taskset</h2><h3 id="用法-6"><a class="markdownIt-Anchor" href="#用法-6"></a> 用法</h3><p>-pc 0x3 {pid}：绑定cpu0和cpu1到进程</p><p>-pc {pid}：查看进程绑定的cpu(输出为３，也就是011，表示第０，１个cpu)</p><h2 id="cpulimit"><a class="markdownIt-Anchor" href="#cpulimit"></a> cpulimit</h2><h3 id="用法-7"><a class="markdownIt-Anchor" href="#用法-7"></a> 用法</h3><p>-p {pid} -l {percent}：进程允许的cpu用量为percent%</p><p>-k：如果进程cpu超量，直接杀掉进程而不是限制cpu使用(默认)；</p><p>-m：输出统计信息；</p><h2 id="pstack"><a class="markdownIt-Anchor" href="#pstack"></a> pstack</h2><p>$ pstack 11613 11613: ./jin pstack: Input/output error failed to read target. 【解决】 参考此处： <a href="https://blog.csdn.net/u010164190/article/details/111059283">https://blog.csdn.net/u010164190/article/details/111059283</a></p><h3 id="用法-8"><a class="markdownIt-Anchor" href="#用法-8"></a> 用法</h3><p>pstack｛pid｝对指定PID的进程输出函数调用栈</p><h3 id="场景-2"><a class="markdownIt-Anchor" href="#场景-2"></a> 场景</h3><p>应用并未崩溃，如何查看stack trace信息？</p><h2 id="strace"><a class="markdownIt-Anchor" href="#strace"></a> strace</h2><h3 id="用法-9"><a class="markdownIt-Anchor" href="#用法-9"></a> 用法</h3><blockquote><p>-p {pid｝<br />-f 跟踪子进程<br />-t 在输出中的每一行前加上时间信息<br />-T 显示每一个系统调用所耗的时间<br />-c 统计每一个系统调用的调用次数、错误次数、执行时间和执行时间占比</p></blockquote><h3 id="场景-3"><a class="markdownIt-Anchor" href="#场景-3"></a> 场景</h3><p>正在运行的程序实际读取的是哪个配置文件？</p><p>程序好像hang住了，具体是什么情况，为什么hang住？hang在了哪里？</p><p>进程运行很慢，但是没有源代码，想看看时间都花在了哪里？</p><p>容器环境下，如何对应用程序的网络行为进行调试和追踪？</p><h2 id="stap"><a class="markdownIt-Anchor" href="#stap"></a> stap</h2><h3 id="用法-10"><a class="markdownIt-Anchor" href="#用法-10"></a> 用法</h3><p>stap --all-modules dropwatch.stp</p><h2 id="proc"><a class="markdownIt-Anchor" href="#proc"></a> /proc</h2><p>用法</p><p>通过子进程的Pid得到父进程的Pid：<code>cat /proc/&#123;pid&#125;/status | grep PPid</code></p><h1 id="调试方法"><a class="markdownIt-Anchor" href="#调试方法"></a> 调试方法</h1><h2 id="用户cpu使用率较高-checklist"><a class="markdownIt-Anchor" href="#用户cpu使用率较高-checklist"></a> 用户cpu使用率较高 checklist</h2><p>分析过程</p><ol><li>通过top命令查看系统整体的cpu使用率和平均负载</li><li>pidstat -u 1| more 查看进程的cpu使用率，找到可疑进程</li><li>pstree -p {pid}查看进程的进程结构（继承关系）</li><li>strace -f -p {pid} 追踪进程的系统调用情况，是否存在频繁的系统调用？</li><li>pstack {pid}找到代码瓶颈点</li></ol><h2 id="软中断cpu使用率较高checklist"><a class="markdownIt-Anchor" href="#软中断cpu使用率较高checklist"></a> 软中断cpu使用率较高，Checklist</h2><p>分析过程</p><ol><li>通过top命令查看系统整体的cpu使用率和平均负载</li><li>watch -d cat /proc/softirqs 找到瓶颈所在的软件中断</li><li>perf record -g 采集内核事件</li><li>perf report分析事件，找到瓶颈所在的内核函数代码</li></ol><h2 id="cpu使用率较高checklist"><a class="markdownIt-Anchor" href="#cpu使用率较高checklist"></a> cpu使用率较高，Checklist</h2><p>分析过程</p><ol><li>通过top命令查看系统整体的cpu使用率和平均负载</li><li>pidstat -u 1| more<br />查看进程的cpu使用率，找到可疑进程</li><li>iostat查看系统整体的I/O情况</li><li>iotop查看进程的I/O压力情况</li><li>strace -f -p {pid} 追踪进程的系统调用情况，是否存在频繁的系统调用？</li></ol><h2 id="案例分析"><a class="markdownIt-Anchor" href="#案例分析"></a> 案例分析</h2><p><code>sysbench</code>模拟多线程调度切换</p><h3 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h3><blockquote><p>一台Linux机器，打开三个终端</p></blockquote><h3 id="正式实战"><a class="markdownIt-Anchor" href="#正式实战"></a> 正式实战</h3><ol><li>第一个终端：运行<code>sysbench</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以10个线程运行5分钟的基准测试，模拟多线程切换的问题</span><br><span class="line">$ sysbench --threads=10 --max-time=300 threads run</span><br></pre></td></tr></table></figure><ol start="2"><li>第二个终端：运行<code>vmstat</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔1秒输出1组数据（需要Ctrl+C才结束）</span></span><br><span class="line">$ vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy <span class="built_in">id</span> wa st</span><br><span class="line"> 6  0      0 6487428 118240 1292772    0    0     0     0 9019 1398830 16 84  0  0  0</span><br><span class="line"> 8  0      0 6487428 118240 1292772    0    0     0     0 10191 1392312 16 84  0  0  0</span><br></pre></td></tr></table></figure><p>指标观察：</p><ul><li><p>cs列：上升到39万</p></li><li><p>r列：就绪队列长度上升到8</p></li><li><p>in列：终端次数上升到1万</p></li><li><p>us（user）和sy（system）列：使用率加起来100%，sy为84%，主要被内核占用</p></li></ul><ol start="3"><li>查看进程情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 每隔1秒输出1组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标</span></span><br><span class="line">$ pidstat -w -u 1</span><br><span class="line">08:06:33      UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">08:06:34        0     10488   30.00  100.00    0.00    0.00  100.00     0  sysbench</span><br><span class="line">08:06:34        0     26326    0.00    1.00    0.00    0.00    1.00     0  kworker/u4:2</span><br><span class="line"></span><br><span class="line">08:06:33      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:06:34        0         8     11.00      0.00  rcu_sched</span><br><span class="line">08:06:34        0        16      1.00      0.00  ksoftirqd/1</span><br><span class="line">08:06:34        0       471      1.00      0.00  hv_balloon</span><br><span class="line">08:06:34        0      1230      1.00      0.00  iscsid</span><br><span class="line">08:06:34        0      4089      1.00      0.00  kworker/1:5</span><br><span class="line">08:06:34        0      4333      1.00      0.00  kworker/0:3</span><br><span class="line">08:06:34        0     10499      1.00    224.00  pidstat</span><br><span class="line">08:06:34        0     26326    236.00      0.00  kworker/u4:2</span><br><span class="line">08:06:34     1000     26784    223.00      0.00  sshd</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：CPU 使用率的升高果然是 sysbench 导致的，它的 CPU 使用率已经达到了 100%。但上下文切换则是来自其他进程，包括非自愿上下文切换频率最高的 pidstat  ，以及自愿上下文切换频率最高的内核线程 kworker 和 sshd</p><p><strong>注意</strong>：pidstat 输出的上下文切换次数，加起来也就几百，比 vmstat 的 139 万明显小了太多？</p><ol start="4"><li>查看线程的情况</li></ol><p>可以看到，sysbench 进程（也就是主线程）的上下文切换次数看起来并不多，但它的子线程的上下文切换次数却有很多。上下文切换罪魁祸首，还是过多的 sysbench 线程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔1秒输出一组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -wt 参数表示输出线程的上下文切换指标</span></span><br><span class="line">$ pidstat -wt 1</span><br><span class="line">08:14:05      UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">...</span><br><span class="line">08:14:05        0     10551         -      6.00      0.00  sysbench</span><br><span class="line">08:14:05        0         -     10551      6.00      0.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10552  18911.00 103740.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10553  18915.00 100955.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10554  18827.00 103954.00  |__sysbench</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="5"><li>查看中断升高的原因<br />根据前文的分析，中断次数也升高到了1万左右，从/proc/interrupts只读文件查看中断情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 参数表示高亮显示变化的区域</span></span><br><span class="line">$ watch -d <span class="built_in">cat</span> /proc/interrupts</span><br><span class="line">           CPU0       CPU1</span><br><span class="line">...</span><br><span class="line">RES:    2450431    5279697   Rescheduling interrupts</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>观察发现，变化速度最快的是<strong>重调度中断（RES）</strong>，它代表唤醒空闲状态的 CPU 来调度新的任务运行，这是在多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为<strong>处理器间中断</strong>（Inter-Processor Interrupts，IPI）</p><p><strong>分析</strong>：过多任务导致了重调度中断的升高，和前面分析结果一致</p><h3 id="每秒上下文切换多少次正常"><a class="markdownIt-Anchor" href="#每秒上下文切换多少次正常"></a> 每秒上下文切换多少次正常？</h3><p><strong>上下文切换次数取决于系统本身的CPU性能</strong>。如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题，这时根据具体上下文切换的类型具体分析：</p><ul><li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题</li><li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈</li><li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型</li></ul><h3 id="系统出现大量不可中断进程和僵尸进程怎么办"><a class="markdownIt-Anchor" href="#系统出现大量不可中断进程和僵尸进程怎么办"></a> 系统出现大量不可中断进程和僵尸进程怎么办？</h3><h4 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h4><ul><li><p><strong>R</strong>：表示正在就绪队列中的进程，正在运行或者正在等待运行</p></li><li><p><strong>D</strong>：Disk Sleep，不可中断状态睡眠（Uninterruptible Sleep），一般是进程和硬件交互，并且交互过程不允许其他进程或中断打断</p></li><li><p><strong>Z</strong> ：Zombie 的缩写，它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）</p></li><li><p><strong>S</strong> ：Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态</p></li><li><p><strong>I</strong>： Idle 的缩写，也就是空闲状态，用在<strong>不可中断睡眠的内核线程</strong>上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会</p></li><li><p><strong>T</strong>：Stopped或者Traced，表示进程处于暂停或者跟踪状态（SIGSTOP信号会让进程变为暂停状态，再发送SIGCONT信号，进程又会恢复运行）</p></li><li><p><strong>X</strong>：Dead，表示进程已经消亡，top或者ps看不到</p></li></ul><blockquote><p>不可中断状态，是为了保证进程数据与硬件状态一致，正常情况下，不可中断状态在很短时间内就会结束。短时的不可中断状态进程，我们一般可以忽略。</p><p>但如果系统或硬件发生了故障，进程可能会在不可中断状态保持很久，甚至导致系统中出现大量不可中断进程。需要注意下，系统是不是出现了 I/O 等性能问题。</p></blockquote><p><strong>注意</strong>：ps查看进程状态时，会有Ss+，D+等情况，其中s表示进程是会话的领导进程，+表示前台进程组</p><h4 id="案例分析-2"><a class="markdownIt-Anchor" href="#案例分析-2"></a> 案例分析</h4><h5 id="指标分析"><a class="markdownIt-Anchor" href="#指标分析"></a> 指标分析</h5><ol><li>运行案例的docker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --privileged --name=app -itd feisky/app:iowait</span><br></pre></td></tr></table></figure><ol start="2"><li>top查看指标</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按下数字 1 切换到所有 CPU 的使用情况，观察一会儿按 Ctrl+C 结束</span></span><br><span class="line">$ top</span><br><span class="line">top - 05:56:23 up 17 days, 16:45,  2 <span class="built_in">users</span>,  load average: 2.00, 1.68, 1.39</span><br><span class="line">Tasks: 247 total,   1 running,  79 sleeping,   0 stopped, 115 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  0.7 sy,  0.0 ni, 38.9 <span class="built_in">id</span>, 60.5 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  0.7 sy,  0.0 ni,  4.7 <span class="built_in">id</span>, 94.6 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 4340 root      20   0   44676   4048   3432 R   0.3  0.0   0:00.05 top</span><br><span class="line"> 4345 root      20   0   37280  33624    860 D   0.3  0.0   0:00.01 app</span><br><span class="line"> 4344 root      20   0   37280  33624    860 D   0.3  0.4   0:00.01 app</span><br><span class="line">    1 root      20   0  160072   9416   6752 S   0.0  0.1   0:38.59 systemd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li>分析</li></ol><ul><li>第一行的平均负载（ Load Average），过去 1 分钟、5 分钟和 15 分钟内的平均负载在依次减小，说明平均负载正在升高；而 1 分钟内的平均负载已经达到系统的 CPU 个数，说明系统很可能已经有了性能瓶颈。</li><li>第二行的 Tasks，有 1 个正在运行的进程，但僵尸进程比较多，而且还在不停增加，说明有子进程在退出时没被清理。</li><li>CPU 的使用率情况，用户 CPU 和系统 CPU 都不高，但 iowait 分别是 60.5% 和 94.6%，好像有点儿不正常。</li><li>最后再看每个进程的情况， CPU 使用率最高的进程只有 0.3%，看起来并不高；但有两个进程处于 D 状态，它们可能在等待 I/O，但光凭这里并不能确定是它们导致了 iowait 升高。</li></ul><ol start="4"><li>结论</li></ol><ul><li>第一点，iowait 太高了，导致系统的平均负载升高，甚至达到了系统 CPU 的个数</li><li>第二点，僵尸进程在不断增多，说明有程序没能正确清理子进程的资源。</li></ul><h5 id="iowait分析"><a class="markdownIt-Anchor" href="#iowait分析"></a> iowait分析</h5><ol><li>dstat查看系统I/O情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔1秒输出10组数据</span></span><br><span class="line">$ dstat 1 10</span><br><span class="line">You did not <span class="keyword">select</span> any stats, using -cdngy by default.</span><br><span class="line">--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai stl| <span class="built_in">read</span>  writ| recv  send|  <span class="keyword">in</span>   out | int   csw</span><br><span class="line">  0   0  96   4   0|1219k  408k|   0     0 |   0     0 |  42   885</span><br><span class="line">  0   0   2  98   0|  34M    0 | 198B  790B|   0     0 |  42   138</span><br><span class="line">  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  42   135</span><br><span class="line">  0   0  84  16   0|5633k    0 |  66B  342B|   0     0 |  52   177</span><br><span class="line">  0   3  39  58   0|  22M    0 |  66B  342B|   0     0 |  43   144</span><br><span class="line">  0   0   0 100   0|  34M    0 | 200B  450B|   0     0 |  46   147</span><br><span class="line">  0   0   2  98   0|  34M    0 |  66B  342B|   0     0 |  45   134</span><br><span class="line">  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  39   131</span><br><span class="line">  0   0  83  17   0|5633k    0 |  66B  342B|   0     0 |  46   168</span><br><span class="line">  0   3  39  59   0|  22M    0 |  66B  342B|   0     0 |  37   134</span><br></pre></td></tr></table></figure><p>可以看到，每当 iowait 升高（wai）时，磁盘的读请求（read）都会很大。这说明 iowait 的升高跟磁盘的读请求有关，很可能就是磁盘读导致的</p><ol start="2"><li>pidstat分析D状态的进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 展示 I/O 统计数据，-p 指定进程号，间隔 1 秒输出 3 组数据</span></span><br><span class="line">$ pidstat -d -p 4344 1 3</span><br><span class="line">06:38:50      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:38:51        0      4344      0.00      0.00      0.00       0  app</span><br><span class="line">06:38:52        0      4344      0.00      0.00      0.00       0  app</span><br><span class="line">06:38:53        0      4344      0.00      0.00      0.00       0  app</span><br></pre></td></tr></table></figure><ul><li>kB_rd 表示每秒读的 KB 数</li><li>kB_wr 表示每秒写的 KB 数</li><li>iodelay 表示 I/O 的延迟（单位是时钟周期）。</li><li>它们都是 0，那就表示此时没有任何的读写，说明问题不是 4344 进程导致的。</li></ul><ol start="3"><li>pidstat查看所有进程情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 1 秒输出多组数据 (这里是 20 组)</span></span><br><span class="line">$ pidstat -d 1 20</span><br><span class="line">...</span><br><span class="line">06:48:46      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:47        0      4615      0.00      0.00      0.00       1  kworker/u4:1</span><br><span class="line">06:48:47        0      6080  32768.00      0.00      0.00     170  app</span><br><span class="line">06:48:47        0      6081  32768.00      0.00      0.00     184  app</span><br><span class="line"></span><br><span class="line">06:48:47      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:48        0      6080      0.00      0.00      0.00     110  app</span><br><span class="line"></span><br><span class="line">06:48:48      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:49        0      6081      0.00      0.00      0.00     191  app</span><br><span class="line"></span><br><span class="line">06:48:49      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line"></span><br><span class="line">06:48:50      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:51        0      6082  32768.00      0.00      0.00       0  app</span><br><span class="line">06:48:51        0      6083  32768.00      0.00      0.00       0  app</span><br><span class="line"></span><br><span class="line">06:48:51      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:52        0      6082  32768.00      0.00      0.00     184  app</span><br><span class="line">06:48:52        0      6083  32768.00      0.00      0.00     175  app</span><br><span class="line"></span><br><span class="line">06:48:52      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:53        0      6083      0.00      0.00      0.00     105  app</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>观察一会儿可以发现，的确是 app 进程在进行磁盘读，并且每秒读的数据有 32 MB，看来就是 app 的问题。不过，app 进程到底在执行啥 I/O 操作呢？<strong>进程想要访问磁盘，就必须使用系统调用，所以接下来，重点就是找出 app 进程的系统调用</strong></p><ol start="4"><li>strace跟踪进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ strace -p 6082</span><br><span class="line">strace: attach: ptrace(PTRACE_SEIZE, 6082): Operation not permitted</span><br></pre></td></tr></table></figure><ul><li>检查一下进程的状态，已经变成僵尸进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep 6082</span><br><span class="line">root      6082  0.0  0.0      0     0 pts/0    Z+   13:43   0:00 [app] &lt;defunct&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>动态追踪</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ perf record -g</span><br><span class="line">$ perf report</span><br></pre></td></tr></table></figure><p>如下图，swapper是内核的调度进程，可忽略</p><p>可以发现， app 的确在通过系统调用 <strong>sys_read()</strong> 读取数据。并且从 new_sync_read 和 blkdev_direct_IO  能看出，进程正在对磁盘进行<strong>直接读</strong>，也就是<strong>绕过了系统缓存</strong>，每个读请求都会从磁盘直接读，这就可以解释我们观察到的 iowait 升高了<br /><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/21e79416e946ed049317a4b4c5a576a1.webp.webp" alt="img" /></p><ol start="6"><li>打开app.py文件，可以看到使用了 O_DIRECT 选项打开磁盘</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(disk, O_RDONLY|O_DIRECT|O_LARGEFILE, 0755)</span><br></pre></td></tr></table></figure><blockquote><p>直接读写磁盘，对 I/O 敏感型应用（比如数据库系统）是很友好的，因为你可以在应用中，直接控制磁盘的读写。但在大部分情况下，我们最好还是通过系统缓存来优化磁盘 I/O</p></blockquote><ol start="7"><li>修复代码</li></ol><p><a href="http://xn--app-fix1-8t1m43fvzrka047nwg5b3i3c.py">修复后的文件名app-fix1.py</a>，运行docker如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 首先删除原来的应用</span><br><span class="line">$ docker rm -f app</span><br><span class="line"># 运行新的应用</span><br><span class="line">$ docker run --privileged --name=app -itd feisky/app:iowait-fix1</span><br></pre></td></tr></table></figure><p>top检查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ top</span><br><span class="line">top - 14:59:32 up 19 min,  1 user,  load average: 0.15, 0.07, 0.05</span><br><span class="line">Tasks: 137 total,   1 running,  72 sleeping,   0 stopped,  12 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  1.7 sy,  0.0 ni, 98.0 <span class="built_in">id</span>,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  1.3 sy,  0.0 ni, 98.7 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 3084 root      20   0       0      0      0 Z   1.3  0.0   0:00.04 app</span><br><span class="line"> 3085 root      20   0       0      0      0 Z   1.3  0.0   0:00.04 app</span><br><span class="line">    1 root      20   0  159848   9120   6724 S   0.0  0.1   0:09.03 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd</span><br><span class="line">    3 root      20   0       0      0      0 I   0.0  0.0   0:00.40 kworker/0:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="僵尸进程分析"><a class="markdownIt-Anchor" href="#僵尸进程分析"></a> 僵尸进程分析</h5><blockquote><p>僵尸进程是因为父进程没有回收子进程的资源而出现的，那么，就需要找出父进程，然后在父进程里解决。</p></blockquote><ol><li>pstree</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a 表示输出每个程序完整的命令（包含路径，参数或是常驻服务的标示）</span></span><br><span class="line"><span class="comment"># p指定PID</span></span><br><span class="line"><span class="comment"># s表示显示指定进程的父进程</span></span><br><span class="line">$ pstree -aps 3084</span><br><span class="line">systemd,1</span><br><span class="line">  └─dockerd,15006 -H fd://</span><br><span class="line">      └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml</span><br><span class="line">          └─docker-containe,3991 -namespace moby -workdir...</span><br><span class="line">              └─app,4009</span><br><span class="line">                  └─(app,3084)</span><br></pre></td></tr></table></figure><ol start="2"><li>查看app-fix1.py代码</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> status = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fork()== <span class="number">0</span>) &#123;</span><br><span class="line">        sub_process();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(wait(&amp;status)&gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以发现，文件错误地把 wait() 放到了 for 死循环的外面，也就是说，wait() 函数实际上并没被调用到，我们把它挪到 for 循环的里面就可以了。</p><p>修改后的文件我放到了 app-fix2.c ，运行对应的docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先停止产生僵尸进程的 app</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f app</span><br><span class="line"><span class="comment"># 然后启动新的 app</span></span><br><span class="line">$ docker run --privileged --name=app -itd feisky/app:iowait-fix2</span><br></pre></td></tr></table></figure><ol start="3"><li><p>top查看</p><p>僵尸进程（Z 状态）没有了， iowait 也是 0，问题解决</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ top</span><br><span class="line">top - 15:00:44 up 20 min,  1 user,  load average: 0.05, 0.05, 0.04</span><br><span class="line">Tasks: 125 total,   1 running,  72 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  1.7 sy,  0.0 ni, 98.3 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  1.3 sy,  0.0 ni, 98.7 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 3198 root      20   0    4376    840    780 S   0.3  0.0   0:00.01 app</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd</span><br><span class="line">    3 root      20   0       0      0      0 I   0.0  0.0   0:00.41 kworker/0:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="怎么理解cpu软中断"><a class="markdownIt-Anchor" href="#怎么理解cpu软中断"></a> 怎么理解CPU软中断</h3><blockquote><p>中断是一种异步的事件处理机制，可以提高系统的并发处理能力</p><p>为了减少对正常进程运行调度的影响，中断处理程序应该尽快完成</p></blockquote><h4 id="软中断"><a class="markdownIt-Anchor" href="#软中断"></a> 软中断</h4><p>中断过程分为上半部和下半部：</p><ul><li>上半部：用来快速处理中断，它在中断禁止模式下运行，主要处理和<strong>硬件紧密相关</strong>或者<strong>时间敏感</strong>的工作</li><li>下半部：用来延迟处理上半部未完成的工作，通常以<strong>内核线程</strong>的形式运行</li></ul><p>网卡接收数据包的例子：网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。对上半部来说，既然是快速处理，其实就是要把网卡的数据<strong>读到内存</strong>中，然后<strong>更新硬件寄存器的状态</strong>（表示数据已经读好了），最后再发送一个软中断信号，通知下半部做进一步的处理。而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照<strong>网络协议栈</strong>，对数据进行<strong>逐层解析和处理</strong>，直到把它送给应用程序。</p><p>可以理解为：<strong>上半部快速执行，下半部延迟执行</strong></p><h4 id="查看软中断和内核线程"><a class="markdownIt-Anchor" href="#查看软中断和内核线程"></a> 查看软中断和内核线程</h4><ol><li>查看/proc文件系统</li></ol><ul><li>/proc/softirqs，提供了软中断的运行情况</li><li>/proc/interrupts，提供了硬中断的运行情况</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看到各类软中断在不同CPU上累积的运行次数</span></span><br><span class="line">$ <span class="built_in">cat</span> /proc/softirqs</span><br><span class="line">                    CPU0       CPU1</span><br><span class="line">          HI:          0          0</span><br><span class="line">       TIMER:     811613    1972736</span><br><span class="line">      NET_TX:         49          7</span><br><span class="line">      NET_RX:    1136736    1506885</span><br><span class="line">       BLOCK:          0          0</span><br><span class="line">    IRQ_POLL:          0          0</span><br><span class="line">     TASKLET:     304787       3691</span><br><span class="line">       SCHED:     689718    1897539</span><br><span class="line">     HRTIMER:          0          0</span><br><span class="line">         RCU:    1330771    1354737</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>软中断的类型：第一列的内容，对应软中断的类型，比如<strong>NET_TX代表网络接收中断，NET_RX代表网络发送中断，SCHE代表调度，TIMER代表定时器</strong>等等</li><li>每种软中断在不同CPU上的运行情况：同一行的内容，正常情况下，同一种中断在不同CPU上的累计次数应该差不多，比如NET_RX。 而TASKLET只在调用它的函数所在的CPU运行（存在的<strong>问题</strong>：由于只在一个 CPU 上运行导致的调度不均衡，或者因为不能在多个 CPU 上并行运行带来了性能限制）</li></ul><ol start="2"><li>软中断以内核线程方式运行，每个CPU都对应一个软中断内核线程（ksoftirqd/CPU编号）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep softirq</span><br><span class="line">root         7  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/0]</span><br><span class="line">root        16  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/1]</span><br></pre></td></tr></table></figure><h3 id="系统的软中断cpu使用率升高该怎么办"><a class="markdownIt-Anchor" href="#系统的软中断cpu使用率升高该怎么办"></a> 系统的软中断CPU使用率升高，该怎么办？</h3><h4 id="案例准备"><a class="markdownIt-Anchor" href="#案例准备"></a> 案例准备</h4><p>工具介绍：</p><ul><li>sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。</li><li>hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等。</li><li>tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题</li></ul><p>案例图示</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image.webp" alt="image.png" /></p><p>其中一台虚拟机运行 Nginx ，用来模拟待分析的 Web 服务器；而另一台当作 Web 服务器的客户端，用来给 Nginx 增加压力请求</p><h4 id="操作和分析"><a class="markdownIt-Anchor" href="#操作和分析"></a> 操作和分析</h4><p>运行Nginx应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行Nginx服务并对外开放80端口</span></span><br><span class="line">$ docker run -itd --name=nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>在另一个终端运行hping3模拟客户端的请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -S参数表示设置TCP协议的SYN（同步序列号），-p表示目的端口为80</span></span><br><span class="line"><span class="comment"># -i u100表示每隔100微秒发送一个网络帧</span></span><br><span class="line"><span class="comment"># 注：如果你在实践过程中现象不明显，可以尝试把100调小，比如调成10甚至1</span></span><br><span class="line">$ hping3 -S -p 80 -i u100 192.168.0.30</span><br></pre></td></tr></table></figure><p>会发现简单的shell命令都变慢了，执行top查看系统整体情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># top运行后按数字1切换到显示所有CPU</span></span><br><span class="line">$ top</span><br><span class="line">top - 10:50:58 up 1 days, 22:10,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 122 total,   1 running,  71 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni, 96.7 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  3.3 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni, 95.6 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  4.4 si,  0.0 st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    7 root      20   0       0      0      0 S   0.3  0.0   0:01.64 ksoftirqd/0</span><br><span class="line">   16 root      20   0       0      0      0 S   0.3  0.0   0:01.97 ksoftirqd/1</span><br><span class="line"> 2663 root      20   0  923480  28292  13996 S   0.3  0.3   4:58.66 docker-containe</span><br><span class="line"> 3699 root      20   0       0      0      0 I   0.3  0.0   0:00.13 kworker/u4:0</span><br><span class="line"> 3708 root      20   0   44572   4176   3512 R   0.3  0.1   0:00.07 top</span><br><span class="line">    1 root      20   0  225384   9136   6724 S   0.0  0.1   0:23.25 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.03 kthreadd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>平均负载全是 0，就绪队列里面只有一个进程（1 running）。</li><li>每个 CPU 的使用率都挺低，最高的 CPU1 的使用率也只有 4.4%，并不算高。</li><li>再看进程列表，CPU 使用率最高的进程也只有 0.3%</li><li>两个 CPU 的使用率虽然分别只有 3.3% 和 4.4%，但都用在了软中断上；而从进程列表上也可以看到，CPU 使用率最高的也是软中断进程 ksoftirqd</li></ul><p>查看软中断变化情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d <span class="built_in">cat</span> /proc/softirqs</span><br><span class="line">                    CPU0       CPU1</span><br><span class="line">          HI:          0          0</span><br><span class="line">       TIMER:    1083906    2368646</span><br><span class="line">      NET_TX:         53          9</span><br><span class="line">      NET_RX:    1550643    1916776</span><br><span class="line">       BLOCK:          0          0</span><br><span class="line">    IRQ_POLL:          0          0</span><br><span class="line">     TASKLET:     333637       3930</span><br><span class="line">       SCHED:     963675    2293171</span><br><span class="line">     HRTIMER:          0          0</span><br><span class="line">         RCU:    1542111    1590625</span><br></pre></td></tr></table></figure><p>可以发现， TIMER（定时中断）、NET_RX（网络接收）、SCHED（内核调度）、RCU（RCU 锁）等这几个软中断都在不停变化，这些中断是保证 Linux 调度、时钟和临界区保护这些正常工作所必需，变化是正常的。而其中的NET_RX，也就是<strong>网络数据包接收软中断</strong>的变化速率最快</p><p>使用sar工具查看网络收发情况(可以观察网络收发吞吐量和PPS)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -n DEV 表示显示网络收发的报告，间隔1秒输出一组数据</span></span><br><span class="line">$ sar -n DEV 1</span><br><span class="line">15:03:46        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">15:03:47         eth0  12607.00   6304.00    664.86    358.11      0.00      0.00      0.00      0.01</span><br><span class="line">15:03:47      docker0   6302.00  12604.00    270.79    664.66      0.00      0.00      0.00      0.00</span><br><span class="line">15:03:47           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">15:03:47    veth9f6bbcd   6302.00  12604.00    356.95    664.66      0.00      0.00      0.00      0.05</span><br></pre></td></tr></table></figure><p>可以发现：</p><ul><li>对网卡 eth0 来说，每秒接收的网络帧数比较大，达到了 12607，而发送的网络帧数则比较小，只有 6304；每秒接收的千字节数只有 664 KB，而发送的千字节数更小，只有 358 KB。</li><li>docker0 和 veth9f6bbcd 的数据跟 eth0 基本一致，只是发送和接收相反，发送的数据较大而接收的数据较小。这是 Linux 内部网桥转发导致的，暂且不用深究，只要知道这是系统把 eth0 收到的包转发给 Nginx 服务即可</li><li>重点来看 eth0 ：接收的 PPS 比较大，达到 12607，而接收的 BPS 却很小，只有 664 KB。直观来看网络帧应该都是比较小的，664*1024/12607 = 54 字节，说明平均每个网络帧只有 54 字节，这显然是很小的网络帧，也就是所谓的<strong>小包问题</strong></li></ul><p>tcpdump抓取eth0上的包，指定TCP协议和80端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -i eth0 只抓取eth0网卡，-n不解析协议名和主机名</span></span><br><span class="line"><span class="comment"># tcp port 80表示只抓取tcp协议并且端口号为80的网络帧</span></span><br><span class="line">$ tcpdump -i eth0 -n tcp port 80</span><br><span class="line">15:11:32.678966 IP 192.168.0.2.18238 &gt; 192.168.0.30.80: Flags [S], <span class="built_in">seq</span> 458303614, win 512, length 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从 tcpdump 的输出中，你可以发现：</p><ul><li>192.168.0.2.18238 &gt; 192.168.0.30.80  ，表示网络帧从 192.168.0.2 的 18238 端口发送到 192.168.0.30 的 80 端口，也就是从运行 hping3 机器的 18238 端口发送网络帧，目的为 Nginx 所在机器的 80 端口。</li><li>Flags [S] 则表示这是一个 SYN 包</li></ul><p><strong>最后，可以确定这是从192.168.0.2.18238来的SYN FLOOF攻击</strong></p><p>SYN FLOOD 问题最简单的解决方法：从交换机或者硬件防火墙中封掉来源 IP，这样 SYN FLOOD 网络帧就不会发送到服务器中（后面的网络篇再进一步深究）</p><h3 id="套路篇如何迅速分析出cpu的瓶颈在哪里"><a class="markdownIt-Anchor" href="#套路篇如何迅速分析出cpu的瓶颈在哪里"></a> 套路篇：如何迅速分析出CPU的瓶颈在哪里？</h3><h4 id="cpu性能指标"><a class="markdownIt-Anchor" href="#cpu性能指标"></a> CPU性能指标</h4><p>性能指标总览</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image.webp" alt="image.png" /></p><h5 id="cpu使用率"><a class="markdownIt-Anchor" href="#cpu使用率"></a> CPU使用率</h5><p>CPU 使用率描述了非空闲时间占总 CPU 时间的百分比，根据 CPU 上运行任务的不同，又被分为用户 CPU、系统 CPU、等待 I/O CPU、软中断和硬中断等。用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态</p><ul><li>CPU 使用率（nice），表示 CPU 在<strong>用户态</strong>运行的时间百分比。用户 CPU 使用率高，通常说明有<strong>应用程序</strong>比较繁忙。</li><li>系统 CPU 使用率，表示 CPU 在<strong>内核态</strong>运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明<strong>内核</strong>比较繁忙。</li><li>等待 I/O 的 CPU 使用率，通常也称为 <strong>iowait</strong>，表示<strong>等待 I/O</strong> 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互时间比较长。</li><li>软中断和硬中断的 CPU 使用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断。</li><li>除了上面这些，还有在虚拟化环境中会用到的<strong>窃取 CPU 使用率（steal）<strong>和</strong>客户 CPU 使用率（guest）</strong>，分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比。</li></ul><h5 id="平均负载"><a class="markdownIt-Anchor" href="#平均负载"></a> 平均负载</h5><blockquote><p>系统的平均活跃进程数。它反应了系统的整体负载情况，主要包括三个数值，分别指过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。</p><p>理想情况下，平均负载等于逻辑 CPU 个数，这表示每个 CPU 都恰好被充分利用。如果平均负载大于逻辑 CPU 个数，就表示负载比较重了。</p></blockquote><h5 id="进程上下文切换-2"><a class="markdownIt-Anchor" href="#进程上下文切换-2"></a> 进程上下文切换</h5><p>进程上下文切换分为：</p><ol><li>自愿上下文切换</li><li>非自愿上下文切换</li></ol><p><strong>注意</strong>：过多的上下文切换，会将原本运行进程的 CPU 时间，消耗在<strong>寄存器、内核栈以及虚拟内存等数据的保存和恢复</strong>上，缩短进程真正运行的时间，成为性能瓶颈</p><h5 id="cpu缓存命中率"><a class="markdownIt-Anchor" href="#cpu缓存命中率"></a> CPU缓存命中率</h5><p>CPU 缓存的速度介于 CPU 和内存之间，缓存的是<strong>热点的内存数据</strong>。</p><p>如下图，根据不断增长的热点数据，这些缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 常用在单核中， L3 则用在多核中。从 L1 到 L3，三级缓存的大小依次增大，相应的，性能依次降低（当然比内存还是好得多）。而它们的命中率，衡量的是 <strong>CPU 缓存的复用情况</strong>，命中率越高，则表示性能越好。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/aa08816b60e453b52b5fae5e63549e33.webp.webp" alt="img" /></p><h4 id="cpu性能工具"><a class="markdownIt-Anchor" href="#cpu性能工具"></a> CPU性能工具</h4><ul><li>平均负载案例：使用<strong>uptime</strong>查看平均负载，在平均负载升高时，使用<strong>mpstat</strong>和<strong>pidstat</strong>分别观察每个CPU和每个进程CPU的使用情况，找到导致平均负载升高的stress进程</li><li>上下文切换的案例：先使用<strong>vmstat</strong>，查看系统的上下文切换次数和中断次数；然后通过<strong>pidstat</strong>（-w参数）观察进程的自愿上下文切换和非自愿上下文切换；最后通过<strong>vmstat</strong>（-wt参数）查看线程的上下文切换情况，从而找到了线程上下文切换增多的原因是sysbench工具</li><li>进程CPU使用率升高的案例：先使用top找出系统和进程CPU的使用情况，发现了CPU使用率很高的进程php-fpm，再使用perf top找出热点函数sqrt()；如果是Python应用，可以使用profiler工具<strong>pyflame</strong>对指定进程分析（pyflame -p pid --threads -s 检测时间 -r 取样间隔 -o &lt;file.txt&gt;），再通过flamegraph.pl将输出的txt文件转换为*.svg格式的火焰图（./flamegraph.pl prof.txt &gt; prof.svg）</li><li>不可中断进程和僵尸进程的案例：<ul><li>不可中断进程分析过程：先使用top查看，发现存在D状态（不可中断休眠进程）和Z状态（僵尸进程），并且iowait较高；使用<strong>dstat</strong>分析磁盘I/O，发现<strong>app</strong>进程有大量的磁盘读请求；使用<strong>pidstat</strong>(-d -p 参数)分析app进程的I/O操作，发现没有大量的I/O操作，再用pidstat -d分析系统的I/O情况，发现还是app进程在进行磁盘读；再使用<strong>strace</strong>跟踪D状态进程对应进程号的系统调用，发现没有权限；ps查看发现对应进程号的进程已经变成僵尸进程；之后，通过perf record -g和perf report生成报告，查看app进程的调用栈，发现CPU使用主要是在sys_read()函数，定位到是在对磁盘进行直接读（direct_IO）；查看代码发现open()系统调用使用了O_DIRECT参数</li><li>僵尸进程分析：使用pstree命令找出僵尸进程的父进程是app进程，然后查看app.c文件，发现wait()使用位置不当导致不能回收子进程</li></ul></li><li>软中断的案例：先使用top查看系统指标，发现系统CPU使用率很低，但是主要是在软中断si上，然后查看/proc/softirqs查看系统软中断变化情况，发现NET_RX变化率很快，再使用sar工具查看系统的网络收发情况，发现eth0网卡接收到了大量的小包；在通过抓包工具tcpdump，发现eth0接受到了大量的SYN包，最终确定了是SYN FLOOD攻击</li></ul><h5 id="性能指标找工具"><a class="markdownIt-Anchor" href="#性能指标找工具"></a> 性能指标找工具</h5><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/202406012245720.webp" alt="image.png" /></p><h5 id="工具找指标"><a class="markdownIt-Anchor" href="#工具找指标"></a> 工具找指标</h5><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/202406012244925.webp" alt="image.png" /></p><h4 id="如何分析cpu的性能瓶颈"><a class="markdownIt-Anchor" href="#如何分析cpu的性能瓶颈"></a> 如何分析CPU的性能瓶颈</h4><p><strong>重点</strong>：弄清楚性能指标之间的关联性</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/202406012244017.webp" alt="image.png" /></p><h3 id="cpu性能优化的几个思路"><a class="markdownIt-Anchor" href="#cpu性能优化的几个思路"></a> CPU性能优化的几个思路</h3><h4 id="性能优化方法论"><a class="markdownIt-Anchor" href="#性能优化方法论"></a> 性能优化方法论</h4><p>确定三个问题：</p><ul><li>判断所做的性能优化是否有效？优化后，能提升多少性能，有多少收益？</li><li>如果有多个性能问题同时存在，应该先优化哪一个？</li><li>当有多种优化的方法，应该选择哪一种？</li></ul><h5 id="怎么评估性能优化的效果"><a class="markdownIt-Anchor" href="#怎么评估性能优化的效果"></a> 怎么评估性能优化的效果</h5><p><strong>三步走</strong>的原则：</p><ol><li>确定性能的量化指标</li><li>测试优化前的性能指标</li><li>测试优化后的性能指标</li></ol><p><strong>第一步</strong>，性能的量化指标包括CPU使用率、应用的吞吐量、响应时间等等，<strong>不要局限在单一维度的指标上</strong>。例如，以Web应用为例：</p><ul><li>应用程序的维度，使用<strong>吞吐量和请求延时</strong>来评估</li><li>系统资源的维度，使用<strong>CPU使用率</strong>来评估</li></ul><p>好的应用程序是性能优化的最终结果和目的，要使用应用程序的指标，来评估性能优化的整体效果；而系统资源的使用情况是影响应用程序的根源，需要用资源的指标，来分析应用性能的瓶颈来源</p><p><strong>第二三步</strong>，对比第一步确定的<strong>量化指标</strong>在优化前后的差距，拿数据说话。例如，使用ab工具测试Web应用的并发请求数和响应延时，同时使用vmstat,pidstat等工具，观察系统和进程的CPU使用率，同时获得了应用和系统两个维度的性能指标</p><p><strong>进行性能测试需要注意的是</strong>：</p><ul><li>要避免性能测试工具干扰应用程序的性能</li><li>避免外部环境的变化影响性能指标的评估。在优化前、后的应用程序，都运行在相同配置的机器上，并且它们的外部依赖也要完全一致</li></ul><h5 id="多个性能问题同时存在怎么选择"><a class="markdownIt-Anchor" href="#多个性能问题同时存在怎么选择"></a> 多个性能问题同时存在，怎么选择？</h5><p>遵循<strong>二八原则</strong>，80%的性能问题都是由于20%的代码导致的，<strong>并不是所有的性能问题都值得优化</strong></p><p>分析的步骤：</p><ul><li>挨个分析出所有的性能瓶颈，排除掉有因果关系的性能问题</li><li>在剩下的几个性能问题中，选择能明显提升应用性能的问题进行修复，有两种方法：<ul><li>如果系统资源出现瓶颈，首先优化系统资源使用的问题</li><li>针对不同类型的指标，，首先优化导致<strong>性能指标变化幅度最大</strong>的那些瓶颈问题</li></ul></li></ul><h5 id="有多种优化方法时如何选择"><a class="markdownIt-Anchor" href="#有多种优化方法时如何选择"></a> 有多种优化方法时，如何选择？</h5><p><strong>性能优化并非没有成本</strong>。</p><p>一个很典型的例子网络中的 DPDK（Data Plane Development Kit）。DPDK 是一种优化网络处理速度的方法，它通过绕开内核网络协议栈的方法，提升网络的处理能力。不过它有一个很典型的要求，就是要<strong>独占一个 CPU 以及一定数量的内存大页</strong>，并且总是以 100% 的 CPU 使用率运行。所以，如果你的 CPU 核数很少，就有点得不偿失了。</p><p>因此，在考虑性能优化方法时，要结合实际情况，考虑多方面的因素，进行权衡在做选择</p><h4 id="cpu优化"><a class="markdownIt-Anchor" href="#cpu优化"></a> CPU优化</h4><h5 id="应用程序优化"><a class="markdownIt-Anchor" href="#应用程序优化"></a> 应用程序优化</h5><p>常见的几种优化方法：</p><ul><li><strong>编译器优化</strong>：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如， gcc 就提供了优化选项 -O2，开启后会自动对应用程序的代码进行优化。</li><li><strong>算法优化</strong>：使用复杂度更低的算法，显著加快处理速度</li><li><strong>异步处理</strong>：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题。</li><li><strong>多线程代替多进程</strong>：前面讲过，相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本。</li><li><strong>善用缓存</strong>：经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度。</li></ul><h5 id="系统优化"><a class="markdownIt-Anchor" href="#系统优化"></a> 系统优化</h5><p>常见的系统优化方法：</p><ul><li><strong>CPU 绑定</strong>：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题</li><li><strong>CPU 独占</strong>：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU</li><li><strong>优先级调整</strong>：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。可以适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理</li><li><strong>为进程设置资源限制</strong>：使用 Linux cgroups  来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。</li><li><strong>NUMA（Non-Uniform Memory Access）优化</strong>：支持 NUMA 的处理器会将内存划分为多个 node，每个 node 关联到系统的一个处理器。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存。</li><li><strong>中断负载均衡</strong>：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把<strong>中断处理过程自动负载均衡到多个 CPU 上</strong>。</li></ul><h5 id="避免过早优化"><a class="markdownIt-Anchor" href="#避免过早优化"></a> 避免过早优化</h5><p>性能优化最好是<strong>逐步完善，动态进行，不追求一步到位</strong>，而要<strong>首先保证能满足当前的性能要求</strong>。当发现性能不满足要求或者出现性能瓶颈时，再根据性能评估的结果，选择最重要的性能问题进行优化</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p><strong>要忍住“把 CPU 性能优化到极致”的冲动</strong>，因为 CPU 并不是唯一的性能因素，还会有其他的性能问题，比如内存、网络、I/O 甚至是架构设计的问题。</p><p>如果不做全方位的分析和测试，只是单纯地把某个指标提升到极致，并不一定能带来整体的收益。</p>]]></content>
    
    
    <summary type="html">记录关于Linux CPU性能调试的白皮书</summary>
    
    
    
    <category term="SnowMoonの嵌入式笔记" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式Linux" scheme="https://www.snowmoon.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    <category term="Linux" scheme="https://www.snowmoon.top/tags/Linux/"/>
    
    <category term="CPU" scheme="https://www.snowmoon.top/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>Git操作学习——从一个可视化的git练习网站说起</title>
    <link href="https://www.snowmoon.top/2023/12/27/Git%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84git%E7%BB%83%E4%B9%A0%E7%BD%91%E7%AB%99%E8%AF%B4%E8%B5%B7/"/>
    <id>https://www.snowmoon.top/2023/12/27/Git%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84git%E7%BB%83%E4%B9%A0%E7%BD%91%E7%AB%99%E8%AF%B4%E8%B5%B7/</id>
    <published>2023-12-27T13:50:21.000Z</published>
    <updated>2024-06-01T15:16:05.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>自以为自己已经学会了使用git，但是当我被分配了大量的bug需要修复并且大量使用git时才知道自己的git的掌握程度有多菜，因此回家开始补习git的操作了。</p><p>最好的练习方式自然是能够可视化的进行练习，因此我找到了一个进行可视化练习git操作的网站<a href="https://learngitbranching.js.org/?locale=zh_CN">Learngitbranching</a>来学习git相关的操作，本文为学习的记录，以便后续查询使用。</p><h1 id="git-本地操作"><a class="markdownIt-Anchor" href="#git-本地操作"></a> Git 本地操作</h1><h2 id="git-commit提交更改"><a class="markdownIt-Anchor" href="#git-commit提交更改"></a> git commit——提交更改</h2><p><code>git commit</code> 主要是用于记录下各种修改的历史记录，<code>git commit</code> 的提交记录类似文件快照，但做的非常轻量化。</p><p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p><p>进行<code>git commit</code>的时候，他会将你add过的文件进行提交，每次提交会检查当前目录下所有跟踪的文件是否发生了变化，如果有则会提醒你进行add，在所有跟踪了的文件都add了以后，Git会保存add了的文件与上次提交间的差异，并要求你输入一定的commit message。</p><h2 id="git-branch新建分支"><a class="markdownIt-Anchor" href="#git-branch新建分支"></a> git branch——新建分支</h2><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">早建分支！多用分支！</span><br></pre></td></tr></table></figure><p>这是因为<strong>即使创建再多的分支也不会造成储存或内存上的开销</strong>，因为分支只是相当于新建了个指向当前提交的指针而已，并不会复制任何文件，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p><p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：<strong>“我想基于这个提交以及它所有的 parent 提交进行新的工作。”</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch NewBranch</span><br></pre></td></tr></table></figure><p>这个语句仅仅相当于新建一个名为NewBranch的分支，指向目前最新的一个提交。</p><p>分支相关的操作如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建分支</span><br><span class="line">git branch newImage</span><br><span class="line">git commit</span><br><span class="line">// 切换分支</span><br><span class="line">git checkout newImage</span><br><span class="line">git commit</span><br><span class="line">// 创建并切换分支</span><br><span class="line">git checkout -b bugFix</span><br></pre></td></tr></table></figure><h2 id="git-merge合并分支"><a class="markdownIt-Anchor" href="#git-merge合并分支"></a> git merge——合并分支</h2><p>使用 <code>git merge</code>在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent 节点。翻译成自然语言相当于：“我要把这两个 parent 节点本身及它们所有的祖先都包含进来。</p><p>当目前工作区中没有未提交的更改并且不产生冲突时，<code>git merge bugFix</code>操作会将下图的C2、C3提交合并到一起并产生一个新提交C4</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227222857591.png" alt="image-20231227222857591" /></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227223357594.png" alt="image-20231227223357594" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 当前分支与目标分支合并</span><br><span class="line">git merge bugFix</span><br><span class="line">git checkout bugFix</span><br><span class="line">git merge main</span><br><span class="line">// 由于 main 的一个父节点是 bugFix</span><br><span class="line">// 换句话说，main 继承自 bugFix</span><br><span class="line">// 所以 Git 什么也没做</span><br></pre></td></tr></table></figure><p>由于<code>git merge</code>会在本地产生一个merge的提交，而一般远程不会允许普通开发者进行merge操作，故我们在本地进行开发时一般不适用merge操作，更常用的是rabase操作</p><h2 id="git-rebase分支合并方法之二"><a class="markdownIt-Anchor" href="#git-rebase分支合并方法之二"></a> git rebase——分支合并方法之二</h2><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227233048032.png" alt="image-20231227233048032" /></p><p>执行<code>git rebase main</code>后得到下图所示提交情况</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227233139759.png" alt="image-20231227233139759" /></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227233250524.png" alt="image-20231227233250524" /></p><p>rebase 第二个参数是要移动的源分支，如果不提供默认为 HEAD。如果当前分支不在源分支上，使用第二个参数可以节省一次 checkout 动作。</p><h2 id="在提交树上移动"><a class="markdownIt-Anchor" href="#在提交树上移动"></a> 在提交树上移动</h2><p>HEAD：你目前正在工作的提交记录，一般指向当前分支的最近一次提交记录，但有时候checkout或者别的原因也可能导致头指针和工作的分支分离，需要查看<code>HEAD</code>的指向可以使用使用<code>cat .git/HEAD</code>命令或者直接使用<code>git branch</code>指令</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101162004970.png" alt="image-20240101162004970" /></p><p><code>git checkout hashnumber</code>指令的作用即为将目前的头指针指向hashnumber对应的提交，也即执行<code>git checkout C1</code>后，头指针会从main上分离，变为下图的状态</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101162117892.png" alt="image-20240101162117892" /></p><h3 id="相对引用~"><a class="markdownIt-Anchor" href="#相对引用~"></a> 相对引用(^)(~)</h3><p>Git中提供了一些操作符来引用提交，这样便于我们进行快速的移动头指针而不用随时都列出当前工作区的log来checkout过去。相对引用非常给力，这里我介绍两个简单的用法：</p><ul><li>使用 <code>^</code> 向上移动 1 个提交记录</li><li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li></ul><p>首先看看操作符 (^)。把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的 parent 提交。</p><p>所以 <code>main^</code> 相当于“<code>main</code> 的 parent 节点”，<code>main^^</code> 是 <code>main</code> 的第二个 parent 节点。我们也可以将 <code>HEAD</code> 作为相对引用的参照，将头指针相对自己往上移动一定的位置。</p><p>如果你想在提交树中向上移动很多步的话，敲那么多 <code>^</code> 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 <code>~</code>。</p><p>该操作符后面可以跟一个数字（可选，不跟数字时与 <code>^</code> 相同，向上移动一次），指定向上移动多少次。</p><h3 id="git-branch-f-强制修改分支位置"><a class="markdownIt-Anchor" href="#git-branch-f-强制修改分支位置"></a> git branch -f 强制修改分支位置</h3><p>我使用相对引用最多的就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交。例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -f main HEAD~3</span><br></pre></td></tr></table></figure><p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级 parent 提交。</p><p>也可以直接使用绝对引用，将分支切换到某个特定提交，但是在切换前一般会要保存工作区的内容，并且移动有时候也会有比较多的冲突之类的问题因此需要最好不要将该分支直接移动到另外的分支中某个与要移动的分支不重合的提交前，也即对于下图而言最好不用使用如下命令，建议多建分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -f main C3</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101163648382.png" alt="image-20240101163648382" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 查看日志</span><br><span class="line">git log</span><br><span class="line">// 找到 main 的父节点</span><br><span class="line">git checkout main^</span><br><span class="line">// 找到 HEAD 的父节点</span><br><span class="line">git checkout HEAD^</span><br><span class="line">// 让 main 分支指向 HEAD 的第三级父提交节点</span><br><span class="line">// 可以说，git branch -f 和 git branch 内容都不一样</span><br><span class="line">// git branch 是创建分支，而 git branch -f 是改变分支指向提交节点</span><br><span class="line">git branch -f main HEAD~3</span><br><span class="line">// 注意，不能写 git branch -f HEAD HEAD^，因为没有这个分支</span><br><span class="line">// 只能用 checkout 调整 HEAD</span><br><span class="line">git checkout HEAD^</span><br></pre></td></tr></table></figure><h2 id="撤销变更"><a class="markdownIt-Anchor" href="#撤销变更"></a> 撤销变更</h2><p>可以通过 Reset 和 Revert 撤销变更。</p><h3 id="git-reset"><a class="markdownIt-Anchor" href="#git-reset"></a> git reset</h3><p>Reset 相当于撤销历史。通过它可以回退本地的提交节点。但是无法处理远程分支。</p><p>Revert 用于撤销远程提交。这个过程引入了新的提交节点，因为这个节点做的事情是撤销上个提交节点的内容，所以和上上个节点的内容是一样的。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101164209093.png" alt="image-20240101164209093" /></p><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><h3 id="git-revert"><a class="markdownIt-Anchor" href="#git-revert"></a> git revert</h3><p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p><p>在我们输入指令git revert C2后要撤销的提交记录后面多了一个新提交！这是因为新提交记录 <code>C2'</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2'</code> 的状态与 <code>C1</code> 是相同的。</p><p>revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101164931457.png" alt="image-20240101164931457" /></p><p>PS：事实上，我们在本地使用revert撤销提交一般较少，为了保证更清晰的提交线，我们一般是<strong>在云端进行revert</strong>，本地如果要对上一次修改进行重新修改的话直接<code>git commit --amend</code>就行，对于云端已merge的提交要再次进行修改，最好的做法是<strong>提交一个新的提交来修复上次提交存在的问题而不是revert</strong>，因为当你reverse 再commit后就会存在两个提交需要审核再合入，因此会多一个提交的审核量，所以更建议使用新提交来修复</p><h2 id="变更提交顺序"><a class="markdownIt-Anchor" href="#变更提交顺序"></a> 变更提交顺序</h2><h3 id="git-cherry-pick"><a class="markdownIt-Anchor" href="#git-cherry-pick"></a> git cherry-pick</h3><p>Cherry-pick 可以用于将指定提交节点复制到 <code>HEAD</code> 分支上，它的命令的格式如下</p><p><code>git cherry-pick &lt;提交号&gt;...</code></p><p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。</p><p>PS：如果你cherry-pick的是一个云端的未合并的提交，你在本地进行开发后再提交会将这个未合并的提交再commit一遍，这个提交的uploader就变成你了</p><h3 id="交互式rebase"><a class="markdownIt-Anchor" href="#交互式rebase"></a> 交互式rebase</h3><p>当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p><p>但是如果你不清楚你想要的提交记录的哈希值呢? 或者你想要再修改前面的提交呢？幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p><p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p><p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p><p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。</p><p>下图为我的博客中使用指令<code>git rebase -i HEAD~2</code>得到的交互式指令界面，我们要调整提交的顺序就可以通过这里pick的顺序来修改，其他的指令如下图所示。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103214804407.png" alt="image-20240103214804407" /></p><ul><li><p>pick：保留该 commit</p></li><li><p>reword：保留该 commit，但我需要修改该 commit 的注释</p></li><li><p>edit：保留该 commit，但我要停下来修改该提交（不禁惊修改注释）</p></li><li><p>squash：将该 commit 和前一个 commit 合并</p></li><li><p>fixup：将该 commit 和前一个 commit 合并，但我不要保留该提交的注释信息</p></li><li><p>exec：执行 shell 命令</p></li><li><p>drop：我要丢弃该 commit</p></li></ul><p>当 rebase UI界面打开时, 你能做3件事:</p><ul><li>调整提交记录的顺序（通过鼠标拖放来完成）</li><li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li><li>合并提交。 它允许你把多个提交记录合并成一个。</li></ul><h2 id="一些技巧"><a class="markdownIt-Anchor" href="#一些技巧"></a> 一些技巧</h2><h3 id="截取单次提交"><a class="markdownIt-Anchor" href="#截取单次提交"></a> 截取单次提交</h3><p>来看两个在开发中经常会遇到的情况：</p><p>1.我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息，这些调试和打印语句都在它们各自的提交记录里，最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p><p>最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>main</code> 分支上，但这样的话 <code>main</code> 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用<code>git rebase -i</code> <code>git cherry-pick</code>来达到目的。</p><p>使用<code>git rebase -i</code>时将某几个提交放弃，就会只保留最新的提交</p><p>在原分支<code>cherry-pick</code>某个提交即可只保留该提交</p><p>2.当我们一次性提交了5个提交，后三个提交已经merge，而第二个提交需要有新的修改时</p><p>我们就可以使用<code>git rebase -i HEAD~4</code>指令，然后将顶部的我们要修改的提交改为edit状态，然后修改后使用<code>git add</code>+<code>git commit --amend</code>再使用<code>git rebase --continue</code>回到最新的工作区</p><h3 id="提交的技巧"><a class="markdownIt-Anchor" href="#提交的技巧"></a> 提交的技巧</h3><h4 id="git-rebase"><a class="markdownIt-Anchor" href="#git-rebase"></a> git rebase</h4><p>接下来这种情况也是很常见的：你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，然后又提交了一次。</p><p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p><p>我们可以通过下面的方法来克服困难：</p><ol><li>用 git rebase -i 将提交重新排序，然后把我们想要修改的提交记录挪到最前</li><li>用 git commit --amend 来进行一些小修改</li><li>用 git rebase -i 来将他们调回原来的顺序</li><li>把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li></ol><p>或者觉得调整顺序麻烦的话，我们也可以按下列步骤修改</p><ol><li>用 git rebase -i 打开交互界面，将我们要修改的提交状态改为edit</li><li>修改然后使用git add 和 git commit --amend的连招</li><li>使用git rebase --continue将当前指针移动到最前，大功告成</li></ol><h4 id="git-cherry-pick-2"><a class="markdownIt-Anchor" href="#git-cherry-pick-2"></a> git cherry-pick</h4><p>我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p><p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。</p><p>使用<code>git cherry-pick</code> 就可以避免一些这些问题，我们使用<code>cherry-pick</code>时会把某个分支上的某个提交拉到我们当前分支的最新提交处，为避免本地和云端冲突，比较好的做法是使用一个Develop分支来作为与云端保持同步的分支，当我们需要cherry-pick某个关系比较复杂的提交时，我们就可以先checkout到这个Develop分支来使用git pull拉取最新的代码，然后再使用git checkout -b bugFix建立一个bugFix分支来进行我们的修改，此时我们就可以在bugFix这个分支上使用<code>cherry-pick</code>拉取要修改的那个提交到最新当前分支处，修改然后使用git add 和 git commit --amend的连招，此时就可以进行push而不存在冲突了</p><h4 id="git-tag"><a class="markdownIt-Anchor" href="#git-tag"></a> git tag</h4><p>分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p><p>你可能会问了：有没有什么可以<em>永远</em>指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p><p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p><p>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103224553317.png" alt="image-20240103224553317" /></p><h4 id="git-describe"><a class="markdownIt-Anchor" href="#git-describe"></a> git describe</h4><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p><p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p><p><code>git describe</code> 的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会使用你目前所在的位置（<code>HEAD</code>）。</p><p>它输出的结果是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</span><br></pre></td></tr></table></figure><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p><p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103224657939.png" alt="image-20240103224657939" /></p><h2 id="多分支rebase"><a class="markdownIt-Anchor" href="#多分支rebase"></a> 多分支rebase</h2><p><code>git rebase side2 side1</code>操作会将当前side1的所有和side2有分支差异且可合并的提交合并到side2的提交上并将HEAD移动到side1上</p><h2 id="选择-parent-提交记录"><a class="markdownIt-Anchor" href="#选择-parent-提交记录"></a> 选择 parent 提交记录</h2><p>操作符 <code>^</code> 与 <code>~</code> 符一样，后面也可以跟一个数字。</p><p>但是该操作符后面的数字与 <code>~</code> 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个 parent 提交。还记得前面提到过的一个合并提交有两个 parent 提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p><p>Git 默认选择合并提交的“第一个” parent 提交，在操作符 <code>^</code> 后跟一个数字可以改变这一默认行为。</p><h2 id="纠缠不清的分支"><a class="markdownIt-Anchor" href="#纠缠不清的分支"></a> 纠缠不清的分支</h2><p>现在我们的 <code>main</code> 分支是比 <code>one</code>、<code>two</code> 和 <code>three</code> 要多几个提交。出于某种原因，我们需要把 <code>main</code> 分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。</p><p><code>one</code> 需要重新排序并删除 <code>C5</code>，<code>two</code> 仅需要重排排序，而 <code>three</code> 只需要提交一次。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103230610668.png" alt="image-20240103230610668" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout one</span><br><span class="line">git cherry-pick C4 C3 C2</span><br><span class="line">git checkout two</span><br><span class="line">git cherry-pick C5 C4 C3 C2</span><br><span class="line">git branch -f three C2</span><br></pre></td></tr></table></figure><h1 id="git-云端仓库"><a class="markdownIt-Anchor" href="#git-云端仓库"></a> Git 云端仓库</h1><h2 id="远程仓库"><a class="markdownIt-Anchor" href="#远程仓库"></a> 远程仓库</h2><p>远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录</p><p>话虽如此, 远程仓库却有一系列强大的特性</p><ul><li>首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</li><li>还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</li></ul><p>现在用网站来对远程仓库进行可视化操作变得越发流行了(像 <a href="https://github.com/">GitHub</a>), 但远程仓库<strong>永远</strong>是这些工具的顶梁柱, 因此理解其概念非常的重要!</p><p>我们现在需要学习远程仓库的操作 —— 我们需要一个配置这种环境的命令, 它就是 <code>git clone</code>。 从技术上来讲，<code>git clone</code> 命令在真实的环境下的作用是在<strong>本地</strong>创建一个远程仓库的拷贝（比如从 <a href="http://github.com">github.com</a>）。</p><p>使用<code>git clone</code> 命令完成对远程仓库和本地仓库的建立，咱们深入地看一下发生了什么。</p><p>你可能注意到的第一个事就是在我们的本地仓库多了一个名为 <code>origin/main</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。由于远程分支的特性导致其拥有一些特殊属性。</p><p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p><p>远程分支有一个特别的属性，在你切换到远程分支时，自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p><p><strong>为什么有 <code>origin/</code>？</strong></p><p>你可能想问这些远程分支的前面的 <code>origin/</code> 是什么意思呢？远程分支有一个命名规范 —— 它们的格式是:</p><ul><li><code>&lt;remote name&gt;/&lt;branch name&gt;</code></li></ul><p>因此，如果你看到一个名为 <code>origin/main</code> 的分支，那么这个分支就叫 <code>main</code>，远程仓库的名称就是 <code>origin</code>。</p><p>大多数的开发人员会将它们主要的远程仓库命名为 <code>origin</code>，这是因为当你用 <code>git clone</code> 某个仓库时，Git 已经帮你把远程仓库的名称设置为 <code>origin</code> 了</p><p>如果切换到远程分支会怎么样呢？</p><p>Git 变成了分离 HEAD 状态，当添加新的提交时 <code>o/main</code> 也不会更新。这是因为 <code>o/main</code> 只有在远程仓库中相应的分支更新了以后才会更新。</p><h2 id="git-fetch"><a class="markdownIt-Anchor" href="#git-fetch"></a> Git Fetch</h2><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p><p>本节课我们将学习如何从远程仓库获取数据 —— 命令如其名，它就是 <code>git fetch</code>。</p><p>你会看到当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103231358387.png" alt="image-20240103231358387" /></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103231413367.png" alt="image-20240103231413367" /></p><h3 id="git-fetch-做了些什么"><a class="markdownIt-Anchor" href="#git-fetch-做了些什么"></a> git fetch 做了些什么</h3><p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>o/main</code>)</li></ul><p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p><p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你<strong>最后一次与它通信时</strong>的状态，<code>git fetch</code> 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 <code>git fetch</code> 与远程分支之间的关系了吧。</p><p><code>git fetch</code> 通常通过互联网（使用 <code>http://</code> 或 <code>git://</code> 协议) 与远程仓库通信。</p><h3 id="git-fetch-不会做的事"><a class="markdownIt-Anchor" href="#git-fetch-不会做的事"></a> git fetch 不会做的事</h3><p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p><p>理解这一点很重要，因为许多开发人员误以为执行了 <code>git fetch</code> 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令 😄</p><p>所以, 你可以将 <code>git fetch</code> 的理解为单纯的下载操作。</p><h2 id="git-pull"><a class="markdownIt-Anchor" href="#git-pull"></a> Git Pull</h2><p>既然我们已经知道了如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p><ul><li><code>git cherry-pick o/main</code></li><li><code>git rebase o/main</code></li><li><code>git merge o/main</code></li><li>等等</li></ul><p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103231614317.png" alt="image-20240103231614317" /></p><p>事实上，<code>git pull</code> 就是 git fetch 和 git merge 的缩写！</p><h2 id="git-push"><a class="markdownIt-Anchor" href="#git-push"></a> Git Push</h2><p><code>git push</code> 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 <code>git push</code> 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p><p>你可以将 <code>git push</code> 想象成发布你成果的命令。它有许多应用技巧，稍后我们会了解到，但是咱们还是先从基础的开始吧……</p><p><em>注意 —— <code>git push</code> 不带任何参数时的行为与 Git 的一个名为 <code>push.default</code> 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 <code>upstream</code>。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。</em></p><h2 id="偏离的工作"><a class="markdownIt-Anchor" href="#偏离的工作"></a> 偏离的工作</h2><p>现在我们已经知道了如何从其它地方 <code>pull</code> 提交记录，以及如何 <code>push</code> 我们自己的变更。看起来似乎没什么难度，但是为何还会让人们如此困惑呢？</p><p>困难来自于远程库提交历史的<strong>偏离</strong>。在讨论这个问题的细节前，我们先来看一个例子……</p><p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目<strong>旧版</strong>的代码，与远程仓库最新的代码不匹配了。</p><p>这种情况下, <code>git push</code> 就不知道该如何操作了。如果你执行 <code>git push</code>，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p><p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 <code>push</code> 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103232357772.png" alt="image-20240103232357772" /></p><p>那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。</p><p>有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。咱们继续，看看怎么 rebase！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase o/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103232635349.png" alt="image-20240103232635349" /></p><p>还有其它的方法可以在远程仓库变更了以后更新我的工作吗? 当然有，我们还可以使用 <code>merge</code></p><p>尽管 <code>git merge</code> 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。</p><p>看下演示…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git merge o/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103232746342.png" alt="image-20240103232746342" /></p><p>事实上，因为merge会多一个单独的C4的提交，对于公司的开发而言，有很多需要审核的地方， 所以不要添加这个merge的提交，最好的方式就是rebase。</p><p>很好！但是要敲那么多命令，有没有更简单一点的？</p><p>当然 —— 前面已经介绍过 <code>git pull</code> 就是 fetch 和 merge 的简写，类似的 <code>git pull --rebase</code> 就是 fetch 和 rebase 的简写！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebae</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103232949536.png" alt="image-20240103232949536" /></p><h2 id="远程服务器拒绝remote-rejected"><a class="markdownIt-Anchor" href="#远程服务器拒绝remote-rejected"></a> 远程服务器拒绝!(Remote Rejected)</h2><p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</span><br></pre></td></tr></table></figure><p><strong>为什么会被拒绝?</strong></p><p>远程服务器拒绝直接推送(push)提交到main, 因为策略配置要求 pull requests 来提交更新.</p><p>你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新.</p><h2 id="合并特性分支"><a class="markdownIt-Anchor" href="#合并特性分支"></a> 合并特性分支</h2><p>既然你应该很熟悉 fetch、pull、push 了，现在我们要通过一个新的工作流来测试你的这些技能。</p><p>在大型项目中开发人员通常会在（从 <code>main</code> 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.</p><p>但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。</p><p>对于接下来这个工作流，我们集成了两个步骤：</p><ul><li>将特性分支集成到 <code>main</code> 上</li><li>推送并更新远程分支</li></ul><p><strong>接下来的关卡建议全部都到网站实操一下，能学到很多</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase o/main side1</span><br><span class="line">git rebase side1 side2</span><br><span class="line">git rebase side2 side3</span><br><span class="line">git rebase side3 main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103233859300.png" alt="image-20240103233859300" /></p><h2 id="为什么不用-merge-呢"><a class="markdownIt-Anchor" href="#为什么不用-merge-呢"></a> 为什么不用 merge 呢?</h2><p>为了 push 新变更到远程仓库，你要做的就是<strong>包含</strong>远程仓库中最新变更。意思就是只要你的本地分支包含了远程分支（如 <code>o/main</code>）中的最新变更就可以了，至于具体是用 rebase 还是 merge，并没有限制。</p><p>那么既然没有规定限制，为何前面几节都在着重于 rebase 呢？为什么在操作远程分支时不喜欢用 <code>merge</code> 呢</p><p>在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：</p><p>优点:</p><ul><li>Rebase 使你的提交树变得很干净, 所有的提交都在一条线上</li></ul><p>缺点:</p><ul><li>Rebase 修改了提交树的历史</li></ul><p>比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。</p><p>一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 😄</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103234212700.png" alt="image-20240103234212700" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull</span><br><span class="line">git merge side1</span><br><span class="line">git merge side2</span><br><span class="line">git merge side3</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="远程跟踪分支"><a class="markdownIt-Anchor" href="#远程跟踪分支"></a> 远程跟踪分支</h3><p>在前几节课程中有件事儿挺神奇的，Git 好像知道 <code>main</code> 与 <code>o/main</code> 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：</p><ul><li>pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。</li><li>push 操作时, 我们把工作从 <code>main</code> 推到远程仓库中的 <code>main</code> 分支(同时会更新远程分支 <code>o/main</code>) 。这个推送的目的地也是由这种关联确定的！</li></ul><p>直接了当地讲，<code>main</code> 和 <code>o/main</code> 的关联关系就是<strong>由分支的“remote tracking”属性决定</strong>的。<code>main</code> 被设定为跟踪 <code>o/main</code> —— 这意味着为 <code>main</code> 分支指定了推送的目的地以及拉取后合并的目标。</p><p>你可能想知道 <code>main</code> 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, <strong>当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了</strong>。</p><p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 <code>o/main</code>）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 <code>main</code>。</p><p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p><p>这也解释了为什么会在克隆的时候会看到下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local branch &quot;main&quot; set to track remote branch &quot;o/main&quot;</span><br></pre></td></tr></table></figure><p><strong>我能自己指定这个属性吗？</strong></p><p>当然可以啦！你可以让任意分支跟踪 <code>o/main</code>, 然后该分支会像 <code>main</code> 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 <code>totallyNotMain</code> 上执行 <code>git push</code>，将工作推送到远程仓库的 <code>main</code> 分支上。</p><p>有两种方法设置这个属性，第一种就是通过远程分支切换到一个新的分支，执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b totallyNotMain o/main</span><br></pre></td></tr></table></figure><p>就可以创建一个名为 <code>totallyNotMain</code> 的分支，它跟踪远程分支 <code>o/main</code><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103234641248.png" alt="image-20240103234641248" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b foo o/main</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>git push 同样适用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b foo o/main</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>我们将一个并不叫 <code>main</code> 的分支上的工作推送到了远程仓库中的 <code>main</code> 分支上</p><p><strong>第二种方法</strong></p><p>另一种设置远程追踪分支的方法就是使用：<code>git branch -u</code> 命令，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o/main foo</span><br></pre></td></tr></table></figure><p>这样 <code>foo</code> 就会跟踪 <code>o/main</code> 了。如果当前就在 foo 分支上, 还可以省略 foo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o/main</span><br></pre></td></tr></table></figure><h2 id="git-push-的参数"><a class="markdownIt-Anchor" href="#git-push-的参数"></a> Git Push 的参数</h2><p>很好! 既然你知道了远程跟踪分支，我们可以开始揭开 git push、fetch 和 pull 的神秘面纱了。我们会逐个介绍这几个命令，它们在理念上是非常相似的。</p><p>首先来看 <code>git push</code>。在远程跟踪课程中，你已经学到了 Git 是通过当前所在分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;place&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;place&gt;</code> 参数是什么意思呢？我们稍后会深入其中的细节, 先看看例子, 这个命令是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>把这个命令翻译过来就是：</p><p><strong>切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</strong></p><p>我们通过<code>&lt;place&gt;</code>参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。</p><p>需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所切换分支的属性！</p><h2 id="place参数详解"><a class="markdownIt-Anchor" href="#place参数详解"></a> <code>&lt;place&gt;</code>参数详解</h2><p>还记得之前课程说的吧，当为 git push 指定 place 参数为 <code>main</code> 时，我们同时指定了提交记录的来源和去向。</p><p>你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 <code>foo</code> 分支推送到远程仓库中的 <code>bar</code> 分支。</p><p>哎，很遗憾 Git 做不到…… 开个玩笑，别当真！当然是可以的啦 😃 Git 拥有超强的灵活性（有点过于灵活了）</p><p>接下来咱们看看是怎么做的……</p><p>要同时为源和目的地指定 <code>&lt;place&gt;</code> 的话，只需要用冒号 <code>:</code> 将二者连起来就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;source&gt;:&lt;destination&gt;</span><br></pre></td></tr></table></figure><p>这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 <code>foo</code> 或者 <code>HEAD~1</code>）</p><p>一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了，让我们看看演示！</p><p>记住，<code>source</code> 可以是任何 Git 能识别的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin foo^:main</span><br></pre></td></tr></table></figure><p>这是个令人困惑的命令，但是它确实是可以运行的 —— Git 将 <code>foo^</code> 解析为一个位置，上传所有未被包含到远程仓库里 <code>main</code> 分支中的提交记录。</p><p>如果你要推送到的目的分支不存在会怎么样呢？没问题！<strong>Git 会在远程仓库中根据你提供的名称帮你创建这个分支！</strong></p><h2 id="git-fetch-的参数"><a class="markdownIt-Anchor" href="#git-fetch-的参数"></a> Git fetch 的参数</h2><p>我们刚学习了 git push 的参数，很酷的 <code>&lt;place&gt;</code> 参数，还有用冒号分隔的 refspecs（<code>&lt;source&gt;:&lt;destination&gt;</code>）。 这些参数可以用于 <code>git fetch</code> 吗？</p><p>你猜中了！<code>git fetch</code> 的参数和 <code>git push</code> 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）</p><p>让我们逐个讨论下这些概念……</p><h3 id="place-参数"><a class="markdownIt-Anchor" href="#place-参数"></a> <code>&lt;place&gt;</code> 参数</h3><p>如果你像如下命令这样为 git fetch 设置 的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo</span><br></pre></td></tr></table></figure><p>Git 会到远程仓库的 <code>foo</code> 分支上，然后获取所有本地不存在的提交，放到本地的 <code>o/foo</code> 上。</p><p>来看个例子（还是前面的例子，只是命令不同了）</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240104001239753.png" alt="image-20240104001239753" /></p><p>你可能会好奇 —— 为何 Git 会将新提交放到 <code>o/foo</code> 而不是放到我本地的 foo 分支呢？之前不是说这样的 参数就是同时应用于本地和远程的位置吗？</p><p>好吧, 本例中 Git 做了一些特殊处理，因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。还记得在 <code>git fetch</code> 课程里我们讲到的吗 —— 它不会更新你的本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检查或者合并了）。</p><p>“如果我们指定 <code>&lt;source&gt;:&lt;destination&gt;</code> 会发生什么呢？”</p><p>如果你觉得直接更新本地分支很爽，那你就用冒号分隔的 refspec 吧。不过，你不能在当前切换的分支上干这个事，但是其它分支是可以的。</p><p>这里有一点是需要注意的 —— <code>source</code> 现在指的是远程仓库中的位置，而 <code>&lt;destination&gt;</code> 才是要放置提交的本地仓库的位置。它与 git push 刚好相反，这是可以讲的通的，因为我们在往相反的方向传送数据。</p><p>理论上虽然行的通，但开发人员很少这么做。我在这里介绍它主要是为了从概念上说明 <code>fetch</code> 和 <code>push</code> 的相似性，只是方向相反罢了。</p><p>来看个疯狂的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo~:bar</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240104001532665.png" alt="image-20240104001532665" /></p><p>如果执行命令前目标分支不存在会怎样呢？我们看一下上个对话框中没有 bar 分支的情况。</p><p>跟 git push 一样，<strong>Git 会在 fetch 前自己创建立本地分支</strong>, 就像是 Git 在 push 时，如果远程仓库中不存在目标分支，会自己在建立一样。</p><p>没有参数呢?</p><p><strong>如果 <code>git fetch</code> 没有参数，它会下载所有的提交记录到各个远程分支……</strong></p><p>相当简单，但是仅需更新一次，值得你去做！</p><h3 id="古怪的-source"><a class="markdownIt-Anchor" href="#古怪的-source"></a> 古怪的 <code>&lt;source&gt;</code></h3><p>Git 有两种关于 <code>&lt;source&gt;</code> 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 <code>source</code>，方法就是仅保留冒号和 destination 部分，source 部分留空。</p><ul><li><code>git push origin :side</code></li><li><code>git fetch origin :bugFix</code></li></ul><p>我们分别来看一下这两条命令的作用……</p><p>如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :foo</span><br></pre></td></tr></table></figure><p>就是这样子, 我们通过给 push 传空值 source，成功删除了远程仓库中的 <code>foo</code> 分支, 这真有意思…</p><p>如果 fetch 空 到本地，会在本地创建一个新分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin :bugFix</span><br></pre></td></tr></table></figure><p>很神奇吧！但无论怎么说, 这就是 Git！</p><h2 id="git-pull-参数"><a class="markdownIt-Anchor" href="#git-pull-参数"></a> Git pull 参数</h2><p>既然你已经掌握关于 <code>git fetch</code> 和 <code>git push</code> 参数的方方面面了，关于 git pull 几乎没有什么可以讲的了 😃</p><p>因为 git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。</p><p>还可以和其它更复杂的参数一起使用, 来看一些例子:</p><p>以下命令在 Git 中是等效的:</p><p><code>git pull origin foo</code> 相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo; git merge o/foo</span><br></pre></td></tr></table></figure><p>还有…</p><p><code>git pull origin bar~1:bugFix</code> 相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin bar~1:bugFix; git merge bugFix</span><br></pre></td></tr></table></figure><p>看到了? git pull 实际上就是 fetch + merge 的缩写, git pull 唯一关注的是提交最终合并到哪里（也就是为 git fetch 所提供的 destination 参数）</p><p>一起来看个例子吧：</p><p>如果我们指定要抓取的 place，所有的事情都会跟之前一样发生，只是增加了 merge 操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240104002457100.png" alt="image-20240104002457100" /></p><p>pull 也可以用 source:destination 吗? 当然喽, 看看吧:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main:foo</span><br></pre></td></tr></table></figure><p>哇, 这个命令做的事情真多。它先在本地创建了一个叫 <code>foo</code> 的分支，从远程仓库中的 main 分支中下载提交记录，并合并到 <code>foo</code>，然后再 merge 到我们的当前所在的分支 <code>bar</code> 上。操作够多的吧？！</p>]]></content>
    
    
    <summary type="html">可视化练习git操作</summary>
    
    
    
    <category term="SnowMoonの计算机基础知识" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>考研复习日记</title>
    <link href="https://www.snowmoon.top/2022/08/26/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    <id>https://www.snowmoon.top/2022/08/26/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%97%A5%E8%AE%B0/</id>
    <published>2022-08-26T08:11:54.000Z</published>
    <updated>2023-11-30T16:40:10.636Z</updated>
    
    <content type="html"><![CDATA[<p>最近太摆了，开个帖子来记录自己的复(bai)习(lan)日记，希望在帖子的监督下，自己能稍微认真点学习。</p><p>专业课一轮都还没干完，属实拉胯，而且一天天的越来越不想学专业课，打开书就想打开B站之类的逃避，属实是不应该。</p><h2 id="08-26"><a class="markdownIt-Anchor" href="#08-26"></a> 08-26</h2><p>今日复习记录：摆了一天，看完了概率的最后一章，写了下张宇基础30+李正元全书的一部分题，本来上个月就能结束的一轮，嗯是拖到了这个月的现在，值得反思。。。</p><p>明日目标：明天不用去健身房，可以好好学一波咯</p><p>数学：写完李正元第七章的题，开始写660。之前写到了第15题，希望明天能写到40题。</p><p>计组：明天必须结束浮点数和前面编码这一节，写完这部分的选择，开足马力 好好复习，拒绝摆烂 从我做起。</p><p>英语：写完02年的text1 2，3尽力写。</p><span id="more"></span><h2 id="08-27"><a class="markdownIt-Anchor" href="#08-27"></a> 08-27</h2><p>今日进度：</p><p>数学：发下李正元概率论的第六章还没做完，补做了一波概率论的六七章，然后660刷了一下前30里的重点题，今天九点左右才开始进入状态，导致刷数学刷了好久，而且效率不高导致早上下午都在数学，希望明天能提高点效率。</p><p>英语和计组都没写，晚上开摆了。。。</p><p>总结：寄</p><p>明日计划：</p><p>数学：李正元概率论最后一章收尾，早上再把勾了的660里的题写一下，把前60题里的重点题做一做。</p><p>英语：晚上得写点英语了，不说多的，02年text1,2。。。单词得接着背</p><p>计组：下午多看点计组，不要睡一觉起来想着数学没整完又去整数学了，专业课进度严重落后，要重视。</p><h2 id="8-28"><a class="markdownIt-Anchor" href="#8-28"></a> 8-28</h2><p>寄×2</p><p>今天和朋友键政了一下午，早上也没学进去多少，一整天加起来写了两三个题，只能说：寄</p><h2 id="8-29"><a class="markdownIt-Anchor" href="#8-29"></a> 8-29</h2><p>今日进度：</p><p>660做完了前60题里的重点题，刚开始进度挺快，做到后面几个积分题后越写越慢，不管怎么说，今天效率还可以。</p><p>计组继续学了一下浮点数这节，还差点运算就能结束这节了，专业课进度属实缓慢。</p><p>今日英语：无。。。希望明天能学点英语</p><p>明日计划：660中60-90题的重点题</p><p>计组完成王道第二章，适当学一点操作系统</p><p>英语读两篇文章</p><h2 id="8-30"><a class="markdownIt-Anchor" href="#8-30"></a> 8-30</h2><p>660做到了70题左右的重点题，积分和微分方程这两节开始有挺多难题了，收录进入错题本好几个题</p><p>计组继续看了一些王道的视频，感觉这课像没学过一样</p><p>写了一波实习报告，然后花了50块钱找了个代抄。4000字手写报告是真的TMD傻逼。</p><p>明日计划</p><p>计组浮点数运算写题</p><p>数学继续660</p><p>英语复习一两个list的单词+做点阅读</p><h2 id="8-31"><a class="markdownIt-Anchor" href="#8-31"></a> 8-31</h2><p>今日进度：660做到了80题左右，这部分题目难度还是挺大的</p><p>计组写了浮点数这一节的题，写的很迷茫，感觉这两天是白听了</p><p>英语写了一篇阅读</p><p>明日计划：660：做到100题</p><p>计组：结束浮点数，开下一节的存储器</p><p>英语：两篇阅读保底+两个list</p><p>状态渐入佳境，是个好兆头。到现在一共翘了6个大课了，有两个签到没到，一个课堂抽人抽到了我，老师三连击，全是翘了的，真不戳。</p><h2 id="9-1~9-4"><a class="markdownIt-Anchor" href="#9-1~9-4"></a> 9-1~9-4</h2><p>懵逼了三四天，做的东西不多，浪费了挺多时间，晚上睡的太晚，而且摆烂能力太强以至于408学不完了还在摆</p><p>计组：还在浮点数，到了乘除法有点懵逼，希望能在9.4晚上刷完</p><p>数学：660做到了116题，继续加油吧</p><p>英语：我哭死，我又浪费了好几天</p><h2 id="95-96"><a class="markdownIt-Anchor" href="#95-96"></a> 9.5-9.6</h2><p>计组：学到了Cache前面一个小部分</p><p>OS：学完了第一章</p><p>660：做到了153T，先做到160左右就继续搞880错题吧</p><p>英语：背了一点单词</p><h2 id="97-911"><a class="markdownIt-Anchor" href="#97-911"></a> 9.7-9.11</h2><p>这次浪费的时间更多</p><p>9.11打了一天游戏，应该是这个学期最后一次LOL，后面顶多看看比赛的比分了，天天和ZZB、ZZB盆友、游戏认识的一个28岁大姐姐打游戏，持续了一个暑假到现在，浪费了挺多时间，以后好好学习，天天向上了</p><p>9.7-9.10主要完成了880前两章里的错题整理和复习，计组查缺补漏看完了存储这章，但是题还没做完，这四天学习时间大概相当于两天</p><p>以后的记录改为周记吧，啥时候想起来了就写点</p><p>下周计划：计组一天一章，在下周内结束。</p><p>数学改错（即880二刷）完成高数部分</p><p>英语写完02-04年的卷子</p><h2 id="一点杂记"><a class="markdownIt-Anchor" href="#一点杂记"></a> 一点杂记</h2><p>今天前女友贼喜欢的明星李易峰《多次嫖娼》被行政拘留咯，看她qq里的反应还是挺大的，换头像，换个签，估计受的打击还挺大的。看她keep里的动态推断出她的作息来看，她应该也在准备考研，不过我也不好意思去问她想去哪，等着都考完以后捷报飞来贺自己吧。</p><h2 id="912"><a class="markdownIt-Anchor" href="#912"></a> 9.12</h2><p>今天看到了下周预报名的消息了，趁机查了一波考408的学校的分数线，发现一流的均分基本都在400+，次一流385+，再次一流370+</p><p><strong>计算机是真他娘的卷呐</strong></p><p>现在还没结束一轮，不知道自己究竟有多少能耐，但是按照自己英语和408的学习进度这尿性。。。370可能都不一定。</p><p><strong>现在看过来，自己大一到现在一路上错过了好多好多机会啊</strong></p><p>军训时期考卓越班转专业没好好把握当时考前也没仔细想想，被转专业群里的几个学长学姐的指南劝退，以为都是选择数竞选手，直接放弃了准备，考前也没好好选，头铁往最难的方向考，自然被淘汰。要是选个容易进去的，就能进有40%+的保研名额的班级，后面保研也容易很多，当初没多接触几个学长学姐问问经验，只能说自己的性格决定了现在的命运吧。</p><p>正式转专业考试时准备的也不够充分，还头铁选了最难的，刚好碰到了最卷的一年，从180进120变为了我们这一年的300+进60，信息类的自动化、通信工程等转专业时同时缩招，调剂都没得卷的。时也，命也。</p><p>分流时期又没去个不卷的方向83 84的分数稳稳拿名额，硬卷一个88 89才能拿名额的专业方向。卷也就算了，在大二又得了疫情后综合征，变得没有大一时候那么能卷了，于是想考好的时候考不好，改好好复习的时候学不进去，导致大二成绩很不理想，到了大三又直接开摆，被舍友同化成了游戏小子。大一大二都没怎么玩游戏，大三居然瘾大到不可理喻的地步。大三的寒假二月份在家就开了考研的复习，结果开学后4、5、6三个月加起来的复习速度赶不上寒假里学的一个月。到了现在，对自己的考试水平和能力完全没有个底，是真的废物，醒不过来的废物。明明第二天都是七点多就起床，结果天天晚上都是两点多三点多睡觉，永远都不能保持满状态学习，废物</p><p><strong>错过了四五个机会的我，希望可以把握住考研这次机会</strong></p><h2 id="9-18周记"><a class="markdownIt-Anchor" href="#9-18周记"></a> 9-18周记</h2><p>本周进度喜人，戒掉游戏之后就是不一样，</p><p>主要在看计组了，看到了第五章结束，上周刚差不多看完第二章，这周All in计组有点效果，看完了三章，基本两天一章，OS也看完了两章，预计下周能结束计组+OS，计网可以开了，本周数学基本处于荒废状态，赶408进度去了，下次学快点，没时间了，提高速度，提高效率。</p><h2 id="9-25周记"><a class="markdownIt-Anchor" href="#9-25周记"></a> 9-25周记</h2><p>本周进度:于9.24完成了OS与组原的复习，复习效率提上来了，学习速度不错。唉，要是早戒掉游戏，今天应该二轮复习了挺多了。9.25开了计网，9.24完成了浙大的预报名，190报名费。。政治开始加大小程序刷题的力度，一天刷个一百题左右，争取十月中旬结束1600题。</p><p>希望这周结束计网，开始408二轮及大题的复习，同时数学继续放回原应有的地位，每日刷2个小时吧先。加油，一定上岸!</p><h2 id="104记录"><a class="markdownIt-Anchor" href="#104记录"></a> 10.4记录</h2><p>本来这个记录应该在10.2完成的，但是复习的太投入了，今天才想起来写记录</p><p>总体进度赶上来了，计网结束，刚开始DS的二轮，大题写算法忘得有点多，要捡起来的有点多，预计一周结束DS二轮，接下来的408二轮3天一科，预计到10月的17-18号能结束，开启真题。</p><p>数学复习了三四天高数了，感觉再来两三天可以开线代，三四天结束线代，再来两三天结束概率，然后是10.15左右能开真题。</p><p>英语真题阅读刷了01-03年以及05年的，坚持一天两到三篇阅读，坚持背单词！</p><p>政治算是这周才找到了复习节奏吧，看了马原的两章，写了肖1000，预计这周结束马原，史纲能做一半。赶进度赶了快一个月了，效率还可以，但是有点怀疑自己的水平了，不知道处于考浙大的人群中的什么水平</p><p>这周心灵导师辰哥给了我挺多激励，说的也有道理——你的学习能力是经过高考验证的，按照自己学习的方法论和节奏走肯定是能有结果的。</p><p>——每个考研的人复习就像在一间没有灯光的房间里洗衣服，谁也不知道自己洗的怎么样，但是只要坚持洗，不断地洗，最后从房间里拿出来的时候一定挺干净</p><p>——985的没考上，大部分不是水平不够，而是努力不够</p><p>涛涛和宇哥也是两个好的教育者，涛涛说：你会遭到某些人的嫉妒之类的情绪是因为你比他们优秀，但只比他们优秀一点点，你们之间还有太多的同一性，所以你们才会处在不断的斗争性中间。要想没有斗争性，你就要让自己变得更优秀，优秀到能斩断你和他之间的同一性，没有了同一性，你们就没有斗争性了</p><p>宇哥则是每天都给我们激励，考研之路不易，不断斩断前路的艰难险阻，才能曲折的前进</p><p>道路是曲折的，前路是光明的</p><p>坚定信念，前进，不择手段的前进！</p><p>（此处应该有一句 自然选择，前进四！😁😁😁</p><h2 id="10-9记录"><a class="markdownIt-Anchor" href="#10-9记录"></a> 10-9记录</h2><p>又是一个周记，本周结束了高数的二轮并开启了线代的二轮，DS二轮学的有点慢，进度并不能使人满意，故打算放一放，开启时间片轮转模式，将408的四科都轮一轮。</p><p>DS：结束了查找和排序算法的学习，刚开始几天去温习快排的代码写法了，走了弯路，花了时间没有取得什么成果，应试学习应以应试为主，记几个模板让自己到时候能根据模板做些修改写出来就差不多了，没必要那么严谨的让他跑通，所以换学习模式了，一天复个一两科408，防止某一科长时间不碰饥饿致死。</p><p>计组：结束了前两章的二轮，开启存储系统</p><p>计网：结束前两章</p><p>英语：完成了03、04、05、18、的阅读，日经List单词完成至Day10</p><p>政治：肖1000完成了马原的前四五章内容，史纲完成了前三四章，看完了腿姐带背的对应内容。</p><p>下周计划：</p><p>数学：结束线代+概率二轮，开启真题</p><p>英语：完成06-10年的阅读，List的单词推进至Day11结束</p><p>计组：结束存储系统+指令系统+中央处理器</p><p>OS：结束进程+内存</p><p>DS：结束线性表+树+图</p><p>计网：复习至传输层结束</p><p>408预计于10.18-19日结束，于10.20左右开启每日一套真题的节奏。</p><p>数学预计于10.15-10.16结束，开启真题节奏。</p><p>英语预计月底左右结束真题阅读一刷。</p><p>政治预计于10.20刷完肖1000除毛中特外的所有部分。</p><p>进度不快，但求扎实学好每个知识。</p><h1 id="考后碎碎念"><a class="markdownIt-Anchor" href="#考后碎碎念"></a> 考后碎碎念</h1><p>一次忘记记录就拖啊拖，拖到了现在，已经考完咯！</p><blockquote><p>从二月开始复习，到开学后开摆四个月，从七八的低强度复习，到九月开始的删游戏高强度复习，再到一步步的择校，择专业，择梦想。</p><p>这是我第一次，完完全全由自己自主做决定，并为之全权负责的时刻。</p><p>一路中反反复复，磕磕绊绊。见证了自己的弱小与傲慢，见证了自己的懒惰与怯懦，也见证了自己的进步与成长。</p><p>要是没那么粗心，要是多看几遍错题本，要是当时看多往后看几页冷僻的知识点……</p><p>哪有那么多要是！落子无悔！小孩子可以哭，但成年人不行。</p><p>即使发挥的没有那么理想，但我依然可以说，我来过，我战斗过，这里的风景，独好。</p><p>感谢那个努力的自己，愿所有努力，都能得尝所愿。</p></blockquote><p>以上是我刚考完研的那个晚上记录下的文字，如今考研已经过去了一个星期，我也在考完研回家的第一个晚上就感染了新冠，现在已经基本痊愈了。</p><p>有一说一，新冠是真的痛苦，要是考研的那几天得了新冠，估计是直接寄了，高烧了3天，39度两天，38度一天，即使已经痊愈了依旧还是在咳嗽，在疯狂地流鼻涕，高烧那两天，近乎无眠，可以说，能发烧烧到这种程度，是我疫情三年，乃至初中以来的10年里都没有过的体验。我感染的还是BF7毒株，应该是回宿舍收东西准备回家时候感染的，当时看舍友都没啥症状了也，自己也考完研了，就没那么小心了。回家时候因为爸妈新冠还没好，就让我单独去住到一个亲戚家的房子里，结果才住进去的当天喉咙就开始疼，第二天起床就烧起来了，38度，持续到晚上变成了39度，烧了两天39度，速释的对乙酰氨基酚第一天吃了完全没用，烧到了四五点睡不着，我爸妈给我拿来了布洛芬的缓释胶囊吃完才退烧，舒服到了第二天下午，又开始烧，依旧是坚挺的39度，这回布洛芬也没用了，吃了三个小时从39.4掉到了39.3，反正就是很绝望，此时还好还有人吹吹牛，和祁医生进行的话疗很有效，在吃下退烧药后第五个小时，拉出了堵在肚子里三四天的💩，祁医生说是张仲景讲过，高热且便秘，便通则烧退，嘿，还真灵，拉完第二天就舒服了。虽然这天还是烧到了38度多，但是已经没有了明显的不适感，我也就此把药停了。停药以后就是咳，咳咳咳咳咳咳咳咳咳咳，一直咳到肺都快咳出来了，喉咙还疼的要死，只求它慢慢地好了吧。</p><p>在我差不多好了的时候，我爷爷和我外婆又几乎同时得了新冠，打了几天针以后又送去医院里住院了，只希望他们尽快好了吧，关关难过关关过，都能到这个年纪了，希望他们能渡过眼前的难关，健健康康地活下去。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近太摆了，开个帖子来记录自己的复(bai)习(lan)日记，希望在帖子的监督下，自己能稍微认真点学习。&lt;/p&gt;
&lt;p&gt;专业课一轮都还没干完，属实拉胯，而且一天天的越来越不想学专业课，打开书就想打开B站之类的逃避，属实是不应该。&lt;/p&gt;
&lt;h2 id=&quot;08-26&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#08-26&quot;&gt;&lt;/a&gt; 08-26&lt;/h2&gt;
&lt;p&gt;今日复习记录：摆了一天，看完了概率的最后一章，写了下张宇基础30+李正元全书的一部分题，本来上个月就能结束的一轮，嗯是拖到了这个月的现在，值得反思。。。&lt;/p&gt;
&lt;p&gt;明日目标：明天不用去健身房，可以好好学一波咯&lt;/p&gt;
&lt;p&gt;数学：写完李正元第七章的题，开始写660。之前写到了第15题，希望明天能写到40题。&lt;/p&gt;
&lt;p&gt;计组：明天必须结束浮点数和前面编码这一节，写完这部分的选择，开足马力 好好复习，拒绝摆烂 从我做起。&lt;/p&gt;
&lt;p&gt;英语：写完02年的text1 2，3尽力写。&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの生活随笔" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="摆烂日记" scheme="https://www.snowmoon.top/tags/%E6%91%86%E7%83%82%E6%97%A5%E8%AE%B0/"/>
    
    <category term="考研" scheme="https://www.snowmoon.top/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="生活记录" scheme="https://www.snowmoon.top/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法与外挂标签写法汇总</title>
    <link href="https://www.snowmoon.top/2022/08/09/Markdown%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE%E5%86%99%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>https://www.snowmoon.top/2022/08/09/Markdown%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE%E5%86%99%E6%B3%95%E6%B1%87%E6%80%BB/</id>
    <published>2022-08-09T10:19:03.000Z</published>
    <updated>2022-10-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1markdown语法自带格式"><a class="markdownIt-Anchor" href="#1markdown语法自带格式"></a> 1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="11-代码块"><a class="markdownIt-Anchor" href="#11-代码块"></a> 1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="12-多级标题"><a class="markdownIt-Anchor" href="#12-多级标题"></a> 1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="13-文字样式"><a class="markdownIt-Anchor" href="#13-文字样式"></a> 1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br /><font face="黑体">黑体</font><br /><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="14-引用"><a class="markdownIt-Anchor" href="#14-引用"></a> 1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br />二级引用演示<br />MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="15-分割线"><a class="markdownIt-Anchor" href="#15-分割线"></a> 1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr /><hr /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="16-列表-跟空格都可以"><a class="markdownIt-Anchor" href="#16-列表-跟空格都可以"></a> 1.6 列表(*,+,-跟空格都可以)</h2><h3 id="161-无序列表"><a class="markdownIt-Anchor" href="#161-无序列表"></a> 1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="162-有序列表"><a class="markdownIt-Anchor" href="#162-有序列表"></a> 1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="17-图片"><a class="markdownIt-Anchor" href="#17-图片"></a> 1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br /><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br />在线图片:<br /><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code" /></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="18-表格"><a class="markdownIt-Anchor" href="#18-表格"></a> 1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="19-公式"><a class="markdownIt-Anchor" href="#19-公式"></a> 1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><msup><mi>t</mi><mrow><mi>z</mi><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>e</mi><mrow><mo>−</mo><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.326242em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.843556em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mord">.</span></span></span></span></span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="2butterfly外挂标签"><a class="markdownIt-Anchor" href="#2butterfly外挂标签"></a> 2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="21-行内文本样式-text"><a class="markdownIt-Anchor" href="#21-行内文本样式-text"></a> 2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="22-行内文本-span"><a class="markdownIt-Anchor" href="#22-行内文本-span"></a> 2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br />在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br />文档「开始」页面中的标题部分就是超大号文字。<br /><span class='p center logo large'>Volantis</span><br /><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="23-段落文本-p"><a class="markdownIt-Anchor" href="#23-段落文本-p"></a> 2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br />在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br />文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="24-引用note"><a class="markdownIt-Anchor" href="#24-引用note"></a> 2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="25-上标标签-tip"><a class="markdownIt-Anchor" href="#25-上标标签-tip"></a> 2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="26-动态标签-anima"><a class="markdownIt-Anchor" href="#26-动态标签-anima"></a> 2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br />You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="27-复选列表-checkbox"><a class="markdownIt-Anchor" href="#27-复选列表-checkbox"></a> 2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="28-单选列表-radio"><a class="markdownIt-Anchor" href="#28-单选列表-radio"></a> 2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="29-时间轴-timeline"><a class="markdownIt-Anchor" href="#29-时间轴-timeline"></a> 2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="210-链接卡片-link"><a class="markdownIt-Anchor" href="#210-链接卡片-link"></a> 2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="211-按钮-btns"><a class="markdownIt-Anchor" href="#211-按钮-btns"></a> 2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br />默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="212-github卡片-ghcard"><a class="markdownIt-Anchor" href="#212-github卡片-ghcard"></a> 2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br />以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="213-github徽标-ghbdage"><a class="markdownIt-Anchor" href="#213-github徽标-ghbdage"></a> 2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br /><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br />//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br /><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br />//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br /><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="214-网站卡片-sites"><a class="markdownIt-Anchor" href="#214-网站卡片-sites"></a> 2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="215-行内图片-inlineimage"><a class="markdownIt-Anchor" href="#215-行内图片-inlineimage"></a> 2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="216-单张图片-image"><a class="markdownIt-Anchor" href="#216-单张图片-image"></a> 2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="217-音频-audio"><a class="markdownIt-Anchor" href="#217-音频-audio"></a> 2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="218-视频-video"><a class="markdownIt-Anchor" href="#218-视频-video"></a> 2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="219-相册-gallery"><a class="markdownIt-Anchor" href="#219-相册-gallery"></a> 2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt="" /><br /><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt="" /></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="220-折叠框-folding"><a class="markdownIt-Anchor" href="#220-折叠框-folding"></a> 2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt="" /></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="221-分栏-tab"><a class="markdownIt-Anchor" href="#221-分栏-tab"></a> 2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="222-诗词标签-poem"><a class="markdownIt-Anchor" href="#222-诗词标签-poem"></a> 2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br />明月几时有？把酒问青天。<br />不知天上宫阙，今夕是何年？<br />我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br />起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br />不应有恨，何事长向别时圆？<br />人有悲欢离合，月有阴晴圆缺，此事古难全。<br />但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="223-阿里图标-icon"><a class="markdownIt-Anchor" href="#223-阿里图标-icon"></a> 2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="224-特效标签wow"><a class="markdownIt-Anchor" href="#224-特效标签wow"></a> 2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="225-进度条-progress"><a class="markdownIt-Anchor" href="#225-进度条-progress"></a> 2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br />源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="226-注释-notation"><a class="markdownIt-Anchor" href="#226-注释-notation"></a> 2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="227-气泡注释-bubble"><a class="markdownIt-Anchor" href="#227-气泡注释-bubble"></a> 2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="228-引用文献-reference"><a class="markdownIt-Anchor" href="#228-引用文献-reference"></a> 2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br />主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br />Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="229-pdf展示"><a class="markdownIt-Anchor" href="#229-pdf展示"></a> 2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="230-hexo-tag-map-插件"><a class="markdownIt-Anchor" href="#230-hexo-tag-map-插件"></a> 2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="231-隐藏块"><a class="markdownIt-Anchor" href="#231-隐藏块"></a> 2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br /><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</summary>
    
    
    
    <category term="SnowMoonの计算机基础知识" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Markdown" scheme="https://www.snowmoon.top/tags/Markdown/"/>
    
    <category term="外挂标签" scheme="https://www.snowmoon.top/tags/%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>211007——碎碎念</title>
    <link href="https://www.snowmoon.top/2021/10/07/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-1007-%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>https://www.snowmoon.top/2021/10/07/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-1007-%E7%A2%8E%E7%A2%8E%E5%BF%B5/</id>
    <published>2021-10-07T03:36:51.000Z</published>
    <updated>2023-11-30T16:43:42.639Z</updated>
    
    <content type="html"><![CDATA[<p>愉快的国庆结束了，坐在回学校的高铁上码下这篇文章，大概的记录下近几天的一些想法，就想到啥写啥了，琐碎的记录</p><h1 id="失齿之痛"><a class="markdownIt-Anchor" href="#失齿之痛"></a> 失齿之痛</h1><p>这个国庆拔了个智齿，在拔这个牙之前，我只是感觉它和另一颗牙之间有比较大的缝隙，然后它被腐蚀的有点龋了，然后就跑到医院看了看，第一家小医院就建议我拔了。。。有点接受不了，去了另外一家大口腔医院看了看，发现我的四个智齿有两个是阻生，，，所以人家也建议拔了，，，还建议直接拔四颗。</p><p>考虑了半天，还是先拔一颗比较坏的，左下颌的智齿。</p><p>在知道要把这玩意拔掉之后，我还没有意识到问题的严重性。。。</p><p>拔牙这天我心慌慌的坐在候诊室等着处刑，越接近拔牙时刻心跳速度愈发的快，打完麻药之后医生直接把我脸给盖上了，之路出嘴周围的一圈。我只感觉她在我嘴里一顿操作，还听见医生在聊哪个主任开着路虎，人长得又帅，想多看几遍。我TM。。。</p><span id="more"></span><p>十分钟左右，我的牙就没了。十分钟，￥-1490</p><blockquote><p>后来了解了一下这个拔牙的过程，感觉赶得上一个小手术了</p><p>因为是下颌，得先把牙齿附近的骨头给锯掉一部分，然后把牙冠给整个锯断取出来，接下来就是取牙根，md得把牙根从中间锯成两段，再分别取出来，最后把留下的大坑给缝上，我的牙直接缝了5针！</p></blockquote><p>麻药劲儿还没过去那阵，我活蹦乱跳的，心想：拔个智齿就这？也不疼嘛，但是在几个小时后，麻药开始失效了，这时候我开始渐渐的意识到了这玩意不简单，是真TNND疼啊！睡了半小时，被疼醒四次，吃了些止疼药，暂时还没药效的时候属实难受，坐立不安，在家里到处走来走去，后来药劲儿上来了才逐渐舒服了</p><h1 id="与老友小聚"><a class="markdownIt-Anchor" href="#与老友小聚"></a> 与老友小聚</h1><p>回家见了一波近两年都没见的老朋友聊了好多各自行业和专业内的动态，认识有七八年了，但是这么长时间不见又见面时还是有说不完的话和话题。各自都在变得更强，都很有追求，那就希望我们都能成为各自行业里的翘楚吧！</p><h1 id="to-be-continued"><a class="markdownIt-Anchor" href="#to-be-continued"></a> To be continued</h1><p>现在的我走得越来越远了，离父母也越来越远了，每次回家的间隔也在逐渐的变长，可以比较明显的感受到他们在渐渐的离我远去，回家了和他们的共同话题也越来越少，逐渐的聚焦到了未来的安排和结婚生子上。不回来不知道，原来我父亲的工作这么辛苦，整个国庆留给他的休息时间加起来不超过两天。拿着微薄的工资，做着最重的体力活。要是自己能早点开始赚钱就好了，他们对我那么好，只有对他们更好，才能对得起他们对我的好</p><p>在车上看到了妈妈发的朋友圈——“愿你前程似锦，不负余生”。差点没有崩住，我是前程似锦了，我是不负余生了，他们把最好的都给了我，我能给他们什么呢？</p><p>这个问题，需要用我的余生来回答。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;愉快的国庆结束了，坐在回学校的高铁上码下这篇文章，大概的记录下近几天的一些想法，就想到啥写啥了，琐碎的记录&lt;/p&gt;
&lt;h1 id=&quot;失齿之痛&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#失齿之痛&quot;&gt;&lt;/a&gt; 失齿之痛&lt;/h1&gt;
&lt;p&gt;这个国庆拔了个智齿，在拔这个牙之前，我只是感觉它和另一颗牙之间有比较大的缝隙，然后它被腐蚀的有点龋了，然后就跑到医院看了看，第一家小医院就建议我拔了。。。有点接受不了，去了另外一家大口腔医院看了看，发现我的四个智齿有两个是阻生，，，所以人家也建议拔了，，，还建议直接拔四颗。&lt;/p&gt;
&lt;p&gt;考虑了半天，还是先拔一颗比较坏的，左下颌的智齿。&lt;/p&gt;
&lt;p&gt;在知道要把这玩意拔掉之后，我还没有意识到问题的严重性。。。&lt;/p&gt;
&lt;p&gt;拔牙这天我心慌慌的坐在候诊室等着处刑，越接近拔牙时刻心跳速度愈发的快，打完麻药之后医生直接把我脸给盖上了，之路出嘴周围的一圈。我只感觉她在我嘴里一顿操作，还听见医生在聊哪个主任开着路虎，人长得又帅，想多看几遍。我TM。。。&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの生活随笔" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://www.snowmoon.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>琐碎的记录——生活真美好</title>
    <link href="https://www.snowmoon.top/2021/09/25/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E7%90%90%E7%A2%8E%E7%9A%84%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E7%94%9F%E6%B4%BB%E7%9C%9F%E7%BE%8E%E5%A5%BD/"/>
    <id>https://www.snowmoon.top/2021/09/25/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E7%90%90%E7%A2%8E%E7%9A%84%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E7%94%9F%E6%B4%BB%E7%9C%9F%E7%BE%8E%E5%A5%BD/</id>
    <published>2021-09-25T15:27:31.000Z</published>
    <updated>2024-06-01T04:45:13.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先写不开心的事抠出一万套海景房的尬聊"><a class="markdownIt-Anchor" href="#先写不开心的事抠出一万套海景房的尬聊"></a> 先写不开心的事——抠出一万套海景房的尬聊</h1><p>今天在地铁上可真是把我尬的受不了了，我本来开开心心的坐在座位上打游戏，打的正开心的时候，一个老哥过来问我借充电宝，借过去稍微讲了两句话，到目前为止一切正常。然后过了一会之后，这个老哥开始和我疯狂地吹牛：“兄弟，我跟你说，充电宝这玩意还得是以前质量高！我爸有一个，牌子货！呵，一个用了十多年！” 嚯，好家伙，难道这就是传说中的葫芦娃合体的牛逼闪闪的充电宝嘛，我不禁向这么🐮🍺的充电宝低下了头，继续玩我的游戏，然后这位大哥似乎没有停下来的意思，继续给我讲充电宝的故事，顺带补充了一下他那🐮🍺的充一次电可以玩十天的手机，然后他讲这个讲了二十多分钟。。。我打了两三局炉石后停下来听他继续吹牛，，，然后我开始左顾右盼，他开始越来越离谱，给我扯他的充电宝多多少钱。。。属实听不下去，，，尬的抠出一万套海景房</p><span id="more"></span><h1 id="其次是今天的出游"><a class="markdownIt-Anchor" href="#其次是今天的出游"></a> 其次是今天的出游</h1><p>在图书馆写了一天代码的我决定放空下自我，约舍友出门游玩，阔惜莫得一个人理我，那行，爷自己去🙃晚上六点多坐着地铁奔向了江汉路。</p><p>虽然来过了几遍了，但是这次过来还是有很多耳目一新的收获</p><p>又会想起了当初一个人游荡在杭州的街头，感受着这个世界的美好与喧嚣，感受着生活的存在，感受着社会的存在，感受着学校的三点一线以外的生活，我这才意识到——原来这才是生活啊，原来世界有这么大，原来世界有这么精彩，原来生活可以活的这么有趣</p><p>在象牙塔里待一段时间一定要出来走走，要出来见识见识这个美妙的世界，见识见识生活本来的样子，这样我才会更热爱生活！</p><p>吹着江风，看着江上的轮渡，和江边钓鱼的大叔唠上几句，再欣赏欣赏长江大桥的壮阔，生活遍由此而变得多姿多彩了，变得更能使我快乐了</p><h1 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h1><p>另外，今天还是学院的国家奖学金答辩的日子，啊，不知不觉已经大三了，不知不觉减已经到了第二次奖学金的评审了，在第一次评审时自己还为总成绩差了一名没法参与评审而懊恼，现在已经完全放下了这些狗屁奖学金，不就是几千块钱嘛，将来工作了一两个月就能挣回来了。</p><p>想想各个卷王为了争抢那么点荣誉拼的你死我活，课堂知识在课上学一遍就算了，回了寝室还要再在慕课上刷一遍，恨不得把所有时间都拿来学，这有什么值得的呢？为了拿点分数，都不管学的这些知识有没有什么作用，卷就完了，保了研我就🐮🍺了。</p><p>这些知识体系是几十年前工业时代下建立起来的学科体系遗留下来的传统知识。我个人非常反对学院设置的这些非常非常传统的传统机械的相关的知识体系的灌输，我认为即使是本科生，也应该接收最新的，最前沿的技术与知识，而不是抱着九几年，八几年甚至六几年出的课本传授一堆很可能已经过时的知识！</p><p>现在再想想大一大二为了点加权，为了点加分，各种蹭比赛，各种蹭科研项目，即使是打杂也要一头钻进去，为了这些个项目急红了眼，真是不值得。一切的项目，都是基于某些学长做了95%的项目进行修改，做一个机器人70%的时间装配，20%的时间调参数，剩下10%的时间看学长的代码里哪些参数有什么用，能怎么调，时间是花了，技术呢？一无所获。除了所获奖项上又能增加那么一行意外一无是处，真是后悔了自己当初的所作所为。</p><p>不过还好，现在已经悟到了自己不喜欢这些东西，既然不喜欢，那就拒绝呗，开始认真做能使我感到快乐的事情！</p><h2 id="后后记"><a class="markdownIt-Anchor" href="#后后记"></a> 后后记</h2><p>今天还是前女友的生日，一直感觉挺对不起她的，所以今年还给她了生日祝福，并且把我翻墙用的SSR传授给了她🙈，不过总感觉她挺冷淡的，没事，冷淡就冷淡叭，也该冷淡点，我本来早该删了她了的，不过似乎还是有些放不下呀，害</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;先写不开心的事抠出一万套海景房的尬聊&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#先写不开心的事抠出一万套海景房的尬聊&quot;&gt;&lt;/a&gt; 先写不开心的事——抠出一万套海景房的尬聊&lt;/h1&gt;
&lt;p&gt;今天在地铁上可真是把我尬的受不了了，我本来开开心心的坐在座位上打游戏，打的正开心的时候，一个老哥过来问我借充电宝，借过去稍微讲了两句话，到目前为止一切正常。然后过了一会之后，这个老哥开始和我疯狂地吹牛：“兄弟，我跟你说，充电宝这玩意还得是以前质量高！我爸有一个，牌子货！呵，一个用了十多年！” 嚯，好家伙，难道这就是传说中的葫芦娃合体的牛逼闪闪的充电宝嘛，我不禁向这么🐮🍺的充电宝低下了头，继续玩我的游戏，然后这位大哥似乎没有停下来的意思，继续给我讲充电宝的故事，顺带补充了一下他那🐮🍺的充一次电可以玩十天的手机，然后他讲这个讲了二十多分钟。。。我打了两三局炉石后停下来听他继续吹牛，，，然后我开始左顾右盼，他开始越来越离谱，给我扯他的充电宝多多少钱。。。属实听不下去，，，尬的抠出一万套海景房&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの生活随笔" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://www.snowmoon.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>jyy与yzh的折磨——从0到1撸PA的日子</title>
    <link href="https://www.snowmoon.top/2021/09/23/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-jyy%E4%B8%8Eyzh%E7%9A%84%E6%8A%98%E7%A3%A8%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%92%B8PA%E4%B9%8B%E8%B7%AF/"/>
    <id>https://www.snowmoon.top/2021/09/23/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-jyy%E4%B8%8Eyzh%E7%9A%84%E6%8A%98%E7%A3%A8%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%92%B8PA%E4%B9%8B%E8%B7%AF/</id>
    <published>2021-09-23T09:16:35.000Z</published>
    <updated>2023-12-01T10:53:57.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><p>本文为自己做南京大学计算机科学与技术系<code>计算机系统基础</code>课程的小(mo)型(gui)项目 (Programming Assignment, PA)的一些心路历程与实验记录，会一直更新到把整个PA给写完了</p><p>博主目前为国内某中流985天坑专业在读大三老🐶一枚，在学CSAPP的时候了解到了这个小(mo)型(gui)项目，于是下定决心来做它，为了变强，加油！</p><p>至于标题为啥这么取，，，只是为了补偿一下我最近被他摧残的差不多了的小心脏😭，yzh老师真是太太太太太好了，把这么好的资料都公开了出来，唯一的小瑕疵就是不提供OJ给我们测试，，，不过我也很理解，能有这么好的学习资料我这种天坑专业的已经很满足了！🤑</p><p>南大真是太好了，南大就是中国的CMU啊——某中流985学子投来羡慕的目光</p><h1 id="pa0我已出仓感觉良好"><a class="markdownIt-Anchor" href="#pa0我已出仓感觉良好"></a> PA0😏——我已出仓，感觉良好</h1><p>PA0还算蛮简单的，也就是配配环境，玩玩Git和vim。虽然之前都了解过这两个家伙，但是都没怎么用过，所以熟悉它们还是花了些时间的。就是唯一想吐槽的是老师这里的讲义居然是全英文的😭，英语不好的我流下了不争气的泪水😭 但是作为一名”工程师“应有的素质，我觉得老师这里做的肥肠棒，成功的让我燃起了好好学英语的兴趣！而且强制使用英语看这些报告虽然刚开始慢了点，还得时刻借助翻译的插件，但是时间长了之后对自己肯定只有好处，没有坏处。正如讲义里提到的：坚持一年, 你就会发现有不同; 坚持两年, 你就会发现大有不同。</p><p>整个讲义看下来，能明显的感觉到老师的良苦用心，又是让我阅读<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a>和<a href="https://github.com/tangx/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md">别像弱智一样提问</a>然后写800字的感想，又是随时都在让我</p><ul><li><p>STFW——Search The Friendly Web</p></li><li><p>RTFM——Read The Friendly Menu</p></li><li><p>RTFSC——Read The Friendly Source Code</p><span id="more"></span></li></ul><h1 id="pa1开始有些难度"><a class="markdownIt-Anchor" href="#pa1开始有些难度"></a> PA1——开始有些难度</h1><p>这个PA我读完手册还是一脸懵逼，不知道从哪开始，然后找了<a href="https://www.bilibili.com/video/BV1qa4y1j7xk?p=1">老师相关的习题课</a>以及相关的博客文章看了一些之后才有了一丝修改的意识与方法</p><h2 id="单步执行"><a class="markdownIt-Anchor" href="#单步执行"></a> 单步执行</h2><p>这里看了看了好久才知道是要自己实现让CPU单步执行程序的功能（原谅我菜的真实555）</p><p>然后需要使用老师提示使用的<code>strtok</code>和<code>sscanf</code>函数，具体应该是解析指令然后解析出数字，传送到CPU处使用CPU提供的指令单步执行</p><p>一次si多行倒是实现的快，但是无参数默认单步执行一直实现不出来，X了狗了，就先跳过，去做下一个命令</p><h2 id="打印寄存器信息"><a class="markdownIt-Anchor" href="#打印寄存器信息"></a> 打印寄存器信息</h2><p>这个看起来比较简单，找到CPU的寄存器结构体的定义和数据用printf打印出来就行，就是看工程文件看的有点头秃，第一波打印完之后数据有点对不齐，因为数字超过了8位，<code>\t</code>直接控制到下一个光标去了，就很丑，在这里卡了一会终于搞完了，很舒服</p><h1 id="扫描内存"><a class="markdownIt-Anchor" href="#扫描内存"></a> 扫描内存</h1><p>感觉每个任务最难的是理解题目需求和意思，看懂了要干什么之后找起文件来也就容易多了</p><h1 id="表达式"><a class="markdownIt-Anchor" href="#表达式"></a> 表达式</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面&quot;&gt;&lt;/a&gt; 写在前面&lt;/h1&gt;
&lt;p&gt;本文为自己做南京大学计算机科学与技术系&lt;code&gt;计算机系统基础&lt;/code&gt;课程的小(mo)型(gui)项目 (Programming Assignment, PA)的一些心路历程与实验记录，会一直更新到把整个PA给写完了&lt;/p&gt;
&lt;p&gt;博主目前为国内某中流985天坑专业在读大三老🐶一枚，在学CSAPP的时候了解到了这个小(mo)型(gui)项目，于是下定决心来做它，为了变强，加油！&lt;/p&gt;
&lt;p&gt;至于标题为啥这么取，，，只是为了补偿一下我最近被他摧残的差不多了的小心脏😭，yzh老师真是太太太太太好了，把这么好的资料都公开了出来，唯一的小瑕疵就是不提供OJ给我们测试，，，不过我也很理解，能有这么好的学习资料我这种天坑专业的已经很满足了！🤑&lt;/p&gt;
&lt;p&gt;南大真是太好了，南大就是中国的CMU啊——某中流985学子投来羡慕的目光&lt;/p&gt;
&lt;h1 id=&quot;pa0我已出仓感觉良好&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pa0我已出仓感觉良好&quot;&gt;&lt;/a&gt; PA0😏——我已出仓，感觉良好&lt;/h1&gt;
&lt;p&gt;PA0还算蛮简单的，也就是配配环境，玩玩Git和vim。虽然之前都了解过这两个家伙，但是都没怎么用过，所以熟悉它们还是花了些时间的。就是唯一想吐槽的是老师这里的讲义居然是全英文的😭，英语不好的我流下了不争气的泪水😭 但是作为一名”工程师“应有的素质，我觉得老师这里做的肥肠棒，成功的让我燃起了好好学英语的兴趣！而且强制使用英语看这些报告虽然刚开始慢了点，还得时刻借助翻译的插件，但是时间长了之后对自己肯定只有好处，没有坏处。正如讲义里提到的：坚持一年, 你就会发现有不同; 坚持两年, 你就会发现大有不同。&lt;/p&gt;
&lt;p&gt;整个讲义看下来，能明显的感觉到老师的良苦用心，又是让我阅读&lt;a href=&quot;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md&quot;&gt;提问的智慧&lt;/a&gt;和&lt;a href=&quot;https://github.com/tangx/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md&quot;&gt;别像弱智一样提问&lt;/a&gt;然后写800字的感想，又是随时都在让我&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;STFW——Search The Friendly Web&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RTFM——Read The Friendly Menu&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RTFSC——Read The Friendly Source Code&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの项目记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="计算机组成原理" scheme="https://www.snowmoon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="PA" scheme="https://www.snowmoon.top/tags/PA/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP——bomblab</title>
    <link href="https://www.snowmoon.top/2021/09/21/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E2%80%94%E2%80%94bomblab/"/>
    <id>https://www.snowmoon.top/2021/09/21/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E2%80%94%E2%80%94bomblab/</id>
    <published>2021-09-21T00:30:00.000Z</published>
    <updated>2023-12-01T10:55:25.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：看了好久的书，写了好几个晚上，参考了一些大佬的笔记，终于把这个bomblab写完了</p></blockquote><h1 id="实验简介"><a class="markdownIt-Anchor" href="#实验简介"></a> 实验简介</h1><p>这个著名的bomblab为我们提供了一个二进制文件，然后我们需要将这个二进制文件进行反汇编得到一堆的汇编文件，通过阅读汇编文件中的代码以及GDB的调试来得到需要输入的字符密码来进入下一关。</p><p>整个实验一共有六个正式关卡，一个隐藏关卡，密码和进入隐藏关卡的方法也藏在文件中，需要我们一点点的探寻其中的蛛丝马迹，拆开炸弹。如果拆弹失败的话，实验文件会给我们打印出一个BOMB！！！如果你是CMU的学生，每次不小心的BOMB还会扣你这个实验的分数，不过我们不是CMU的学生，就随便他炸了23333</p><h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1><p>没有实验文件的需要先到<a href="http://csapp.cs.cmu.edu/3e/bomb.tar">这个网站</a>下载一个</p><p>首先我们需要进入到这个lab的文件所在的文件夹下，可以看到有README、bomb、和bomb.c三个文件，我们先打开bomb.c看看有些什么东西</p><p>可以看到有6个phase，每个phase基本都是要我们输入一段字符，然后它调用了判断我们字符对不对的函数。大概浏览一下，知道要干什么之后先把bomb文件反汇编一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump bomb -d &gt; disassemble.txt</span><br></pre></td></tr></table></figure><p>得到了bomb的反汇编代码打开</p><p>看到一堆莫名其妙的东西，不知道怎么下手，想起来之前有6个phase，于是就搜索了下phase，找到了phase所在地，就用GDB来进行调试了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb bomb</span><br></pre></td></tr></table></figure><p>然后给爆炸和phase_1先打上断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b explode_bomb</span><br><span class="line">b phase_1</span><br></pre></td></tr></table></figure><p>run了之后，随便输入一点字符进入phase_1，先把当前的函数用disas指令反汇编一下</p><blockquote><p>不熟悉GDB调试的可以参考CMU的<a href="http://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf">课程提供的手册</a></p></blockquote><span id="more"></span><h1 id="phase1"><a class="markdownIt-Anchor" href="#phase1"></a> phase1</h1><p>phase1的反汇编代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">=&gt; 0x0000000000400ee0 &lt;+0&gt;:        sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:        mov    $0x402400,%esi</span><br><span class="line">   0x0000000000400ee9 &lt;+9&gt;:        callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:    retq   </span><br></pre></td></tr></table></figure><p>在第二行我们看到了个很奇怪的地址<code>0x402400</code>先把它移动到了<code>esi</code>里，有使用了一个判断字符是否相等的函数，所以我们可以大胆推测密码应该就在<code>0x402400</code>里,直接展示这个地址里的数据：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109211752381.png" alt="image-20210921175234221" /></p><p>猜的差不多，我们再run一次，这次直接把上面的字符粘贴进去：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109211755754.png" alt="image-20210921175556714" /></p><p>发现已经通过了第一关</p><p>注意：在每个lab里，每个使用到了固定地址的都很重要，一般都要打印出来看看是个啥</p><p>hhh在这里还发现了点彩蛋</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109242321631.png" alt="image-20210921183658215" /></p><h1 id="phase2"><a class="markdownIt-Anchor" href="#phase2"></a> phase2</h1><p>现在我们已经有了第一关的密码，所以我们先把它存到一个文档里，然后进入gdb，设置好断点后设置一下命令参数，然后run一波，可以看到我们已经过了第一个phase</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109242340808.png" alt="image-20210924234044751" /></p><p>接下来我们开始解决phase2，随便输入一点参数后进入phase2，phase2的反汇编代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:    55                   push   %rbp</span><br><span class="line">  400efd:    53                   push   %rbx</span><br><span class="line">  400efe:    48 83 ec 28          sub    $0x28,%rsp# 堆栈操作</span><br><span class="line">  400f02:    48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  400f05:    e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;# 读入6个数字</span><br><span class="line">  400f0a:    83 3c 24 01          cmpl   $0x1,(%rsp)</span><br><span class="line">  400f0e:    74 20                je     400f30 &lt;phase_2+0x34&gt;# 堆栈顶部数字 != 1 爆炸</span><br><span class="line">  400f10:    e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:    eb 19                jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  循环体：</span><br><span class="line">  &#123;</span><br><span class="line">  400f17:    8b 43 fc             mov    -0x4(%rbx),%eax# %eax = %rsp </span><br><span class="line">  400f1a:    01 c0                add    %eax,%eax# (%eax) += (%eax)</span><br><span class="line">  400f1c:    39 03                cmp    %eax,(%rbx)# %eax == valueat(%rsp+4)</span><br><span class="line">  400f1e:    74 05                je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:    e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:    48 83 c3 04          add    $0x4,%rbx# %rbx += 4 #地址+4，相当于移向下一个数</span><br><span class="line">  400f29:    48 39 eb             cmp    %rbp,%rbx# %rbx == %rsp+24#rbx是否为第六个数后的地址</span><br><span class="line">  400f2c:    75 e9                jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  400f2e:    eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:    48 8d 5c 24 04       lea    0x4(%rsp),%rbx# %rbx = %rsp+4 #rbx存储的应该是地址</span><br><span class="line">  400f35:    48 8d 6c 24 18       lea    0x18(%rsp),%rbp# %rbp = %rsp+24</span><br><span class="line">  400f3a:    eb db                jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:    48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  400f40:    5b                   pop    %rbx</span><br><span class="line">  400f41:    5d                   pop    %rbp</span><br><span class="line">  400f42:    c3                   retq   </span><br></pre></td></tr></table></figure><p>这段代码比较长，仔细看可以看出来第一次判断的数字一定是1，需要六个数字，然后每次判断的数字都是前一个数字的两倍，于是我们就可以推导出来答案是<code>1 2 4 8 16 32</code></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109250022389.png" alt="image-20210925002200317" /></p><h1 id="phase3"><a class="markdownIt-Anchor" href="#phase3"></a> phase3</h1><p>phase3的代码稍微有点长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:    48 83 ec 18          sub    $0x18,%rsp</span><br><span class="line">  400f47:    48 8d 4c 24 0c       lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:    48 8d 54 24 08       lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:    be cf 25 40 00       mov    $0x4025cf,%esi</span><br><span class="line">  400f56:    b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400f5b:    e8 90 fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:    83 f8 01             cmp    $0x1,%eax</span><br><span class="line">  400f63:    7f 05                jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:    e8 d0 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:    83 7c 24 08 07       cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:    77 3c                ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">  400f71:    8b 44 24 08          mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:    ff 24 c5 70 24 40 00 jmpq   *0x402470(,%rax,8)</span><br><span class="line">  400f7c:    b8 cf 00 00 00       mov    $0xcf,%eax</span><br><span class="line">  400f81:    eb 3b                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:    b8 c3 02 00 00       mov    $0x2c3,%eax</span><br><span class="line">  400f88:    eb 34                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:    b8 00 01 00 00       mov    $0x100,%eax</span><br><span class="line">  400f8f:    eb 2d                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:    b8 85 01 00 00       mov    $0x185,%eax</span><br><span class="line">  400f96:    eb 26                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:    b8 ce 00 00 00       mov    $0xce,%eax</span><br><span class="line">  400f9d:    eb 1f                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:    b8 aa 02 00 00       mov    $0x2aa,%eax</span><br><span class="line">  400fa4:    eb 18                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:    b8 47 01 00 00       mov    $0x147,%eax</span><br><span class="line">  400fab:    eb 11                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:    e8 88 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:    b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400fb7:    eb 05                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:    b8 37 01 00 00       mov    $0x137,%eax</span><br><span class="line">  400fbe:    3b 44 24 0c          cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:    74 05                je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:    e8 71 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:    48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  400fcd:    c3                   retq   </span><br></pre></td></tr></table></figure><p>阅读下来看到第四行有个奇怪的地址<code>0x4025cf</code>，不管三七二十一先把它打印出来看看：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109250025504.png" alt="image-20210925002556461" /></p><p>可以看出来题目需要我们输入两个整数</p><p>继续往下读，看到它使用了一个好像是库函数的函数<code>&lt;__isoc99_sscanf@plt&gt;</code>搜了一下得知它的返回数字为读入的数字数目</p><p>接下来就是比较了一下我们输入的第一个数字是否大于7，然后跳转到<code>0x402470+8*%rax</code>的位置，此时我们rax有0~7一共八种选择，所以我们打印一下<code>0x402470</code>附近的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/8a 0x402470</span><br><span class="line">0x402470:    0x400f7c &lt;phase_3+57&gt;0x400fb9 &lt;phase_3+118&gt;</span><br><span class="line">0x402480:    0x400f83 &lt;phase_3+64&gt;0x400f8a &lt;phase_3+71&gt;</span><br><span class="line">0x402490:    0x400f91 &lt;phase_3+78&gt;0x400f98 &lt;phase_3+85&gt;</span><br><span class="line">0x4024a0:    0x400f9f &lt;phase_3+92&gt;0x400fa6 &lt;phase_3+99&gt;</span><br></pre></td></tr></table></figure><p>再对照代码中的逻辑可以知道按照以下任意一对数字输入都可以通过</p><table><thead><tr><th style="text-align:center">数字1</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">数字2</td><td style="text-align:center">207</td><td style="text-align:center">311</td><td style="text-align:center">707</td><td style="text-align:center">256</td><td style="text-align:center">389</td><td style="text-align:center">206</td><td style="text-align:center">682</td><td style="text-align:center">327</td></tr></tbody></table><h1 id="phase4"><a class="markdownIt-Anchor" href="#phase4"></a> phase4</h1><p>接下来我们就进入到了phase_4，它的反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">=&gt; 0x000000000040100c &lt;+0&gt;:        sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401010 &lt;+4&gt;:        lea    0xc(%rsp),%rcx# %rcx = %rsp + 12</span><br><span class="line">   0x0000000000401015 &lt;+9&gt;:        lea    0x8(%rsp),%rdx# %rdx = %rsp + 8</span><br><span class="line">   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi# 0x4025cf:&quot;%d %d&quot;</span><br><span class="line">   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax</span><br><span class="line">   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)# (%rsp+8) &lt;= 14</span><br><span class="line">   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx# %edx = 14</span><br><span class="line">   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi# %esi = 0</span><br><span class="line">   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi# %edi = %rsp + 8 </span><br><span class="line">   0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax</span><br><span class="line">   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;# 返回值%rax一定为0</span><br><span class="line">   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)</span><br><span class="line">   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;# (%rsp + 12) == 0</span><br><span class="line">   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp</span><br><span class="line">   0x0000000000401061 &lt;+85&gt;:    retq   </span><br></pre></td></tr></table></figure><p>第四行出现了一个地址，打印之后得到的是<code># 0x4025cf:&quot;%d %d&quot;</code>说明需要我们输入两个整数，然后继续往下读，在倒数第四行可以看出来我们要输入的一个数字一定为0。func4具体的内容还不清楚，把func4的代码输出一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function func4:</span><br><span class="line">=&gt; 0x0000000000400fce &lt;+0&gt;:        sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:        mov    %edx,%eax# %eax = 14</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:        sub    %esi,%eax# %eax -= %esi = 14-0 = 14</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:        mov    %eax,%ecx# %ecx = %eax = 14</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx# %ecx&gt;&gt;31 = 0//%ecx = sign of %eax</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax# %eax += %ecx = 14</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:    sar    %eax# %eax&gt;&gt;1 // %eax = 7</span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx# %ecx = %rax+%rsi = 7+0=7</span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx</span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;# %edi = %ecx</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx# %edx = %rcx-1</span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax# %eax = 2*%eax</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax# %eax = 0</span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx# %ecx &gt;= %edi?</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi# %esi = %rcx+1</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax# %rax = 2%rax</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x000000000040100b &lt;+61&gt;:    retq  </span><br></pre></td></tr></table></figure><p>在func4里推了一推，发现7满足要求，所以答案可以为<code>7 0</code></p><p>看了下知乎大佬<a href="https://www.zhihu.com/people/yansongtw">@Yannick</a>逆向出来的C代码，发现答案不止一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a:%rdi b:%rsi  c:%rdx</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">  <span class="type">int</span> return_v = c - b; <span class="comment">// %rax</span></span><br><span class="line">  <span class="type">int</span> t = ((<span class="type">unsigned</span>)return_v) &gt;&gt; <span class="number">31</span>; <span class="comment">// %rcx</span></span><br><span class="line">  return_v = (t + return_v) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  t = return_v + b;</span><br><span class="line">  <span class="keyword">if</span> (t - a &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    return_v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (t - a &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> return_v;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      b = t + <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> r = func4(a,b,c);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span> * r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = t - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r = func4(a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后的代码</span></span><br><span class="line"><span class="comment">// x为输入的数</span></span><br><span class="line"><span class="comment">// y为0 z为14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k = z - y;</span><br><span class="line">    k = ((<span class="type">int</span>)(((<span class="type">unsigned</span>)k&gt;&gt;<span class="number">31</span>) + k) &gt;&gt; <span class="number">1</span>) + y;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*func4(x, k+<span class="number">1</span>, z)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*func4(x, y, k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现其实第一个数的取值范围是[0,0xe]，我们可以对它进行一个穷举：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(!func4(i, <span class="number">0</span>, <span class="number">14</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ./func4 </span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>所以最终答案是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 | 1 0 | 3 0 | 7 0</span><br></pre></td></tr></table></figure><h1 id="phase_5"><a class="markdownIt-Anchor" href="#phase_5"></a> phase_5</h1><p>进入phase_5，首先查看phase5的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">=&gt; 0x0000000000401062 &lt;+0&gt;:        push   %rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:        sub    $0x20,%rsp#堆栈相关</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:        mov    %rdi,%rbx# rbx = rdi</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:        mov    %fs:0x28,%rax# 将内存中一段数据移到rax</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)# rax = (rsp + 24)</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax# 输入的字符串长度为6</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   </span><br><span class="line">   # 循环,作用为将读入的字符串取二进制后四位作为偏移量，从0x4024b0处偏移取出字符，然后压入堆栈</span><br><span class="line">   &#123;</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx# ecx = rax+rbx = rax</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)# (rsp) = ecx</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx# rdx = rsp</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx# 取edx二进制的后四位</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx# edx = rdx+0x4024b0</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)# rsp+rax+10 = rdx</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax# rax += 1</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;# rax!=6时循环</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:    nopl   0x0(%rax,%rax,1)</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:    jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:    mov    $0x0,%eax# eax = 0</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:    jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:    mov    0x18(%rsp),%rax</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:    xor    %fs:0x28,%rax</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:    je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:    callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:    add    $0x20,%rsp</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:    pop    %rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:    retq   </span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>可以看到这段代码的逻辑是取出输入的字符的二进制后四位作为偏移量，从0x4024b0处偏移此偏移量取出字符，然后压入堆栈，再到后面的循环中从第一个压入的堆栈与地址<code>$0x40245e</code>中所含的字符进行比较，先打印<code>0x4024b0</code>处的字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4024b0</span><br><span class="line">0x4024b0 &lt;array.3449&gt;:    <span class="string">&quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span></span><br></pre></td></tr></table></figure><p>再打印<code>$0x40245e</code>中的字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br><span class="line">0x40245e:    <span class="string">&quot;flyers&quot;</span></span><br></pre></td></tr></table></figure><p>由此可知<strong>我们只要让输入的6个字符的ascii码的后四位作为偏移量，在<code>maduiersnfotvbyl</code>这十六个字符中偏移正确的值，最后取出flyers</strong>就可以了，flyers 对应的偏移量为 9fe567</p><p>所以我们的答案就很显然了，在Terminal中使用<code>man ascii</code>语句查看所有字符对应的ascii码，找出正确偏移的字符，得到一组可行的答案：<code>9?&gt;567</code></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109251104999.jpeg" alt="img" /></p><h1 id="phase_6"><a class="markdownIt-Anchor" href="#phase_6"></a> phase_6</h1><p>phase_6的代码就有点长了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:    41 56                push   %r14</span><br><span class="line">  4010f6:    41 55                push   %r13</span><br><span class="line">  4010f8:    41 54                push   %r12</span><br><span class="line">  4010fa:    55                   push   %rbp</span><br><span class="line">  4010fb:    53                   push   %rbx</span><br><span class="line">  4010fc:    48 83 ec 50          sub    $0x50,%rsp</span><br><span class="line">  401100:    49 89 e5             mov    %rsp,%r13</span><br><span class="line">  401103:    48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  401106:    e8 51 03 00 00       callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  </span><br><span class="line">  40110b:    49 89 e6             mov    %rsp,%r14# r14 = rsp[0]</span><br><span class="line">  40110e:    41 bc 00 00 00 00    mov    $0x0,%r12d# r12d = 0</span><br><span class="line">  # 循环体2 r13每次+4，r12每次+1直到r12 = 6</span><br><span class="line">  &#123;</span><br><span class="line">  401114:    4c 89 ed             mov    %r13,%rbp# rbp = r13</span><br><span class="line">  401117:    41 8b 45 00          mov    0x0(%r13),%eax# eax = r13+0x0</span><br><span class="line">  40111b:    83 e8 01             sub    $0x1,%eax# eax--</span><br><span class="line">  40111e:    83 f8 05             cmp    $0x5,%eax# 小于等于5时不爆炸</span><br><span class="line">  401121:    76 05                jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:    e8 12 03 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401128:    41 83 c4 01          add    $0x1,%r12d# r12d += 1</span><br><span class="line">  40112c:    41 83 fc 06          cmp    $0x6,%r12d</span><br><span class="line">  401130:    74 21                je     401153 &lt;phase_6+0x5f&gt;# r12d是否等于6</span><br><span class="line">  401132:    44 89 e3             mov    %r12d,%ebx# ebx = r12d</span><br><span class="line">  </span><br><span class="line">  # 循环体1，作用为读入堆栈上的第2-6个数字，和第1个数字相比，如果相同就爆炸</span><br><span class="line">      &#123;</span><br><span class="line">  401135:    48 63 c3             movslq %ebx,%rax# rax = ebx</span><br><span class="line">  401138:    8b 04 84             mov    (%rsp,%rax,4),%eax# 读入堆栈上第rax个数放到eax上</span><br><span class="line">  40113b:    39 45 00             cmp    %eax,0x0(%rbp)</span><br><span class="line">  40113e:    75 05                jne    401145 &lt;phase_6+0x51&gt;# eax 为rbp的第0个数时 爆炸</span><br><span class="line">  401140:    e8 f5 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:    83 c3 01             add    $0x1,%ebx# ebx += 1 </span><br><span class="line">  401148:    83 fb 05             cmp    $0x5,%ebx</span><br><span class="line">  40114b:    7e e8                jle    401135 &lt;phase_6+0x41&gt;# 小于等于5跳转</span><br><span class="line">      &#125;</span><br><span class="line">  40114d:    49 83 c5 04          add    $0x4,%r13# r13 += 4</span><br><span class="line">  401151:    eb c1                jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  401153:    48 8d 74 24 18       lea    0x18(%rsp),%rsi# rsi = rsp[6]</span><br><span class="line">  401158:    4c 89 f0             mov    %r14,%rax# rax = r14 = *rsp[0]</span><br><span class="line">  40115b:    b9 07 00 00 00       mov    $0x7,%ecx# ecx = 7</span><br><span class="line">  </span><br><span class="line">  # 循环体3, 对输入的每个数进行 a[i] = 7 - a[i]操作</span><br><span class="line">  &#123;</span><br><span class="line">  401160:    89 ca                mov    %ecx,%edx# edx = 7</span><br><span class="line">  401162:    2b 10                sub    (%rax),%edx# edx -= rax</span><br><span class="line">  401164:    89 10                mov    %edx,(%rax)# (rax) = 7-rsp[0]</span><br><span class="line">  401166:    48 83 c0 04          add    $0x4,%rax# rax += 4</span><br><span class="line">  40116a:    48 39 f0             cmp    %rsi,%rax</span><br><span class="line">  40116d:    75 f1                jne    401160 &lt;phase_6+0x6c&gt;# 循环直到 rax == rsp[0]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  40116f:    be 00 00 00 00       mov    $0x0,%esi# esi = 0</span><br><span class="line">  401174:    eb 21                jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">  </span><br><span class="line">  # 循环体4，rsi == 24时跳出</span><br><span class="line">  &#123;</span><br><span class="line">  # 循环5，ecx == eax 跳出//即eax == 7 跳出</span><br><span class="line">      &#123;</span><br><span class="line">  401176:    48 8b 52 08          mov    0x8(%rdx),%rdx# rdx = (rdx所存地址+8)</span><br><span class="line">  40117a:    83 c0 01             add    $0x1,%eax# eax += 1</span><br><span class="line">  40117d:    39 c8                cmp    %ecx,%eax</span><br><span class="line">  40117f:    75 f5                jne    401176 &lt;phase_6+0x82&gt;# ecx = eax</span><br><span class="line">      &#125;</span><br><span class="line">  401181:    eb 05                jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  </span><br><span class="line">  # 循环体6，ecx &gt; 1 跳出</span><br><span class="line">      &#123;</span><br><span class="line">  401183:    ba d0 32 60 00       mov    $0x6032d0,%edx# edx = 0x6032d0</span><br><span class="line">  401188:    48 89 54 74 20       mov    %rdx,0x20(%rsp,%rsi,2)# rsp + 0x20 + 2rsi = rdx</span><br><span class="line">  40118d:    48 83 c6 04          add    $0x4,%rsi# rsi += 4</span><br><span class="line">  401191:    48 83 fe 18          cmp    $0x18,%rsi</span><br><span class="line">  401195:    74 14                je     4011ab &lt;phase_6+0xb7&gt;# rsi == 24</span><br><span class="line">  401197:    8b 0c 34             mov    (%rsp,%rsi,1),%ecx# ecx = rsp[rsi]</span><br><span class="line">  40119a:    83 f9 01             cmp    $0x1,%ecx</span><br><span class="line">  40119d:    7e e4                jle    401183 &lt;phase_6+0x8f&gt;# ecx &lt;= 1</span><br><span class="line">      &#125;</span><br><span class="line">  40119f:    b8 01 00 00 00       mov    $0x1,%eax# eax = 1</span><br><span class="line">  4011a4:    ba d0 32 60 00       mov    $0x6032d0,%edx# edx = 0x6032d0</span><br><span class="line">  4011a9:    eb cb                jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  4011ab:    48 8b 5c 24 20       mov    0x20(%rsp),%rbx# rbx = rsp[8]</span><br><span class="line">  4011b0:    48 8d 44 24 28       lea    0x28(%rsp),%rax# rax = rsp[9]</span><br><span class="line">  4011b5:    48 8d 74 24 50       lea    0x50(%rsp),%rsi# rax = rsp[20]</span><br><span class="line">  4011ba:    48 89 d9             mov    %rbx,%rcx# rcx = rbx</span><br><span class="line">  </span><br><span class="line">  # 循环7,循环直到rsi == rax</span><br><span class="line">  &#123;</span><br><span class="line">  4011bd:    48 8b 10             mov    (%rax),%rdx# rdx = rax</span><br><span class="line">  4011c0:    48 89 51 08          mov    %rdx,0x8(%rcx)# (rcx+8) = rax</span><br><span class="line">  4011c4:    48 83 c0 08          add    $0x8,%rax# rax += 8</span><br><span class="line">  4011c8:    48 39 f0             cmp    %rsi,%rax</span><br><span class="line">  4011cb:    74 05                je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:    48 89 d1             mov    %rdx,%rcx</span><br><span class="line">  4011d0:    eb eb                jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  4011d2:    48 c7 42 08 00 00 00 movq   $0x0,0x8(%rdx)# (rdx + 8) = 0</span><br><span class="line">  4011d9:    00 </span><br><span class="line">  4011da:    bd 05 00 00 00       mov    $0x5,%ebp# ebp = 5</span><br><span class="line">  </span><br><span class="line">  # 循环8 循环直到ebp &lt; 0</span><br><span class="line">  &#123;</span><br><span class="line">  4011df:    48 8b 43 08          mov    0x8(%rbx),%rax# rax = (rbx + 8)</span><br><span class="line">  4011e3:    8b 00                mov    (%rax),%eax# eax = (rax)</span><br><span class="line">  4011e5:    39 03                cmp    %eax,(%rbx)</span><br><span class="line">  4011e7:    7d 05                jge    4011ee &lt;phase_6+0xfa&gt;# 如果 rbx &lt; eax,爆炸</span><br><span class="line">  4011e9:    e8 4c 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:    48 8b 5b 08          mov    0x8(%rbx),%rbx# rbx = (rbx + 8)</span><br><span class="line">  4011f2:    83 ed 01             sub    $0x1,%ebp# ebp--</span><br><span class="line">  4011f5:    75 e8                jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  4011f7:    48 83 c4 50          add    $0x50,%rsp</span><br><span class="line">  4011fb:    5b                   pop    %rbx</span><br><span class="line">  4011fc:    5d                   pop    %rbp</span><br><span class="line">  4011fd:    41 5c                pop    %r12</span><br><span class="line">  4011ff:    41 5d                pop    %r13</span><br><span class="line">  401201:    41 5e                pop    %r14</span><br><span class="line">  401203:    c3                   retq   </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/24w 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:    332163044800</span><br><span class="line">0x6032e0 &lt;node2&gt;:    168263044960</span><br><span class="line">0x6032f0 &lt;node3&gt;:    924363045120</span><br><span class="line">0x603300 &lt;node4&gt;:    691463045280</span><br><span class="line">0x603310 &lt;node5&gt;:    477563045440</span><br><span class="line">0x603320 &lt;node6&gt;:    443600</span><br></pre></td></tr></table></figure><p>可以看出来前面的代码要求我们输入的数字都不一样且小于等于6，然后它里面有有个链表需要我们进行比较，我们输入的数字的顺序就是比较链表节点的顺序，而其中有个判断又需要我们将比较的这些链表中的数据降序输出，带入数字推断后得到期望的顺序<code>3 4 5 6 1 2</code>，每位都与7取余后得到答案: <code>4 3 2 1 6 5</code></p><p>写的很简陋，详细的分析建议看大佬的<a href="https://zhuanlan.zhihu.com/p/104130161">Introduction to CSAPP（十九）：这可能是你能找到的分析最全的Bomblab了</a></p><h1 id="secret-phase"><a class="markdownIt-Anchor" href="#secret-phase"></a> secret phase</h1><p>在看bomb文件的反汇编代码的时候，看到了个<code>secret_phase</code>全局搜索后在<code>phase_defuse</code>中发现了调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">4015c4:  sub    $0x78,%rsp</span><br><span class="line">4015c8:  mov    %fs:0x28,%rax</span><br><span class="line">4015cf:  </span><br><span class="line">4015d1:  mov    %rax,0x68(%rsp)</span><br><span class="line">4015d6:  xor    %eax,%eax</span><br><span class="line">4015d8:  cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;</span><br><span class="line">4015df:  jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line">4015e1:  lea    0x10(%rsp),%r8</span><br><span class="line">4015e6:  lea    0xc(%rsp),%rcx</span><br><span class="line">4015eb:  lea    0x8(%rsp),%rdx</span><br><span class="line">4015f0:  mov    $0x402619,%esi # 这里包括下面发现了奇怪的地址，打印看看，发现是 &quot;%d %d %s&quot;</span><br><span class="line">4015f5:  mov    $0x603870,%edi # 这里是 &quot;&quot;</span><br><span class="line">4015fa:  callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">4015ff:  cmp    $0x3,%eax # sscanf的返回值表示输入的参数个数，如果是3个，就到401604行，那么究竟什么时候会执行这段逻辑呢？</span><br><span class="line">401602:  jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401604:  mov    $0x402622,%esi # &quot;DrEvil&quot;</span><br><span class="line">401609:  lea    0x10(%rsp),%rdi # 比较 &quot;DrEvil&quot; 和某个值</span><br><span class="line">40160e:  callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">401613:  test   %eax,%eax</span><br><span class="line">401615:  jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401617:  mov    $0x4024f8,%edi # &quot;Curses, you&#x27;ve found the secret phase!&quot;</span><br><span class="line">40161c:  callq  400b10 &lt;puts@plt&gt; # 打印之</span><br><span class="line">401621:  mov    $0x402520,%edi # &quot;But finding it and solving it are quite different...&quot;</span><br><span class="line">401626:  callq  400b10 &lt;puts@plt&gt; # 打印之</span><br><span class="line">40162b:  mov    $0x0,%eax</span><br><span class="line">401630:  callq  401242 &lt;secret_phase&gt; # 调用了彩蛋关</span><br><span class="line">401635:  mov    $0x402558,%edi # &quot;Congratulations! You&#x27;ve defused the bomb!&quot;</span><br><span class="line">40163a:  callq  400b10 &lt;puts@plt&gt; # 打印之</span><br><span class="line">40163f:  mov    0x68(%rsp),%rax</span><br><span class="line">401644:  xor    %fs:0x28,%rax</span><br><span class="line">40164b:  </span><br><span class="line">40164d:  je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line">40164f:  callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">401654:  add    $0x78,%rsp</span><br><span class="line">401658:  retq   </span><br><span class="line">401659:  nop</span><br><span class="line">40165a:  nop</span><br><span class="line">40165b:  nop</span><br><span class="line">40165c:  nop</span><br><span class="line">40165d:  nop</span><br><span class="line">40165e:  nop</span><br><span class="line">40165f:  nop</span><br></pre></td></tr></table></figure><p>阅读后发现在前面某个关卡处输入的秘文为整数 整数 字符串时进入secret，推测字符串为前文发现的<code>DrEvil</code>，又发现只有phase4和phase3能满足这个要求，然后都尝试后发现在phase4输入的秘文后接一个<code>DrEvil</code>可以进入隐藏的secret_phase，以下为secret_phase的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">401242:  push   %rbx</span><br><span class="line">401243:  callq  40149e &lt;read_line&gt;</span><br><span class="line">401248:  mov    $0xa,%edx</span><br><span class="line">40124d:  mov    $0x0,%esi</span><br><span class="line">401252:  mov    %rax,%rdi</span><br><span class="line">401255:  callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">40125a:  mov    %rax,%rbx # 断点可以设置在这里，打印后发现，rax中存的是我们输入的值</span><br><span class="line">40125d:  lea    -0x1(%rax),%eax # eax = eax - 1</span><br><span class="line">401260:  cmp    $0x3e8,%eax # eax - 0x3e8 &lt;= 0 即 in - 1 &lt;= 1000</span><br><span class="line">401265:  jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">401267:  callq  40143a &lt;explode_bomb&gt; # 不满足时 爆炸</span><br><span class="line">40126c:  mov    %ebx,%esi # 这个是我们输入的值</span><br><span class="line">40126e:  mov    $0x6030f0,%edi # 观察输入的参数：</span><br><span class="line"># (gdb) x 0x6030f0</span><br><span class="line"># 0x6030f0 &lt;n1&gt;:  0x00000024</span><br><span class="line">401273:  callq  401204 &lt;fun7&gt;</span><br><span class="line">401278:  cmp    $0x2,%eax</span><br><span class="line">40127b:  je     401282 &lt;secret_phase+0x40&gt; # fun7返回值和2比，如果等于零，则成功</span><br><span class="line">40127d:  callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401282:  mov    $0x402438,%edi</span><br><span class="line">401287:  callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">40128c:  callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">401291:  pop    %rbx</span><br></pre></td></tr></table></figure><p>关键点就在于func7这个函数了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line"># %esi 存我们输入的值</span><br><span class="line"># %edi 存某一地址</span><br><span class="line">401204: sub    $0x8,%rsp</span><br><span class="line">401208: test   %rdi,%rdi # 查看是否为null</span><br><span class="line">40120b: je     401238 &lt;fun7+0x34&gt; # 满足跳转</span><br><span class="line">40120d: mov    (%rdi),%edx </span><br><span class="line">40120f: cmp    %esi,%edx</span><br><span class="line">401211: jle    401220 &lt;fun7+0x1c&gt;</span><br><span class="line">401213: mov    0x8(%rdi),%rdi</span><br><span class="line">401217: callq  401204 &lt;fun7&gt;</span><br><span class="line">40121c: add    %eax,%eax</span><br><span class="line">40121e: jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">401220: mov    $0x0,%eax</span><br><span class="line">401225: cmp    %esi,%edx</span><br><span class="line">401227: je     40123d &lt;fun7+0x39&gt;</span><br><span class="line">401229: mov    0x10(%rdi),%rdi</span><br><span class="line">40122d: callq  401204 &lt;fun7&gt;</span><br><span class="line">401232: lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">401236: jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">401238: mov    $0xffffffff,%eax # 返回全1序列</span><br><span class="line">40123d: add    $0x8,%rsp</span><br><span class="line">401241: retq</span><br></pre></td></tr></table></figure><p>大佬<a href="https://www.zhihu.com/people/yansongtw">@Yannick</a>逆向的等价C语言:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun7</span><span class="params">(<span class="type">int</span> cmp, Node* addr)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(addr == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> v = addr-&gt;value;</span><br><span class="line">  <span class="keyword">if</span> (v == cmp)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( v &lt; cmp)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span>*fun7(cmp, addr-&gt;right);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*func7(cmp, addr-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看这个二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/120 0x6030f0</span><br><span class="line">0x6030f0 &lt;n1&gt;:    36063040160</span><br><span class="line">0x603100 &lt;n1+16&gt;:    6304048000</span><br><span class="line">0x603110 &lt;n21&gt;:    8063041440</span><br><span class="line">0x603120 &lt;n21+16&gt;:    6304080000</span><br><span class="line">0x603130 &lt;n22&gt;:    50063041120</span><br><span class="line">0x603140 &lt;n22+16&gt;:    6304176000</span><br><span class="line">0x603150 &lt;n32&gt;:    22063043680</span><br><span class="line">0x603160 &lt;n32+16&gt;:    6304304000</span><br><span class="line">0x603170 &lt;n33&gt;:    45063042080</span><br><span class="line">0x603180 &lt;n33+16&gt;:    6304400000</span><br><span class="line">0x603190 &lt;n31&gt;:    6063042400</span><br><span class="line">0x6031a0 &lt;n31+16&gt;:    6304336000</span><br><span class="line">0x6031b0 &lt;n34&gt;:    107063042720</span><br><span class="line">0x6031c0 &lt;n34+16&gt;:    6304432000</span><br><span class="line">0x6031d0 &lt;n45&gt;:    40000</span><br><span class="line">0x6031e0 &lt;n45+16&gt;:    0000</span><br><span class="line">0x6031f0 &lt;n41&gt;:    1000</span><br><span class="line">0x603200 &lt;n41+16&gt;:    0000</span><br><span class="line">0x603210 &lt;n47&gt;:    99000</span><br><span class="line">0x603220 &lt;n47+16&gt;:    0000</span><br><span class="line">0x603230 &lt;n44&gt;:    35000</span><br><span class="line">0x603240 &lt;n44+16&gt;:    0000</span><br><span class="line">0x603250 &lt;n42&gt;:    7000</span><br><span class="line">0x603260 &lt;n42+16&gt;:    0000</span><br><span class="line">0x603270 &lt;n43&gt;:    20000</span><br><span class="line">0x603280 &lt;n43+16&gt;:    0000</span><br><span class="line">0x603290 &lt;n46&gt;:    47000</span><br><span class="line">0x6032a0 &lt;n46+16&gt;:    0000</span><br><span class="line">0x6032b0 &lt;n48&gt;:    1001000</span><br><span class="line">0x6032c0 &lt;n48+16&gt;:    0000</span><br></pre></td></tr></table></figure><p>画出其结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">└─ 36</span><br><span class="line">   ├─ 8</span><br><span class="line">   │  ├─ 6</span><br><span class="line">   │  │  ├─ left: 1</span><br><span class="line">   │  │  └─ right: 7</span><br><span class="line">   │  └─ 22</span><br><span class="line">   │     ├─ left: 20</span><br><span class="line">   │     └─ right: 35</span><br><span class="line">   └─ 50</span><br><span class="line">      ├─ 45</span><br><span class="line">      │  ├─ left: 40</span><br><span class="line">      │  └─ right: 47</span><br><span class="line">      └─ 107</span><br><span class="line">         ├─ left: 99</span><br><span class="line">         └─ right: 1001</span><br></pre></td></tr></table></figure><p>然后我就穷举了。。。</p><p>得到的答案是<code>22</code>或者<code>20</code>，终于拆外所有炸弹</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109251141149.png" alt="image-20210925114142077" /></p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://wdxtub.com/csapp/thick-csapp-lab-2/2016/04/16/">【读厚 CSAPP】II Bomb Lab</a></p><p><a href="https://zhuanlan.zhihu.com/p/104130161">Introduction to CSAPP（十九）：这可能是你能找到的分析最全的Bomblab了</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前言：看了好久的书，写了好几个晚上，参考了一些大佬的笔记，终于把这个bomblab写完了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;实验简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实验简介&quot;&gt;&lt;/a&gt; 实验简介&lt;/h1&gt;
&lt;p&gt;这个著名的bomblab为我们提供了一个二进制文件，然后我们需要将这个二进制文件进行反汇编得到一堆的汇编文件，通过阅读汇编文件中的代码以及GDB的调试来得到需要输入的字符密码来进入下一关。&lt;/p&gt;
&lt;p&gt;整个实验一共有六个正式关卡，一个隐藏关卡，密码和进入隐藏关卡的方法也藏在文件中，需要我们一点点的探寻其中的蛛丝马迹，拆开炸弹。如果拆弹失败的话，实验文件会给我们打印出一个BOMB！！！如果你是CMU的学生，每次不小心的BOMB还会扣你这个实验的分数，不过我们不是CMU的学生，就随便他炸了23333&lt;/p&gt;
&lt;h1 id=&quot;准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#准备工作&quot;&gt;&lt;/a&gt; 准备工作&lt;/h1&gt;
&lt;p&gt;没有实验文件的需要先到&lt;a href=&quot;http://csapp.cs.cmu.edu/3e/bomb.tar&quot;&gt;这个网站&lt;/a&gt;下载一个&lt;/p&gt;
&lt;p&gt;首先我们需要进入到这个lab的文件所在的文件夹下，可以看到有README、bomb、和bomb.c三个文件，我们先打开bomb.c看看有些什么东西&lt;/p&gt;
&lt;p&gt;可以看到有6个phase，每个phase基本都是要我们输入一段字符，然后它调用了判断我们字符对不对的函数。大概浏览一下，知道要干什么之后先把bomb文件反汇编一下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objdump bomb -d &amp;gt; disassemble.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;得到了bomb的反汇编代码打开&lt;/p&gt;
&lt;p&gt;看到一堆莫名其妙的东西，不知道怎么下手，想起来之前有6个phase，于是就搜索了下phase，找到了phase所在地，就用GDB来进行调试了&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gdb bomb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后给爆炸和phase_1先打上断点&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;b explode_bomb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b phase_1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;run了之后，随便输入一点字符进入phase_1，先把当前的函数用disas指令反汇编一下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不熟悉GDB调试的可以参考CMU的&lt;a href=&quot;http://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf&quot;&gt;课程提供的手册&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="SnowMoonの项目记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="CSAPP" scheme="https://www.snowmoon.top/tags/CSAPP/"/>
    
    <category term="bomblab" scheme="https://www.snowmoon.top/tags/bomblab/"/>
    
  </entry>
  
  <entry>
    <title>动态规划2——线性动态规划问题</title>
    <link href="https://www.snowmoon.top/2021/09/07/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A02/"/>
    <id>https://www.snowmoon.top/2021/09/07/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A02/</id>
    <published>2021-09-07T00:30:00.000Z</published>
    <updated>2023-11-30T16:44:48.205Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：本文为学习力扣文章<a href="https://leetcode-cn.com/leetbook/detail/dynamic-programming-1-plus/">《动态规划精讲（一）》</a>时的学习笔记，本文对其进行线性动态规划相关的文章和问题进行了一定的转载和修改并在其中加入了一些个人的理解。</p></blockquote><h1 id="线性动态规划简介"><a class="markdownIt-Anchor" href="#线性动态规划简介"></a> 线性动态规划简介</h1><p>线性动态规划主要是从0开始从小到大依次递推过去的，特点为问题规模依次从0到i依次递增，较大规模的问题依赖较小规模问题的解</p><p>这里问题规模为 i 的含义是考虑前 i 个元素 [0…i] 时问题的解。</p><p>状态定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[n] := [0..n] 上问题的解</span><br></pre></td></tr></table></figure><p>状态转移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[n] = f(dp[n-1], ..., dp[0])</span><br></pre></td></tr></table></figure><h1 id="单串"><a class="markdownIt-Anchor" href="#单串"></a> 单串</h1><p>单串是线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 dp[i] := 考虑[0…i]上，原问题的解，其中 i 位置的处理，根据不同的问题，主要有两种方式：</p><ul><li>第一种是 i 位置必须取，此时状态可以进一步描述为 dp[i] := 考虑[0…i]上，且取 i，原问题的解；</li><li>第二种是 i 位置可以取可以不取</li></ul><span id="more"></span><h2 id="1-依赖比-i-小的-o1-个子问题"><a class="markdownIt-Anchor" href="#1-依赖比-i-小的-o1-个子问题"></a> 1. 依赖比 i 小的 O(1) 个子问题</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></p><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><p>一个数组有很多个子数组，求哪个子数组的和最大。可以按照子数组的最后一个元素来分子问题，确定子问题后设计状态</p><p>状态的推导是按照 i 从 0 到 n - 1 按顺序推的，推到 dp[i]，时，dp[i - 1], …, dp[0] 已经计算完。因为子数组是连续的，所以子问题 dp[i] 其实只与子问题 dp[i - 1] 有关。如果 [0…i-1] 上以 nums[i-1] 结尾的最大子数组和(缓存在 dp[i-1] )为非负数，则以 nums[i] 结尾的最大子数组和就在 dp[i-1] 的基础上加上 nums[i] 就是 dp[i] 的结果否则以 i 结尾的子数组就不要 i-1 及之前的数，因为选了的话子数组的和只会更小。</p><p>按照以上的分析，状态的转移可以写出来，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = nums[i] + max(dp[i - 1], 0)</span><br></pre></td></tr></table></figure><h2 id="2-依赖比-i-小的-on-个子问题"><a class="markdownIt-Anchor" href="#2-依赖比-i-小的-on-个子问题"></a> 2. 依赖比 i 小的 O(n) 个子问题</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a></p><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p></blockquote><p>输入是一个单串，首先思考单串问题中设计状态 dp[i] 时拆分子问题的方式：枚举子串或子序列的结尾元素来拆分子问题，设计状态 dp[i] := 在子数组 [0…i] 上，且选了 nums[i] 时，的最长上升子序列。</p><p>因为子序列需要上升，因此以 i 结尾的子序列中，nums[i] 之前的数字一定要比 nums[i] 小才行，因此目标就是先找到以此前比 nums[i] 小的各个元素，然后每个所选元素对应一个以它们结尾的最长子序列，从这些子序列中选择最长的，其长度加 1 就是当前的问题的结果。如果此前没有比 nums[i] 小的数字，则当前问题的结果就是 1 。</p><p>按照以上的分析，状态的转移方程可以写出来，如下</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[i] = max_{j}(dp[j]) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">0 \leq j &lt; i, nums[j] &lt; nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>。</p><h2 id="单串问题最经典单串lis系列"><a class="markdownIt-Anchor" href="#单串问题最经典单串lis系列"></a> 单串问题：最经典单串LIS系列</h2><h3 id="1最长上升子序列"><a class="markdownIt-Anchor" href="#1最长上升子序列"></a> 1.最长上升子序列</h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>1 &lt;= nums.length &lt;= 2500</code><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">-10^4 \leq nums[i] \leq 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></p><p>进阶：</p><p>你可以设计时间复杂度为 O(n2) 的解决方案吗？</p><p>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前言：本文为学习力扣文章&lt;a href=&quot;https://leetcode-cn.com/leetbook/detail/dynamic-programming-1-plus/&quot;&gt;《动态规划精讲（一）》&lt;/a&gt;时的学习笔记，本文对其进行线性动态规划相关的文章和问题进行了一定的转载和修改并在其中加入了一些个人的理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;线性动态规划简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线性动态规划简介&quot;&gt;&lt;/a&gt; 线性动态规划简介&lt;/h1&gt;
&lt;p&gt;线性动态规划主要是从0开始从小到大依次递推过去的，特点为问题规模依次从0到i依次递增，较大规模的问题依赖较小规模问题的解&lt;/p&gt;
&lt;p&gt;这里问题规模为 i 的含义是考虑前 i 个元素 [0…i] 时问题的解。&lt;/p&gt;
&lt;p&gt;状态定义：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dp[n] := [0..n] 上问题的解&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;状态转移：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dp[n] = f(dp[n-1], ..., dp[0])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;单串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单串&quot;&gt;&lt;/a&gt; 单串&lt;/h1&gt;
&lt;p&gt;单串是线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 dp[i] := 考虑[0…i]上，原问题的解，其中 i 位置的处理，根据不同的问题，主要有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种是 i 位置必须取，此时状态可以进一步描述为 dp[i] := 考虑[0…i]上，且取 i，原问题的解；&lt;/li&gt;
&lt;li&gt;第二种是 i 位置可以取可以不取&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://www.snowmoon.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer15——双指针（简单）</title>
    <link href="https://www.snowmoon.top/2021/09/04/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer15/"/>
    <id>https://www.snowmoon.top/2021/09/04/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer15/</id>
    <published>2021-09-04T00:30:00.000Z</published>
    <updated>2023-11-30T16:46:03.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-25-合并两个排序的链表"><a class="markdownIt-Anchor" href="#剑指-offer-25-合并两个排序的链表"></a> <a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h1><p>难度 简单</p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 链表长度 &lt;= 1000</span><br></pre></td></tr></table></figure><p>注意：本题与主站 21 题相同：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><span id="more"></span><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>开辟一个空节点用来返回，也可以在进入循环前进行一下判断，不开辟节点直接进循环</p><p>循环：将l1和l2中值较大的节点作为当前节点的下一节点</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode *head,*cur;</span><br><span class="line">        head = (ListNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ListNode));</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>( l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-52-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#剑指-offer-52-两个链表的第一个公共节点"></a> <a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h1><p>难度 简单</p><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表**：**</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109050042866.png" alt="img" /></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109050042483.png" alt="img" /></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109050042893.png" alt="img" /></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Reference of the node with value = 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109050043045.png" alt="img" /></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li><li>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li></ul><h2 id="思路与题解"><a class="markdownIt-Anchor" href="#思路与题解"></a> 思路与题解</h2><p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p><p>这样，当它们相遇时，所指向的结点就是第一个公共结点。</p><p>两个链表长度分别为L1+C、L2+C， C为公共部分的长度， 第一个人走了L1+C步后，回到第二个人起点走L2步；第2个人走了L2+C步后，回到第一个人起点走L1步。 当两个人走的步数都为L1+L2+C时就两个家伙就相爱了</p><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *node1 = headA, *node2 = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (node1 != node2) &#123;</span><br><span class="line">            node1 = node1 != <span class="literal">NULL</span> ? node1-&gt;next : headB;</span><br><span class="line">            node2 = node2 != <span class="literal">NULL</span> ? node2-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-25-合并两个排序的链表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-25-合并两个排序的链表&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/&quot;&gt;剑指 Offer 25. 合并两个排序的链表&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;难度 简单&lt;/p&gt;
&lt;p&gt;输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;限制：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;= 链表长度 &amp;lt;= 1000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意：本题与主站 21 题相同：&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists/&quot;&gt;https://leetcode-cn.com/problems/merge-two-sorted-lists/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="https://www.snowmoon.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="https://www.snowmoon.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer14——双指针（简单）</title>
    <link href="https://www.snowmoon.top/2021/09/03/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer14/"/>
    <id>https://www.snowmoon.top/2021/09/03/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer14/</id>
    <published>2021-09-03T00:30:00.000Z</published>
    <updated>2023-11-30T16:45:58.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-22-链表中倒数第k个节点"><a class="markdownIt-Anchor" href="#剑指-offer-22-链表中倒数第k个节点"></a> <a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h1><p>难度 简单</p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="思路与题解"><a class="markdownIt-Anchor" href="#思路与题解"></a> 思路与题解</h2><p>循环两次：</p><pre><code>1. 统计链表节点数n2. 遍历到第n-k个节点（即倒数第k个节点）并返回</code></pre><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* getKthFromEnd(ListNode* head, int k) &#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        int n = 0,i;</span><br><span class="line">        while(cur != NULL) </span><br><span class="line">        &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        for(i = 0;i &lt; n-k;i++)</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-18-删除链表的节点"><a class="markdownIt-Anchor" href="#剑指-offer-18-删除链表的节点"></a> <a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h1><p>难度 简单</p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>**注意：**此题对比原题有改动</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>题目保证链表中节点的值互不相同</li><li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li></ul><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>遍历链表，遇到这个节点就修改并删除</p><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *cur;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val == val) head = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-22-链表中倒数第k个节点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-22-链表中倒数第k个节点&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/&quot;&gt;剑指 Offer 22. 链表中倒数第k个节点&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;难度 简单&lt;/p&gt;
&lt;p&gt;输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。&lt;/p&gt;
&lt;p&gt;例如，一个链表有 &lt;code&gt;6&lt;/code&gt; 个节点，从头节点开始，它们的值依次是 &lt;code&gt;1、2、3、4、5、6&lt;/code&gt;。这个链表的倒数第 &lt;code&gt;3&lt;/code&gt; 个节点是值为 &lt;code&gt;4&lt;/code&gt; 的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 k = 2.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回链表 4-&amp;gt;5.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="双指针" scheme="https://www.snowmoon.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer刷题13——动态规划（中等）</title>
    <link href="https://www.snowmoon.top/2021/09/02/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer13/"/>
    <id>https://www.snowmoon.top/2021/09/02/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer13/</id>
    <published>2021-09-02T00:30:00.000Z</published>
    <updated>2023-11-30T16:45:54.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-48-最长不含重复字符的子字符串"><a class="markdownIt-Anchor" href="#剑指-offer-48-最长不含重复字符的子字符串"></a> <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h1><p>难度 中等</p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="思路与题解"><a class="markdownIt-Anchor" href="#思路与题解"></a> 思路与题解</h2><p>这是一道典型的动态规划题目。对于一个数 num[i]，我们有两种选择：</p><ol><li>只翻译自己；</li><li>和前面的数字组合翻译，前提是组合的数在 10−25 之间。</li></ol><p>用F[i]表示前 i 个数字的翻译方法数。根据以上两种选择，我们进行如下分析：</p><ul><li>如果只翻译自己，比如 12345，如果 5 单独翻译，那么方法数与 1234 是一样的， dp(i)=dp(i-1)。</li><li>如果和前面的数字组合，比如 1235，如果 35 组合翻译，从两方面考虑：<br />35 看成一个整体，虽然加了 5 但是和没加是一样的，状态 dp(i)=dp(i-1)；<br />35 组合就意味着不能再组合了，相当于条件 11 中的单独翻译自己，方法数与 12 是一样的。这时 dp(i)=dp(i-2)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">translateNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">           <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, x, y = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            x = num % <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">10</span> * x + y;</span><br><span class="line">            <span class="type">int</span> c = (tmp &gt;= <span class="number">10</span> &amp;&amp; tmp &lt;= <span class="number">25</span>) ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">            y = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-48-最长不含重复字符的子字符串-2"><a class="markdownIt-Anchor" href="#剑指-offer-48-最长不含重复字符的子字符串-2"></a> <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h1><p>难度 中等</p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h2 id="思路与题解-2"><a class="markdownIt-Anchor" href="#思路与题解-2"></a> 思路与题解</h2><p>PS:这题剑指里归类为了动态规划，不过感觉好像滑动窗口更适合这个题点，解出来的时间也更快，不过可能主要是因为测试样例的原因把。。。</p><ol><li>用一个字符串str来存储从s[0]到s[i]中最长的字符串，初始化为空</li><li>遍历s，如果str中含有此时的s[i]，删除从第一位到重复位的字符串</li><li>每个遍历过程中更新最大值max</li><li>返回最大值</li></ol><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Max = <span class="number">0</span>,i,j,index;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            index = str.<span class="built_in">find</span>(s[i],<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(index != <span class="number">-1</span>) str.<span class="built_in">erase</span>(<span class="number">0</span>,index+<span class="number">1</span>);</span><br><span class="line">            str+=s[i];</span><br><span class="line">            Max = <span class="built_in">max</span>((<span class="type">int</span>)str.<span class="built_in">length</span>(), Max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-48-最长不含重复字符的子字符串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-48-最长不含重复字符的子字符串&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/&quot;&gt;剑指 Offer 48. 最长不含重复字符的子字符串&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;难度 中等&lt;/p&gt;
&lt;p&gt;请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;abcabcbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;bbbbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;pwwkew&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="https://www.snowmoon.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="https://www.snowmoon.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer12——动态规划（中等）</title>
    <link href="https://www.snowmoon.top/2021/09/01/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer12/"/>
    <id>https://www.snowmoon.top/2021/09/01/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer12/</id>
    <published>2021-09-01T00:30:00.000Z</published>
    <updated>2023-11-30T16:45:49.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-42-连续子数组的最大和"><a class="markdownIt-Anchor" href="#剑指-offer-42-连续子数组的最大和"></a> <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h1><p>难度 简单</p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-100 &lt;= arr[i] &lt;= 100</code></li></ul><p>注意：本题与主站 53 题相同：<a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设数组为[-2,1,-3,4,-1,2,1,-5,4]，分解每一步问题：</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1,2,1,-5,4] -&gt; 6</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1,2,1,-5] -&gt; 6</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1,2,1] -&gt; 6</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1,2] -&gt; 5</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1] -&gt; 4</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4] -&gt; 4</span></span><br><span class="line"><span class="comment">    [-2,1,-3] -&gt; 1</span></span><br><span class="line"><span class="comment">    [-2,1] -&gt; 1</span></span><br><span class="line"><span class="comment">    [-2] -&gt; -2</span></span><br><span class="line"><span class="comment">    转移方程：F[i] = nums[i] + F[i-1]; //F[i-1] &gt; 0</span></span><br><span class="line"><span class="comment">            F[i] = nums[i];           //F[i-1] &lt;= 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.<span class="built_in">empty</span>() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max,n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        max = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i<span class="number">-1</span>] &gt; <span class="number">0</span> ) nums[i] += nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &gt; max ) max = nums[i];</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-47-礼物的最大价值"><a class="markdownIt-Anchor" href="#剑指-offer-47-礼物的最大价值"></a> <a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h1><p>难度 中等</p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt; grid.length &lt;= 200</code></li><li><code>0 &lt; grid[0].length &lt;= 200</code></li></ul><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>转移方程：</p><p class='katex-block katex-error' title='ParseError: KaTeX parse error: Unknown column alignment: * at position 33: …\begin{array}{*̲*lr**}grid(i,j…'>dp(i,j)= \left\{\begin{array}{**lr**}grid(i,j) &amp; i=0;j=0;\\grid(i,j)+dp(i,j−1) &amp; ,i=0,j\neq0\\grid(i,j)+dp(i−1,j) &amp; ,i\neq0,j=0\\grid(i,j)+max[dp(i−1,j),dp(i,j−1)] &amp; ,i\neq0,j\neq0\\\end{array}\right.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    转移方程：F[i][j] = max(F[i-1][j], F[i][j-1]) + grid[i][j];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m,n,sum;</span><br><span class="line"></span><br><span class="line">        sum = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        m = grid.<span class="built_in">size</span>();</span><br><span class="line">        n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>( j = <span class="number">1</span>; j &lt; n ;j++ )</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; m ;i++ )</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i<span class="number">-1</span>][<span class="number">0</span>] ;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; m ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( j = <span class="number">1</span>; j &lt; n; j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                grid[i][j] += <span class="built_in">max</span>(grid[i][j<span class="number">-1</span>], grid[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-42-连续子数组的最大和&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-42-连续子数组的最大和&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/&quot;&gt;剑指 Offer 42. 连续子数组的最大和&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;难度 简单&lt;/p&gt;
&lt;p&gt;输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。&lt;/p&gt;
&lt;p&gt;要求时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums = [-2,1,-3,4,-1,2,1,-5,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= arr.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-100 &amp;lt;= arr[i] &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：本题与主站 53 题相同：&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/&quot;&gt;https://leetcode-cn.com/problems/maximum-subarray/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://www.snowmoon.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer11——动态规划（简单）</title>
    <link href="https://www.snowmoon.top/2021/08/31/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer11/"/>
    <id>https://www.snowmoon.top/2021/08/31/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer11/</id>
    <published>2021-08-31T00:30:00.000Z</published>
    <updated>2023-11-30T16:45:45.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-10-i-斐波那契数列"><a class="markdownIt-Anchor" href="#剑指-offer-10-i-斐波那契数列"></a> <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h1><p>难度 简单</p><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><span id="more"></span><h2 id="思路与题解"><a class="markdownIt-Anchor" href="#思路与题解"></a> 思路与题解</h2><ol><li><p>**状态定义：**F[i]为第i个斐波那契数列的数字</p></li><li><p><strong>转移方程：</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i] = F[i-1]+F[i-2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></p></li><li><p><strong>初始状态：</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn><mo separator="true">;</mo><mi>F</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F[0]=0;F[1]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p></li><li><p>**计算顺序：**从0开始向目标迭代</p></li></ol><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *F = <span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        F[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n ; i++)</span><br><span class="line">            F[i] = ( F[i<span class="number">-1</span>] + F[i<span class="number">-2</span>] ) % <span class="number">1000000007</span>;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> F[n] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-10-ii-青蛙跳台阶问题"><a class="markdownIt-Anchor" href="#剑指-offer-10-ii-青蛙跳台阶问题"></a> <a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h1><p>难度 简单</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><p>注意：本题与主站 70 题相同：<a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><h2 id="思路与题解-2"><a class="markdownIt-Anchor" href="#思路与题解-2"></a> 思路与题解</h2><p>由于最后一级台阶只能从倒数第二级和倒数第三级跳上来，所以<br />跳上第n个台阶的方法数量 = 跳上第n-1个台阶的方法数量 + 跳上第n-2个台阶的方法数量<br />所以本题和斐波那契数列的题是一致的，只不过初始条件由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(0) = 0,F (1) = 1,F(2) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>变成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">F(0) = 1,F (1) = 1,F(2) = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    转移方程：F[n] = F[n-1]+F[n-2]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> a,b,tmp,i,sum;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            tmp = b;</span><br><span class="line">            b = sum;</span><br><span class="line">            a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-63-股票的最大利润"><a class="markdownIt-Anchor" href="#剑指-offer-63-股票的最大利润"></a> <a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h1><p>难度 中等</p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 数组长度 &lt;= 10^5</span><br></pre></td></tr></table></figure><h2 id="思路与题解-3"><a class="markdownIt-Anchor" href="#思路与题解-3"></a> 思路与题解</h2><p>假设输入为[7,1,5,3,6,4]</p><p>分解问题并缩小为六个子问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[7,1,5,3,6,4] -&gt; max = 5</span><br><span class="line"></span><br><span class="line">[7,1,5,3,6] -&gt; max = 5</span><br><span class="line"></span><br><span class="line">[7,1,5,3] -&gt; max = 4</span><br><span class="line"></span><br><span class="line">[7,1,5] -&gt; max = 4</span><br><span class="line"></span><br><span class="line">[7,1] -&gt; max = 0</span><br><span class="line"></span><br><span class="line">[7] -&gt; max = 0</span><br></pre></td></tr></table></figure><p>则</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F[n] = max( F[n-1], max(prices[n] - prices[i]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>即 F[n] 为过去的最高利润 与 在第n日卖出时利润更高者</p><p>但是这里我用了两个循环来解，把时间复杂度整高了。。。导致了超时。。。</p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设输入为[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">    分解问题并缩小为六个子问题：</span></span><br><span class="line"><span class="comment">    [7,1,5,3,6,4] -&gt; max = 5</span></span><br><span class="line"><span class="comment">    [7,1,5,3,6] -&gt; max = 5</span></span><br><span class="line"><span class="comment">    [7,1,5,3] -&gt; max = 4</span></span><br><span class="line"><span class="comment">    [7,1,5] -&gt; max = 4</span></span><br><span class="line"><span class="comment">    [7,1] -&gt; max = 0</span></span><br><span class="line"><span class="comment">    [7] -&gt; max = 0</span></span><br><span class="line"><span class="comment">    F[n] = max( F[n-1], max(nums[n] - nums[i]))</span></span><br><span class="line"><span class="comment">    即 F[n] 为过去的最高利润 与 在第n日卖出时利润更高者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( prices.<span class="built_in">empty</span>() ) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> *F = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"></span><br><span class="line">        F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; n; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            F[i] = F[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i] - prices[j] &gt; F[i] )</span><br><span class="line">                    F[i] = <span class="built_in">max</span>(F[i<span class="number">-1</span>], prices[i] - prices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> F[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路2"><a class="markdownIt-Anchor" href="#思路2"></a> 思路2</h2><p>大佬的思路：</p><p>大佬的转移方程写的比我的清楚：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>前</mtext><mi>i</mi><mtext>日最大利润</mtext><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>前</mtext><mo stretchy="false">(</mo><mi>i</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">)</mo><mtext>日最大利润</mtext><mo separator="true">,</mo><mtext>第</mtext><mi>i</mi><mtext>日价格−前</mtext><mi>i</mi><mtext>日最低价格</mtext><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mtext>−</mtext><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo>:</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">前i日最大利润=\max(前(i−1)日最大利润,第i日价格−前i日最低价格)\\dp[i]=\max(dp[i−1],prices[i]−\min(prices[0:i]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">前</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">日</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">利</span><span class="mord cjk_fallback">润</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord cjk_fallback">前</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">日</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">利</span><span class="mord cjk_fallback">润</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">第</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">日</span><span class="mord cjk_fallback">价</span><span class="mord cjk_fallback">格</span><span class="mord">−</span><span class="mord cjk_fallback">前</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">日</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">低</span><span class="mord cjk_fallback">价</span><span class="mord cjk_fallback">格</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><strong>时间复杂度降低：</strong> 前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 日的最低价格 $min(prices[0:i]) $时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> 。而在遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">prices</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span></span>时，可以借助一个变量（记为成本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cost</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span> ）每日更新最低价格。优化后的转移方程为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mtext>−</mtext><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i]=\max(dp[i−1],prices[i]−\min(cost,prices[i]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><strong>空间复杂度降低：</strong> 由于$ dp[i]$ 只与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">dp[i - 1] , prices[i] , cost</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span> 相关，因此可使用一个变量（记为利润 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">profit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span> ）代替 $dp $列表。优化后的转移方程为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>t</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>t</mi><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">profit = \max(profit, prices[i] - \min(cost, prices[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设输入为[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">    分解问题并缩小为六个子问题：</span></span><br><span class="line"><span class="comment">    [7,1,5,3,6,4] -&gt; max = 5</span></span><br><span class="line"><span class="comment">    [7,1,5,3,6] -&gt; max = 5</span></span><br><span class="line"><span class="comment">    [7,1,5,3] -&gt; max = 4</span></span><br><span class="line"><span class="comment">    [7,1,5] -&gt; max = 4</span></span><br><span class="line"><span class="comment">    [7,1] -&gt; max = 0</span></span><br><span class="line"><span class="comment">    [7] -&gt; max = 0</span></span><br><span class="line"><span class="comment">    F[n] = max( F[n-1], max(nums[n] - nums[i]))</span></span><br><span class="line"><span class="comment">    即 F[n] 为过去的最高利润 与 在第n日卖出时利润更高者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Special case</span></span><br><span class="line">        <span class="keyword">if</span>( prices.<span class="built_in">empty</span>() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Variable declaration</span></span><br><span class="line">        <span class="type">int</span> n,cost,profit;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Initialize</span></span><br><span class="line">        n = prices.<span class="built_in">size</span>();</span><br><span class="line">        profit = <span class="number">0</span>;</span><br><span class="line">        cost = prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Main loop</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cost = <span class="built_in">min</span>(cost,prices[i]);</span><br><span class="line">            profit = <span class="built_in">max</span>(profit, prices[i] - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-10-i-斐波那契数列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-10-i-斐波那契数列&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/&quot;&gt;剑指 Offer 10- I. 斐波那契数列&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;难度 简单&lt;/p&gt;
&lt;p&gt;写一个函数，输入 &lt;code&gt;n&lt;/code&gt; ，求斐波那契（Fibonacci）数列的第 &lt;code&gt;n&lt;/code&gt; 项（即 &lt;code&gt;F(N)&lt;/code&gt;）。斐波那契数列的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;F(0) = 0,   F(1) = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。&lt;/p&gt;
&lt;p&gt;答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= n &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="https://www.snowmoon.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="https://www.snowmoon.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
