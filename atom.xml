<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SnowMoon-Haoyu&#39;s Blog</title>
  
  <subtitle>记录成长，变得更强！</subtitle>
  <link href="https://www.snowmoon.top/atom.xml" rel="self"/>
  
  <link href="https://www.snowmoon.top/"/>
  <updated>2024-10-19T15:22:28.153Z</updated>
  <id>https://www.snowmoon.top/</id>
  
  <author>
    <name>雪月</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux I/O调优</title>
    <link href="https://www.snowmoon.top/2024/10/19/Linux_IO%E8%B0%83%E4%BC%98/"/>
    <id>https://www.snowmoon.top/2024/10/19/Linux_IO%E8%B0%83%E4%BC%98/</id>
    <published>2024-10-19T14:40:20.000Z</published>
    <updated>2024-10-19T15:22:28.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h1><h2 id="应用层io操作"><a class="markdownIt-Anchor" href="#应用层io操作"></a> 应用层I/O操作</h2><p>是否利用标准库缓存</p><h3 id="非缓冲io"><a class="markdownIt-Anchor" href="#非缓冲io"></a> 非缓冲I/O</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;0123456789\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd, ret;</span><br><span class="line">    fd = open(<span class="string">&quot;./test.txt&quot;</span>, O_RDWR|O_CREAT|O_APPEND);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">       perror(<span class="string">&quot;ret&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># build</span></span><br><span class="line">gcc -o file file.c</span><br></pre></td></tr></table></figure><p>系统调用提供，如：open, read, write, close等</p><h3 id="缓冲io"><a class="markdownIt-Anchor" href="#缓冲io"></a> 缓冲I/O</h3><p>c语言标准输入输出库提供，如：fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs等</p><p><strong>是否利用内核里的页缓存</strong><br />open(2) O_DIRECT</p><ul><li>直接I/O</li></ul><p>跳过操作系统的文件缓存，直接跟文件系统交互来访问文件</p><ul><li>接I/O</li></ul><p>需要经过操作系统的文件缓存</p><p><strong>阻塞自身运行</strong><br />open(2) O_NONBLOCK</p><ul><li><p>阻塞I/O</p></li><li><p>非阻塞I/O</p></li></ul><p>** 连续IO和随机IO**</p><ul><li>连续IO</li></ul><p>read-&gt;read-&gt;read<br />write-&gt;write-&gt;write</p><ul><li>随机IO</li></ul><p>lseek-&gt;read<br />lseek-&gt;write</p><h2 id="虚拟文件系统"><a class="markdownIt-Anchor" href="#虚拟文件系统"></a> 虚拟文件系统</h2><p>文件缓存</p><p>inode缓存</p><p>dentry缓存</p><p>I/O内核架构</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/Storage%20Stack.webp" alt="Storage Stack" /></p><h3 id="通用块设备层"><a class="markdownIt-Anchor" href="#通用块设备层"></a> 通用块设备层</h3><p>通用块设备层，包括块设备 I/O 队列和 I/O 调度器。它会对文件系统的 I/O 请求进行排队，再通过重新排序和请求合并，然后才要发送给下一级的设备层。</p><p><strong>I/O队列</strong></p><p>对文件系统的 I/O 请求进行排队，再通过【重新排序】和【请求合并】，然后把请求发送到块设备驱动层。</p><p><strong>调度</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. I/O调度指对I/O请求进行排序的过程。Linux 内核支持四种 I/O 调度算法，分别是 NONE、NOOP、CFQ 以及 DeadLine。</span><br><span class="line"></span><br><span class="line">2. 查看和修改某个块设备的IO调度器：</span><br><span class="line">$ cat /sys/block/sda/queue/scheduler </span><br><span class="line">noop deadline [cfq] </span><br><span class="line"></span><br><span class="line">NONE</span><br><span class="line">完全不使用任何 I/O 调度器，常用在虚拟机中。</span><br><span class="line"></span><br><span class="line">NOOP（电梯式调度程序）</span><br><span class="line">它实际上是一个先入先出的队列，只做一些最基本的请求合并（类似电梯算法），常用于闪存、SSD等存储。 NOOP倾向饿死读而利于写！</span><br><span class="line"></span><br><span class="line">CFQ（完全公平排队I/O调度器）</span><br><span class="line">CFQ是现在很多发行版的默认 I/O 调度器，它为【每个进程】维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求。 类似于进程 CPU 调度，CFQ 还支持进程 I/O 的优先级调度。 CFQ试图均匀地分布对I/O带宽的访问,避免进程被饿死并实现较低的延迟。</span><br><span class="line"></span><br><span class="line">DeadLine（截止时间调度程序）</span><br><span class="line">DeadLine 调度算法，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量。DeadLine 调度算法，多用在 I/O 压力比较重的场景，比如数据库等。</span><br></pre></td></tr></table></figure><h3 id="块设备驱动层"><a class="markdownIt-Anchor" href="#块设备驱动层"></a> 块设备驱动层</h3><p>负责最终物理设备的I/O操作</p><p>HDD</p><p><a href="https://blog.csdn.net/qyxls/article/details/117322123">/blog.csdn.net/qyxls/article/details/117322123</a></p><p>寻道时间</p><p>旋转时间</p><p>数据传输时间</p><p>SSD</p><h2 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h2><p><strong>磁盘用量、剩余等</strong></p><p>相关工具</p><p>df -h</p><p><strong>inode节点用量、剩余等</strong></p><p>inode节点空间不足，但是磁盘空间充足，可能是过多小文件造成的！</p><p>相关工具</p><p>df -i</p><p>测试： # mount -t tmpfs -o size=1G tmpfs /tftpboot/minio</p><p><strong>使用率：磁盘处理I/O的时间占比</strong></p><p>相关工具</p><p>iostat -d -x -p sda（%util）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">【指标解释】</span><br><span class="line">r/s:设备每秒完成的读请求数(合并后)；</span><br><span class="line">w/s:设备每秒完成的写请求数(合并后)；</span><br><span class="line">rkB/s:每秒从磁盘读取的数据量；</span><br><span class="line">wkB/s:每秒向磁盘写入的数据量；</span><br><span class="line">rrqm/s:每秒排队到设备上的合并的读请求数；</span><br><span class="line">wrqm/s:每秒排队到设备上的合并的写请求数；</span><br><span class="line">r_await:读请求处理完成等待时间，包括队列中等待时间和设备实际处理所花的时间，单位是毫秒</span><br><span class="line">w_await:写请求处理完成等待时间，包括队列中等待时间和设备实际处理所花的时间，单位是毫秒</span><br><span class="line">aqu-sz:平均请求队列长度</span><br><span class="line">rareq-sz:读请求的平均数据量大小（单位是KB）</span><br><span class="line">wareq-sz：写请求的平均数据量大小（单位是KB）</span><br><span class="line">svctm：处理I/O请求所需的平均时间（单位是毫秒），该指标不准，后续会移除。</span><br><span class="line">%util：磁盘处理I/O的时间百分比</span><br><span class="line"></span><br><span class="line">【几个重要的指标】</span><br><span class="line">磁盘 I/O 使用率 --&gt; %util</span><br><span class="line">每秒I/O读请求数 --&gt; r/s</span><br><span class="line">每秒I/O写请求数　--&gt; w/s </span><br><span class="line">每秒I/O读请求大小　--&gt; rkB/s</span><br><span class="line">每秒I/O写请求大小　--&gt; wkB/s</span><br><span class="line">读响应时间 --&gt; r_await</span><br><span class="line">写响应时间 --&gt; w_await</span><br></pre></td></tr></table></figure><ul><li>局限</li></ul><p>对于RAID和SSD，该指标不能反映其真实性能</p><p><strong>每秒的I/O请求数（读、写）</strong></p><p>iostat -d -x -p sda （r/s, w/s）</p><p>dstat -r</p><p><strong>每秒的I/O请求大小（读、写）</strong></p><p>iostat -d -x -p sda（rkB/s, wkB/s）</p><p>dstat -d</p><p><strong>响应时间：I/O 请求从发出到收到响应的间隔时间（读、写）</strong></p><p>相关工具</p><p>iostat -d -x -p sda（r_await，w_await）</p><p><strong>进程I/O大小或者I/O延迟</strong></p><p>相关工具</p><p>pidstat -d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kB_rd/s：该进程每秒从磁盘读取的数据大小</span><br><span class="line"></span><br><span class="line">kB_wr/s：该进程每秒写入磁盘的数据大小</span><br><span class="line"></span><br><span class="line">kB_ccwr/s：每秒取消的写请求数据大小，当任务截断一些脏页缓存时可能会发生这种情况</span><br><span class="line"></span><br><span class="line">iodelay：块 I/O 延迟，包括等待同步块 I/O 完成时间和换入块 I/O 的时间，单位是时钟周期。</span><br></pre></td></tr></table></figure><p>iotop<br />IO：进程在等待I/O上花费的时间占比(%)；</p><p>biotop<br />AVGms：进程平均I/O时间，单位是ms</p><p><strong>进程每次IO操作的IO延迟</strong></p><p>相关工具</p><p>biosnoop-bpfcc -Q<br />LAT(ms)：磁盘I/O的延迟，包括请求提交给设备到请求完成的时间</p><p>实践</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">１、file.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    char *p = &quot;123456789\n&quot;;</span><br><span class="line">    char file[128];</span><br><span class="line">    sprintf(file, &quot;test-%d.log&quot;, pid);</span><br><span class="line">    int fd, ret;</span><br><span class="line">    fd = open(file, O_RDWR|O_CREAT|O_APPEND);</span><br><span class="line">    if(fd == -1) &#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = write(fd, p, strlen(p));</span><br><span class="line">    if(ret == -1) &#123;</span><br><span class="line">       perror(&quot;ret&quot;);</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    sleep(1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">２、test.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    ./file</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="文件缓存"><a class="markdownIt-Anchor" href="#文件缓存"></a> 文件缓存</h3><p>相关工具</p><p>查看整体：<br />cat /proc/meminfo | grep “^Cached”</p><p>单个文件：<br />pcstat /tftpboot/test</p><p>释放文件缓存：<br />echo 1 &gt; /proc/sys/vm/drop_caches</p><h3 id="dentry和inode缓存"><a class="markdownIt-Anchor" href="#dentry和inode缓存"></a> dentry和inode缓存</h3><p><strong>dentry缓存</strong><br />（dcache）</p><p>相关工具</p><p>cat /proc/slabinfo | grep -E ‘^#|dentry’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name：slab object对象的名称</span><br><span class="line">active_objs：被申请走（正在被使用）的对象个数。</span><br><span class="line">num_objs：总对象（slab object）个数。</span><br><span class="line">objsize：每个对象（slab object）大小，以字节为单位。</span><br><span class="line">objperslab：表示一个slab中包含多少个对象（slab object）。</span><br><span class="line">pagesperslab : 一个slab占用几个page内存页。</span><br><span class="line">active_slabs：活动slab个数。</span><br><span class="line">num_slabs：总slab个数。</span><br></pre></td></tr></table></figure><p><strong>inode缓存</strong><br />（icache）</p><p>相关工具</p><p>cat /proc/slabinfo | grep -E ‘^#|inode’</p><p>释放：echo 2 &gt; /proc/sys/vm/drop_caches<br />前后对比查看：cat /proc/meminfo | grep SReclaimable</p><h1 id="工具汇总"><a class="markdownIt-Anchor" href="#工具汇总"></a> 工具汇总</h1><h2 id="iostat"><a class="markdownIt-Anchor" href="#iostat"></a> iostat</h2><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c：显示cpu指标</span><br><span class="line">-d：显示磁盘使用情况</span><br><span class="line">-k: 以KB为单位显示</span><br><span class="line">-m：以MB为单位显示</span><br><span class="line">-x：显示详细信息</span><br><span class="line">-p：显示某个磁盘或者分区的使用情况</span><br></pre></td></tr></table></figure><h2 id="dstat"><a class="markdownIt-Anchor" href="#dstat"></a> dstat</h2><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-m: 显示内存使用情况</span><br><span class="line">-c：显示cpu使用情况</span><br><span class="line">-n: 显示网络状况</span><br><span class="line">-l：显示系统负载情况</span><br><span class="line">-r：显示I/O请求读写请求数</span><br><span class="line">-d: 磁盘读写情况</span><br><span class="line">-y：显示中断和上下文切换次数等</span><br><span class="line">--socket：显示套接字(tcp,udp等)的个数</span><br><span class="line">--top-io: 显示消耗I/O最大的进程</span><br><span class="line">--top-cpu: 显示消耗cpu最大的进程</span><br><span class="line">--top-cputime: 显示使用cpu时间最大的进程(ms)</span><br><span class="line">--top-latency:  显示总延迟最大的进程(ms)</span><br><span class="line">--top-mem: 显示使用内存最大的进程</span><br></pre></td></tr></table></figure><h2 id="pidstat"><a class="markdownIt-Anchor" href="#pidstat"></a> pidstat</h2><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-d：统计进程的I/O大小及I/O延迟</span><br></pre></td></tr></table></figure><h2 id="iotop"><a class="markdownIt-Anchor" href="#iotop"></a> iotop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写大小总数。</span><br><span class="line"></span><br><span class="line">- TID/PID：线程ID/进程ID；</span><br><span class="line">- PRIO：I/O 优先级；</span><br><span class="line">- USER：用户名；</span><br><span class="line">- DISK READ：每秒读磁盘的大小；</span><br><span class="line">- DISK WRITE：每秒写磁盘的大小；</span><br><span class="line">- SWAPIN：进程在SWAPIN上花费的时间占比；</span><br><span class="line">- IO：进程在等待I/O上花费的时间占比；</span><br></pre></td></tr></table></figure><p>用法</p><p>不加任何参数显示所有【线程】的I/O使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写大小总数。</span><br><span class="line"></span><br><span class="line">- TID/PID：线程ID/进程ID；</span><br><span class="line">- PRIO：I/O 优先级；</span><br><span class="line">- USER：用户名；</span><br><span class="line">- DISK READ：每秒读磁盘的大小；</span><br><span class="line">- DISK WRITE：每秒写磁盘的大小；</span><br><span class="line">- SWAPIN：进程在SWAPIN上花费的时间占比；</span><br><span class="line">- IO：进程在等待I/O上花费的时间占比；</span><br></pre></td></tr></table></figure><h2 id="ionice"><a class="markdownIt-Anchor" href="#ionice"></a> ionice</h2><p>用法</p><p>ionice对进程的IO调度class and priority 的设置只有当调度算法是CFQ时才是有效的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c &#123;class&#125; ：指定调度策略</span><br><span class="line">&#123;class&#125;表示调度策略，其中0 for none, 1 for real time, 2 for best-effort, 3 for idle</span><br><span class="line">-n &#123;classdata&#125;：指定IO优先级别</span><br><span class="line">classdata表示IO优先级级别，对于best effort和real time，classdata可以设置为0~7，0的优先级最高</span><br><span class="line">-p &#123;pid&#125;：指定要查看或设置的进程号或者线程号</span><br></pre></td></tr></table></figure><h2 id="strace"><a class="markdownIt-Anchor" href="#strace"></a> strace</h2><p>用法</p><p>追踪进程的I/O系统调用</p><h2 id="filetop"><a class="markdownIt-Anchor" href="#filetop"></a> filetop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filetop实时追踪文件的读写情况。</span><br><span class="line">TID：线程ID</span><br><span class="line">COMM：线程命令行</span><br><span class="line">READS：读取次数</span><br><span class="line">WRITES：写入次数</span><br><span class="line">R_Kb：读取字节数</span><br><span class="line"></span><br><span class="line">W_Kb：写入字节数</span><br><span class="line">T：文件类型</span><br><span class="line">FILE：文件名称</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-a：包含非常规文件，例如：sockets, FIFOs等</span><br><span class="line">-C：不清屏</span><br><span class="line">-r: 最多打印多少行，默认为20</span><br><span class="line">-s &#123;all,reads,writes,rbytes,wbytes&#125;：按指标排序，默认为rbytes</span><br><span class="line">-p &#123;pid&#125;：只追踪&#123;pid&#125;这个进程的文件读写情况</span><br><span class="line">每隔５秒打印一次，共打印１０次</span><br><span class="line">filetop 5 10</span><br></pre></td></tr></table></figure><h2 id="biotop"><a class="markdownIt-Anchor" href="#biotop"></a> biotop</h2><p><a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu---binary">github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu—binary</a></p><p>用法</p><p><a href="https://github.com/iovisor/bcc/blob/master/tools/biotop_example.txt">github.com/iovisor/bcc/blob/master/tools/biotop_example.txt</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I/O：读或者写的I/O次数</span><br><span class="line"></span><br><span class="line">Kbytes：读或者写的字节数</span><br><span class="line"></span><br><span class="line">AVGms：平均I/O时间，单位是ms （统计的是当前时间周期的数据）</span><br><span class="line"></span><br><span class="line">追踪进程I/O并按I/O吞吐量大小排序，默认每１秒统计一次</span><br><span class="line">-C：不清屏</span><br><span class="line">设置为每5秒打印一次，共打印10次：</span><br><span class="line">biotop 5 10</span><br></pre></td></tr></table></figure><h2 id="biosnoop"><a class="markdownIt-Anchor" href="#biosnoop"></a> biosnoop</h2><p>用法</p><p><a href="https://github.com/iovisor/bcc/blob/master/tools/biosnoop_example.txt">github.com/iovisor/bcc/blob/master/tools/biosnoop_example.txt</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LAT(ms)：磁盘I/O的延迟，包括请求提交给设备到请求完成的时间统计。</span><br><span class="line">追踪并打印进程访问I/O时的内核事件</span><br><span class="line">-Q：include OS queued time</span><br><span class="line">-d &#123;DISK&#125;：Trace this disk only</span><br></pre></td></tr></table></figure><h2 id="biolatency"><a class="markdownIt-Anchor" href="#biolatency"></a> biolatency</h2><p>用法</p><p><a href="https://github.com/iovisor/bcc/blob/master/tools/biolatency_example.txt">github.com/iovisor/bcc/blob/master/tools/biolatency_example.txt</a></p><p>直方图的方式统计系统IO延迟（单位：us）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">直方图的方式统计系统IO延迟（单位：us）</span><br><span class="line">-T: 在输出里包含时间戳</span><br><span class="line">-Q: include OS queued time in I/O time</span><br><span class="line">-m: 按照ms统计系统IO延迟</span><br><span class="line">-D: 分开打印各个磁盘的直方图</span><br><span class="line">输出带时间戳，每秒输出一次，共输出５次：</span><br><span class="line">biolatency -T 1 5</span><br></pre></td></tr></table></figure><h2 id="blktrace"><a class="markdownIt-Anchor" href="#blktrace"></a> blktrace</h2><p>用法</p><p><a href="https://www.cnblogs.com/codelogs/p/16060775.html">www.cnblogs.com/codelogs/p/16060775.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">第一个字段：主、次设备号;</span><br><span class="line">第二个字段：cpu号;</span><br><span class="line">第三个字段：序列号;</span><br><span class="line">第四个字段：时间戳;</span><br><span class="line">第五个字段：本次I/O对应的进程 ID;</span><br><span class="line">第六个字段：Event，这个字段非常重要，反映了 I/O 进行到了哪一步;</span><br><span class="line">第七个字段：R 表示 Read， W 是 Write，S表示sync;</span><br><span class="line">第八个字段：223490+56，表示的是起始 block number 和 number of blocks，即我们常说的Offset 和 Size;</span><br><span class="line">第九个字段：进程名字;</span><br><span class="line"></span><br><span class="line">第六个字段Event:</span><br><span class="line">A:IO被重新映射到不同的设备；</span><br><span class="line">Q:将要被 request 代码处理（即将生成 I/O 请求）；</span><br><span class="line">G: I/O 请求（request）生成，为 I/O 分配一个 request 结构体；</span><br><span class="line">P:插入I/O请求</span><br><span class="line">U:准备向磁盘驱动发送该 I/O</span><br><span class="line">D:IO发给driver去处理</span><br><span class="line">C:IO处理完毕</span><br><span class="line"></span><br><span class="line">采集：</span><br><span class="line">blktrace -d /dev/vda1</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">blkparse -i vda1</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">blktrace -d /dev/vda1 -o - | blkparse -i -</span><br></pre></td></tr></table></figure><p>fio</p><p>IO性能基准测试</p><h1 id="调优实践"><a class="markdownIt-Anchor" href="#调优实践"></a> 调优实践</h1><h2 id="实践一-linux应用遇到io性能问题如何一步一步进行调试"><a class="markdownIt-Anchor" href="#实践一-linux应用遇到io性能问题如何一步一步进行调试"></a> 实践一、linux应用遇到I/O性能问题，如何一步一步进行调试？</h2><p>分析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查看系统总体I/O使用情况：</span><br><span class="line">iostat -d -x -p sda 1</span><br><span class="line">top验证</span><br><span class="line">查看所有进程的I/O使用情况，找到可疑的进程：</span><br><span class="line">pidstat -d 1</span><br><span class="line">追踪可疑进程（子进程）的系统调用情况：</span><br><span class="line">strace -f -p &#123;pid&#125;</span><br><span class="line">show出可疑进程的子进程树：</span><br><span class="line">pstree &#123;pid&#125;</span><br></pre></td></tr></table></figure><p>环境搭建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">１、file.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfd\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> file[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;test-%d.log&quot;</span>, pid);</span><br><span class="line">    <span class="type">int</span> fd, ret;</span><br><span class="line">    fd = open(file, O_RDWR|O_CREAT|O_APPEND);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">       perror(<span class="string">&quot;ret&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc -o file file.c</span><br><span class="line"></span><br><span class="line">２、exfile</span><br><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ./file</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="实践二-如何针对linux应用程序的io访问行为具体分析每一步的时间开销"><a class="markdownIt-Anchor" href="#实践二-如何针对linux应用程序的io访问行为具体分析每一步的时间开销"></a> 实践二、如何针对linux应用程序的I/O访问行为，具体分析每一步的时间开销？</h2><p>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1、file.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    char *p = &quot;0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfd\n&quot;;</span><br><span class="line">    char file[128];</span><br><span class="line">    sprintf(file, &quot;test-%d.log&quot;, pid);</span><br><span class="line">    int fd, ret;</span><br><span class="line">    fd = open(file, O_RDWR|O_CREAT|O_APPEND);</span><br><span class="line">    if(fd == -1) &#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = write(fd, p, strlen(p));</span><br><span class="line">    if(ret == -1) &#123;</span><br><span class="line">       perror(&quot;ret&quot;);</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    ret = write(fd, p, strlen(p));</span><br><span class="line">    if(ret == -1) &#123;</span><br><span class="line">       perror(&quot;ret&quot;);</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、exfile</span><br><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    ./file</span><br><span class="line">    sleep 1</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>分析过程</strong></p><p>查看进程实时读写情况：<br />biosnoop</p><p>blktrace -d /dev/vda1 -o - | blkparse -i -</p><p>Q-&gt;G：生成 I/O 请求所消耗的时间； G-&gt;P：I/O 请求进入 I/O Scheduler 所消耗的时间； P-&gt;D: I/O 请求在 I/O Scheduler 中等待的时间； D-&gt;C：I/O 请求在 Driver 和硬件上所消耗的时间，可以作为硬件性能的指标； Q-&gt;C：整个 I/O 请求所消耗的时间(Q-&gt;G + G-&gt;P + P-&gt;D + D-&gt;C = Q2C)，相当于 iostat 的 await。</p><p>io操作时间戳</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/62dc972cf346fb4e907818ea" alt="img" /></p><h2 id="实践三-rm-删掉的文件还能找回来吗能不过得分情况"><a class="markdownIt-Anchor" href="#实践三-rm-删掉的文件还能找回来吗能不过得分情况"></a> 实践三、rm 删掉的文件还能找回来吗？能，不过得分情况！</h2><p>实践过程</p><ul><li>创建文件：/app/test.c</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vi /app/test.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">    printf(&quot;pid %d\n&quot;, getpid());</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;debug\n&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>删掉文件<br />$ rm /app/test.c</p></li><li><p>恢复过程１</p></li></ul><p>找到正在打开/app/file.c这个文件的进程id(20904)以及该文件在上述进程里的文件描述符(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof | grep /app/test.c filekeep  <span class="number">20904</span>                   root    <span class="number">3</span>r      REG                <span class="number">8</span>,<span class="number">5</span>        <span class="number">449</span>   <span class="number">20731531</span> /app/file.c (deleted)</span><br></pre></td></tr></table></figure><ul><li>恢复过程２</li></ul><p>恢复文件： $ cat /proc/20904/fd/3  &gt; /app/test1.c 即可修复被误删除的文件。</p><ul><li>前提条件：filekeep</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">filekeep.c</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = NULL;</span><br><span class="line"> </span><br><span class="line">   fp = fopen(&quot;/app/test.c&quot;, &quot;r&quot;);</span><br><span class="line">   sleep(600);</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实践总结</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">１、struct dentry</span><br><span class="line">&#123;</span><br><span class="line">  //..</span><br><span class="line">  struct inode *d_inode;//相关联的索引节点</span><br><span class="line">　struct qstr d_name;//目录项名称</span><br><span class="line">　struct dentry *d_parent;//父目录</span><br><span class="line">  //..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">２、struct inode</span><br><span class="line">&#123;</span><br><span class="line">　//...</span><br><span class="line">  unsigned long i_ino;//节点号</span><br><span class="line">  atomic_t i_count;//引用计数</span><br><span class="line">  unsigned int i_nlink;//硬链接数 　</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">３、struct file</span><br><span class="line">&#123;</span><br><span class="line">  //...</span><br><span class="line">  atomic_t f_count;//引用计数</span><br><span class="line">  struct path f_path;//包含目录项 </span><br><span class="line">  struct inode *f_inode;//i节点</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件对象（struct file）是已打开的文件在内存中的表示</span><br><span class="line">由于多个进程可以打开和操作同一个文件，所以同一个文件也可能存在多个文件对象</span><br><span class="line">虽然一个文件对应的文件对象不是唯一的，但是对应的索引节点（struct inode）和目录项（struct dentry）对象是唯一的</span><br><span class="line">rm命令底层调用了unlinkat()函数</span><br><span class="line">unlinkat()：如果该文件对象是对文件的最后一个引用且没有进程正在打开这个文件，才会真正的删除文件；</span><br><span class="line">否则，文件内容会依然保存在内存里，这样的文件就可以被恢复。</span><br></pre></td></tr></table></figure><h2 id="调优方法"><a class="markdownIt-Anchor" href="#调优方法"></a> 调优方法</h2><h3 id="应用程序优化"><a class="markdownIt-Anchor" href="#应用程序优化"></a> 应用程序优化</h3><p>追加写替代随机写</p><p>充分利用缓存（包括系统缓存和标准库缓存），降低实际 I/O 的次数</p><p>可以在应用程序内部构建自己的缓存，或者用 Redis/memcached 这类外部缓存系统</p><p>在需要同步写的场景中，尽量将写请求合并，而不是让每个请求都同步写入磁盘，即可以用 fsync() 取代 O_SYNC</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">wfile.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfdf0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyzdfd\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fd, len;</span><br><span class="line">    fd = open(<span class="string">&quot;./test.txt&quot;</span>, O_RDWR|O_CREAT|O_APPEND<span class="comment">/*|O_SYNC*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    i++;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 【总结】</h4><p>当文件在open()时指定了O_SYNC选项，则意味着每个write()调用后面都隐含地跟着一个fsync()调用。</p><p>在使用 CFQ 调度器时，使用ionice调整进程的I/O调度优先级</p><p>在使用 CFQ 调度器时，可以用 ionice 来调整进程的 I/O 调度优先级，特别是提高核心应用的 I/O 优先级。 ionice 支持三个优先级类：Idle、Best-effort 和 Realtime。 其中， Best-effort 和 Realtime 还分别支持 0-7 的级别，数值越小，则表示优先级别越高。</p><h3 id="文件系统优化"><a class="markdownIt-Anchor" href="#文件系统优化"></a> 文件系统优化</h3><ul><li>优化文件系统的缓存</li></ul><p>比如，你可以优化 pdflush 脏页的刷新频率（比如设置 dirty_expire_centisecs 和 dirty_writeback_centisecs）以及脏页的限额（比如调整 dirty_background_ratio 和 dirty_ratio 等）。 备注：以上配置都在/proc/sys/vm/目录下。</p><ul><li>优化内核回收目录项缓存和索引节点缓存的倾向</li></ul><p>可以优化内核回收目录项缓存和索引节点缓存的倾向，即调整 vfs_cache_pressure（/proc/sys/vm/vfs_cache_pressure，默认值 100），数值越大，就表示越倾向于回收目录项缓存和索引节点缓存占用的内存。</p><ul><li>使用tmpfs，获得更好的I/O性能</li></ul><p>磁盘文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、建表</span><br><span class="line">spark-sql&gt;</span><br><span class="line">CREATE table diskfile</span><br><span class="line">USING csv</span><br><span class="line">OPTIONS (</span><br><span class="line">  header true,</span><br><span class="line">  path &quot;/app/tools/test-tool/data/test.csv&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">２、查询</span><br><span class="line">spark-sql&gt; </span><br><span class="line">select * from diskfile where name=&quot;name23453&quot;;</span><br></pre></td></tr></table></figure><p>tmpfs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、创建tmpfs</span><br><span class="line">mkdir -p  /tftpboot/tmp</span><br><span class="line">mount -t tmpfs -o size=1G tmpfs /tftpboot/tmp</span><br><span class="line">２、复制csv文件到tmpfs文件系统目录</span><br><span class="line">３、建表</span><br><span class="line">spark-sql&gt;</span><br><span class="line">CREATE table tmpfile</span><br><span class="line">USING csv</span><br><span class="line">OPTIONS (</span><br><span class="line">  header true,</span><br><span class="line">  path &quot;/tftpboot/tmp/test.csv&quot;</span><br><span class="line">);</span><br><span class="line">4、查询</span><br><span class="line">spark-sql&gt; </span><br><span class="line">select * from tmpfile where name=&quot;name23453&quot;;</span><br></pre></td></tr></table></figure><h3 id="磁盘优化"><a class="markdownIt-Anchor" href="#磁盘优化"></a> 磁盘优化</h3><ul><li>SSD替代HDD</li></ul><p>针对磁盘和应用程序 I/O 模式的特征，我们可以选择最适合的 I/O 调度算法</p><p>在顺序读比较多的场景中，我们可以增大磁盘的预读数据</p><p>你可以通过下面的proc文件，调整 /dev/sda 设备的预读大小： $ cat /sys/block/sda/queue/read_ahead_kb 128 默认大小是 128，单位为 KB。</p><p>可以优化内核块设备 I/O 的选项</p><p>比如，可以调整磁盘队列的长度 /sys/block/sda/queue/nr_requests。 适当增大队列长度，可以提升磁盘的吞吐量。</p>]]></content>
    
    
    <summary type="html">Linux IO 占用调优</summary>
    
    
    
    <category term="SnowMoonの嵌入式笔记" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式Linux" scheme="https://www.snowmoon.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    <category term="Linux" scheme="https://www.snowmoon.top/tags/Linux/"/>
    
    <category term="I/O" scheme="https://www.snowmoon.top/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>Linux——网络调优</title>
    <link href="https://www.snowmoon.top/2024/09/06/Linux_%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/"/>
    <id>https://www.snowmoon.top/2024/09/06/Linux_%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/</id>
    <published>2024-09-06T03:13:31.000Z</published>
    <updated>2024-10-19T15:22:28.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-网络调优"><a class="markdownIt-Anchor" href="#linux-网络调优"></a> Linux 网络调优</h1><h2 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h2><h3 id="tcpip五层模型"><a class="markdownIt-Anchor" href="#tcpip五层模型"></a> TCP/IP五层模型</h3><ul><li>应用层</li></ul><p>负责应用程序沟通，常见协议：http/ftp/tftp/snmp/smtp/telnet等，可自定义</p><ul><li>传输层</li></ul><p>提供端到端的通信服务，常见协议：tcp和udp协议</p><ul><li>网络层</li></ul><p>负责数据的分片、寻址和路由，常见协议：ip协议</p><ul><li>数据链路层</li></ul><p>负责硬件设备之间的数据帧的传送和识别，例如帧同步、冲突检测等，常见协议：ethernet协议</p><ul><li>物理层</li></ul><p>透明的传输比特流，常见硬件厂商：<br />- broadcom（博通）<br />- realtek（瑞昱）<br />- intel</p><h4 id="实践一-linux-c实现聊天功能及wireshark抓包分析"><a class="markdownIt-Anchor" href="#实践一-linux-c实现聊天功能及wireshark抓包分析"></a> 实践一、linux c实现聊天功能及wireshark抓包分析</h4><p>案例代码在这里 -&gt;</p><p><a href="https://github.com/simple-tec/linux-driver/tree/main/app/tcp">https://github.com/simple-tec/linux-driver/tree/main/app/tcp</a></p><h3 id="linux网络设备驱动"><a class="markdownIt-Anchor" href="#linux网络设备驱动"></a> linux网络设备驱动</h3><p>(以dm9000芯片为例)</p><p>硬件datasheet在这里 -&gt;</p><p><a href="http://www.davicom.com.tw/pddocs/DM9000A-DS-F01-030311.pdf">http://www.davicom.com.tw/pddocs/DM9000A-DS-F01-030311.pdf</a></p><h4 id="最大传输单元mtu"><a class="markdownIt-Anchor" href="#最大传输单元mtu"></a> 最大传输单元mtu</h4><p>mtu范围：【68, 1500】</p><p>ip报头最小：20 Bytes</p><p>tcp头部最小：20 Bytes</p><p>最大mss = 1500-20-20=1460</p><p>最大报文段长度（MSS）是TCP协议的一个选项，用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度（不包括文段头）。 MSS = MTU - TCP头部大小 - IP头部大小 其中，TCP 头部和 IP 头部的大小是固定的，分别为 20 字节和 20 字节。</p><p>mtu限制了数据链接层上可以传输的数据包的大小，也因此限制了上层（IP层）的数据包大小</p><p>mtu和IP分片的关系</p><p>当要求发送的IP数据包比数据链路层的MTU大时，必把该数据包分割成多个IP数据包才能发送。</p><h4 id="linux网卡驱动发送和接收"><a class="markdownIt-Anchor" href="#linux网卡驱动发送和接收"></a> linux网卡驱动发送和接收</h4><p>参考代码(linux 4.9.229)：drivers/net/ethernet/davicom/dm9000.c</p><p>网卡驱动整体框架</p><ul><li>数据帧发送</li></ul><p>1、dm9000_start_xmit()</p><p>2、 dm9000_interrupt()</p><p>３、dm9000_tx_done</p><ul><li>数据帧接收</li></ul><p>1、 dm9000_interrupt()</p><p>2、dm9000_rx()</p><p>3、netif_rx()</p><ul><li>软中断NET_TX, NET_RX处理</li></ul><p>参考代码(linux 4.9.229)：net/core/dev.c</p><p>网络底半部发送：net_tx_action()</p><p>网络底半部接收：net_rx_action()</p><h2 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h2><h3 id="最大传输单元mtu-2"><a class="markdownIt-Anchor" href="#最大传输单元mtu-2"></a> 最大传输单元mtu</h3><p>相关工具</p><p>查看：<br />ifconfig eth0 | grep mtu</p><p>修改（临时）：<br />ifconfig eth0 mtu 1450</p><p>实践：IP数据包（包含IP头）超过MTU大小，会发生什么情形？</p><p>操作步骤</p><p>【假设】eth0接口的mtu为1500！ 命令１： ping -I eth0 -s 147２ -M do 192.168.0.101 命令２： ping -I eth0 -s 1473 -M do 192.168.0.101</p><h3 id="带宽"><a class="markdownIt-Anchor" href="#带宽"></a> 带宽</h3><p>链路的最大传输速度，单位b/s（比特/s），属于基础设施。</p><p>相关工具</p><p>ethtool eth0 | grep Speed</p><h3 id="pps"><a class="markdownIt-Anchor" href="#pps"></a> PPS</h3><p>Packet Per Second，表示以网络包为单位的传输速率</p><p>相关工具</p><p>sar -n DEV</p><h3 id="吞吐量"><a class="markdownIt-Anchor" href="#吞吐量"></a> 吞吐量</h3><p>单位时间内传输的数据量，单位b/s或者B/s</p><p>相关工具</p><p>sar -n DEV</p><p>rxpck/s 和 txpck/s 分别是接收和发送的 PPS; rxkB/s 和 txkB/s 分别是接收和发送的吞吐量； rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数； %ifutil 是网络接口的使用率，即半双工模式下为 (rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s, txkB/s)/Bandwidth；</p><h3 id="往返延时rtt"><a class="markdownIt-Anchor" href="#往返延时rtt"></a> 往返延时（RTT）</h3><p>RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</p><p>相关工具</p><p>【ICMP】ping -c4 8.8.8.8</p><p>ping命令的输出中的最后一行： rtt min/avg/max/mdev = 58.325/71.634/94.710/14.502 ms mdev全称Mean Deviation，译为平均方差 mdev越大，表示网络越不稳定。</p><p>【TCP】hping3 -c 3 -S -p 80 <a href="http://httpbin.org">httpbin.org</a></p><h3 id="tcp相关性能工具"><a class="markdownIt-Anchor" href="#tcp相关性能工具"></a> TCP相关性能工具</h3><p>tcp半连接队列的大小</p><p>相关工具</p><p>max(64, net.ipv4.tcp_max_syn_backlog)</p><p>tcp全连接队列的大小</p><p>相关工具</p><p>min(backlog, net.core.somaxconn)</p><p>tcp/udp吞吐量</p><p>相关工具</p><p>【tcp】<br />server端：iperf -s -p 10000<br />client端：iperf -c 192.168.0.100 -p 10000</p><p>【udp】<br />server端：iperf -s -p 10000<br />client端：iperf -u -c 192.168.0.100 -p 10000</p><p>tcp缓冲区大小</p><p>相关工具或配置</p><p>tcp发送缓冲区大小：<br />查看：<br />cat /proc/sys/net/ipv4/tcp_wmem<br />该文件包含3个整数值，分别是：min，default，max<br />更改：<br />sysctl -w net.ipv4.tcp_wmem=“XXXX XXXX XXXX”</p><p>tcp接收缓冲区大小：<br />查看：<br />cat /proc/sys/net/ipv4/tcp_rmem<br />该文件包含3个整数值，分别是：min，default，max<br />更改：<br />sysctl -w net.ipv4.tcp_rmem=“XXXX XXXX XXXX”</p><p>socket连接数</p><p>相关工具</p><p>查看tcp状态为SYN_REC的sockets：<br />netstat -n -p -t | grep SYN_REC</p><p>查看tcp状态为SYN_REC的sockets：<br />ss -n -p -t | grep SYN_REC</p><h3 id="udp相关性能工具"><a class="markdownIt-Anchor" href="#udp相关性能工具"></a> UDP相关性能工具</h3><p>udp缓冲区大小</p><p>相关工具或配置</p><p>udp缓冲区大小：<br />查看：<br />cat /proc/sys/net/ipv4/udp_mem<br />该文件包含3个整数值，分别是：min，default，max</p><p>套接字缓冲区大小</p><p>单个套接字缓冲区大小</p><p>相关工具或配置</p><p>setsockopt(,SO_SNDBUF,)配置</p><p>在调用connect或listen之前通过setsockopt设置。</p><p>setsockopt(,SO_RCVBUF,)配置</p><p>在调用connect或listen之前通过setsockopt设置。</p><p>内核全局的套接字缓冲区大小</p><p>相关工具或配置</p><p>套接字接收缓冲区大小：<br />查看：<br />cat /proc/sys/net/core/rmem_max<br />修改：<br />sysctl -w net.core.rmem_max=212993</p><p>套接字发送缓冲区大小：<br />查看：<br />cat /proc/sys/net/core/wmem_max<br />修改：<br />sysctl -w net.core.wmem_max=212993</p><h3 id="工具汇总"><a class="markdownIt-Anchor" href="#工具汇总"></a> 工具汇总</h3><h4 id="wireshark"><a class="markdownIt-Anchor" href="#wireshark"></a> wireshark</h4><p>用法</p><p>过滤器</p><p>捕获过滤器：用于决定捕获什么数据</p><p>显示过滤器：在捕获的结果中进行详细查找</p><p>详细语法：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/631179d61e0853188ea104c4" alt="img" /></p><p>比较运算：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/63117bd11e0853188ea10c9f" alt="img" /></p><p>逻辑运算：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/63117bde1efad41efc4ca3a8" alt="img" /></p><p>例子</p><p>frame.cap_len &gt; 100<br />【备注】cap_len长度包括【以太网头＋ip头＋tcp头＋应用数据】的总长度</p><p>ip.len &gt;= 100<br />【备注】ip.len是ip层以上的（包含ip头）数据的总长度</p><p>tcp.len &gt;= 60<br />【备注】tcp.len即tcp segment len，指的是tcp所承载的应用数据的长度（不包含tcp头部）</p><p>udp.length &gt; 100<br />【备注】udp.length是udp报头和udp载荷数据的总大小</p><p>对多个条件进行过滤：<br />ip.addr==172.16.10.2 and tcp.flag.fin</p><p>按字节位置的内容进行过滤（十六机制）：<br />tcp[0:2]==ac3a（匹配源端口号44090）<br />【备注】tcp[n,m] ：n是起始位置偏移，m是从指定位置的区域长度</p><p>按比特位置的内容进行过滤：<br />tcp[13]&amp;2<br />【备注】用“&amp;2”符号指出要取这个字节中第2位即SYN位置的值</p><p>tcp.segment_data contains 49:27:6d:20:64:61:74:61<br />【备注】49:27:6d:20:64:61:74:61是16进制的内容序列</p><p>Flow Graph</p><p>1, 在选择一个包后，单击右键并选择 “Follow” -&gt; “TCP Stream”； 2，关闭弹出来的对话框，回到 Wireshark 主窗口。这时候，你会发现 Wireshark 已经自动帮你设置了一个过滤表达式，例如：tcp.stream eq 24。 从这里，你可以看到这个 TCP 连接从三次握手开始的每个请求和响应情况。 3，为了更加直观，你可以继续点击菜单栏里的 Statics -&gt; Flow Graph，选中 “Limit to display filter” 并设置 Flow type 为 “TCP Flows”。就可以看到更直观的通信细节。</p><h4 id="tcpdump"><a class="markdownIt-Anchor" href="#tcpdump"></a> tcpdump</h4><p>用法</p><p>-i eth0：指定网络接口</p><p>-nn：不解析ip地址和端口号的名称</p><p>-c {count}：指定要抓取的数据包的个数</p><p>-w {file}：抓包并保存到文件，比如：file.pcap</p><p>[expression] tcpdump的过滤表达式和wireshark是类似的</p><p>tcpdump的过滤表达式</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/63119746079129647b69c738" alt="img" /></p><p>输出格式：时间戳　协议　源IP地址：源端口 &gt; 目的IP地址：目的端口　网络包详细信息</p><p>例子：tcpdump -i eth0 icmp and host 192.168.0.102 -nn</p><h4 id="netstat"><a class="markdownIt-Anchor" href="#netstat"></a> netstat</h4><p>用法</p><p>-a: 显示所有的socket连接（包括listening和non-listening连接）</p><p>-l: 只显示listening状态的socket连接</p><p>-n: 表示显示数字地址和端口(而不是名字)</p><p>-p: 表示显示进程信息</p><p>-t: 只显示tcp连接（若不指定-l，则默认仅显示non-listening连接）</p><p>-u: 只显示udp连接（若不指定-l，则默认仅显示non-listening连接）</p><p>-x: 只显示unix连接</p><p>-i: 显示所有网络接口的状态</p><p>-s：汇总了 ip、icmp、udp、tcp 等各种协议的收发统计信息</p><h4 id="ip"><a class="markdownIt-Anchor" href="#ip"></a> ip</h4><p>Forwarding: 1 //开启转发    8641328 total packets received //总收包数    73 with invalid addresses // 有着错误地址的封包数    0 forwarded //转发包数    0 incoming packets discarded //接收丢包数    8598954 incoming packets delivered //接收的数据包数    5161967 requests sent out //发出的数据包数    160 dropped because of missing route //找不到路由而导致的丢包数    1 fragments dropped after timeout　//超时导致的丢包数    274 reassemblies required　//需要重组的封包数    117 packets reassembled ok//重组成功的封包数    1 packet reassemblies failed　//重组失败的封包数</p><p>-e：显示额外的信息，比如socket path等</p><p>-r：显示内核的路由表，等同于route -e</p><p>Recv-Q 和 Send-Q的解释</p><p>注意，在不同套接字状态下，它们的含义不同： 1、当套接字处于Established状态（Established）时，Recv-Q 表示OS持有的、尚未交付给应用程序的数据的字节数；而 Send-Q 表示已经发送给对端应用，但对端应用尚未ack的字节数。 2、当套接字处于监听状态（Listening）时，Recv-Q 表示当前全连接队列的长度。而 Send-Q 表示全连接队列的最大长度，其值为min(backlog, somaxconn)。 注意，Listening状态时，Recv-Q的最大值为Send-Q+1，即：min(backlog, somaxconn)+1。 之所以加1，是因为OS内核在判断队列是否已满时，用的是&gt;（应该用&gt;=），这导致当已创建成功的连接数量正好等于min(backlog, somaxconn)时，还会再多创建一个tcp连接，最终结果就是：min(backlog, somaxconn)+1。</p><p>场景</p><p>１、列出所有的tcp端口（包含listen和非listen状态）：<br />$ netstat -ta<br />列出处于Listen状态的tcp端口：<br />$ netstat -tl<br />注意：netstat -t会列出处于no-listen状态的tcp连接</p><p>２、显示各个协议的统计信息：<br />$ netstat -s</p><p>３、显示tcp的统计信息<br />$ netstat -st</p><p>４、初步检测你的系统有没有受到DDOS攻击：<br />$ netstat -n -p|grep SYN_REC | wc -l</p><h4 id="ss"><a class="markdownIt-Anchor" href="#ss"></a> ss</h4><p>用法</p><p>-a: 显示所有的sockets（包括LISTEN和非LISTEN）</p><p>-l: 只显示LISTEN状态的sockets</p><p>-n：不解析服务名字，显示数字和端口</p><p>-p：显示进程信息</p><p>-t：只显示tcp连接</p><p>-u：只显示udp连接</p><p>-x：只显示unix连接</p><p>-s：连接信息汇总</p><h4 id="iperf"><a class="markdownIt-Anchor" href="#iperf"></a> iperf</h4><p>用法</p><p>-f [kmKM] ：分别表示以Kbits, Mbits, KBytes, MBytes显示报告</p><p>-s：以server模式启动</p><p>-c：以client模式启动</p><p>-p：指定端口号</p><p>-u：使用udp协议</p><p>-t {sec}：表示测试多久，一般指定在client端（因为client为封包发送方）</p><p>-m：在结果中打印tcp mss的值</p><p>-N：禁止Nagle算法</p><p>场景</p><p>测试tcp的吞吐量：<br />server端：iperf -s -p 10000<br />client端：iperf -c 192.168.0.100 -p 10000</p><p>测试udp的吞吐量：<br />server端：iperf -s -p 10000 -u<br />client端：iperf -c 192.168.0.100 -p 10000 -u</p><h4 id="ab"><a class="markdownIt-Anchor" href="#ab"></a> ab</h4><p>用法</p><p>-c: 并发数</p><p>-n: 总请求数</p><p>-s: 设置每个请求的超时时间</p><p>-r: 套接字接收错误时仍然继续执行</p><p>注意</p><p>测试高并发，需要提前修改进程能打开的最大文件描述符的大小：<br />$ ulimit -n 10240</p><p>场景</p><p>测试某个服务的性能：<br />$ ab -c 100 -n 10000 <a href="http://httpbin.org/ip">http://httpbin.org/ip</a></p><p>Failed requests:　//失败的请求数； Non-2xx responses://非2xx回应的请求数； Requests per second://每秒完成的请求数； Time per request【１】:每个请求的平均处理时间； Time per request【２】:引入并发因素后，每个请求的平均处理时间； Transfer rate: //每秒数据传输量，表示网络吞吐； 备注： 某些情况下Time per request【２】乘以concurrency，约等于Time per request【１】，希望这样有助于你理解这两者的区别。</p><h4 id="hping3"><a class="markdownIt-Anchor" href="#hping3"></a> hping3</h4><p>用法</p><p>模式选择，默认tcp</p><p>–rawip：RAWIP模式</p><p>–icmp：ICMP模式</p><p>–udp：UDP模式</p><p>–scan：SCAN模式，指定扫描对应的端口</p><p>–listen：监听模式</p><p>-S：表示设置TCP协议的SYN（同步序列号）</p><p>-p {port}: 设置端口号</p><p>-c {count}：发送的总封包数</p><p>-i {interval}：u100表示每隔100微秒发送一个网络帧</p><p>-i 1：表示每隔1秒发送一个网络帧； -i u100：表示每隔100微妙发送一个网络帧；</p><p>-a {hostname}：源地址欺骗</p><p>–rand-source：随机化源IP</p><p>–flood：尽量快的发包，无需再指定-i</p><p>场景</p><p>１、端口扫描<br />扫描一个端口：<br />$ hping3 192.168.0.1 --scan 80 -S<br />扫描多个端口：<br />$ hping3 192.168.0.1 --scan 80,8080 -S</p><p>２、模拟DDOS攻击<br />SYN ddos攻击：<br />$ hping3 -S -p 80 -i u10 192.168.0.1<br />flood＋随机源地址SYN攻击：<br />$ hping3 -S -p 80 192.168.0.1 --flood --rand-source</p><p>3、伪造源IP地址<br />伪装源地址为10.0.0.1给192.168.0.1的80端口发送syn包：<br />$ hping3 -S -p 80 -a 10.0.0.1 -S 192.168.0.1</p><h4 id="ping"><a class="markdownIt-Anchor" href="#ping"></a> ping</h4><p>用法</p><p>-n：不会进行名称解析</p><p>-s {packetsize}：指定要发送的封包大小。<br />【注意】{packetsize}+8+20应该小于等于mtu，否则会执行分片策略</p><p>-M {pmtudisc_opt}：选择Path MTU发现策略，可选值如下：<br />- do：禁止分片<br />- want：package太大时执行分片<br />- dont：不设置DF flag</p><p>例子：<br />ping 192.168.0.101 -c 1</p><h4 id="nethogs"><a class="markdownIt-Anchor" href="#nethogs"></a> nethogs</h4><p>用法</p><p>排序显示每个进程所使用的网络带宽，例如：<br />nethogs -d 2 -s</p><p>-d {seconds}：指定刷新频率</p><p>-s：按照网络发送量排序</p><p>交互参数：<br />m：切换byte, kb, mb等<br />r: 按照接收排序<br />s：按照发送量排序</p><h4 id="iftop"><a class="markdownIt-Anchor" href="#iftop"></a> iftop</h4><p>用法</p><p>界面参数说明： =&gt;代表发送数据 &lt;=代表接收数据 TX：发送流量（过去 2s 10s 40s ） RX：接收流量（过去 2s 10s 40s ） TOTAL：总流量 Cumm：运行iftop到目前时间的字节总量 peak：过去40s的流量峰值 rates：分别表示过去 2s 10s 40s 的平均流量 备注：流量的单位是Bytes/s，也就是传输速度。</p><p>-i ${dev}：设定监测的网卡</p><p>-B：以bytes为单位显示流量(默认是bits)</p><p>-n：不使用host信息、而是使用ip地址和端口的方式来显示</p><p>常用组合：<br />iftop -i eth0 -B -n</p><h2 id="调优实践"><a class="markdownIt-Anchor" href="#调优实践"></a> 调优实践</h2><h3 id="实践一-ping不通服务器该从哪些方面去调试"><a class="markdownIt-Anchor" href="#实践一-ping不通服务器该从哪些方面去调试"></a> 实践一、ping不通服务器，该从哪些方面去调试？</h3><p>分析过程</p><p>【物理层】查看网线接口灯的状态是否正常。</p><p>绿灯是链路指示灯,黄灯是信号指示灯。 １、黄灯闪动,绿灯长亮 表示链路正常,正在通信中； ２、黄灯不亮,绿灯长亮 表示链接正常,不过目前没有数据通信； ３、黄灯不亮,绿灯闪动 表示链路不稳定，存在比如线头接触不良等问题</p><p>【数据链路层】ifconfig查看相应的网络接口是否存在RX errors或者TX errors<br />$ watch -d ifconfig eth0</p><p>【arp层】查看本地的arp缓存中关于目标ip的mac地址是否正确？<br />$ arp -e</p><p>【网络层】执行route查看针对目标IP的出口设备是否正常？有时docker bridge就创建它自己的172打头的路由规则，导致路由出错</p><p>【本机的软件防火墙】通过iptables -L查看是否有针对目标服务器地址的可疑规则</p><p>【第三方防火墙】和服务器机器是否直连，中间有没有通过其他设备，该设备有无防火墙规则设定？</p><p>【Tcp层】通过nmap -sS -v 172.21.84.140或则nmap -sT -v 172.21.84.140扫描服务器开关机状态和存活端口号</p><h3 id="实践二-对端socket发出了rst报文导致连接异常关闭该怎么分析"><a class="markdownIt-Anchor" href="#实践二-对端socket发出了rst报文导致连接异常关闭该怎么分析"></a> 实践二、对端socket发出了RST报文，导致连接异常关闭，该怎么分析？</h3><p>分析过程</p><p>通过wireshark或tcpdump分析tcp通信过程</p><p>RST是发生在３次握手过程中吗？是否在向一个未监听的端口发送<br />SYN封包？</p><p>客户端和服务端程序有任何一方发生了异常退出吗？</p><p>是否在已关闭的socket上收到了数据呢？</p><p>客户端和服务端程序有任何一方发生了提前close退出吗？</p><p>案例代码</p><p>在已经关闭的socket上收到了数据，底层协议栈会发RST</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8887</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> listen_fd, real_fd;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">listen_addr</span>, <span class="title">client_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);  </span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(listen_fd == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;socket failed   &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bzero(&amp;listen_addr,<span class="keyword">sizeof</span>(listen_addr));  </span><br><span class="line">    listen_addr.sin_family = AF_INET;  </span><br><span class="line">    listen_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    listen_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    bind(listen_fd,(<span class="keyword">struct</span> sockaddr *)&amp;listen_addr, len);  </span><br><span class="line">    listen(listen_fd, WAIT_COUNT);  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        real_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);  </span><br><span class="line">        <span class="keyword">if</span>(real_fd == <span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            perror(<span class="string">&quot;accpet fail  &quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            close(listen_fd);  </span><br><span class="line">            <span class="type">char</span> pcContent[<span class="number">4096</span>];</span><br><span class="line">            read(real_fd,pcContent,<span class="number">4096</span>);</span><br><span class="line">            close(real_fd);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);              </span><br><span class="line">        &#125;  </span><br><span class="line">        close(real_fd);  </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8887</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> send_sk;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">s_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(s_addr);  </span><br><span class="line">    send_sk = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(send_sk == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;socket failed  &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bzero(&amp;s_addr, <span class="keyword">sizeof</span>(s_addr));  </span><br><span class="line">    s_addr.sin_family = AF_INET;  </span><br><span class="line">    s_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    s_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    <span class="keyword">if</span>(connect(send_sk,(<span class="keyword">struct</span> sockaddr*)&amp;s_addr,len) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;connect fail  &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">char</span> pcContent[<span class="number">4096</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// first send</span></span><br><span class="line">    write(send_sk,pcContent,<span class="number">4096</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// second send</span></span><br><span class="line">    write(send_sk,pcContent,<span class="number">4096</span>);</span><br><span class="line">    close(send_sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wireshark截图</p><p><img src="C:%5CUsers%5CZHY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241019212806209.png" alt="image-20241019212806209" /></p><p>接收方应用程序未接收完接收缓冲区的数据、就提前close退出，底层协议栈会发RST</p><p>Server.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8887</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> listen_fd, real_fd;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">listen_addr</span>, <span class="title">client_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);  </span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(listen_fd == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;socket failed   &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bzero(&amp;listen_addr,<span class="keyword">sizeof</span>(listen_addr));  </span><br><span class="line">    listen_addr.sin_family = AF_INET;  </span><br><span class="line">    listen_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    listen_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    bind(listen_fd,(<span class="keyword">struct</span> sockaddr *)&amp;listen_addr, len);  </span><br><span class="line">    listen(listen_fd, WAIT_COUNT);  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        real_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);  </span><br><span class="line">        <span class="keyword">if</span>(real_fd == <span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            perror(<span class="string">&quot;accpet fail  &quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            close(listen_fd);  </span><br><span class="line">            <span class="type">char</span> pcContent[<span class="number">4096</span>];</span><br><span class="line">            read(real_fd,pcContent,<span class="number">4096</span>);</span><br><span class="line">            close(real_fd);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);              </span><br><span class="line">        &#125;  </span><br><span class="line">        close(real_fd);  </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8887</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> send_sk;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">s_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(s_addr);  </span><br><span class="line">    send_sk = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(send_sk == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;socket failed  &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bzero(&amp;s_addr, <span class="keyword">sizeof</span>(s_addr));  </span><br><span class="line">    s_addr.sin_family = AF_INET;  </span><br><span class="line">    s_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    s_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    <span class="keyword">if</span>(connect(send_sk,(<span class="keyword">struct</span> sockaddr*)&amp;s_addr,len) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;connect fail  &quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">char</span> pcContent[<span class="number">5000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(send_sk,pcContent,<span class="number">5000</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    close(send_sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20241019213237649.webp" alt="image-20241019213237649" /></p><h3 id="实践三-压测nginx服务时网络延迟居高不下该如何解决"><a class="markdownIt-Anchor" href="#实践三-压测nginx服务时网络延迟居高不下该如何解决"></a> 实践三、压测nginx服务时网络延迟居高不下，该如何解决？</h3><p>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. nginx打开nagle算法</span><br><span class="line">vi /etc/nginx/nginx.conf</span><br><span class="line">http &#123;</span><br><span class="line">  ...  </span><br><span class="line">  tcp_nodelay off;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 客户端使用ab工具并发压测：</span><br><span class="line">$  ab -c 100 -n 10000 -k http://172.21.84.207:8081/</span><br><span class="line">结果：</span><br><span class="line">Requests per second:    2259.76 [#/sec] (mean)</span><br><span class="line">Time per request:       44.253 [ms] (mean)</span><br><span class="line"></span><br><span class="line">3. nginx关闭nagle算法</span><br><span class="line">vi /etc/nginx/nginx.conf</span><br><span class="line">http &#123;</span><br><span class="line">  ...  </span><br><span class="line">  tcp_nodelay on;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. 再测压测</span><br><span class="line">$  ab -c 100 -n 10000 -k http://172.21.84.207:8081/</span><br><span class="line">结果：</span><br><span class="line">Requests per second:    20316.37 [#/sec] (mean)</span><br><span class="line">Time per request:       4.922 [ms] (mean)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【附】本例使用的完整的nginx.conf文件如下：</span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8081;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">           root  /var/www/html;             #html访问路径</span><br><span class="line">           index index.html index2.htm;     #html文件名称</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析过程</p><p>[Nagle算法和tcp延迟确认](<a href="https://shimo.im/docs/nPixnamNKxQiG7dQ/">https://shimo.im/docs/nPixnamNKxQiG7dQ/</a> 《Nagle算法和tcp延迟确认-public》，可复制链接后用石墨文档 App 打开)</p><p>调优方法</p><p>数据链路层</p><p>网卡驱动优化</p><p>NAPI：中断+轮询</p><p>为网卡中断配置cpu亲和性（smp_affinity），将这些中断处理程序调度到不同的 CPU 上执行</p><p>DPDK</p><p>跳过逻辑复杂的linux网络协议栈，直接由用户态进程用轮询的方式，来处理网络请求</p><p>传输层</p><h4 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> tcp</h4><p>tcp TIME_WAIT优化</p><p>增大处于 TIME_WAIT 状态的连接数量： net.ipv4.tcp_max_tw_buckets</p><p>tcp_max_tw_buckets控制kernel中最多存在的TIME_WAIT数量。</p><p>减小 net.ipv4.tcp_fin_timeout，让处于FIN状态的tcp连接尽早释放</p><p>开启端口复用 net.ipv4.tcp_tw_reuse，这样被 TIME_WAIT 状态占用的端口，能很快被用于新的连接</p><p>增加可用端口号或者文件数</p><p>增大本地端口的范围 net.ipv4.ip_local_port_range ，这样就可以支持更多连接，提高服务并发能力</p><p>linux里，一切皆是文件，socket连接也是，可增加最大文件描述符的数量（ulimit -n 10240）</p><p>SYN相关优化</p><p>增大 TCP 半连接的最大数量：net.ipv4.tcp_max_syn_backlog</p><p>减少 SYN_RECV 状态的连接重传 SYN+ACK 包的次数 ：net.ipv4.tcp_synack_retries。</p><p>其他优化</p><p>tcp nagle算法</p><p>启用时可提高小封包场景下的网络利用率，但同时也增加了网络延迟</p><p>tcp延迟确认</p><p>提高某些场景下的网络利用率</p><h4 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> udp</h4><p>增大UDP的缓冲区大小</p><p>跟前面 TCP 部分提到的一样，增大本地端口号的范围</p><p>根据 MTU 大小，调整 UDP 数据包的大小，减少或者避免分片的发生</p><p>配置套接字缓冲区大小<br />参考出处：<br />linux-4.9.229/Documentation/sysctl/net.txt</p><p>net.core.optmem_max：每个套接字允许的最大辅助缓冲区大小</p><p>net.core.rmem_max：最大接收套接字缓冲区大小(以字节为单位)</p><p>net.core.wmem_max：最大发送套接字缓冲区大小(以字节为单位)</p><p>应用程序</p><p>使用epoll取代select和poll</p><p>尽量使用连接池，比如postgres和redis编程都支持连接池方式，可避免每次请求的时候都要建立3次握手</p><p>为socket配置较大的套接字的缓冲区SO_SNDBUF和SO_RCVBUF</p><p>使用缓存技术，缓存一部分实时性没那么高的数据，减少不必要的网络访问</p>]]></content>
    
    
    <summary type="html">Linux 网络相关功能调试工具汇总</summary>
    
    
    
    <category term="SnowMoonの嵌入式笔记" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式Linux" scheme="https://www.snowmoon.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    <category term="Linux" scheme="https://www.snowmoon.top/tags/Linux/"/>
    
    <category term="CPU" scheme="https://www.snowmoon.top/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>Linux调试原理及方法2——内存占用调优</title>
    <link href="https://www.snowmoon.top/2024/06/01/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-Linux-Memory%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98-Processing/"/>
    <id>https://www.snowmoon.top/2024/06/01/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-Linux-Memory%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98-Processing/</id>
    <published>2024-06-01T05:16:28.000Z</published>
    <updated>2024-10-19T14:16:33.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-调试系列文章"><a class="markdownIt-Anchor" href="#linux-调试系列文章"></a> Linux 调试系列文章</h1><p>[[Linux CPU 占用调优]]<br />[[Linux Memory占用调优(Processing)]]</p><h1 id="调试工具总览"><a class="markdownIt-Anchor" href="#调试工具总览"></a> 调试工具总览</h1><p>Brendan D. Gregg 维护了一份Linux性能调优工具的蓝图<a href="http://www.brendangregg.com/linuxperf.html">Linux Performance Tools</a>，针对Linux系统的各个组件都有相应的分析工具，一目了然。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/202406012053732.webp" alt="image.png" /></p><h1 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h1><h2 id="linux内核内存管理"><a class="markdownIt-Anchor" href="#linux内核内存管理"></a> linux内核内存管理</h2><ul><li><p>【批发】linux内核基于伙伴算法管理物理内存页</p></li><li><p>【零售】linux内核基于slab管理内存</p></li><li><p>linux内核所用物理内存大小统计</p></li></ul><h2 id="linux进程内存管理"><a class="markdownIt-Anchor" href="#linux进程内存管理"></a> linux进程内存管理</h2><p>malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()</p><p>对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。</p><p>对大块内存（大于 128K），则直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去</p><p>各自的<strong>优缺点</strong>：</p><ul><li><p>brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率；不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片</p></li><li><p>mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大</p></li></ul><p>整体来说，Linux 使用<strong>伙伴系统</strong>来管理内存分配。前面我们提到过，这些内存在 MMU 中以页为单位进行管理，伙伴系统也一样，以页为单位来管理内存，并且会通过相邻页的合并，减少内存碎片化（比如 brk 方式造成的内存碎片）</p><h3 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h3><blockquote><ul><li>进程独享虚拟地址空间（32位）  ０～３Ｇ</li><li>进程内分段管理内存空间</li></ul><blockquote><p>代码段<br />数据段<br />heap<br />malloc()<br />stack<br />文件映射，匿名映射 mmap()</p></blockquote></blockquote><p>进程内存按照用途分类</p><p><img src="http://cdn.processon.com/62c842730e3e740a4750ac02?e=1657294979&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:QcniUfzyckg6p1p7BtzFkoetjOY=" alt="" /></p><h3 id="物理内存"><a class="markdownIt-Anchor" href="#物理内存"></a> 物理内存</h3><h4 id="进程所用物理内存大小统计"><a class="markdownIt-Anchor" href="#进程所用物理内存大小统计"></a> 进程所用物理内存大小统计</h4><ul><li>PSS</li></ul><blockquote><p>一个进程所使用的内存可通过PSS和RSS来衡量。 计算进程的Pss: $ cat /proc/1/smaps | grep Pss | awk ‘{total+=$2}; END {print total}’<br />把一个共享库占用的内存，分摊到使用了这个共享库的各个进程头上</p></blockquote><ul><li>RSS(不合理)</li></ul><blockquote><p>把共享库占用的内存直接加到每个进程头上</p></blockquote><ul><li>USS</li></ul><blockquote><p>进程独自占用的物理内存（不包含共享库占用的内存）</p></blockquote><h2 id="内存回收"><a class="markdownIt-Anchor" href="#内存回收"></a> 内存回收</h2><p>在用户空间，malloc 通过 brk() 分配的内存，在释放时并不立即归还系统，而是缓存起来重复利用。在内核空间，Linux 通过 slab 分配器来管理小内存，可以把 slab 看成构建在<strong>伙伴系统上的一个缓存</strong>，主要作用就是分配并释放内核中的小对象</p><p>系统也不会任由某个进程用完所有内存。在发现内存紧张时，系统就会通过一系列机制来回收内存：</p><ul><li><p>回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面</p></li><li><p>回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中（会用到交换分区）</p></li><li><p>杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程</p></li></ul><p>OOM是内核的一种保护机制。它监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：</p><ul><li><p>进程消耗的内存越大，oom_score 就越大</p></li><li><p>进程运行占用的 CPU 越多，oom_score 就越小</p></li></ul><p>可以手动设置进程的oom_adj来调整oom_score。oom_adj的范围是[-17, 15]，数值越大，进程越容易被OOM杀死；反之，越不容易被OOM杀死</p><h3 id="回收时机"><a class="markdownIt-Anchor" href="#回收时机"></a> 回收时机</h3><ul><li>内存紧缺回收(alloc_pages的时候)</li><li>周期性内存回收：linux内存回收总结：<a href="https://cfn2lv4v46.feishu.cn/docx/P914dlXpro6CHnxErshcFuaNnYg">从swapd触发到回收3部曲</a></li><li>手动回收</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/vm/drop_caches   # &quot;clean&quot; page cache</span><br><span class="line">echo 2 &gt; /proc/sys/vm/drop_caches # shrink slab(dentry &amp; inode)</span><br><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><h3 id="回收方式"><a class="markdownIt-Anchor" href="#回收方式"></a> 回收方式</h3><ul><li>页回写 直接释放物理页面</li><li>页交换 回写到swap分区，然后释放物理页面</li><li>OOM Killer （较为暴力，应尽量避免）</li></ul><h2 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h2><h3 id="系统内存使用量"><a class="markdownIt-Anchor" href="#系统内存使用量"></a> 系统内存使用量</h3><p>buffer, cache, used</p><h4 id="相关工具"><a class="markdownIt-Anchor" href="#相关工具"></a> 相关工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/proc/meminfo</span><br><span class="line"></span><br><span class="line">free</span><br><span class="line"></span><br><span class="line">sar -r 1</span><br><span class="line"></span><br><span class="line">vmstat </span><br></pre></td></tr></table></figure><p><strong>系统内存余量</strong><br />free, available</p><p>available等于“空闲内存减去所有zones的lowmem reserve和high watermark，再加上page cache和slab中可以回收的部分“</p><h3 id="进程虚拟内存"><a class="markdownIt-Anchor" href="#进程虚拟内存"></a> 进程虚拟内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/proc/{id}/maps</p><p>pmap -p 1</p><p>进程内存使用量</p><h4 id="相关工具-2"><a class="markdownIt-Anchor" href="#相关工具-2"></a> 相关工具</h4><p>ps -aux</p><p>top</p><p>RES：常驻内存大小<br />RES=RSan+RSfd+RSsh</p><p>RSan：常驻匿名内存大小</p><p>RSfd：常驻文件映射内存大小</p><p>RSsh：常驻被锁定内存大小</p><p>SHR：共享内存大小</p><p>/proc/{pid}/status</p><p>smem -k -s rss| more</p><h3 id="缓存与缓冲区命中率"><a class="markdownIt-Anchor" href="#缓存与缓冲区命中率"></a> 缓存与缓冲区命中率</h3><p>缓存命中率，是指直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。</p><h4 id="相关工具-3"><a class="markdownIt-Anchor" href="#相关工具-3"></a> 相关工具</h4><p>cachestat/cachestat-bpfcc（系统整体）</p><p>HITS ，表示page cache命中的次数； MISSES ，表示page caceh未命中的次数； DIRTIES， Number of dirty pages added to the page cache； BUFFERS_MB，表示 Buffers 的大小，以 MB 为单位； CACHED_MB，表示 Cache 的大小，以 MB 为单位； HITRATIO，表示 page cache 命中率；</p><p>cachetop/cachetop-bpfcc（进程）</p><p>pcstat （进程&amp;文件）</p><h3 id="swap分区使用量"><a class="markdownIt-Anchor" href="#swap分区使用量"></a> swap分区使用量</h3><p>swap分区的作用是在系统物理内存不足时,将一部分物理内存中的数据交换到swap分区（磁盘上），从而把这部分物理内存释放出来给需要的程序来使用。 一、哪部分内存会被交换到swap分区？ １、匿名页(AnonPages)； ２、Shmem(基于tmpfs实现)虽然未统计在AnonPages里，但它们背后没有硬盘文件，所以也是需要交换区的。 二、从进程角度看，以下的函数或者机制分配的内存在物理内存不足时会被交换到swap分区，包括： - stack - malloc() - brk()/sbrk()  - mmap(PRIVATE, ANON) - POSIX shm* - mmap(SHARED, ANON) - tmpfs</p><h4 id="相关工具-4"><a class="markdownIt-Anchor" href="#相关工具-4"></a> 相关工具</h4><p>free（系统整体）</p><p>sar -S 1（系统整体）</p><p>smem -k（进程）</p><p>计算所有进程的swap总的大小： $ smem | awk ‘{if(NR&gt;1) total+=$(NF-3)}; END{printf total}’</p><h3 id="内存泄露情况"><a class="markdownIt-Anchor" href="#内存泄露情况"></a> 内存泄露情况</h3><h4 id="相关工具-5"><a class="markdownIt-Anchor" href="#相关工具-5"></a> 相关工具</h4><p>memleak -a -p {pid}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">leak.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">128</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">64</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺页异常主-次"><a class="markdownIt-Anchor" href="#缺页异常主-次"></a> 缺页异常（主、次）</h3><p>缺页异常：cpu拿到虚拟地址，让MMU进行地址转换的时候，MMU找不到虚拟地址的页表映射关系。 主缺页：需要从磁盘加载 memory page； 次缺页：不需要从磁盘加载 memory page；</p><h4 id="相关工具-6"><a class="markdownIt-Anchor" href="#相关工具-6"></a> 相关工具</h4><p>进程自启动以来发生的缺页事件的总和：<br />ps -eo min_flt,maj_flt,cmd | more</p><p>进程每秒缺页错误次数：<br />pidstat -r</p><h2 id="工具汇总"><a class="markdownIt-Anchor" href="#工具汇总"></a> 工具汇总</h2><h3 id="free命令"><a class="markdownIt-Anchor" href="#free命令"></a> free命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意不同版本的free输出可能会有所不同</span></span><br><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        8169348      263524     6875352         668     1030472     7611064</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><ul><li>第一列，total 是总内存大小；</li><li>第二列，used 是已使用内存的大小，包含了共享内存；</li><li>第三列，free 是未使用内存的大小；</li><li>第四列，shared 是共享内存的大小；</li><li>第五列，buff/cache 是缓存和缓冲区的大小；</li><li>最后一列，available 是新进程可用内存的大小</li></ul><p><strong>注意</strong>：available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中</p><h3 id="top命令"><a class="markdownIt-Anchor" href="#top命令"></a> top命令</h3><p>可以查看每个进程的内存使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按下M切换到内存排序</span></span><br><span class="line">$ top</span><br><span class="line">...</span><br><span class="line">KiB Mem :  8169348 total,  6871440 free,   267096 used,  1030812 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  7607492 avail Mem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">  430 root      19  -1  122360  35588  23748 S   0.0  0.4   0:32.17 systemd-journal</span><br><span class="line"> 1075 root      20   0  771860  22744  11368 S   0.0  0.3   0:38.89 snapd</span><br><span class="line"> 1048 root      20   0  170904  17292   9488 S   0.0  0.2   0:00.24 networkd-dispat</span><br><span class="line">    1 root      20   0   78020   9156   6644 S   0.0  0.1   0:22.92 systemd</span><br><span class="line">12376 azure     20   0   76632   7456   6420 S   0.0  0.1   0:00.01 systemd</span><br><span class="line">12374 root      20   0  107984   7312   6304 S   0.0  0.1   0:00.00 sshd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>主要的几个信息：</p><ul><li>VIRT 是<strong>进程虚拟内存</strong>的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内</li><li>RES 是<strong>常驻内存</strong>的大小，也就是进程<strong>实际使用的物理内存</strong>大小，但<strong>不包括 Swap 和共享内存</strong></li><li>SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等</li><li>%MEM 是进程使用物理内存占系统总内存的百分比</li></ul><p><strong>注意</strong>：</p><ul><li>虚拟内存通常并不会全部分配物理内存。从上面的输出，你可以发现每个进程的虚拟内存都比常驻内存大得多</li><li>共享内存 SHR 并不一定是共享的，比方说，<strong>程序的代码段、非共享的动态链接库</strong>，也都算在 SHR 里。SHR 也包括了<strong>进程间真正共享的内存</strong>。所以在计算多个进程的内存使用时，不要把所有进程的 SHR 直接相加得出结果</li></ul><h3 id="sar"><a class="markdownIt-Anchor" href="#sar"></a> sar</h3><p>用法： sar -r -S 1</p><p>-r: 表示显示内存使用情况</p><p>kbcommit，表示当前系统负载需要的内存。它实际上是为了保证系统内存不溢出（不超出），对需要内存的估计值。 %commit，就是这个值相对总内存的百分比，因为commit统计的是RAM+swap，所以%commit可能会大于100%</p><p>-S: 表示显示Swap使用情况</p><p>kbswpcad：其实就是swap文件的file cache。 kbswpcad = SwapCached(来自/proc/meminfo)</p><h3 id="vmstat"><a class="markdownIt-Anchor" href="#vmstat"></a> vmstat</h3><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-f: 显示系统启动到今创建的所有的进程数</span><br><span class="line"></span><br><span class="line">-S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）。默认单位为K（1024 bytes）</span><br><span class="line"></span><br><span class="line">-a: 显示活跃和非活跃内存</span><br><span class="line"></span><br><span class="line">-s：内存使用详情</span><br><span class="line"></span><br><span class="line">-m: 显示slab详情</span><br><span class="line"></span><br><span class="line">-d：磁盘读写的详情</span><br><span class="line"></span><br><span class="line">-p：显示指定磁盘分区统计信息</span><br></pre></td></tr></table></figure><h3 id="cachestatcachestat-bpfcc"><a class="markdownIt-Anchor" href="#cachestatcachestat-bpfcc"></a> cachestat/cachestat-bpfcc</h3><p>安装方法： $ sudo apt-key adv --keyserver <a href="http://keyserver.ubuntu.com">keyserver.ubuntu.com</a> --recv-keys 4052245BD4284CDD $ echo “deb <a href="https://repo.iovisor.org/apt/xenial">https://repo.iovisor.org/apt/xenial</a> xenial main” | sudo tee /etc/apt/sources.list.d/iovisor.list $ sudo apt-get update $ sudo apt-get install -y bcc-tools libbcc-examples linux-headers-$(uname -r) $ export PATH=$PATH:/usr/share/bcc/tools</p><p>用法</p><p>HITS ，表示page cache命中的次数； MISSES ，表示page caceh未命中的次数； DIRTIES， Number of dirty pages added to the page cache； BUFFERS_MB，表示 Buffers 的大小，以 MB 为单位； CACHED_MB，表示 Cache 的大小，以 MB 为单位； HITRATIO，表示 page cache 命中率；</p><p>提供了整个系统的 page cache 的读写命中情况</p><p>cachetop/cachetop-bpfcc</p><p>用法</p><p>提供了每个进程的 page cache 的读写命中情况</p><h3 id="pcstat"><a class="markdownIt-Anchor" href="#pcstat"></a> pcstat</h3><p>安装方法： $ export GOPATH=~/go $ go get <a href="http://github.com/tobert/pcstat">github.com/tobert/pcstat</a> $ cp -rfa $GOPATH/bin/pcstat /bin</p><p>用法</p><p>查看文件的缓存大小以及缓存比例：<br />$ pcstat /tftpboot/hello</p><p>查看进程打开的所有文件的缓存大小以及缓存比例：<br />$ pcstat -pid {pid}</p><h3 id="hcache"><a class="markdownIt-Anchor" href="#hcache"></a> hcache</h3><p>go version &gt; 1.12 【安装】 git clone <a href="https://github.com/silenceshell/hcache.git">https://github.com/silenceshell/hcache.git</a> cd hcache make build sudo cp hcache /usr/local/bin/</p><p>用法</p><p>输出系统中前10大使用缓存最多的文件：<br />hcache --top 10</p><p>只显示基本名字：<br />hcache --top 10 -basename</p><h3 id="memleak"><a class="markdownIt-Anchor" href="#memleak"></a> memleak</h3><p>memleak跟踪内存申请和释放请求。 【实现原理】 在跟踪某个进程时，memleak会追踪libc中的分配函数，具体来说包括：malloc、calloc、realloc、valloc、memalign、pvalloc、aligned d_alloc和free； 当跟踪所有进程时，memleak追踪包括kmalloc/kfree、kmem_cache_alloc/kmem_cache_free，以及get_free_pages/free_pages所分配的页面。</p><p>用法</p><p>-a: 表示显示每个内存分配请求的大小以及地址</p><p>-p {pid}：指定要检测的进程</p><p>-c {command}：运行指定的命令并只跟踪其分配，这会跟踪libc分配器。</p><p>-z ｛MIN_SIZE｝：只捕获大于等于MIN_SIZE字节的内存泄露</p><p>-Z {MAX_SIZE}：只捕获小于等于MAX_SIZE字节的内存泄露</p><p>INTERVAL：每隔INTERVAL秒打印未释放的申请及其调用堆栈的摘要。缺省值为5秒。</p><p>每隔１秒打印一次进程31826的内存泄露统计：<br />memleak -a -p 31826 1</p><p>限制</p><p>当追踪的进程快速申请和释放内存时，memleak可能会带来很大的开销</p><p>此工具仅适用于Linux 4.6+</p><h3 id="smem"><a class="markdownIt-Anchor" href="#smem"></a> smem</h3><p>用法</p><p>统计物理内存用量，支持的维度：process, user, mapping, systemwide</p><p>-k：显示单位后缀</p><p>-p：用百分比显示</p><p>-u：显示用户占用内存信息swap/rss/uss/pss大小</p><p>-w：显示系统内存用量，包括内核空间和用户空间</p><p>-m：统计mapping所用的物理内存</p><p>$ smem -m -k  Map  PIDs   AVGPSS      PSS  /lib/x86_64-linux-gnu/libc-2.27.so         173    29.0K     5.1M  第一列(Map)： 表示被共享的文件名字； 第二列(PIDs)： 表示上述文件被几个进程共享； 第三列(AVGPSS)： 各个进程平均分摊的内存，AVGPSS＝PSS/PIDs 第四列(PSS)： 文件加载后，占用的物理内存；</p><p>-s {swap/pss/uss/rss}：按照进程对swap/rss/pss/uss的使用量排序</p><h2 id="调优实践"><a class="markdownIt-Anchor" href="#调优实践"></a> 调优实践</h2><h3 id="实践一linux-c语言开发遇到的最常见的内存问题该如何定位解决"><a class="markdownIt-Anchor" href="#实践一linux-c语言开发遇到的最常见的内存问题该如何定位解决"></a> 实践一：linux c语言开发遇到的最常见的内存问题，该如何定位解决？</h3><p><strong>分析过程</strong></p><p>查看系统总体内存用量，确定大致问题：<br />vmstat -S K 1</p><p>对使用物理内存最多的20个进程进行监控（间隔１ｓ），确定进程是否存在内存异常：<br />watch -n 1 -d “smem -s rss |tail -n 20”</p><p>如果进程使用内存持续增加，进行内存泄露监控：<br />memleak -a -p {pid} 1</p><p>对其他内存使用量较高的进程代码进行review，主要关注如下部分：<br />- malloc<br />- brk()/sbrk()<br />- mmap()<br />- shmem等</p><p>进行代码层面的性能优化</p><p><strong>环境搭建</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">main.c</span><br><span class="line"><span class="comment">// 斐波那契数列（Fibonacci sequence）</span></span><br><span class="line"><span class="comment">// 1、1、2、3、5、8、13、21、34</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_SIZE 256000</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">fibo</span><span class="params">(<span class="type">int</span> *n0, <span class="type">int</span> *n1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *v = (<span class="type">int</span> *) <span class="built_in">malloc</span>(MALLOC_SIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, MALLOC_SIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *v = *n0 + *n1;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n0 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *v = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">2</span>; n &gt; <span class="number">0</span>; n++) &#123;</span><br><span class="line">        v = fibo(&amp;n0, &amp;n1);</span><br><span class="line">        n0 = n1;</span><br><span class="line">        n1 = *v;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dth =&gt; %lld\n&quot;</span>, n, *v);</span><br><span class="line">        <span class="comment">//free(v)</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    do_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实践二spark处理200w笔数据有时候需要几秒有时候需要几十秒原因何在"><a class="markdownIt-Anchor" href="#实践二spark处理200w笔数据有时候需要几秒有时候需要几十秒原因何在"></a> 实践二：spark处理200w笔数据，有时候需要几秒，有时候需要几十秒，原因何在？</h3><p>分析过程</p><p>检查程序执行过程中有没有涉及到文件的操作？<br />lsof -p 28161| grep test.csv</p><p>查看文件的缓存命中情况<br />pcstat /app/tools/test-tool/data/test.csv</p><p>记录测试结果</p><p>清除文件缓存<br />echo 1 &gt; /proc/sys/vm/drop_caches</p><p>查看缓存命中情况</p><p>记录测试结果</p><p>结论：由于文件缓存的作用，性能提升了10倍左右！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spark-sql&gt; </span><br><span class="line">CREATE table csv</span><br><span class="line">USING csv</span><br><span class="line">OPTIONS (</span><br><span class="line"> header true,</span><br><span class="line">  path &quot;/app/tools/test-tool/data/test.csv&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">spark-sql&gt;</span><br><span class="line">select * from csv where name=&#x27;nam9876&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在另一个terminal执行：</span><br><span class="line"># echo 1 &gt; /proc/sys/vm/drop_caches </span><br></pre></td></tr></table></figure><h3 id="调优方法"><a class="markdownIt-Anchor" href="#调优方法"></a> 调优方法</h3><p>应用层面</p><p>尽量使用缓存或者缓冲区来缓存数据</p><p>fluent-bit; flume; spark等</p><p>考虑使用tmpfs替代磁盘目录<br />mount -t tmpfs -o size=1G tmpfs /tftpboot/spark</p><p>系统层面</p><p>减少swap使用，比如减少swappiness大小</p><p>限制进程内存资源</p><p>使用HugePage（大页内存，4k-&gt;2M, 1G等），提高TLB的命中率</p><p>通过 /proc/pid/oom_adj ，调整核心应用的 oom_score<br />范围 【-17，+15】，值越大越被容易杀死</p>]]></content>
    
    
    <summary type="html">记录关于Linux Memory性能调试的白皮书</summary>
    
    
    
    <category term="SnowMoonの嵌入式笔记" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.snowmoon.top/tags/Linux/"/>
    
    <category term="Memory" scheme="https://www.snowmoon.top/tags/Memory/"/>
    
    <category term="Cache" scheme="https://www.snowmoon.top/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能调优1——CPU</title>
    <link href="https://www.snowmoon.top/2024/04/20/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-Linux-CPU-%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98/"/>
    <id>https://www.snowmoon.top/2024/04/20/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-Linux-CPU-%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98/</id>
    <published>2024-04-20T14:40:20.000Z</published>
    <updated>2024-06-02T11:52:00.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：最近的工作中涉及到了太多Linux相关调试方法与原理性的问题，但是前期工作太忙一直没来得及好好学习，仔细钻研，最近项目算是告一段落，因此希望能借此机会精进一下技术并好好总结一些方法与原理</p></blockquote><h1 id="cpu相关性能调试基本原理"><a class="markdownIt-Anchor" href="#cpu相关性能调试基本原理"></a> CPU相关性能调试基本原理</h1><p>在Linux系统中，影响性能的指标主要为CPU、内存、IO、网络，每个模块都有其特定的调试方式和工具。与CPU相关的主要调试方向为进程和线程、软硬件的中断、和上下文的切换情况。</p><h2 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h2><p>进程是资源拥有的基本单位，线程是调度的基本单位。进程与线程在内核中使用的结构体都为task_struct，二者间区别主要是进程的pid=tgid，线程的pid！=tgid。</p><p>进程状态：</p><ol><li>TASK_RUNNING 并不是说进程正在运行，而是表示进程在时刻准备运行的状态</li><li>TASK_INTERRUPTIBLE 因等待事件（比如IO事件）而进入睡眠</li><li>TASK_UNINTERRUPTIBLE 因等待事件（比如IO事件）而进入睡眠，不可以被信号唤醒</li></ol><h3 id="调度"><a class="markdownIt-Anchor" href="#调度"></a> 调度</h3><h4 id="调度策略"><a class="markdownIt-Anchor" href="#调度策略"></a> 调度策略</h4><p>普通调度策略</p><blockquote><p>SCHED_NORMAL：普通进程<br />SCHED_BATCH：后台进程<br />SCHED_IDLE：空闲进程</p></blockquote><p>实时调度策略</p><blockquote><p>SCHED_FIFO：高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，先到先得<br />SCHED_RR：高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，轮换着来<br />SCHED_DEADLIN7E</p></blockquote><h4 id="调度优先级"><a class="markdownIt-Anchor" href="#调度优先级"></a> 调度优先级</h4><p>实时进程：0 ~ 99</p><p>普通进程：100 ~ 139</p><h4 id="调度器类"><a class="markdownIt-Anchor" href="#调度器类"></a> 调度器类</h4><p>Fair</p><blockquote><p>常用的策略为：SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE</p></blockquote><p>完全公平算法 – CFS</p><blockquote><p>CFS对应的调度策略：SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE。 CFS 会为每一个进程安排一个虚拟运行时间 vruntime。如果一个进程在运行，随着时间的增加，进程的 vruntime 将不断增大。没有得到执行的进程 vruntime 不变。 显然，那些 vruntime 少的，原来受到了不公平的对待，需要给它补上，所以会优先运行这样的进程。 你可能会说，不还有优先级呢？如何给优先级高的进程多分时间呢？按比例！</p></blockquote><p>Real_Time</p><blockquote><p>常用的策略为：SCHED<em>FIFO 和 SCHED</em>RR</p></blockquote><h2 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h2><p>硬件中断的处理目前都算比较快，所以目前的调试都不会特别关注硬件中断的过程，主要关注的是软件中断的过程，因为会占用比较大量的时间</p><h2 id="上下文切换"><a class="markdownIt-Anchor" href="#上下文切换"></a> 上下文切换</h2><h3 id="cpu上下文"><a class="markdownIt-Anchor" href="#cpu上下文"></a> CPU上下文</h3><p>包括CPU寄存器和程序计数器</p><blockquote><p>CPU寄存器：是 CPU 内置的容量小、但速度极快的内存<br />程序计数器：是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置(PC指针)</p></blockquote><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/98ac9df2593a193d6a7f1767cd68eb5f.webp.webp" alt="img" /></p><ul><li>CPU上下文切换：是先把前一个任务的 CPU 上下文（也就是<strong>CPU 寄存器和程序计数器</strong>）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务</li><li>这些这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来</li></ul><p>根据任务的不同，CPU的上下文切换分为进程上下文切换、线程上下文切换和中断下文切换</p><h3 id="进程上下文切换"><a class="markdownIt-Anchor" href="#进程上下文切换"></a> 进程上下文切换</h3><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</li></ul><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/4d3f622f272c49132ecb9760310ce1a7.webp.webp" alt="img" /></p><p>从进程用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成，系统调用的过程中会发生<strong>两次CPU上下文切换</strong>。CPU里原来用户态指令的执行位置需要先保存起来，然后更新为内核态执行的指令位置，最后跳转到内核态运行内核任务。在系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。</p><p><strong>注意</strong>：</p><ol><li><p>系统调用的过程中，不会涉及到虚拟内存等进程态的资源，不会切换进程，系统调用过程和进程上下文切换不一样，整个过程都是同一个进程</p></li><li><p>系统调用称为特权模式切换，不是上下文切换</p></li></ol><p>进程上下文切换和系统调用的区别：</p><p>进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的<strong>虚拟内存、栈</strong>等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/395666667d77e718da63261be478a96b.webp.webp" alt="img" /></p><p><strong>保存上下文和恢复上下文的过程需要内核在CPU上运行才能完成</strong>（上下文切换过程是CPU密集型），每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。</p><p>在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在<strong>寄存器、内核栈以及虚拟内存</strong>等资源的保存和恢复上，进而大大缩短了真正运行进程的时间，从而导致系统平均负载升高。</p><p>Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在<strong>多处理器系统</strong>上，缓存是被多个处理器<strong>共享</strong>的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p><p>Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是<strong>优先级最高和等待 CPU 时间最长</strong>的进程来运行。</p><p>进程被CPU重新调度的时机：</p><ol><li>进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行</li><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行</li><li>进程在系统<strong>资源</strong>不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行</li><li>进程通过睡眠函数  sleep 这样的方法将自己主动挂起时，自然也会重新调度</li><li>有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序</li></ol><h3 id="线程上下文切换"><a class="markdownIt-Anchor" href="#线程上下文切换"></a> 线程上下文切换</h3><p>线程和进程的区别：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</p><p>所谓内核中的任务调度，实际上的调度对象是<strong>线程</strong>；而进程只是给线程提供了虚拟内存、全局变量等资源。</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的</li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的</li></ul><p>因此，线程的上下文切换分为两种情况：</p><ol><li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样</li><li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的<strong>私有数据、寄存器</strong>等不共享的数据</li></ol><p><strong>注意</strong>：同进程的线程切换要比进程间的切换消耗更少的资源，更加轻量级</p><h3 id="中断上下文切换"><a class="markdownIt-Anchor" href="#中断上下文切换"></a> 中断上下文切换</h3><p>为了响应硬件事件，<strong>中断处理会打断进程的正常调度和执行</strong>，转而调用中断处理程序，响应设备事件。</p><p>中断上下文切换不会涉及到进程的用户态，它其实只包括内核态中断服务程序执行所必需的状态，包括<strong>CPU 寄存器、内核堆栈、硬件中断参数</strong>等</p><p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以<strong>中断上下文切换并不会与进程上下文切换同时发生</strong></p><p>大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能</p><h1 id="性能指标1cpu使用率"><a class="markdownIt-Anchor" href="#性能指标1cpu使用率"></a> 性能指标1——CPU使用率</h1><p>CPU的使用率，就是一段时间内有进程在CPU上运行的时间占总时间的比例，包含：用户CPU、系统CPU、iowait、硬件中断、软件中断等。</p><h2 id="相关工具"><a class="markdownIt-Anchor" href="#相关工具"></a> 相关工具</h2><h3 id="top"><a class="markdownIt-Anchor" href="#top"></a> top</h3><p>top工具的输出一般像下面这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line">top - 23:50:38 up  5:13,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 355 total,   1 running, 257 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  0.1 us,  0.0 sy,  0.0 ni, 99.9 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem : 16350296 total, 12577212 free,  1452916 used,  2320168 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2097148 free,        0 used. 14469300 avail Mem </span><br><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR  S  %CPU %MEM     TIME+ COMMAND    </span><br><span class="line">1477 embedfi+  20   0  897564 268572  90336 S   0.7  1.6   0:06.02 Xorg  </span><br></pre></td></tr></table></figure><blockquote><p>top的输出：<br />us: un-niced用户进程使用的cpu时间；<br />sy：系统的内核进程<br />ni: 被调整过nice值的进程占用的CPU使用率；<br />wa:就是IO-wait；<br />hi:hardware Interrupt<br />si:software interrupt</p></blockquote><h3 id="mpstat"><a class="markdownIt-Anchor" href="#mpstat"></a> mpstat</h3><blockquote><p>mpstat的输出和top不一样：<br />%usr: 用户进程使用的cpu时间（包含un-niced和niced）；<br />%nice: niced用户进程使用的cpu时间</p></blockquote><p>显示所有CPU的指标，每秒一次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 1</span><br></pre></td></tr></table></figure><h3 id="pidstat"><a class="markdownIt-Anchor" href="#pidstat"></a> pidstat</h3><blockquote><p>pidstat输出:<br />%user表示用户进程使用的cpu时间（包含un-niced和niced）；<br />%wait表示任务等待运行时所占用的CPU百分比。</p></blockquote><p>显示所有进程的CPU指标，每秒一次:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u 1</span><br></pre></td></tr></table></figure><h3 id="gdb"><a class="markdownIt-Anchor" href="#gdb"></a> gdb</h3><h3 id="perf"><a class="markdownIt-Anchor" href="#perf"></a> perf</h3><p>实时显示CPU时钟占用最多的函数或指令</p><p>平均负载最理想的指标值是等于CPU的个数。</p><h2 id="调试技巧"><a class="markdownIt-Anchor" href="#调试技巧"></a> 调试技巧</h2><ol><li>us cpu 占用高，说明用户态进程占用了较多cpu，着重排查应用程序本身的代码逻辑问题；</li><li>sy cpu占用高，说明内核态代码占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题；</li><li>wa cpu占用高，说明等待 I/O 完成所花的时间比较长，所以应该着重排查linux系统是不是存在IO相关的性能瓶颈；</li><li>hi和si占用高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重排查内核中的中断服务程序，一般是网络；</li><li>系统整体cpu使用较高，而实际的单个进程的cpu使用都不高，要考虑短时进程是否被频繁创建和销毁；</li></ol><h1 id="性能指标2平均负载"><a class="markdownIt-Anchor" href="#性能指标2平均负载"></a> 性能指标2——平均负载</h1><p>平均负载是指单位时间内，系统处于可运行状态（Running）和不可中断等待状态（uninterruptible）的平均进程数</p><p>平均负载为3，意味着：<br />１、在只有3个CPU 的系统上，意味着所有的CPU都刚好被进程完全占用；<br />２、在6个CPU的系统上，意味着CPU有50% 的空闲；<br />３、在只有1个CPU 的系统中，则意味着2/3的进程竞争不到CPU；</p><p>平均负载是一个综合性的指标，需要通过整体变化趋势来看系统是否有压力</p><h2 id="相关工具-2"><a class="markdownIt-Anchor" href="#相关工具-2"></a> 相关工具</h2><p>uptime</p><p>top</p><p>dstat -y</p><h2 id="调优技巧"><a class="markdownIt-Anchor" href="#调优技巧"></a> 调优技巧</h2><ol><li>平均负载高可能是cpu密集型进程导致的；</li><li>平均负载高并不一定代表 CPU 使用率高，还有可能是等待I/O的进程变多了；</li><li>平均负载高的时候，需要辅助其他的工具来做进一步的分析；</li></ol><h1 id="性能指标3上下文切换"><a class="markdownIt-Anchor" href="#性能指标3上下文切换"></a> 性能指标3——上下文切换</h1><p>如果系统的上下文切换次数比较稳定，那么理想数据是１万以内</p><h2 id="相关工具-3"><a class="markdownIt-Anchor" href="#相关工具-3"></a> 相关工具</h2><h3 id="vmstat"><a class="markdownIt-Anchor" href="#vmstat"></a> vmstat</h3><blockquote><p>cs列：系统每秒上下文切换的次数。<br />r列：处于可运行态的进程数量<br />b列：处于不可中断睡眠状态的进程数量</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔5s输出一组数据</span></span><br><span class="line">[root@VM_194_74_centos ~]<span class="comment"># vmstat 5 5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy <span class="built_in">id</span> wa st</span><br><span class="line"> 1  0      0 118120 1188128 13137072    0    0     0    10    0    0  3  1 97  0  0</span><br><span class="line"> 1  0      0 117040 1188128 13137080    0    0     0    22 1071 1311  1  0 99  0  0</span><br><span class="line"> 0  0      0 116824 1188128 13137092    0    0     0    13 1181 1421  1  0 99  0  0</span><br><span class="line"> 0  0      0 117328 1188128 13137100    0    0     0    12 1165 1374  1  0 99  0  0</span><br><span class="line"> 1  0      0 117168 1188128 13137112    0    0     0    22 1148 1391  1  0 99  0  0</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>cs</code>：context switch，每秒上下文切换的次数</li><li><code>in</code>：interrupt ，每秒中断的次数</li><li><code>r</code>：就绪队列的长度（正在运行和等待CPU的进程数）</li><li><code>b</code>：blocked，处于不可中断睡眠状态的进程数</li></ul><h3 id="pidstat-2"><a class="markdownIt-Anchor" href="#pidstat-2"></a> pidstat</h3><p>显示进程的每秒自愿和非自愿上下文切换次数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pidstat -w</span></span><br></pre></td></tr></table></figure><p>命令：pidstat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ [root@VM_194_74_centos ~]<span class="comment"># pidstat -w 5</span></span><br><span class="line">Linux 3.10.107-1-tlinux2_kvm_guest-0049 (VM_194_74_centos)      05/07/20        _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">08:20:54      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:20:59        0         1      0.80      0.00  systemd</span><br><span class="line">08:20:59        0         7      0.80      0.00  migration/0</span><br><span class="line">08:20:59        0         9     90.40      0.00  rcu_sched</span><br><span class="line">08:20:59        0        10      0.20      0.00  watchdog/0</span><br><span class="line">08:20:59        0        11      0.20      0.00  watchdog/1</span><br><span class="line">08:20:59        0        12      2.00      0.00  migration/1</span><br><span class="line">08:20:59        0        16      0.20      0.00  watchdog/2</span><br><span class="line">08:20:59        0        17      1.00      0.00  migration/2</span><br><span class="line">08:20:59        0        18      0.20      0.00  ksoftirqd/2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>cswch：每秒自愿上下文切换的次数（voluntary context switch）</li><li>nvcswch：每秒非自愿上下文切换的次数(non voluntary context switch)</li></ul><blockquote><p>自愿上下文切换：进程无法获取所需资源导致的上下文切换，比如I/O，内存等<strong>系统资源不足</strong>时发生的上下文切换</p><p>非自愿上下文切换：进程因<strong>时间片</strong>已到等原因，被系统强制<strong>调度</strong>发生的上下文切换，比如多个进程<strong>竞争</strong>CPU是发生的上下文切换</p></blockquote><p>/proc/interrupts</p><p>/proc/softirqs</p><h2 id="调优技巧-2"><a class="markdownIt-Anchor" href="#调优技巧-2"></a> 调优技巧</h2><blockquote><p>如果进程的自愿上下文切换多了，表示进程在等待资源；<br />如果进程的非自愿上下文切换多了，说明进程在被强制调度（被实时性更高的进程抢占）；<br />如果中断次数多了，说明中断处理程序在占用大量的cpu;<br />如果软中断次数多了，说明下半部处理程序在占用大量的cpu，一般是网络；</p></blockquote><h1 id="调优工具"><a class="markdownIt-Anchor" href="#调优工具"></a> 调优工具</h1><h2 id="top-2"><a class="markdownIt-Anchor" href="#top-2"></a> top</h2><p>数据及指标</p><blockquote><p>us: 代表用户态cpu时间，不包含被调 整过nice值的进程所占的cpu时间；<br />ni: 代表被调整过nice值的进程占用的cpu时间；　<br />sy: 代表内核态cpu时间<br />id: 空闲时间，注意，它不包括等待 I/O 的时间（iowait）<br />wa: 代表等待I/O的cpu时间<br />hi: 代表硬件中断占据的cpu时间<br />si: 代表软件中断占据的cpu时间</p></blockquote><p>[例子]</p><blockquote><p>１、stress命令起1个进程：<br />stress -c 1<br />2、top查看<br />3、renice<br />renice -n 5 -p 26205<br />4、top查看可见进程26205的cpu用量由原来的统计到us变成了统计到ni上</p></blockquote><h3 id="可添加的参数"><a class="markdownIt-Anchor" href="#可添加的参数"></a> 可添加的参数</h3><blockquote><p>-p {pid}：只显示某个进程的状态</p><p>以下内容中【交互】表示使用top命令实时显示数据时输入对应的选项会将实时显示的数据进行对应的变化</p><p>【交互】h: 显示帮助<br />【交互】c: 切换显示完整的命令行<br />【交互】M：根据常驻内存(RES)用量进行排序<br />【交互】P: 根据CPU使用百分比大小进行排序<br />【交互】S：切换到累加模式<br />【交互】T：根据时间或者累计时间进行排序(TIME+列)<br />【交互】s：改变两次刷新的延迟时间，默认是3s<br />【交互】r：修改某个进程的nice值（对应top的NI列）</p></blockquote><h2 id="ps"><a class="markdownIt-Anchor" href="#ps"></a> ps</h2><p>显示所有进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><p>显示所有线程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf或ps -eTf</span><br></pre></td></tr></table></figure><p>ps统计的是进程的整个生命周期，top是实时的消耗，默认是三秒内</p><p>ps的可选项：</p><blockquote><p>-e：选择所有进程</p><p>-o：用于设定输出格式<br />例如： -o stat,ppid,pid,cmd 表示只输出进程的stat(状态信息)、ppid(父进程pid)、pid（当前进程的pid)，cmd(即进程的可执行文件）<br />-L Show threads, possibly with LWP and NLWP columns<br />-T Show threads, possibly with SPID column<br />-m Show threads after processes.<br />-f 全格式输出<br />-a 选择所有进程，除了session leader(见getsid(2))和与terminal不相关的进程。<br />-A, 选择所有进程（同-e）</p></blockquote><h2 id="mpstat-2"><a class="markdownIt-Anchor" href="#mpstat-2"></a> mpstat</h2><h3 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法：</h3><h3 id="mpstat-p-all-1"><a class="markdownIt-Anchor" href="#mpstat-p-all-1"></a> mpstat -P ALL 1</h3><h2 id="sar"><a class="markdownIt-Anchor" href="#sar"></a> sar</h2><h3 id="用法-2"><a class="markdownIt-Anchor" href="#用法-2"></a> 用法</h3><p>前提条件： 1. sudo vi /etc/default/sysstat　　//把false修改为true 2. sudo service sysstat restart　　//重启sysstat服务</p><h2 id="pidstat-3"><a class="markdownIt-Anchor" href="#pidstat-3"></a> pidstat</h2><blockquote><p>％usr: 进程在用户态执行的cpu时间 %system: 进程在内核态执行的cpu时间 %wait: 进程等待运行时所花费的CPU时间</p></blockquote><h3 id="用法-3"><a class="markdownIt-Anchor" href="#用法-3"></a> 用法</h3><p>每隔１秒输出一组进程的cpu数据： <code>$ pidstat -u 1</code></p><blockquote><p>-p {pid} 指定查看某个进程的信息<br />-U {usrname} 显示属于这个用户的进程<br />-r：内存</p><p>-d: IO<br />kB_rd/s：该进程每秒从磁盘读取的数据大小<br />kB_wr/s：该进程每秒写入磁盘的数据大小<br />kB_ccwr/s：每秒取消的写请求数据大小</p><p>iodelay：块 I/O 延迟，包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期。</p><p>-u: cpu（默认）</p><p>-R: 进程的realtime priority and scheduling policy</p><p>-w：进程的上下文切换信息</p><p>cswch/s：每秒自愿进行上下文切换的次数</p><p>１、所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换； ２、而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。<br />nvcswch/s：表示每秒非自愿上下文切换的次数</p><p>-v：进程相关的线程数和文件描述符数量</p><p>-s：进程stack所用内存信息</p></blockquote><h2 id="perf-2"><a class="markdownIt-Anchor" href="#perf-2"></a> perf</h2><h3 id="用法-4"><a class="markdownIt-Anchor" href="#用法-4"></a> 用法</h3><p>perf list：<br />列出所有能够触发perf采样点的事件，类似/sys/kernel/debug/tracing/available_events的输出<br />实测发现，perf 支持的事件要比ftrace多一倍左右。</p><p>perf probe：<br />定义新的动态tracepoint</p><blockquote><p>–add：添加一个probe event</p><p>例如：perf probe --add do_sys_open<br />–del：删除probe event<br />例如：perf probe --del probe:do_sys_open<br />例子：perf record -e probe:do_sys_open -aR sleep 10</p></blockquote><p>perf trace：<br />类似strace，不过性能更佳，例如：perf trace ls</p><p>perf stat：<br />运行命令并收集性能统计信息</p><p>perf top：<br />可以实时查看当前系统进程函数占用率情况</p><p>perf record：<br />运行命令并保存profile到perf.data</p><blockquote><p>-p {pid} 记录进程的events<br />-a：从所有cpu上进行采集<br />-e {event}：指定PMU（处理器监控单元） event ，默认是cycles:ppp（CPU周期数）<br />-g：启用调用图(堆栈链/回溯)记录<br />-F {freq}：采样频率</p><p>例如：<br />perf record -p 12069 -a -g -F 99 – sleep 10<br />perf record -p 12069 -a -g -F 999 – sleep 10<br />perf record -g -e cpu-clock ./perftest</p></blockquote><p>perf report：<br />从perf.data读取并显示profile</p><blockquote><p>–no-children：不统计Children开销</p><blockquote><p>Self：Self 记录的是最后一列的符号（可以理解为函数）本身的采样数占总采样数的百分比<br />目的：找到最底层的热点函数</p><p>Children：记录的是这个符号调用的其他符号（理解为子函数，包括直接调用和间接调用）的采样数之和占总采样数的百分比<br />目的：找到较高层的热点函数</p></blockquote></blockquote><p>perf script：<br />从perf.data读取并显示详细的采样数据</p><p>perf kmem：<br />跟踪/测量内核内存属性</p><blockquote><p>record：记录kmem events</p><blockquote><p>–slab：记录slab申请器的events</p><p>–page：记录page 申请器的events</p></blockquote><p>stat：报告内核内存统计信息</p><blockquote><p>–slab：统计slab申请器的events</p><p>–page：统计page 申请器的events</p></blockquote></blockquote><p>perf mem：<br />分析内存访问</p><p>perf lock：<br />分析锁性能</p><p>perf kvm：<br />针对kvm虚拟化分析</p><p>perf sched：<br />分析内核调度器性能</p><blockquote><p>record：采集和记录scheduling events</p><blockquote><p>例如（全局）：perf sched record – sleep 10<br />例如（进程）：perf sched record -p 752 – sleep 10</p></blockquote><p>script：报告采集到的事件</p><p>latency：报告每个任务的调度延迟和进程的其他调度属性</p><p>timehist：提供调度事件的分析报告</p></blockquote><p>火焰图</p><p>火焰图的横轴和纵轴的含义： - 横轴表示采样数和采样比例。一个函数占用的横轴越宽，就代表它的执行时间越长。同一层的多个函数，则是按照字母来排序。 - 纵轴表示调用栈，由下往上根据调用关系逐个展开。换句话说，上下相邻的两个函数中，下面的函数，是上面函数的父函数。这样，调用栈越深，纵轴就越高。 火焰图不包含任何时间的因素，所以并不能看出横向各个函数的执行次序。</p><h3 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 场景</h3><p>寻找热点函数，定位性能瓶颈</p><p>具体实现是对事件进行采样，然后再根据采样数，评估各个函数的调用频率，</p><p>perf 可以用来分析 CPU cache、CPU 迁移、分支预测、指令周期等各种硬件事件</p><p>perf 也可以只对感兴趣的事件进行动态追踪</p><p>实践过程</p><p>寻找热点函数，定位性能瓶颈</p><p>自定义追踪函数</p><p>1、添加 do_sys_open 探针 $ perf probe --add do_sys_open 2、采样和追踪 $ perf record -e probe:do_sys_open -aR sleep 1 3、查看采样结果 $ perf script 4、删除探针 $ perf probe --del probe:do_sys_open</p><h2 id="pstree"><a class="markdownIt-Anchor" href="#pstree"></a> pstree</h2><h3 id="用法-5"><a class="markdownIt-Anchor" href="#用法-5"></a> 用法</h3><p>经典用法： $ pstree -p 5638 显示5638这个进程的进程树（包含线程） $ pstree -T -p 5638 显示5638这个进程的进程树（不包含线程）</p><blockquote><p>-a 显示命令行参数  If the command line of a process is swapped out，则该进程将显示在括号中，例如类似这样： -{kubeensaas}(8)</p><p>-c 禁止压缩子树（压缩后不显示子树信息）</p><p>-n 通过pid而不是name对相同祖先的进程排序</p><p>-g 显示PGIDs</p><p>-p 显示某个进程的进程树（包含线程）</p><p>-T 隐藏线程、只显示进程</p></blockquote><h2 id="taskset"><a class="markdownIt-Anchor" href="#taskset"></a> taskset</h2><h3 id="用法-6"><a class="markdownIt-Anchor" href="#用法-6"></a> 用法</h3><p>-pc 0x3 {pid}：绑定cpu0和cpu1到进程</p><p>-pc {pid}：查看进程绑定的cpu(输出为３，也就是011，表示第０，１个cpu)</p><h2 id="cpulimit"><a class="markdownIt-Anchor" href="#cpulimit"></a> cpulimit</h2><h3 id="用法-7"><a class="markdownIt-Anchor" href="#用法-7"></a> 用法</h3><p>-p {pid} -l {percent}：进程允许的cpu用量为percent%</p><p>-k：如果进程cpu超量，直接杀掉进程而不是限制cpu使用(默认)；</p><p>-m：输出统计信息；</p><h2 id="pstack"><a class="markdownIt-Anchor" href="#pstack"></a> pstack</h2><p>$ pstack 11613 11613: ./jin pstack: Input/output error failed to read target. 【解决】 参考此处： <a href="https://blog.csdn.net/u010164190/article/details/111059283">https://blog.csdn.net/u010164190/article/details/111059283</a></p><h3 id="用法-8"><a class="markdownIt-Anchor" href="#用法-8"></a> 用法</h3><p>pstack｛pid｝对指定PID的进程输出函数调用栈</p><h3 id="场景-2"><a class="markdownIt-Anchor" href="#场景-2"></a> 场景</h3><p>应用并未崩溃，如何查看stack trace信息？</p><h2 id="strace"><a class="markdownIt-Anchor" href="#strace"></a> strace</h2><h3 id="用法-9"><a class="markdownIt-Anchor" href="#用法-9"></a> 用法</h3><blockquote><p>-p {pid｝<br />-f 跟踪子进程<br />-t 在输出中的每一行前加上时间信息<br />-T 显示每一个系统调用所耗的时间<br />-c 统计每一个系统调用的调用次数、错误次数、执行时间和执行时间占比</p></blockquote><h3 id="场景-3"><a class="markdownIt-Anchor" href="#场景-3"></a> 场景</h3><p>正在运行的程序实际读取的是哪个配置文件？</p><p>程序好像hang住了，具体是什么情况，为什么hang住？hang在了哪里？</p><p>进程运行很慢，但是没有源代码，想看看时间都花在了哪里？</p><p>容器环境下，如何对应用程序的网络行为进行调试和追踪？</p><h2 id="stap"><a class="markdownIt-Anchor" href="#stap"></a> stap</h2><h3 id="用法-10"><a class="markdownIt-Anchor" href="#用法-10"></a> 用法</h3><p>stap --all-modules dropwatch.stp</p><h2 id="proc"><a class="markdownIt-Anchor" href="#proc"></a> /proc</h2><p>用法</p><p>通过子进程的Pid得到父进程的Pid：<code>cat /proc/&#123;pid&#125;/status | grep PPid</code></p><h1 id="调试方法"><a class="markdownIt-Anchor" href="#调试方法"></a> 调试方法</h1><h2 id="用户cpu使用率较高-checklist"><a class="markdownIt-Anchor" href="#用户cpu使用率较高-checklist"></a> 用户cpu使用率较高 checklist</h2><p>分析过程</p><ol><li>通过top命令查看系统整体的cpu使用率和平均负载</li><li>pidstat -u 1| more 查看进程的cpu使用率，找到可疑进程</li><li>pstree -p {pid}查看进程的进程结构（继承关系）</li><li>strace -f -p {pid} 追踪进程的系统调用情况，是否存在频繁的系统调用？</li><li>pstack {pid}找到代码瓶颈点</li></ol><h2 id="软中断cpu使用率较高checklist"><a class="markdownIt-Anchor" href="#软中断cpu使用率较高checklist"></a> 软中断cpu使用率较高，Checklist</h2><p>分析过程</p><ol><li>通过top命令查看系统整体的cpu使用率和平均负载</li><li>watch -d cat /proc/softirqs 找到瓶颈所在的软件中断</li><li>perf record -g 采集内核事件</li><li>perf report分析事件，找到瓶颈所在的内核函数代码</li></ol><h2 id="cpu使用率较高checklist"><a class="markdownIt-Anchor" href="#cpu使用率较高checklist"></a> cpu使用率较高，Checklist</h2><p>分析过程</p><ol><li>通过top命令查看系统整体的cpu使用率和平均负载</li><li>pidstat -u 1| more<br />查看进程的cpu使用率，找到可疑进程</li><li>iostat查看系统整体的I/O情况</li><li>iotop查看进程的I/O压力情况</li><li>strace -f -p {pid} 追踪进程的系统调用情况，是否存在频繁的系统调用？</li></ol><h2 id="案例分析"><a class="markdownIt-Anchor" href="#案例分析"></a> 案例分析</h2><p><code>sysbench</code>模拟多线程调度切换</p><h3 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h3><blockquote><p>一台Linux机器，打开三个终端</p></blockquote><h3 id="正式实战"><a class="markdownIt-Anchor" href="#正式实战"></a> 正式实战</h3><ol><li>第一个终端：运行<code>sysbench</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以10个线程运行5分钟的基准测试，模拟多线程切换的问题</span><br><span class="line">$ sysbench --threads=10 --max-time=300 threads run</span><br></pre></td></tr></table></figure><ol start="2"><li>第二个终端：运行<code>vmstat</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔1秒输出1组数据（需要Ctrl+C才结束）</span></span><br><span class="line">$ vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy <span class="built_in">id</span> wa st</span><br><span class="line"> 6  0      0 6487428 118240 1292772    0    0     0     0 9019 1398830 16 84  0  0  0</span><br><span class="line"> 8  0      0 6487428 118240 1292772    0    0     0     0 10191 1392312 16 84  0  0  0</span><br></pre></td></tr></table></figure><p>指标观察：</p><ul><li><p>cs列：上升到39万</p></li><li><p>r列：就绪队列长度上升到8</p></li><li><p>in列：终端次数上升到1万</p></li><li><p>us（user）和sy（system）列：使用率加起来100%，sy为84%，主要被内核占用</p></li></ul><ol start="3"><li>查看进程情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 每隔1秒输出1组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标</span></span><br><span class="line">$ pidstat -w -u 1</span><br><span class="line">08:06:33      UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">08:06:34        0     10488   30.00  100.00    0.00    0.00  100.00     0  sysbench</span><br><span class="line">08:06:34        0     26326    0.00    1.00    0.00    0.00    1.00     0  kworker/u4:2</span><br><span class="line"></span><br><span class="line">08:06:33      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:06:34        0         8     11.00      0.00  rcu_sched</span><br><span class="line">08:06:34        0        16      1.00      0.00  ksoftirqd/1</span><br><span class="line">08:06:34        0       471      1.00      0.00  hv_balloon</span><br><span class="line">08:06:34        0      1230      1.00      0.00  iscsid</span><br><span class="line">08:06:34        0      4089      1.00      0.00  kworker/1:5</span><br><span class="line">08:06:34        0      4333      1.00      0.00  kworker/0:3</span><br><span class="line">08:06:34        0     10499      1.00    224.00  pidstat</span><br><span class="line">08:06:34        0     26326    236.00      0.00  kworker/u4:2</span><br><span class="line">08:06:34     1000     26784    223.00      0.00  sshd</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：CPU 使用率的升高果然是 sysbench 导致的，它的 CPU 使用率已经达到了 100%。但上下文切换则是来自其他进程，包括非自愿上下文切换频率最高的 pidstat  ，以及自愿上下文切换频率最高的内核线程 kworker 和 sshd</p><p><strong>注意</strong>：pidstat 输出的上下文切换次数，加起来也就几百，比 vmstat 的 139 万明显小了太多？</p><ol start="4"><li>查看线程的情况</li></ol><p>可以看到，sysbench 进程（也就是主线程）的上下文切换次数看起来并不多，但它的子线程的上下文切换次数却有很多。上下文切换罪魁祸首，还是过多的 sysbench 线程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔1秒输出一组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -wt 参数表示输出线程的上下文切换指标</span></span><br><span class="line">$ pidstat -wt 1</span><br><span class="line">08:14:05      UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">...</span><br><span class="line">08:14:05        0     10551         -      6.00      0.00  sysbench</span><br><span class="line">08:14:05        0         -     10551      6.00      0.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10552  18911.00 103740.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10553  18915.00 100955.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10554  18827.00 103954.00  |__sysbench</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="5"><li>查看中断升高的原因<br />根据前文的分析，中断次数也升高到了1万左右，从/proc/interrupts只读文件查看中断情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 参数表示高亮显示变化的区域</span></span><br><span class="line">$ watch -d <span class="built_in">cat</span> /proc/interrupts</span><br><span class="line">           CPU0       CPU1</span><br><span class="line">...</span><br><span class="line">RES:    2450431    5279697   Rescheduling interrupts</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>观察发现，变化速度最快的是<strong>重调度中断（RES）</strong>，它代表唤醒空闲状态的 CPU 来调度新的任务运行，这是在多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为<strong>处理器间中断</strong>（Inter-Processor Interrupts，IPI）</p><p><strong>分析</strong>：过多任务导致了重调度中断的升高，和前面分析结果一致</p><h3 id="每秒上下文切换多少次正常"><a class="markdownIt-Anchor" href="#每秒上下文切换多少次正常"></a> 每秒上下文切换多少次正常？</h3><p><strong>上下文切换次数取决于系统本身的CPU性能</strong>。如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题，这时根据具体上下文切换的类型具体分析：</p><ul><li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题</li><li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈</li><li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型</li></ul><h3 id="系统出现大量不可中断进程和僵尸进程怎么办"><a class="markdownIt-Anchor" href="#系统出现大量不可中断进程和僵尸进程怎么办"></a> 系统出现大量不可中断进程和僵尸进程怎么办？</h3><h4 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h4><ul><li><p><strong>R</strong>：表示正在就绪队列中的进程，正在运行或者正在等待运行</p></li><li><p><strong>D</strong>：Disk Sleep，不可中断状态睡眠（Uninterruptible Sleep），一般是进程和硬件交互，并且交互过程不允许其他进程或中断打断</p></li><li><p><strong>Z</strong> ：Zombie 的缩写，它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）</p></li><li><p><strong>S</strong> ：Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态</p></li><li><p><strong>I</strong>： Idle 的缩写，也就是空闲状态，用在<strong>不可中断睡眠的内核线程</strong>上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会</p></li><li><p><strong>T</strong>：Stopped或者Traced，表示进程处于暂停或者跟踪状态（SIGSTOP信号会让进程变为暂停状态，再发送SIGCONT信号，进程又会恢复运行）</p></li><li><p><strong>X</strong>：Dead，表示进程已经消亡，top或者ps看不到</p></li></ul><blockquote><p>不可中断状态，是为了保证进程数据与硬件状态一致，正常情况下，不可中断状态在很短时间内就会结束。短时的不可中断状态进程，我们一般可以忽略。</p><p>但如果系统或硬件发生了故障，进程可能会在不可中断状态保持很久，甚至导致系统中出现大量不可中断进程。需要注意下，系统是不是出现了 I/O 等性能问题。</p></blockquote><p><strong>注意</strong>：ps查看进程状态时，会有Ss+，D+等情况，其中s表示进程是会话的领导进程，+表示前台进程组</p><h4 id="案例分析-2"><a class="markdownIt-Anchor" href="#案例分析-2"></a> 案例分析</h4><h5 id="指标分析"><a class="markdownIt-Anchor" href="#指标分析"></a> 指标分析</h5><ol><li>运行案例的docker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --privileged --name=app -itd feisky/app:iowait</span><br></pre></td></tr></table></figure><ol start="2"><li>top查看指标</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按下数字 1 切换到所有 CPU 的使用情况，观察一会儿按 Ctrl+C 结束</span></span><br><span class="line">$ top</span><br><span class="line">top - 05:56:23 up 17 days, 16:45,  2 <span class="built_in">users</span>,  load average: 2.00, 1.68, 1.39</span><br><span class="line">Tasks: 247 total,   1 running,  79 sleeping,   0 stopped, 115 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  0.7 sy,  0.0 ni, 38.9 <span class="built_in">id</span>, 60.5 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  0.7 sy,  0.0 ni,  4.7 <span class="built_in">id</span>, 94.6 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 4340 root      20   0   44676   4048   3432 R   0.3  0.0   0:00.05 top</span><br><span class="line"> 4345 root      20   0   37280  33624    860 D   0.3  0.0   0:00.01 app</span><br><span class="line"> 4344 root      20   0   37280  33624    860 D   0.3  0.4   0:00.01 app</span><br><span class="line">    1 root      20   0  160072   9416   6752 S   0.0  0.1   0:38.59 systemd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li>分析</li></ol><ul><li>第一行的平均负载（ Load Average），过去 1 分钟、5 分钟和 15 分钟内的平均负载在依次减小，说明平均负载正在升高；而 1 分钟内的平均负载已经达到系统的 CPU 个数，说明系统很可能已经有了性能瓶颈。</li><li>第二行的 Tasks，有 1 个正在运行的进程，但僵尸进程比较多，而且还在不停增加，说明有子进程在退出时没被清理。</li><li>CPU 的使用率情况，用户 CPU 和系统 CPU 都不高，但 iowait 分别是 60.5% 和 94.6%，好像有点儿不正常。</li><li>最后再看每个进程的情况， CPU 使用率最高的进程只有 0.3%，看起来并不高；但有两个进程处于 D 状态，它们可能在等待 I/O，但光凭这里并不能确定是它们导致了 iowait 升高。</li></ul><ol start="4"><li>结论</li></ol><ul><li>第一点，iowait 太高了，导致系统的平均负载升高，甚至达到了系统 CPU 的个数</li><li>第二点，僵尸进程在不断增多，说明有程序没能正确清理子进程的资源。</li></ul><h5 id="iowait分析"><a class="markdownIt-Anchor" href="#iowait分析"></a> iowait分析</h5><ol><li>dstat查看系统I/O情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔1秒输出10组数据</span></span><br><span class="line">$ dstat 1 10</span><br><span class="line">You did not <span class="keyword">select</span> any stats, using -cdngy by default.</span><br><span class="line">--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai stl| <span class="built_in">read</span>  writ| recv  send|  <span class="keyword">in</span>   out | int   csw</span><br><span class="line">  0   0  96   4   0|1219k  408k|   0     0 |   0     0 |  42   885</span><br><span class="line">  0   0   2  98   0|  34M    0 | 198B  790B|   0     0 |  42   138</span><br><span class="line">  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  42   135</span><br><span class="line">  0   0  84  16   0|5633k    0 |  66B  342B|   0     0 |  52   177</span><br><span class="line">  0   3  39  58   0|  22M    0 |  66B  342B|   0     0 |  43   144</span><br><span class="line">  0   0   0 100   0|  34M    0 | 200B  450B|   0     0 |  46   147</span><br><span class="line">  0   0   2  98   0|  34M    0 |  66B  342B|   0     0 |  45   134</span><br><span class="line">  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  39   131</span><br><span class="line">  0   0  83  17   0|5633k    0 |  66B  342B|   0     0 |  46   168</span><br><span class="line">  0   3  39  59   0|  22M    0 |  66B  342B|   0     0 |  37   134</span><br></pre></td></tr></table></figure><p>可以看到，每当 iowait 升高（wai）时，磁盘的读请求（read）都会很大。这说明 iowait 的升高跟磁盘的读请求有关，很可能就是磁盘读导致的</p><ol start="2"><li>pidstat分析D状态的进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 展示 I/O 统计数据，-p 指定进程号，间隔 1 秒输出 3 组数据</span></span><br><span class="line">$ pidstat -d -p 4344 1 3</span><br><span class="line">06:38:50      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:38:51        0      4344      0.00      0.00      0.00       0  app</span><br><span class="line">06:38:52        0      4344      0.00      0.00      0.00       0  app</span><br><span class="line">06:38:53        0      4344      0.00      0.00      0.00       0  app</span><br></pre></td></tr></table></figure><ul><li>kB_rd 表示每秒读的 KB 数</li><li>kB_wr 表示每秒写的 KB 数</li><li>iodelay 表示 I/O 的延迟（单位是时钟周期）。</li><li>它们都是 0，那就表示此时没有任何的读写，说明问题不是 4344 进程导致的。</li></ul><ol start="3"><li>pidstat查看所有进程情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 1 秒输出多组数据 (这里是 20 组)</span></span><br><span class="line">$ pidstat -d 1 20</span><br><span class="line">...</span><br><span class="line">06:48:46      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:47        0      4615      0.00      0.00      0.00       1  kworker/u4:1</span><br><span class="line">06:48:47        0      6080  32768.00      0.00      0.00     170  app</span><br><span class="line">06:48:47        0      6081  32768.00      0.00      0.00     184  app</span><br><span class="line"></span><br><span class="line">06:48:47      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:48        0      6080      0.00      0.00      0.00     110  app</span><br><span class="line"></span><br><span class="line">06:48:48      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:49        0      6081      0.00      0.00      0.00     191  app</span><br><span class="line"></span><br><span class="line">06:48:49      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line"></span><br><span class="line">06:48:50      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:51        0      6082  32768.00      0.00      0.00       0  app</span><br><span class="line">06:48:51        0      6083  32768.00      0.00      0.00       0  app</span><br><span class="line"></span><br><span class="line">06:48:51      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:52        0      6082  32768.00      0.00      0.00     184  app</span><br><span class="line">06:48:52        0      6083  32768.00      0.00      0.00     175  app</span><br><span class="line"></span><br><span class="line">06:48:52      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:53        0      6083      0.00      0.00      0.00     105  app</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>观察一会儿可以发现，的确是 app 进程在进行磁盘读，并且每秒读的数据有 32 MB，看来就是 app 的问题。不过，app 进程到底在执行啥 I/O 操作呢？<strong>进程想要访问磁盘，就必须使用系统调用，所以接下来，重点就是找出 app 进程的系统调用</strong></p><ol start="4"><li>strace跟踪进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ strace -p 6082</span><br><span class="line">strace: attach: ptrace(PTRACE_SEIZE, 6082): Operation not permitted</span><br></pre></td></tr></table></figure><ul><li>检查一下进程的状态，已经变成僵尸进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep 6082</span><br><span class="line">root      6082  0.0  0.0      0     0 pts/0    Z+   13:43   0:00 [app] &lt;defunct&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>动态追踪</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ perf record -g</span><br><span class="line">$ perf report</span><br></pre></td></tr></table></figure><p>如下图，swapper是内核的调度进程，可忽略</p><p>可以发现， app 的确在通过系统调用 <strong>sys_read()</strong> 读取数据。并且从 new_sync_read 和 blkdev_direct_IO  能看出，进程正在对磁盘进行<strong>直接读</strong>，也就是<strong>绕过了系统缓存</strong>，每个读请求都会从磁盘直接读，这就可以解释我们观察到的 iowait 升高了<br /><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/21e79416e946ed049317a4b4c5a576a1.webp.webp" alt="img" /></p><ol start="6"><li>打开app.py文件，可以看到使用了 O_DIRECT 选项打开磁盘</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(disk, O_RDONLY|O_DIRECT|O_LARGEFILE, 0755)</span><br></pre></td></tr></table></figure><blockquote><p>直接读写磁盘，对 I/O 敏感型应用（比如数据库系统）是很友好的，因为你可以在应用中，直接控制磁盘的读写。但在大部分情况下，我们最好还是通过系统缓存来优化磁盘 I/O</p></blockquote><ol start="7"><li>修复代码</li></ol><p><a href="http://xn--app-fix1-8t1m43fvzrka047nwg5b3i3c.py">修复后的文件名app-fix1.py</a>，运行docker如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 首先删除原来的应用</span><br><span class="line">$ docker rm -f app</span><br><span class="line"># 运行新的应用</span><br><span class="line">$ docker run --privileged --name=app -itd feisky/app:iowait-fix1</span><br></pre></td></tr></table></figure><p>top检查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ top</span><br><span class="line">top - 14:59:32 up 19 min,  1 user,  load average: 0.15, 0.07, 0.05</span><br><span class="line">Tasks: 137 total,   1 running,  72 sleeping,   0 stopped,  12 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  1.7 sy,  0.0 ni, 98.0 <span class="built_in">id</span>,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  1.3 sy,  0.0 ni, 98.7 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 3084 root      20   0       0      0      0 Z   1.3  0.0   0:00.04 app</span><br><span class="line"> 3085 root      20   0       0      0      0 Z   1.3  0.0   0:00.04 app</span><br><span class="line">    1 root      20   0  159848   9120   6724 S   0.0  0.1   0:09.03 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd</span><br><span class="line">    3 root      20   0       0      0      0 I   0.0  0.0   0:00.40 kworker/0:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="僵尸进程分析"><a class="markdownIt-Anchor" href="#僵尸进程分析"></a> 僵尸进程分析</h5><blockquote><p>僵尸进程是因为父进程没有回收子进程的资源而出现的，那么，就需要找出父进程，然后在父进程里解决。</p></blockquote><ol><li>pstree</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a 表示输出每个程序完整的命令（包含路径，参数或是常驻服务的标示）</span></span><br><span class="line"><span class="comment"># p指定PID</span></span><br><span class="line"><span class="comment"># s表示显示指定进程的父进程</span></span><br><span class="line">$ pstree -aps 3084</span><br><span class="line">systemd,1</span><br><span class="line">  └─dockerd,15006 -H fd://</span><br><span class="line">      └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml</span><br><span class="line">          └─docker-containe,3991 -namespace moby -workdir...</span><br><span class="line">              └─app,4009</span><br><span class="line">                  └─(app,3084)</span><br></pre></td></tr></table></figure><ol start="2"><li>查看app-fix1.py代码</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> status = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fork()== <span class="number">0</span>) &#123;</span><br><span class="line">        sub_process();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(wait(&amp;status)&gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以发现，文件错误地把 wait() 放到了 for 死循环的外面，也就是说，wait() 函数实际上并没被调用到，我们把它挪到 for 循环的里面就可以了。</p><p>修改后的文件我放到了 app-fix2.c ，运行对应的docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先停止产生僵尸进程的 app</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f app</span><br><span class="line"><span class="comment"># 然后启动新的 app</span></span><br><span class="line">$ docker run --privileged --name=app -itd feisky/app:iowait-fix2</span><br></pre></td></tr></table></figure><ol start="3"><li><p>top查看</p><p>僵尸进程（Z 状态）没有了， iowait 也是 0，问题解决</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ top</span><br><span class="line">top - 15:00:44 up 20 min,  1 user,  load average: 0.05, 0.05, 0.04</span><br><span class="line">Tasks: 125 total,   1 running,  72 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  1.7 sy,  0.0 ni, 98.3 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  1.3 sy,  0.0 ni, 98.7 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 3198 root      20   0    4376    840    780 S   0.3  0.0   0:00.01 app</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd</span><br><span class="line">    3 root      20   0       0      0      0 I   0.0  0.0   0:00.41 kworker/0:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="怎么理解cpu软中断"><a class="markdownIt-Anchor" href="#怎么理解cpu软中断"></a> 怎么理解CPU软中断</h3><blockquote><p>中断是一种异步的事件处理机制，可以提高系统的并发处理能力</p><p>为了减少对正常进程运行调度的影响，中断处理程序应该尽快完成</p></blockquote><h4 id="软中断"><a class="markdownIt-Anchor" href="#软中断"></a> 软中断</h4><p>中断过程分为上半部和下半部：</p><ul><li>上半部：用来快速处理中断，它在中断禁止模式下运行，主要处理和<strong>硬件紧密相关</strong>或者<strong>时间敏感</strong>的工作</li><li>下半部：用来延迟处理上半部未完成的工作，通常以<strong>内核线程</strong>的形式运行</li></ul><p>网卡接收数据包的例子：网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。对上半部来说，既然是快速处理，其实就是要把网卡的数据<strong>读到内存</strong>中，然后<strong>更新硬件寄存器的状态</strong>（表示数据已经读好了），最后再发送一个软中断信号，通知下半部做进一步的处理。而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照<strong>网络协议栈</strong>，对数据进行<strong>逐层解析和处理</strong>，直到把它送给应用程序。</p><p>可以理解为：<strong>上半部快速执行，下半部延迟执行</strong></p><h4 id="查看软中断和内核线程"><a class="markdownIt-Anchor" href="#查看软中断和内核线程"></a> 查看软中断和内核线程</h4><ol><li>查看/proc文件系统</li></ol><ul><li>/proc/softirqs，提供了软中断的运行情况</li><li>/proc/interrupts，提供了硬中断的运行情况</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看到各类软中断在不同CPU上累积的运行次数</span></span><br><span class="line">$ <span class="built_in">cat</span> /proc/softirqs</span><br><span class="line">                    CPU0       CPU1</span><br><span class="line">          HI:          0          0</span><br><span class="line">       TIMER:     811613    1972736</span><br><span class="line">      NET_TX:         49          7</span><br><span class="line">      NET_RX:    1136736    1506885</span><br><span class="line">       BLOCK:          0          0</span><br><span class="line">    IRQ_POLL:          0          0</span><br><span class="line">     TASKLET:     304787       3691</span><br><span class="line">       SCHED:     689718    1897539</span><br><span class="line">     HRTIMER:          0          0</span><br><span class="line">         RCU:    1330771    1354737</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>软中断的类型：第一列的内容，对应软中断的类型，比如<strong>NET_TX代表网络接收中断，NET_RX代表网络发送中断，SCHE代表调度，TIMER代表定时器</strong>等等</li><li>每种软中断在不同CPU上的运行情况：同一行的内容，正常情况下，同一种中断在不同CPU上的累计次数应该差不多，比如NET_RX。 而TASKLET只在调用它的函数所在的CPU运行（存在的<strong>问题</strong>：由于只在一个 CPU 上运行导致的调度不均衡，或者因为不能在多个 CPU 上并行运行带来了性能限制）</li></ul><ol start="2"><li>软中断以内核线程方式运行，每个CPU都对应一个软中断内核线程（ksoftirqd/CPU编号）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep softirq</span><br><span class="line">root         7  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/0]</span><br><span class="line">root        16  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/1]</span><br></pre></td></tr></table></figure><h3 id="系统的软中断cpu使用率升高该怎么办"><a class="markdownIt-Anchor" href="#系统的软中断cpu使用率升高该怎么办"></a> 系统的软中断CPU使用率升高，该怎么办？</h3><h4 id="案例准备"><a class="markdownIt-Anchor" href="#案例准备"></a> 案例准备</h4><p>工具介绍：</p><ul><li>sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。</li><li>hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等。</li><li>tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题</li></ul><p>案例图示</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image.webp" alt="image.png" /></p><p>其中一台虚拟机运行 Nginx ，用来模拟待分析的 Web 服务器；而另一台当作 Web 服务器的客户端，用来给 Nginx 增加压力请求</p><h4 id="操作和分析"><a class="markdownIt-Anchor" href="#操作和分析"></a> 操作和分析</h4><p>运行Nginx应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行Nginx服务并对外开放80端口</span></span><br><span class="line">$ docker run -itd --name=nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>在另一个终端运行hping3模拟客户端的请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -S参数表示设置TCP协议的SYN（同步序列号），-p表示目的端口为80</span></span><br><span class="line"><span class="comment"># -i u100表示每隔100微秒发送一个网络帧</span></span><br><span class="line"><span class="comment"># 注：如果你在实践过程中现象不明显，可以尝试把100调小，比如调成10甚至1</span></span><br><span class="line">$ hping3 -S -p 80 -i u100 192.168.0.30</span><br></pre></td></tr></table></figure><p>会发现简单的shell命令都变慢了，执行top查看系统整体情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># top运行后按数字1切换到显示所有CPU</span></span><br><span class="line">$ top</span><br><span class="line">top - 10:50:58 up 1 days, 22:10,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 122 total,   1 running,  71 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni, 96.7 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  3.3 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni, 95.6 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  4.4 si,  0.0 st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    7 root      20   0       0      0      0 S   0.3  0.0   0:01.64 ksoftirqd/0</span><br><span class="line">   16 root      20   0       0      0      0 S   0.3  0.0   0:01.97 ksoftirqd/1</span><br><span class="line"> 2663 root      20   0  923480  28292  13996 S   0.3  0.3   4:58.66 docker-containe</span><br><span class="line"> 3699 root      20   0       0      0      0 I   0.3  0.0   0:00.13 kworker/u4:0</span><br><span class="line"> 3708 root      20   0   44572   4176   3512 R   0.3  0.1   0:00.07 top</span><br><span class="line">    1 root      20   0  225384   9136   6724 S   0.0  0.1   0:23.25 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.03 kthreadd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>平均负载全是 0，就绪队列里面只有一个进程（1 running）。</li><li>每个 CPU 的使用率都挺低，最高的 CPU1 的使用率也只有 4.4%，并不算高。</li><li>再看进程列表，CPU 使用率最高的进程也只有 0.3%</li><li>两个 CPU 的使用率虽然分别只有 3.3% 和 4.4%，但都用在了软中断上；而从进程列表上也可以看到，CPU 使用率最高的也是软中断进程 ksoftirqd</li></ul><p>查看软中断变化情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d <span class="built_in">cat</span> /proc/softirqs</span><br><span class="line">                    CPU0       CPU1</span><br><span class="line">          HI:          0          0</span><br><span class="line">       TIMER:    1083906    2368646</span><br><span class="line">      NET_TX:         53          9</span><br><span class="line">      NET_RX:    1550643    1916776</span><br><span class="line">       BLOCK:          0          0</span><br><span class="line">    IRQ_POLL:          0          0</span><br><span class="line">     TASKLET:     333637       3930</span><br><span class="line">       SCHED:     963675    2293171</span><br><span class="line">     HRTIMER:          0          0</span><br><span class="line">         RCU:    1542111    1590625</span><br></pre></td></tr></table></figure><p>可以发现， TIMER（定时中断）、NET_RX（网络接收）、SCHED（内核调度）、RCU（RCU 锁）等这几个软中断都在不停变化，这些中断是保证 Linux 调度、时钟和临界区保护这些正常工作所必需，变化是正常的。而其中的NET_RX，也就是<strong>网络数据包接收软中断</strong>的变化速率最快</p><p>使用sar工具查看网络收发情况(可以观察网络收发吞吐量和PPS)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -n DEV 表示显示网络收发的报告，间隔1秒输出一组数据</span></span><br><span class="line">$ sar -n DEV 1</span><br><span class="line">15:03:46        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">15:03:47         eth0  12607.00   6304.00    664.86    358.11      0.00      0.00      0.00      0.01</span><br><span class="line">15:03:47      docker0   6302.00  12604.00    270.79    664.66      0.00      0.00      0.00      0.00</span><br><span class="line">15:03:47           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">15:03:47    veth9f6bbcd   6302.00  12604.00    356.95    664.66      0.00      0.00      0.00      0.05</span><br></pre></td></tr></table></figure><p>可以发现：</p><ul><li>对网卡 eth0 来说，每秒接收的网络帧数比较大，达到了 12607，而发送的网络帧数则比较小，只有 6304；每秒接收的千字节数只有 664 KB，而发送的千字节数更小，只有 358 KB。</li><li>docker0 和 veth9f6bbcd 的数据跟 eth0 基本一致，只是发送和接收相反，发送的数据较大而接收的数据较小。这是 Linux 内部网桥转发导致的，暂且不用深究，只要知道这是系统把 eth0 收到的包转发给 Nginx 服务即可</li><li>重点来看 eth0 ：接收的 PPS 比较大，达到 12607，而接收的 BPS 却很小，只有 664 KB。直观来看网络帧应该都是比较小的，664*1024/12607 = 54 字节，说明平均每个网络帧只有 54 字节，这显然是很小的网络帧，也就是所谓的<strong>小包问题</strong></li></ul><p>tcpdump抓取eth0上的包，指定TCP协议和80端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -i eth0 只抓取eth0网卡，-n不解析协议名和主机名</span></span><br><span class="line"><span class="comment"># tcp port 80表示只抓取tcp协议并且端口号为80的网络帧</span></span><br><span class="line">$ tcpdump -i eth0 -n tcp port 80</span><br><span class="line">15:11:32.678966 IP 192.168.0.2.18238 &gt; 192.168.0.30.80: Flags [S], <span class="built_in">seq</span> 458303614, win 512, length 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从 tcpdump 的输出中，你可以发现：</p><ul><li>192.168.0.2.18238 &gt; 192.168.0.30.80  ，表示网络帧从 192.168.0.2 的 18238 端口发送到 192.168.0.30 的 80 端口，也就是从运行 hping3 机器的 18238 端口发送网络帧，目的为 Nginx 所在机器的 80 端口。</li><li>Flags [S] 则表示这是一个 SYN 包</li></ul><p><strong>最后，可以确定这是从192.168.0.2.18238来的SYN FLOOF攻击</strong></p><p>SYN FLOOD 问题最简单的解决方法：从交换机或者硬件防火墙中封掉来源 IP，这样 SYN FLOOD 网络帧就不会发送到服务器中（后面的网络篇再进一步深究）</p><h3 id="套路篇如何迅速分析出cpu的瓶颈在哪里"><a class="markdownIt-Anchor" href="#套路篇如何迅速分析出cpu的瓶颈在哪里"></a> 套路篇：如何迅速分析出CPU的瓶颈在哪里？</h3><h4 id="cpu性能指标"><a class="markdownIt-Anchor" href="#cpu性能指标"></a> CPU性能指标</h4><p>性能指标总览</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image.webp" alt="image.png" /></p><h5 id="cpu使用率"><a class="markdownIt-Anchor" href="#cpu使用率"></a> CPU使用率</h5><p>CPU 使用率描述了非空闲时间占总 CPU 时间的百分比，根据 CPU 上运行任务的不同，又被分为用户 CPU、系统 CPU、等待 I/O CPU、软中断和硬中断等。用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态</p><ul><li>CPU 使用率（nice），表示 CPU 在<strong>用户态</strong>运行的时间百分比。用户 CPU 使用率高，通常说明有<strong>应用程序</strong>比较繁忙。</li><li>系统 CPU 使用率，表示 CPU 在<strong>内核态</strong>运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明<strong>内核</strong>比较繁忙。</li><li>等待 I/O 的 CPU 使用率，通常也称为 <strong>iowait</strong>，表示<strong>等待 I/O</strong> 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互时间比较长。</li><li>软中断和硬中断的 CPU 使用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断。</li><li>除了上面这些，还有在虚拟化环境中会用到的<strong>窃取 CPU 使用率（steal）<strong>和</strong>客户 CPU 使用率（guest）</strong>，分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比。</li></ul><h5 id="平均负载"><a class="markdownIt-Anchor" href="#平均负载"></a> 平均负载</h5><blockquote><p>系统的平均活跃进程数。它反应了系统的整体负载情况，主要包括三个数值，分别指过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。</p><p>理想情况下，平均负载等于逻辑 CPU 个数，这表示每个 CPU 都恰好被充分利用。如果平均负载大于逻辑 CPU 个数，就表示负载比较重了。</p></blockquote><h5 id="进程上下文切换-2"><a class="markdownIt-Anchor" href="#进程上下文切换-2"></a> 进程上下文切换</h5><p>进程上下文切换分为：</p><ol><li>自愿上下文切换</li><li>非自愿上下文切换</li></ol><p><strong>注意</strong>：过多的上下文切换，会将原本运行进程的 CPU 时间，消耗在<strong>寄存器、内核栈以及虚拟内存等数据的保存和恢复</strong>上，缩短进程真正运行的时间，成为性能瓶颈</p><h5 id="cpu缓存命中率"><a class="markdownIt-Anchor" href="#cpu缓存命中率"></a> CPU缓存命中率</h5><p>CPU 缓存的速度介于 CPU 和内存之间，缓存的是<strong>热点的内存数据</strong>。</p><p>如下图，根据不断增长的热点数据，这些缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 常用在单核中， L3 则用在多核中。从 L1 到 L3，三级缓存的大小依次增大，相应的，性能依次降低（当然比内存还是好得多）。而它们的命中率，衡量的是 <strong>CPU 缓存的复用情况</strong>，命中率越高，则表示性能越好。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/aa08816b60e453b52b5fae5e63549e33.webp.webp" alt="img" /></p><h4 id="cpu性能工具"><a class="markdownIt-Anchor" href="#cpu性能工具"></a> CPU性能工具</h4><ul><li>平均负载案例：使用<strong>uptime</strong>查看平均负载，在平均负载升高时，使用<strong>mpstat</strong>和<strong>pidstat</strong>分别观察每个CPU和每个进程CPU的使用情况，找到导致平均负载升高的stress进程</li><li>上下文切换的案例：先使用<strong>vmstat</strong>，查看系统的上下文切换次数和中断次数；然后通过<strong>pidstat</strong>（-w参数）观察进程的自愿上下文切换和非自愿上下文切换；最后通过<strong>vmstat</strong>（-wt参数）查看线程的上下文切换情况，从而找到了线程上下文切换增多的原因是sysbench工具</li><li>进程CPU使用率升高的案例：先使用top找出系统和进程CPU的使用情况，发现了CPU使用率很高的进程php-fpm，再使用perf top找出热点函数sqrt()；如果是Python应用，可以使用profiler工具<strong>pyflame</strong>对指定进程分析（pyflame -p pid --threads -s 检测时间 -r 取样间隔 -o &lt;file.txt&gt;），再通过flamegraph.pl将输出的txt文件转换为*.svg格式的火焰图（./flamegraph.pl prof.txt &gt; prof.svg）</li><li>不可中断进程和僵尸进程的案例：<ul><li>不可中断进程分析过程：先使用top查看，发现存在D状态（不可中断休眠进程）和Z状态（僵尸进程），并且iowait较高；使用<strong>dstat</strong>分析磁盘I/O，发现<strong>app</strong>进程有大量的磁盘读请求；使用<strong>pidstat</strong>(-d -p 参数)分析app进程的I/O操作，发现没有大量的I/O操作，再用pidstat -d分析系统的I/O情况，发现还是app进程在进行磁盘读；再使用<strong>strace</strong>跟踪D状态进程对应进程号的系统调用，发现没有权限；ps查看发现对应进程号的进程已经变成僵尸进程；之后，通过perf record -g和perf report生成报告，查看app进程的调用栈，发现CPU使用主要是在sys_read()函数，定位到是在对磁盘进行直接读（direct_IO）；查看代码发现open()系统调用使用了O_DIRECT参数</li><li>僵尸进程分析：使用pstree命令找出僵尸进程的父进程是app进程，然后查看app.c文件，发现wait()使用位置不当导致不能回收子进程</li></ul></li><li>软中断的案例：先使用top查看系统指标，发现系统CPU使用率很低，但是主要是在软中断si上，然后查看/proc/softirqs查看系统软中断变化情况，发现NET_RX变化率很快，再使用sar工具查看系统的网络收发情况，发现eth0网卡接收到了大量的小包；在通过抓包工具tcpdump，发现eth0接受到了大量的SYN包，最终确定了是SYN FLOOD攻击</li></ul><h5 id="性能指标找工具"><a class="markdownIt-Anchor" href="#性能指标找工具"></a> 性能指标找工具</h5><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/202406012245720.webp" alt="image.png" /></p><h5 id="工具找指标"><a class="markdownIt-Anchor" href="#工具找指标"></a> 工具找指标</h5><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/202406012244925.webp" alt="image.png" /></p><h4 id="如何分析cpu的性能瓶颈"><a class="markdownIt-Anchor" href="#如何分析cpu的性能瓶颈"></a> 如何分析CPU的性能瓶颈</h4><p><strong>重点</strong>：弄清楚性能指标之间的关联性</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/202406012244017.webp" alt="image.png" /></p><h3 id="cpu性能优化的几个思路"><a class="markdownIt-Anchor" href="#cpu性能优化的几个思路"></a> CPU性能优化的几个思路</h3><h4 id="性能优化方法论"><a class="markdownIt-Anchor" href="#性能优化方法论"></a> 性能优化方法论</h4><p>确定三个问题：</p><ul><li>判断所做的性能优化是否有效？优化后，能提升多少性能，有多少收益？</li><li>如果有多个性能问题同时存在，应该先优化哪一个？</li><li>当有多种优化的方法，应该选择哪一种？</li></ul><h5 id="怎么评估性能优化的效果"><a class="markdownIt-Anchor" href="#怎么评估性能优化的效果"></a> 怎么评估性能优化的效果</h5><p><strong>三步走</strong>的原则：</p><ol><li>确定性能的量化指标</li><li>测试优化前的性能指标</li><li>测试优化后的性能指标</li></ol><p><strong>第一步</strong>，性能的量化指标包括CPU使用率、应用的吞吐量、响应时间等等，<strong>不要局限在单一维度的指标上</strong>。例如，以Web应用为例：</p><ul><li>应用程序的维度，使用<strong>吞吐量和请求延时</strong>来评估</li><li>系统资源的维度，使用<strong>CPU使用率</strong>来评估</li></ul><p>好的应用程序是性能优化的最终结果和目的，要使用应用程序的指标，来评估性能优化的整体效果；而系统资源的使用情况是影响应用程序的根源，需要用资源的指标，来分析应用性能的瓶颈来源</p><p><strong>第二三步</strong>，对比第一步确定的<strong>量化指标</strong>在优化前后的差距，拿数据说话。例如，使用ab工具测试Web应用的并发请求数和响应延时，同时使用vmstat,pidstat等工具，观察系统和进程的CPU使用率，同时获得了应用和系统两个维度的性能指标</p><p><strong>进行性能测试需要注意的是</strong>：</p><ul><li>要避免性能测试工具干扰应用程序的性能</li><li>避免外部环境的变化影响性能指标的评估。在优化前、后的应用程序，都运行在相同配置的机器上，并且它们的外部依赖也要完全一致</li></ul><h5 id="多个性能问题同时存在怎么选择"><a class="markdownIt-Anchor" href="#多个性能问题同时存在怎么选择"></a> 多个性能问题同时存在，怎么选择？</h5><p>遵循<strong>二八原则</strong>，80%的性能问题都是由于20%的代码导致的，<strong>并不是所有的性能问题都值得优化</strong></p><p>分析的步骤：</p><ul><li>挨个分析出所有的性能瓶颈，排除掉有因果关系的性能问题</li><li>在剩下的几个性能问题中，选择能明显提升应用性能的问题进行修复，有两种方法：<ul><li>如果系统资源出现瓶颈，首先优化系统资源使用的问题</li><li>针对不同类型的指标，，首先优化导致<strong>性能指标变化幅度最大</strong>的那些瓶颈问题</li></ul></li></ul><h5 id="有多种优化方法时如何选择"><a class="markdownIt-Anchor" href="#有多种优化方法时如何选择"></a> 有多种优化方法时，如何选择？</h5><p><strong>性能优化并非没有成本</strong>。</p><p>一个很典型的例子网络中的 DPDK（Data Plane Development Kit）。DPDK 是一种优化网络处理速度的方法，它通过绕开内核网络协议栈的方法，提升网络的处理能力。不过它有一个很典型的要求，就是要<strong>独占一个 CPU 以及一定数量的内存大页</strong>，并且总是以 100% 的 CPU 使用率运行。所以，如果你的 CPU 核数很少，就有点得不偿失了。</p><p>因此，在考虑性能优化方法时，要结合实际情况，考虑多方面的因素，进行权衡在做选择</p><h4 id="cpu优化"><a class="markdownIt-Anchor" href="#cpu优化"></a> CPU优化</h4><h5 id="应用程序优化"><a class="markdownIt-Anchor" href="#应用程序优化"></a> 应用程序优化</h5><p>常见的几种优化方法：</p><ul><li><strong>编译器优化</strong>：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如， gcc 就提供了优化选项 -O2，开启后会自动对应用程序的代码进行优化。</li><li><strong>算法优化</strong>：使用复杂度更低的算法，显著加快处理速度</li><li><strong>异步处理</strong>：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题。</li><li><strong>多线程代替多进程</strong>：前面讲过，相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本。</li><li><strong>善用缓存</strong>：经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度。</li></ul><h5 id="系统优化"><a class="markdownIt-Anchor" href="#系统优化"></a> 系统优化</h5><p>常见的系统优化方法：</p><ul><li><strong>CPU 绑定</strong>：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题</li><li><strong>CPU 独占</strong>：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU</li><li><strong>优先级调整</strong>：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。可以适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理</li><li><strong>为进程设置资源限制</strong>：使用 Linux cgroups  来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。</li><li><strong>NUMA（Non-Uniform Memory Access）优化</strong>：支持 NUMA 的处理器会将内存划分为多个 node，每个 node 关联到系统的一个处理器。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存。</li><li><strong>中断负载均衡</strong>：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把<strong>中断处理过程自动负载均衡到多个 CPU 上</strong>。</li></ul><h5 id="避免过早优化"><a class="markdownIt-Anchor" href="#避免过早优化"></a> 避免过早优化</h5><p>性能优化最好是<strong>逐步完善，动态进行，不追求一步到位</strong>，而要<strong>首先保证能满足当前的性能要求</strong>。当发现性能不满足要求或者出现性能瓶颈时，再根据性能评估的结果，选择最重要的性能问题进行优化</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p><strong>要忍住“把 CPU 性能优化到极致”的冲动</strong>，因为 CPU 并不是唯一的性能因素，还会有其他的性能问题，比如内存、网络、I/O 甚至是架构设计的问题。</p><p>如果不做全方位的分析和测试，只是单纯地把某个指标提升到极致，并不一定能带来整体的收益。</p>]]></content>
    
    
    <summary type="html">记录关于Linux CPU性能调试的白皮书</summary>
    
    
    
    <category term="SnowMoonの嵌入式笔记" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式Linux" scheme="https://www.snowmoon.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    <category term="Linux" scheme="https://www.snowmoon.top/tags/Linux/"/>
    
    <category term="CPU" scheme="https://www.snowmoon.top/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>Git操作学习——从一个可视化的git练习网站说起</title>
    <link href="https://www.snowmoon.top/2023/12/27/Git%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84git%E7%BB%83%E4%B9%A0%E7%BD%91%E7%AB%99%E8%AF%B4%E8%B5%B7/"/>
    <id>https://www.snowmoon.top/2023/12/27/Git%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84git%E7%BB%83%E4%B9%A0%E7%BD%91%E7%AB%99%E8%AF%B4%E8%B5%B7/</id>
    <published>2023-12-27T13:50:21.000Z</published>
    <updated>2024-06-01T15:16:05.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>自以为自己已经学会了使用git，但是当我被分配了大量的bug需要修复并且大量使用git时才知道自己的git的掌握程度有多菜，因此回家开始补习git的操作了。</p><p>最好的练习方式自然是能够可视化的进行练习，因此我找到了一个进行可视化练习git操作的网站<a href="https://learngitbranching.js.org/?locale=zh_CN">Learngitbranching</a>来学习git相关的操作，本文为学习的记录，以便后续查询使用。</p><h1 id="git-本地操作"><a class="markdownIt-Anchor" href="#git-本地操作"></a> Git 本地操作</h1><h2 id="git-commit提交更改"><a class="markdownIt-Anchor" href="#git-commit提交更改"></a> git commit——提交更改</h2><p><code>git commit</code> 主要是用于记录下各种修改的历史记录，<code>git commit</code> 的提交记录类似文件快照，但做的非常轻量化。</p><p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p><p>进行<code>git commit</code>的时候，他会将你add过的文件进行提交，每次提交会检查当前目录下所有跟踪的文件是否发生了变化，如果有则会提醒你进行add，在所有跟踪了的文件都add了以后，Git会保存add了的文件与上次提交间的差异，并要求你输入一定的commit message。</p><h2 id="git-branch新建分支"><a class="markdownIt-Anchor" href="#git-branch新建分支"></a> git branch——新建分支</h2><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">早建分支！多用分支！</span><br></pre></td></tr></table></figure><p>这是因为<strong>即使创建再多的分支也不会造成储存或内存上的开销</strong>，因为分支只是相当于新建了个指向当前提交的指针而已，并不会复制任何文件，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p><p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：<strong>“我想基于这个提交以及它所有的 parent 提交进行新的工作。”</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch NewBranch</span><br></pre></td></tr></table></figure><p>这个语句仅仅相当于新建一个名为NewBranch的分支，指向目前最新的一个提交。</p><p>分支相关的操作如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建分支</span><br><span class="line">git branch newImage</span><br><span class="line">git commit</span><br><span class="line">// 切换分支</span><br><span class="line">git checkout newImage</span><br><span class="line">git commit</span><br><span class="line">// 创建并切换分支</span><br><span class="line">git checkout -b bugFix</span><br></pre></td></tr></table></figure><h2 id="git-merge合并分支"><a class="markdownIt-Anchor" href="#git-merge合并分支"></a> git merge——合并分支</h2><p>使用 <code>git merge</code>在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent 节点。翻译成自然语言相当于：“我要把这两个 parent 节点本身及它们所有的祖先都包含进来。</p><p>当目前工作区中没有未提交的更改并且不产生冲突时，<code>git merge bugFix</code>操作会将下图的C2、C3提交合并到一起并产生一个新提交C4</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227222857591.png" alt="image-20231227222857591" /></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227223357594.png" alt="image-20231227223357594" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 当前分支与目标分支合并</span><br><span class="line">git merge bugFix</span><br><span class="line">git checkout bugFix</span><br><span class="line">git merge main</span><br><span class="line">// 由于 main 的一个父节点是 bugFix</span><br><span class="line">// 换句话说，main 继承自 bugFix</span><br><span class="line">// 所以 Git 什么也没做</span><br></pre></td></tr></table></figure><p>由于<code>git merge</code>会在本地产生一个merge的提交，而一般远程不会允许普通开发者进行merge操作，故我们在本地进行开发时一般不适用merge操作，更常用的是rabase操作</p><h2 id="git-rebase分支合并方法之二"><a class="markdownIt-Anchor" href="#git-rebase分支合并方法之二"></a> git rebase——分支合并方法之二</h2><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227233048032.png" alt="image-20231227233048032" /></p><p>执行<code>git rebase main</code>后得到下图所示提交情况</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227233139759.png" alt="image-20231227233139759" /></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20231227233250524.png" alt="image-20231227233250524" /></p><p>rebase 第二个参数是要移动的源分支，如果不提供默认为 HEAD。如果当前分支不在源分支上，使用第二个参数可以节省一次 checkout 动作。</p><h2 id="在提交树上移动"><a class="markdownIt-Anchor" href="#在提交树上移动"></a> 在提交树上移动</h2><p>HEAD：你目前正在工作的提交记录，一般指向当前分支的最近一次提交记录，但有时候checkout或者别的原因也可能导致头指针和工作的分支分离，需要查看<code>HEAD</code>的指向可以使用使用<code>cat .git/HEAD</code>命令或者直接使用<code>git branch</code>指令</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101162004970.png" alt="image-20240101162004970" /></p><p><code>git checkout hashnumber</code>指令的作用即为将目前的头指针指向hashnumber对应的提交，也即执行<code>git checkout C1</code>后，头指针会从main上分离，变为下图的状态</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101162117892.png" alt="image-20240101162117892" /></p><h3 id="相对引用~"><a class="markdownIt-Anchor" href="#相对引用~"></a> 相对引用(^)(~)</h3><p>Git中提供了一些操作符来引用提交，这样便于我们进行快速的移动头指针而不用随时都列出当前工作区的log来checkout过去。相对引用非常给力，这里我介绍两个简单的用法：</p><ul><li>使用 <code>^</code> 向上移动 1 个提交记录</li><li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li></ul><p>首先看看操作符 (^)。把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的 parent 提交。</p><p>所以 <code>main^</code> 相当于“<code>main</code> 的 parent 节点”，<code>main^^</code> 是 <code>main</code> 的第二个 parent 节点。我们也可以将 <code>HEAD</code> 作为相对引用的参照，将头指针相对自己往上移动一定的位置。</p><p>如果你想在提交树中向上移动很多步的话，敲那么多 <code>^</code> 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 <code>~</code>。</p><p>该操作符后面可以跟一个数字（可选，不跟数字时与 <code>^</code> 相同，向上移动一次），指定向上移动多少次。</p><h3 id="git-branch-f-强制修改分支位置"><a class="markdownIt-Anchor" href="#git-branch-f-强制修改分支位置"></a> git branch -f 强制修改分支位置</h3><p>我使用相对引用最多的就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交。例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -f main HEAD~3</span><br></pre></td></tr></table></figure><p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级 parent 提交。</p><p>也可以直接使用绝对引用，将分支切换到某个特定提交，但是在切换前一般会要保存工作区的内容，并且移动有时候也会有比较多的冲突之类的问题因此需要最好不要将该分支直接移动到另外的分支中某个与要移动的分支不重合的提交前，也即对于下图而言最好不用使用如下命令，建议多建分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -f main C3</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101163648382.png" alt="image-20240101163648382" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 查看日志</span><br><span class="line">git log</span><br><span class="line">// 找到 main 的父节点</span><br><span class="line">git checkout main^</span><br><span class="line">// 找到 HEAD 的父节点</span><br><span class="line">git checkout HEAD^</span><br><span class="line">// 让 main 分支指向 HEAD 的第三级父提交节点</span><br><span class="line">// 可以说，git branch -f 和 git branch 内容都不一样</span><br><span class="line">// git branch 是创建分支，而 git branch -f 是改变分支指向提交节点</span><br><span class="line">git branch -f main HEAD~3</span><br><span class="line">// 注意，不能写 git branch -f HEAD HEAD^，因为没有这个分支</span><br><span class="line">// 只能用 checkout 调整 HEAD</span><br><span class="line">git checkout HEAD^</span><br></pre></td></tr></table></figure><h2 id="撤销变更"><a class="markdownIt-Anchor" href="#撤销变更"></a> 撤销变更</h2><p>可以通过 Reset 和 Revert 撤销变更。</p><h3 id="git-reset"><a class="markdownIt-Anchor" href="#git-reset"></a> git reset</h3><p>Reset 相当于撤销历史。通过它可以回退本地的提交节点。但是无法处理远程分支。</p><p>Revert 用于撤销远程提交。这个过程引入了新的提交节点，因为这个节点做的事情是撤销上个提交节点的内容，所以和上上个节点的内容是一样的。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101164209093.png" alt="image-20240101164209093" /></p><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><h3 id="git-revert"><a class="markdownIt-Anchor" href="#git-revert"></a> git revert</h3><p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p><p>在我们输入指令git revert C2后要撤销的提交记录后面多了一个新提交！这是因为新提交记录 <code>C2'</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2'</code> 的状态与 <code>C1</code> 是相同的。</p><p>revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240101164931457.png" alt="image-20240101164931457" /></p><p>PS：事实上，我们在本地使用revert撤销提交一般较少，为了保证更清晰的提交线，我们一般是<strong>在云端进行revert</strong>，本地如果要对上一次修改进行重新修改的话直接<code>git commit --amend</code>就行，对于云端已merge的提交要再次进行修改，最好的做法是<strong>提交一个新的提交来修复上次提交存在的问题而不是revert</strong>，因为当你reverse 再commit后就会存在两个提交需要审核再合入，因此会多一个提交的审核量，所以更建议使用新提交来修复</p><h2 id="变更提交顺序"><a class="markdownIt-Anchor" href="#变更提交顺序"></a> 变更提交顺序</h2><h3 id="git-cherry-pick"><a class="markdownIt-Anchor" href="#git-cherry-pick"></a> git cherry-pick</h3><p>Cherry-pick 可以用于将指定提交节点复制到 <code>HEAD</code> 分支上，它的命令的格式如下</p><p><code>git cherry-pick &lt;提交号&gt;...</code></p><p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。</p><p>PS：如果你cherry-pick的是一个云端的未合并的提交，你在本地进行开发后再提交会将这个未合并的提交再commit一遍，这个提交的uploader就变成你了</p><h3 id="交互式rebase"><a class="markdownIt-Anchor" href="#交互式rebase"></a> 交互式rebase</h3><p>当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p><p>但是如果你不清楚你想要的提交记录的哈希值呢? 或者你想要再修改前面的提交呢？幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p><p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p><p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p><p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。</p><p>下图为我的博客中使用指令<code>git rebase -i HEAD~2</code>得到的交互式指令界面，我们要调整提交的顺序就可以通过这里pick的顺序来修改，其他的指令如下图所示。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103214804407.png" alt="image-20240103214804407" /></p><ul><li><p>pick：保留该 commit</p></li><li><p>reword：保留该 commit，但我需要修改该 commit 的注释</p></li><li><p>edit：保留该 commit，但我要停下来修改该提交（不禁惊修改注释）</p></li><li><p>squash：将该 commit 和前一个 commit 合并</p></li><li><p>fixup：将该 commit 和前一个 commit 合并，但我不要保留该提交的注释信息</p></li><li><p>exec：执行 shell 命令</p></li><li><p>drop：我要丢弃该 commit</p></li></ul><p>当 rebase UI界面打开时, 你能做3件事:</p><ul><li>调整提交记录的顺序（通过鼠标拖放来完成）</li><li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li><li>合并提交。 它允许你把多个提交记录合并成一个。</li></ul><h2 id="一些技巧"><a class="markdownIt-Anchor" href="#一些技巧"></a> 一些技巧</h2><h3 id="截取单次提交"><a class="markdownIt-Anchor" href="#截取单次提交"></a> 截取单次提交</h3><p>来看两个在开发中经常会遇到的情况：</p><p>1.我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息，这些调试和打印语句都在它们各自的提交记录里，最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p><p>最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>main</code> 分支上，但这样的话 <code>main</code> 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用<code>git rebase -i</code> <code>git cherry-pick</code>来达到目的。</p><p>使用<code>git rebase -i</code>时将某几个提交放弃，就会只保留最新的提交</p><p>在原分支<code>cherry-pick</code>某个提交即可只保留该提交</p><p>2.当我们一次性提交了5个提交，后三个提交已经merge，而第二个提交需要有新的修改时</p><p>我们就可以使用<code>git rebase -i HEAD~4</code>指令，然后将顶部的我们要修改的提交改为edit状态，然后修改后使用<code>git add</code>+<code>git commit --amend</code>再使用<code>git rebase --continue</code>回到最新的工作区</p><h3 id="提交的技巧"><a class="markdownIt-Anchor" href="#提交的技巧"></a> 提交的技巧</h3><h4 id="git-rebase"><a class="markdownIt-Anchor" href="#git-rebase"></a> git rebase</h4><p>接下来这种情况也是很常见的：你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，然后又提交了一次。</p><p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p><p>我们可以通过下面的方法来克服困难：</p><ol><li>用 git rebase -i 将提交重新排序，然后把我们想要修改的提交记录挪到最前</li><li>用 git commit --amend 来进行一些小修改</li><li>用 git rebase -i 来将他们调回原来的顺序</li><li>把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li></ol><p>或者觉得调整顺序麻烦的话，我们也可以按下列步骤修改</p><ol><li>用 git rebase -i 打开交互界面，将我们要修改的提交状态改为edit</li><li>修改然后使用git add 和 git commit --amend的连招</li><li>使用git rebase --continue将当前指针移动到最前，大功告成</li></ol><h4 id="git-cherry-pick-2"><a class="markdownIt-Anchor" href="#git-cherry-pick-2"></a> git cherry-pick</h4><p>我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p><p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。</p><p>使用<code>git cherry-pick</code> 就可以避免一些这些问题，我们使用<code>cherry-pick</code>时会把某个分支上的某个提交拉到我们当前分支的最新提交处，为避免本地和云端冲突，比较好的做法是使用一个Develop分支来作为与云端保持同步的分支，当我们需要cherry-pick某个关系比较复杂的提交时，我们就可以先checkout到这个Develop分支来使用git pull拉取最新的代码，然后再使用git checkout -b bugFix建立一个bugFix分支来进行我们的修改，此时我们就可以在bugFix这个分支上使用<code>cherry-pick</code>拉取要修改的那个提交到最新当前分支处，修改然后使用git add 和 git commit --amend的连招，此时就可以进行push而不存在冲突了</p><h4 id="git-tag"><a class="markdownIt-Anchor" href="#git-tag"></a> git tag</h4><p>分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p><p>你可能会问了：有没有什么可以<em>永远</em>指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p><p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p><p>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103224553317.png" alt="image-20240103224553317" /></p><h4 id="git-describe"><a class="markdownIt-Anchor" href="#git-describe"></a> git describe</h4><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p><p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p><p><code>git describe</code> 的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会使用你目前所在的位置（<code>HEAD</code>）。</p><p>它输出的结果是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</span><br></pre></td></tr></table></figure><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p><p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103224657939.png" alt="image-20240103224657939" /></p><h2 id="多分支rebase"><a class="markdownIt-Anchor" href="#多分支rebase"></a> 多分支rebase</h2><p><code>git rebase side2 side1</code>操作会将当前side1的所有和side2有分支差异且可合并的提交合并到side2的提交上并将HEAD移动到side1上</p><h2 id="选择-parent-提交记录"><a class="markdownIt-Anchor" href="#选择-parent-提交记录"></a> 选择 parent 提交记录</h2><p>操作符 <code>^</code> 与 <code>~</code> 符一样，后面也可以跟一个数字。</p><p>但是该操作符后面的数字与 <code>~</code> 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个 parent 提交。还记得前面提到过的一个合并提交有两个 parent 提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p><p>Git 默认选择合并提交的“第一个” parent 提交，在操作符 <code>^</code> 后跟一个数字可以改变这一默认行为。</p><h2 id="纠缠不清的分支"><a class="markdownIt-Anchor" href="#纠缠不清的分支"></a> 纠缠不清的分支</h2><p>现在我们的 <code>main</code> 分支是比 <code>one</code>、<code>two</code> 和 <code>three</code> 要多几个提交。出于某种原因，我们需要把 <code>main</code> 分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。</p><p><code>one</code> 需要重新排序并删除 <code>C5</code>，<code>two</code> 仅需要重排排序，而 <code>three</code> 只需要提交一次。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103230610668.png" alt="image-20240103230610668" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout one</span><br><span class="line">git cherry-pick C4 C3 C2</span><br><span class="line">git checkout two</span><br><span class="line">git cherry-pick C5 C4 C3 C2</span><br><span class="line">git branch -f three C2</span><br></pre></td></tr></table></figure><h1 id="git-云端仓库"><a class="markdownIt-Anchor" href="#git-云端仓库"></a> Git 云端仓库</h1><h2 id="远程仓库"><a class="markdownIt-Anchor" href="#远程仓库"></a> 远程仓库</h2><p>远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录</p><p>话虽如此, 远程仓库却有一系列强大的特性</p><ul><li>首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</li><li>还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</li></ul><p>现在用网站来对远程仓库进行可视化操作变得越发流行了(像 <a href="https://github.com/">GitHub</a>), 但远程仓库<strong>永远</strong>是这些工具的顶梁柱, 因此理解其概念非常的重要!</p><p>我们现在需要学习远程仓库的操作 —— 我们需要一个配置这种环境的命令, 它就是 <code>git clone</code>。 从技术上来讲，<code>git clone</code> 命令在真实的环境下的作用是在<strong>本地</strong>创建一个远程仓库的拷贝（比如从 <a href="http://github.com">github.com</a>）。</p><p>使用<code>git clone</code> 命令完成对远程仓库和本地仓库的建立，咱们深入地看一下发生了什么。</p><p>你可能注意到的第一个事就是在我们的本地仓库多了一个名为 <code>origin/main</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。由于远程分支的特性导致其拥有一些特殊属性。</p><p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p><p>远程分支有一个特别的属性，在你切换到远程分支时，自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p><p><strong>为什么有 <code>origin/</code>？</strong></p><p>你可能想问这些远程分支的前面的 <code>origin/</code> 是什么意思呢？远程分支有一个命名规范 —— 它们的格式是:</p><ul><li><code>&lt;remote name&gt;/&lt;branch name&gt;</code></li></ul><p>因此，如果你看到一个名为 <code>origin/main</code> 的分支，那么这个分支就叫 <code>main</code>，远程仓库的名称就是 <code>origin</code>。</p><p>大多数的开发人员会将它们主要的远程仓库命名为 <code>origin</code>，这是因为当你用 <code>git clone</code> 某个仓库时，Git 已经帮你把远程仓库的名称设置为 <code>origin</code> 了</p><p>如果切换到远程分支会怎么样呢？</p><p>Git 变成了分离 HEAD 状态，当添加新的提交时 <code>o/main</code> 也不会更新。这是因为 <code>o/main</code> 只有在远程仓库中相应的分支更新了以后才会更新。</p><h2 id="git-fetch"><a class="markdownIt-Anchor" href="#git-fetch"></a> Git Fetch</h2><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p><p>本节课我们将学习如何从远程仓库获取数据 —— 命令如其名，它就是 <code>git fetch</code>。</p><p>你会看到当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103231358387.png" alt="image-20240103231358387" /></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103231413367.png" alt="image-20240103231413367" /></p><h3 id="git-fetch-做了些什么"><a class="markdownIt-Anchor" href="#git-fetch-做了些什么"></a> git fetch 做了些什么</h3><p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>o/main</code>)</li></ul><p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p><p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你<strong>最后一次与它通信时</strong>的状态，<code>git fetch</code> 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 <code>git fetch</code> 与远程分支之间的关系了吧。</p><p><code>git fetch</code> 通常通过互联网（使用 <code>http://</code> 或 <code>git://</code> 协议) 与远程仓库通信。</p><h3 id="git-fetch-不会做的事"><a class="markdownIt-Anchor" href="#git-fetch-不会做的事"></a> git fetch 不会做的事</h3><p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p><p>理解这一点很重要，因为许多开发人员误以为执行了 <code>git fetch</code> 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令 😄</p><p>所以, 你可以将 <code>git fetch</code> 的理解为单纯的下载操作。</p><h2 id="git-pull"><a class="markdownIt-Anchor" href="#git-pull"></a> Git Pull</h2><p>既然我们已经知道了如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p><ul><li><code>git cherry-pick o/main</code></li><li><code>git rebase o/main</code></li><li><code>git merge o/main</code></li><li>等等</li></ul><p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103231614317.png" alt="image-20240103231614317" /></p><p>事实上，<code>git pull</code> 就是 git fetch 和 git merge 的缩写！</p><h2 id="git-push"><a class="markdownIt-Anchor" href="#git-push"></a> Git Push</h2><p><code>git push</code> 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 <code>git push</code> 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p><p>你可以将 <code>git push</code> 想象成发布你成果的命令。它有许多应用技巧，稍后我们会了解到，但是咱们还是先从基础的开始吧……</p><p><em>注意 —— <code>git push</code> 不带任何参数时的行为与 Git 的一个名为 <code>push.default</code> 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 <code>upstream</code>。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。</em></p><h2 id="偏离的工作"><a class="markdownIt-Anchor" href="#偏离的工作"></a> 偏离的工作</h2><p>现在我们已经知道了如何从其它地方 <code>pull</code> 提交记录，以及如何 <code>push</code> 我们自己的变更。看起来似乎没什么难度，但是为何还会让人们如此困惑呢？</p><p>困难来自于远程库提交历史的<strong>偏离</strong>。在讨论这个问题的细节前，我们先来看一个例子……</p><p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目<strong>旧版</strong>的代码，与远程仓库最新的代码不匹配了。</p><p>这种情况下, <code>git push</code> 就不知道该如何操作了。如果你执行 <code>git push</code>，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p><p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 <code>push</code> 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103232357772.png" alt="image-20240103232357772" /></p><p>那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。</p><p>有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。咱们继续，看看怎么 rebase！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase o/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103232635349.png" alt="image-20240103232635349" /></p><p>还有其它的方法可以在远程仓库变更了以后更新我的工作吗? 当然有，我们还可以使用 <code>merge</code></p><p>尽管 <code>git merge</code> 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。</p><p>看下演示…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git merge o/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103232746342.png" alt="image-20240103232746342" /></p><p>事实上，因为merge会多一个单独的C4的提交，对于公司的开发而言，有很多需要审核的地方， 所以不要添加这个merge的提交，最好的方式就是rebase。</p><p>很好！但是要敲那么多命令，有没有更简单一点的？</p><p>当然 —— 前面已经介绍过 <code>git pull</code> 就是 fetch 和 merge 的简写，类似的 <code>git pull --rebase</code> 就是 fetch 和 rebase 的简写！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebae</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103232949536.png" alt="image-20240103232949536" /></p><h2 id="远程服务器拒绝remote-rejected"><a class="markdownIt-Anchor" href="#远程服务器拒绝remote-rejected"></a> 远程服务器拒绝!(Remote Rejected)</h2><p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</span><br></pre></td></tr></table></figure><p><strong>为什么会被拒绝?</strong></p><p>远程服务器拒绝直接推送(push)提交到main, 因为策略配置要求 pull requests 来提交更新.</p><p>你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新.</p><h2 id="合并特性分支"><a class="markdownIt-Anchor" href="#合并特性分支"></a> 合并特性分支</h2><p>既然你应该很熟悉 fetch、pull、push 了，现在我们要通过一个新的工作流来测试你的这些技能。</p><p>在大型项目中开发人员通常会在（从 <code>main</code> 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.</p><p>但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。</p><p>对于接下来这个工作流，我们集成了两个步骤：</p><ul><li>将特性分支集成到 <code>main</code> 上</li><li>推送并更新远程分支</li></ul><p><strong>接下来的关卡建议全部都到网站实操一下，能学到很多</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase o/main side1</span><br><span class="line">git rebase side1 side2</span><br><span class="line">git rebase side2 side3</span><br><span class="line">git rebase side3 main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103233859300.png" alt="image-20240103233859300" /></p><h2 id="为什么不用-merge-呢"><a class="markdownIt-Anchor" href="#为什么不用-merge-呢"></a> 为什么不用 merge 呢?</h2><p>为了 push 新变更到远程仓库，你要做的就是<strong>包含</strong>远程仓库中最新变更。意思就是只要你的本地分支包含了远程分支（如 <code>o/main</code>）中的最新变更就可以了，至于具体是用 rebase 还是 merge，并没有限制。</p><p>那么既然没有规定限制，为何前面几节都在着重于 rebase 呢？为什么在操作远程分支时不喜欢用 <code>merge</code> 呢</p><p>在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：</p><p>优点:</p><ul><li>Rebase 使你的提交树变得很干净, 所有的提交都在一条线上</li></ul><p>缺点:</p><ul><li>Rebase 修改了提交树的历史</li></ul><p>比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。</p><p>一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 😄</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103234212700.png" alt="image-20240103234212700" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull</span><br><span class="line">git merge side1</span><br><span class="line">git merge side2</span><br><span class="line">git merge side3</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="远程跟踪分支"><a class="markdownIt-Anchor" href="#远程跟踪分支"></a> 远程跟踪分支</h3><p>在前几节课程中有件事儿挺神奇的，Git 好像知道 <code>main</code> 与 <code>o/main</code> 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：</p><ul><li>pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。</li><li>push 操作时, 我们把工作从 <code>main</code> 推到远程仓库中的 <code>main</code> 分支(同时会更新远程分支 <code>o/main</code>) 。这个推送的目的地也是由这种关联确定的！</li></ul><p>直接了当地讲，<code>main</code> 和 <code>o/main</code> 的关联关系就是<strong>由分支的“remote tracking”属性决定</strong>的。<code>main</code> 被设定为跟踪 <code>o/main</code> —— 这意味着为 <code>main</code> 分支指定了推送的目的地以及拉取后合并的目标。</p><p>你可能想知道 <code>main</code> 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, <strong>当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了</strong>。</p><p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 <code>o/main</code>）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 <code>main</code>。</p><p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p><p>这也解释了为什么会在克隆的时候会看到下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local branch &quot;main&quot; set to track remote branch &quot;o/main&quot;</span><br></pre></td></tr></table></figure><p><strong>我能自己指定这个属性吗？</strong></p><p>当然可以啦！你可以让任意分支跟踪 <code>o/main</code>, 然后该分支会像 <code>main</code> 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 <code>totallyNotMain</code> 上执行 <code>git push</code>，将工作推送到远程仓库的 <code>main</code> 分支上。</p><p>有两种方法设置这个属性，第一种就是通过远程分支切换到一个新的分支，执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b totallyNotMain o/main</span><br></pre></td></tr></table></figure><p>就可以创建一个名为 <code>totallyNotMain</code> 的分支，它跟踪远程分支 <code>o/main</code><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240103234641248.png" alt="image-20240103234641248" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b foo o/main</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>git push 同样适用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b foo o/main</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>我们将一个并不叫 <code>main</code> 的分支上的工作推送到了远程仓库中的 <code>main</code> 分支上</p><p><strong>第二种方法</strong></p><p>另一种设置远程追踪分支的方法就是使用：<code>git branch -u</code> 命令，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o/main foo</span><br></pre></td></tr></table></figure><p>这样 <code>foo</code> 就会跟踪 <code>o/main</code> 了。如果当前就在 foo 分支上, 还可以省略 foo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o/main</span><br></pre></td></tr></table></figure><h2 id="git-push-的参数"><a class="markdownIt-Anchor" href="#git-push-的参数"></a> Git Push 的参数</h2><p>很好! 既然你知道了远程跟踪分支，我们可以开始揭开 git push、fetch 和 pull 的神秘面纱了。我们会逐个介绍这几个命令，它们在理念上是非常相似的。</p><p>首先来看 <code>git push</code>。在远程跟踪课程中，你已经学到了 Git 是通过当前所在分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;place&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;place&gt;</code> 参数是什么意思呢？我们稍后会深入其中的细节, 先看看例子, 这个命令是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>把这个命令翻译过来就是：</p><p><strong>切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</strong></p><p>我们通过<code>&lt;place&gt;</code>参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。</p><p>需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所切换分支的属性！</p><h2 id="place参数详解"><a class="markdownIt-Anchor" href="#place参数详解"></a> <code>&lt;place&gt;</code>参数详解</h2><p>还记得之前课程说的吧，当为 git push 指定 place 参数为 <code>main</code> 时，我们同时指定了提交记录的来源和去向。</p><p>你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 <code>foo</code> 分支推送到远程仓库中的 <code>bar</code> 分支。</p><p>哎，很遗憾 Git 做不到…… 开个玩笑，别当真！当然是可以的啦 😃 Git 拥有超强的灵活性（有点过于灵活了）</p><p>接下来咱们看看是怎么做的……</p><p>要同时为源和目的地指定 <code>&lt;place&gt;</code> 的话，只需要用冒号 <code>:</code> 将二者连起来就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;source&gt;:&lt;destination&gt;</span><br></pre></td></tr></table></figure><p>这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 <code>foo</code> 或者 <code>HEAD~1</code>）</p><p>一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了，让我们看看演示！</p><p>记住，<code>source</code> 可以是任何 Git 能识别的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin foo^:main</span><br></pre></td></tr></table></figure><p>这是个令人困惑的命令，但是它确实是可以运行的 —— Git 将 <code>foo^</code> 解析为一个位置，上传所有未被包含到远程仓库里 <code>main</code> 分支中的提交记录。</p><p>如果你要推送到的目的分支不存在会怎么样呢？没问题！<strong>Git 会在远程仓库中根据你提供的名称帮你创建这个分支！</strong></p><h2 id="git-fetch-的参数"><a class="markdownIt-Anchor" href="#git-fetch-的参数"></a> Git fetch 的参数</h2><p>我们刚学习了 git push 的参数，很酷的 <code>&lt;place&gt;</code> 参数，还有用冒号分隔的 refspecs（<code>&lt;source&gt;:&lt;destination&gt;</code>）。 这些参数可以用于 <code>git fetch</code> 吗？</p><p>你猜中了！<code>git fetch</code> 的参数和 <code>git push</code> 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）</p><p>让我们逐个讨论下这些概念……</p><h3 id="place-参数"><a class="markdownIt-Anchor" href="#place-参数"></a> <code>&lt;place&gt;</code> 参数</h3><p>如果你像如下命令这样为 git fetch 设置 的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo</span><br></pre></td></tr></table></figure><p>Git 会到远程仓库的 <code>foo</code> 分支上，然后获取所有本地不存在的提交，放到本地的 <code>o/foo</code> 上。</p><p>来看个例子（还是前面的例子，只是命令不同了）</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240104001239753.png" alt="image-20240104001239753" /></p><p>你可能会好奇 —— 为何 Git 会将新提交放到 <code>o/foo</code> 而不是放到我本地的 foo 分支呢？之前不是说这样的 参数就是同时应用于本地和远程的位置吗？</p><p>好吧, 本例中 Git 做了一些特殊处理，因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。还记得在 <code>git fetch</code> 课程里我们讲到的吗 —— 它不会更新你的本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检查或者合并了）。</p><p>“如果我们指定 <code>&lt;source&gt;:&lt;destination&gt;</code> 会发生什么呢？”</p><p>如果你觉得直接更新本地分支很爽，那你就用冒号分隔的 refspec 吧。不过，你不能在当前切换的分支上干这个事，但是其它分支是可以的。</p><p>这里有一点是需要注意的 —— <code>source</code> 现在指的是远程仓库中的位置，而 <code>&lt;destination&gt;</code> 才是要放置提交的本地仓库的位置。它与 git push 刚好相反，这是可以讲的通的，因为我们在往相反的方向传送数据。</p><p>理论上虽然行的通，但开发人员很少这么做。我在这里介绍它主要是为了从概念上说明 <code>fetch</code> 和 <code>push</code> 的相似性，只是方向相反罢了。</p><p>来看个疯狂的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo~:bar</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240104001532665.png" alt="image-20240104001532665" /></p><p>如果执行命令前目标分支不存在会怎样呢？我们看一下上个对话框中没有 bar 分支的情况。</p><p>跟 git push 一样，<strong>Git 会在 fetch 前自己创建立本地分支</strong>, 就像是 Git 在 push 时，如果远程仓库中不存在目标分支，会自己在建立一样。</p><p>没有参数呢?</p><p><strong>如果 <code>git fetch</code> 没有参数，它会下载所有的提交记录到各个远程分支……</strong></p><p>相当简单，但是仅需更新一次，值得你去做！</p><h3 id="古怪的-source"><a class="markdownIt-Anchor" href="#古怪的-source"></a> 古怪的 <code>&lt;source&gt;</code></h3><p>Git 有两种关于 <code>&lt;source&gt;</code> 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 <code>source</code>，方法就是仅保留冒号和 destination 部分，source 部分留空。</p><ul><li><code>git push origin :side</code></li><li><code>git fetch origin :bugFix</code></li></ul><p>我们分别来看一下这两条命令的作用……</p><p>如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :foo</span><br></pre></td></tr></table></figure><p>就是这样子, 我们通过给 push 传空值 source，成功删除了远程仓库中的 <code>foo</code> 分支, 这真有意思…</p><p>如果 fetch 空 到本地，会在本地创建一个新分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin :bugFix</span><br></pre></td></tr></table></figure><p>很神奇吧！但无论怎么说, 这就是 Git！</p><h2 id="git-pull-参数"><a class="markdownIt-Anchor" href="#git-pull-参数"></a> Git pull 参数</h2><p>既然你已经掌握关于 <code>git fetch</code> 和 <code>git push</code> 参数的方方面面了，关于 git pull 几乎没有什么可以讲的了 😃</p><p>因为 git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。</p><p>还可以和其它更复杂的参数一起使用, 来看一些例子:</p><p>以下命令在 Git 中是等效的:</p><p><code>git pull origin foo</code> 相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo; git merge o/foo</span><br></pre></td></tr></table></figure><p>还有…</p><p><code>git pull origin bar~1:bugFix</code> 相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin bar~1:bugFix; git merge bugFix</span><br></pre></td></tr></table></figure><p>看到了? git pull 实际上就是 fetch + merge 的缩写, git pull 唯一关注的是提交最终合并到哪里（也就是为 git fetch 所提供的 destination 参数）</p><p>一起来看个例子吧：</p><p>如果我们指定要抓取的 place，所有的事情都会跟之前一样发生，只是增加了 merge 操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/image-20240104002457100.png" alt="image-20240104002457100" /></p><p>pull 也可以用 source:destination 吗? 当然喽, 看看吧:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main:foo</span><br></pre></td></tr></table></figure><p>哇, 这个命令做的事情真多。它先在本地创建了一个叫 <code>foo</code> 的分支，从远程仓库中的 main 分支中下载提交记录，并合并到 <code>foo</code>，然后再 merge 到我们的当前所在的分支 <code>bar</code> 上。操作够多的吧？！</p>]]></content>
    
    
    <summary type="html">可视化练习git操作</summary>
    
    
    
    <category term="SnowMoonの计算机基础知识" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>考研复习日记</title>
    <link href="https://www.snowmoon.top/2022/08/26/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    <id>https://www.snowmoon.top/2022/08/26/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%97%A5%E8%AE%B0/</id>
    <published>2022-08-26T08:11:54.000Z</published>
    <updated>2023-11-30T16:40:10.636Z</updated>
    
    <content type="html"><![CDATA[<p>最近太摆了，开个帖子来记录自己的复(bai)习(lan)日记，希望在帖子的监督下，自己能稍微认真点学习。</p><p>专业课一轮都还没干完，属实拉胯，而且一天天的越来越不想学专业课，打开书就想打开B站之类的逃避，属实是不应该。</p><h2 id="08-26"><a class="markdownIt-Anchor" href="#08-26"></a> 08-26</h2><p>今日复习记录：摆了一天，看完了概率的最后一章，写了下张宇基础30+李正元全书的一部分题，本来上个月就能结束的一轮，嗯是拖到了这个月的现在，值得反思。。。</p><p>明日目标：明天不用去健身房，可以好好学一波咯</p><p>数学：写完李正元第七章的题，开始写660。之前写到了第15题，希望明天能写到40题。</p><p>计组：明天必须结束浮点数和前面编码这一节，写完这部分的选择，开足马力 好好复习，拒绝摆烂 从我做起。</p><p>英语：写完02年的text1 2，3尽力写。</p><span id="more"></span><h2 id="08-27"><a class="markdownIt-Anchor" href="#08-27"></a> 08-27</h2><p>今日进度：</p><p>数学：发下李正元概率论的第六章还没做完，补做了一波概率论的六七章，然后660刷了一下前30里的重点题，今天九点左右才开始进入状态，导致刷数学刷了好久，而且效率不高导致早上下午都在数学，希望明天能提高点效率。</p><p>英语和计组都没写，晚上开摆了。。。</p><p>总结：寄</p><p>明日计划：</p><p>数学：李正元概率论最后一章收尾，早上再把勾了的660里的题写一下，把前60题里的重点题做一做。</p><p>英语：晚上得写点英语了，不说多的，02年text1,2。。。单词得接着背</p><p>计组：下午多看点计组，不要睡一觉起来想着数学没整完又去整数学了，专业课进度严重落后，要重视。</p><h2 id="8-28"><a class="markdownIt-Anchor" href="#8-28"></a> 8-28</h2><p>寄×2</p><p>今天和朋友键政了一下午，早上也没学进去多少，一整天加起来写了两三个题，只能说：寄</p><h2 id="8-29"><a class="markdownIt-Anchor" href="#8-29"></a> 8-29</h2><p>今日进度：</p><p>660做完了前60题里的重点题，刚开始进度挺快，做到后面几个积分题后越写越慢，不管怎么说，今天效率还可以。</p><p>计组继续学了一下浮点数这节，还差点运算就能结束这节了，专业课进度属实缓慢。</p><p>今日英语：无。。。希望明天能学点英语</p><p>明日计划：660中60-90题的重点题</p><p>计组完成王道第二章，适当学一点操作系统</p><p>英语读两篇文章</p><h2 id="8-30"><a class="markdownIt-Anchor" href="#8-30"></a> 8-30</h2><p>660做到了70题左右的重点题，积分和微分方程这两节开始有挺多难题了，收录进入错题本好几个题</p><p>计组继续看了一些王道的视频，感觉这课像没学过一样</p><p>写了一波实习报告，然后花了50块钱找了个代抄。4000字手写报告是真的TMD傻逼。</p><p>明日计划</p><p>计组浮点数运算写题</p><p>数学继续660</p><p>英语复习一两个list的单词+做点阅读</p><h2 id="8-31"><a class="markdownIt-Anchor" href="#8-31"></a> 8-31</h2><p>今日进度：660做到了80题左右，这部分题目难度还是挺大的</p><p>计组写了浮点数这一节的题，写的很迷茫，感觉这两天是白听了</p><p>英语写了一篇阅读</p><p>明日计划：660：做到100题</p><p>计组：结束浮点数，开下一节的存储器</p><p>英语：两篇阅读保底+两个list</p><p>状态渐入佳境，是个好兆头。到现在一共翘了6个大课了，有两个签到没到，一个课堂抽人抽到了我，老师三连击，全是翘了的，真不戳。</p><h2 id="9-1~9-4"><a class="markdownIt-Anchor" href="#9-1~9-4"></a> 9-1~9-4</h2><p>懵逼了三四天，做的东西不多，浪费了挺多时间，晚上睡的太晚，而且摆烂能力太强以至于408学不完了还在摆</p><p>计组：还在浮点数，到了乘除法有点懵逼，希望能在9.4晚上刷完</p><p>数学：660做到了116题，继续加油吧</p><p>英语：我哭死，我又浪费了好几天</p><h2 id="95-96"><a class="markdownIt-Anchor" href="#95-96"></a> 9.5-9.6</h2><p>计组：学到了Cache前面一个小部分</p><p>OS：学完了第一章</p><p>660：做到了153T，先做到160左右就继续搞880错题吧</p><p>英语：背了一点单词</p><h2 id="97-911"><a class="markdownIt-Anchor" href="#97-911"></a> 9.7-9.11</h2><p>这次浪费的时间更多</p><p>9.11打了一天游戏，应该是这个学期最后一次LOL，后面顶多看看比赛的比分了，天天和ZZB、ZZB盆友、游戏认识的一个28岁大姐姐打游戏，持续了一个暑假到现在，浪费了挺多时间，以后好好学习，天天向上了</p><p>9.7-9.10主要完成了880前两章里的错题整理和复习，计组查缺补漏看完了存储这章，但是题还没做完，这四天学习时间大概相当于两天</p><p>以后的记录改为周记吧，啥时候想起来了就写点</p><p>下周计划：计组一天一章，在下周内结束。</p><p>数学改错（即880二刷）完成高数部分</p><p>英语写完02-04年的卷子</p><h2 id="一点杂记"><a class="markdownIt-Anchor" href="#一点杂记"></a> 一点杂记</h2><p>今天前女友贼喜欢的明星李易峰《多次嫖娼》被行政拘留咯，看她qq里的反应还是挺大的，换头像，换个签，估计受的打击还挺大的。看她keep里的动态推断出她的作息来看，她应该也在准备考研，不过我也不好意思去问她想去哪，等着都考完以后捷报飞来贺自己吧。</p><h2 id="912"><a class="markdownIt-Anchor" href="#912"></a> 9.12</h2><p>今天看到了下周预报名的消息了，趁机查了一波考408的学校的分数线，发现一流的均分基本都在400+，次一流385+，再次一流370+</p><p><strong>计算机是真他娘的卷呐</strong></p><p>现在还没结束一轮，不知道自己究竟有多少能耐，但是按照自己英语和408的学习进度这尿性。。。370可能都不一定。</p><p><strong>现在看过来，自己大一到现在一路上错过了好多好多机会啊</strong></p><p>军训时期考卓越班转专业没好好把握当时考前也没仔细想想，被转专业群里的几个学长学姐的指南劝退，以为都是选择数竞选手，直接放弃了准备，考前也没好好选，头铁往最难的方向考，自然被淘汰。要是选个容易进去的，就能进有40%+的保研名额的班级，后面保研也容易很多，当初没多接触几个学长学姐问问经验，只能说自己的性格决定了现在的命运吧。</p><p>正式转专业考试时准备的也不够充分，还头铁选了最难的，刚好碰到了最卷的一年，从180进120变为了我们这一年的300+进60，信息类的自动化、通信工程等转专业时同时缩招，调剂都没得卷的。时也，命也。</p><p>分流时期又没去个不卷的方向83 84的分数稳稳拿名额，硬卷一个88 89才能拿名额的专业方向。卷也就算了，在大二又得了疫情后综合征，变得没有大一时候那么能卷了，于是想考好的时候考不好，改好好复习的时候学不进去，导致大二成绩很不理想，到了大三又直接开摆，被舍友同化成了游戏小子。大一大二都没怎么玩游戏，大三居然瘾大到不可理喻的地步。大三的寒假二月份在家就开了考研的复习，结果开学后4、5、6三个月加起来的复习速度赶不上寒假里学的一个月。到了现在，对自己的考试水平和能力完全没有个底，是真的废物，醒不过来的废物。明明第二天都是七点多就起床，结果天天晚上都是两点多三点多睡觉，永远都不能保持满状态学习，废物</p><p><strong>错过了四五个机会的我，希望可以把握住考研这次机会</strong></p><h2 id="9-18周记"><a class="markdownIt-Anchor" href="#9-18周记"></a> 9-18周记</h2><p>本周进度喜人，戒掉游戏之后就是不一样，</p><p>主要在看计组了，看到了第五章结束，上周刚差不多看完第二章，这周All in计组有点效果，看完了三章，基本两天一章，OS也看完了两章，预计下周能结束计组+OS，计网可以开了，本周数学基本处于荒废状态，赶408进度去了，下次学快点，没时间了，提高速度，提高效率。</p><h2 id="9-25周记"><a class="markdownIt-Anchor" href="#9-25周记"></a> 9-25周记</h2><p>本周进度:于9.24完成了OS与组原的复习，复习效率提上来了，学习速度不错。唉，要是早戒掉游戏，今天应该二轮复习了挺多了。9.25开了计网，9.24完成了浙大的预报名，190报名费。。政治开始加大小程序刷题的力度，一天刷个一百题左右，争取十月中旬结束1600题。</p><p>希望这周结束计网，开始408二轮及大题的复习，同时数学继续放回原应有的地位，每日刷2个小时吧先。加油，一定上岸!</p><h2 id="104记录"><a class="markdownIt-Anchor" href="#104记录"></a> 10.4记录</h2><p>本来这个记录应该在10.2完成的，但是复习的太投入了，今天才想起来写记录</p><p>总体进度赶上来了，计网结束，刚开始DS的二轮，大题写算法忘得有点多，要捡起来的有点多，预计一周结束DS二轮，接下来的408二轮3天一科，预计到10月的17-18号能结束，开启真题。</p><p>数学复习了三四天高数了，感觉再来两三天可以开线代，三四天结束线代，再来两三天结束概率，然后是10.15左右能开真题。</p><p>英语真题阅读刷了01-03年以及05年的，坚持一天两到三篇阅读，坚持背单词！</p><p>政治算是这周才找到了复习节奏吧，看了马原的两章，写了肖1000，预计这周结束马原，史纲能做一半。赶进度赶了快一个月了，效率还可以，但是有点怀疑自己的水平了，不知道处于考浙大的人群中的什么水平</p><p>这周心灵导师辰哥给了我挺多激励，说的也有道理——你的学习能力是经过高考验证的，按照自己学习的方法论和节奏走肯定是能有结果的。</p><p>——每个考研的人复习就像在一间没有灯光的房间里洗衣服，谁也不知道自己洗的怎么样，但是只要坚持洗，不断地洗，最后从房间里拿出来的时候一定挺干净</p><p>——985的没考上，大部分不是水平不够，而是努力不够</p><p>涛涛和宇哥也是两个好的教育者，涛涛说：你会遭到某些人的嫉妒之类的情绪是因为你比他们优秀，但只比他们优秀一点点，你们之间还有太多的同一性，所以你们才会处在不断的斗争性中间。要想没有斗争性，你就要让自己变得更优秀，优秀到能斩断你和他之间的同一性，没有了同一性，你们就没有斗争性了</p><p>宇哥则是每天都给我们激励，考研之路不易，不断斩断前路的艰难险阻，才能曲折的前进</p><p>道路是曲折的，前路是光明的</p><p>坚定信念，前进，不择手段的前进！</p><p>（此处应该有一句 自然选择，前进四！😁😁😁</p><h2 id="10-9记录"><a class="markdownIt-Anchor" href="#10-9记录"></a> 10-9记录</h2><p>又是一个周记，本周结束了高数的二轮并开启了线代的二轮，DS二轮学的有点慢，进度并不能使人满意，故打算放一放，开启时间片轮转模式，将408的四科都轮一轮。</p><p>DS：结束了查找和排序算法的学习，刚开始几天去温习快排的代码写法了，走了弯路，花了时间没有取得什么成果，应试学习应以应试为主，记几个模板让自己到时候能根据模板做些修改写出来就差不多了，没必要那么严谨的让他跑通，所以换学习模式了，一天复个一两科408，防止某一科长时间不碰饥饿致死。</p><p>计组：结束了前两章的二轮，开启存储系统</p><p>计网：结束前两章</p><p>英语：完成了03、04、05、18、的阅读，日经List单词完成至Day10</p><p>政治：肖1000完成了马原的前四五章内容，史纲完成了前三四章，看完了腿姐带背的对应内容。</p><p>下周计划：</p><p>数学：结束线代+概率二轮，开启真题</p><p>英语：完成06-10年的阅读，List的单词推进至Day11结束</p><p>计组：结束存储系统+指令系统+中央处理器</p><p>OS：结束进程+内存</p><p>DS：结束线性表+树+图</p><p>计网：复习至传输层结束</p><p>408预计于10.18-19日结束，于10.20左右开启每日一套真题的节奏。</p><p>数学预计于10.15-10.16结束，开启真题节奏。</p><p>英语预计月底左右结束真题阅读一刷。</p><p>政治预计于10.20刷完肖1000除毛中特外的所有部分。</p><p>进度不快，但求扎实学好每个知识。</p><h1 id="考后碎碎念"><a class="markdownIt-Anchor" href="#考后碎碎念"></a> 考后碎碎念</h1><p>一次忘记记录就拖啊拖，拖到了现在，已经考完咯！</p><blockquote><p>从二月开始复习，到开学后开摆四个月，从七八的低强度复习，到九月开始的删游戏高强度复习，再到一步步的择校，择专业，择梦想。</p><p>这是我第一次，完完全全由自己自主做决定，并为之全权负责的时刻。</p><p>一路中反反复复，磕磕绊绊。见证了自己的弱小与傲慢，见证了自己的懒惰与怯懦，也见证了自己的进步与成长。</p><p>要是没那么粗心，要是多看几遍错题本，要是当时看多往后看几页冷僻的知识点……</p><p>哪有那么多要是！落子无悔！小孩子可以哭，但成年人不行。</p><p>即使发挥的没有那么理想，但我依然可以说，我来过，我战斗过，这里的风景，独好。</p><p>感谢那个努力的自己，愿所有努力，都能得尝所愿。</p></blockquote><p>以上是我刚考完研的那个晚上记录下的文字，如今考研已经过去了一个星期，我也在考完研回家的第一个晚上就感染了新冠，现在已经基本痊愈了。</p><p>有一说一，新冠是真的痛苦，要是考研的那几天得了新冠，估计是直接寄了，高烧了3天，39度两天，38度一天，即使已经痊愈了依旧还是在咳嗽，在疯狂地流鼻涕，高烧那两天，近乎无眠，可以说，能发烧烧到这种程度，是我疫情三年，乃至初中以来的10年里都没有过的体验。我感染的还是BF7毒株，应该是回宿舍收东西准备回家时候感染的，当时看舍友都没啥症状了也，自己也考完研了，就没那么小心了。回家时候因为爸妈新冠还没好，就让我单独去住到一个亲戚家的房子里，结果才住进去的当天喉咙就开始疼，第二天起床就烧起来了，38度，持续到晚上变成了39度，烧了两天39度，速释的对乙酰氨基酚第一天吃了完全没用，烧到了四五点睡不着，我爸妈给我拿来了布洛芬的缓释胶囊吃完才退烧，舒服到了第二天下午，又开始烧，依旧是坚挺的39度，这回布洛芬也没用了，吃了三个小时从39.4掉到了39.3，反正就是很绝望，此时还好还有人吹吹牛，和祁医生进行的话疗很有效，在吃下退烧药后第五个小时，拉出了堵在肚子里三四天的💩，祁医生说是张仲景讲过，高热且便秘，便通则烧退，嘿，还真灵，拉完第二天就舒服了。虽然这天还是烧到了38度多，但是已经没有了明显的不适感，我也就此把药停了。停药以后就是咳，咳咳咳咳咳咳咳咳咳咳，一直咳到肺都快咳出来了，喉咙还疼的要死，只求它慢慢地好了吧。</p><p>在我差不多好了的时候，我爷爷和我外婆又几乎同时得了新冠，打了几天针以后又送去医院里住院了，只希望他们尽快好了吧，关关难过关关过，都能到这个年纪了，希望他们能渡过眼前的难关，健健康康地活下去。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近太摆了，开个帖子来记录自己的复(bai)习(lan)日记，希望在帖子的监督下，自己能稍微认真点学习。&lt;/p&gt;
&lt;p&gt;专业课一轮都还没干完，属实拉胯，而且一天天的越来越不想学专业课，打开书就想打开B站之类的逃避，属实是不应该。&lt;/p&gt;
&lt;h2 id=&quot;08-26&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#08-26&quot;&gt;&lt;/a&gt; 08-26&lt;/h2&gt;
&lt;p&gt;今日复习记录：摆了一天，看完了概率的最后一章，写了下张宇基础30+李正元全书的一部分题，本来上个月就能结束的一轮，嗯是拖到了这个月的现在，值得反思。。。&lt;/p&gt;
&lt;p&gt;明日目标：明天不用去健身房，可以好好学一波咯&lt;/p&gt;
&lt;p&gt;数学：写完李正元第七章的题，开始写660。之前写到了第15题，希望明天能写到40题。&lt;/p&gt;
&lt;p&gt;计组：明天必须结束浮点数和前面编码这一节，写完这部分的选择，开足马力 好好复习，拒绝摆烂 从我做起。&lt;/p&gt;
&lt;p&gt;英语：写完02年的text1 2，3尽力写。&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの生活随笔" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="摆烂日记" scheme="https://www.snowmoon.top/tags/%E6%91%86%E7%83%82%E6%97%A5%E8%AE%B0/"/>
    
    <category term="考研" scheme="https://www.snowmoon.top/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="生活记录" scheme="https://www.snowmoon.top/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法与外挂标签写法汇总</title>
    <link href="https://www.snowmoon.top/2022/08/09/Markdown%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE%E5%86%99%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>https://www.snowmoon.top/2022/08/09/Markdown%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE%E5%86%99%E6%B3%95%E6%B1%87%E6%80%BB/</id>
    <published>2022-08-09T10:19:03.000Z</published>
    <updated>2022-10-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1markdown语法自带格式"><a class="markdownIt-Anchor" href="#1markdown语法自带格式"></a> 1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="11-代码块"><a class="markdownIt-Anchor" href="#11-代码块"></a> 1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="12-多级标题"><a class="markdownIt-Anchor" href="#12-多级标题"></a> 1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="13-文字样式"><a class="markdownIt-Anchor" href="#13-文字样式"></a> 1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br /><font face="黑体">黑体</font><br /><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="14-引用"><a class="markdownIt-Anchor" href="#14-引用"></a> 1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br />二级引用演示<br />MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="15-分割线"><a class="markdownIt-Anchor" href="#15-分割线"></a> 1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr /><hr /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="16-列表-跟空格都可以"><a class="markdownIt-Anchor" href="#16-列表-跟空格都可以"></a> 1.6 列表(*,+,-跟空格都可以)</h2><h3 id="161-无序列表"><a class="markdownIt-Anchor" href="#161-无序列表"></a> 1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="162-有序列表"><a class="markdownIt-Anchor" href="#162-有序列表"></a> 1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="17-图片"><a class="markdownIt-Anchor" href="#17-图片"></a> 1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br /><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br />在线图片:<br /><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code" /></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="18-表格"><a class="markdownIt-Anchor" href="#18-表格"></a> 1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="19-公式"><a class="markdownIt-Anchor" href="#19-公式"></a> 1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><msup><mi>t</mi><mrow><mi>z</mi><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>e</mi><mrow><mo>−</mo><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.326242em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.843556em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mord">.</span></span></span></span></span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="2butterfly外挂标签"><a class="markdownIt-Anchor" href="#2butterfly外挂标签"></a> 2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="21-行内文本样式-text"><a class="markdownIt-Anchor" href="#21-行内文本样式-text"></a> 2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="22-行内文本-span"><a class="markdownIt-Anchor" href="#22-行内文本-span"></a> 2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br />在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br />文档「开始」页面中的标题部分就是超大号文字。<br /><span class='p center logo large'>Volantis</span><br /><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="23-段落文本-p"><a class="markdownIt-Anchor" href="#23-段落文本-p"></a> 2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br />在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br />文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="24-引用note"><a class="markdownIt-Anchor" href="#24-引用note"></a> 2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="25-上标标签-tip"><a class="markdownIt-Anchor" href="#25-上标标签-tip"></a> 2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="26-动态标签-anima"><a class="markdownIt-Anchor" href="#26-动态标签-anima"></a> 2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br />You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="27-复选列表-checkbox"><a class="markdownIt-Anchor" href="#27-复选列表-checkbox"></a> 2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="28-单选列表-radio"><a class="markdownIt-Anchor" href="#28-单选列表-radio"></a> 2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="29-时间轴-timeline"><a class="markdownIt-Anchor" href="#29-时间轴-timeline"></a> 2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="210-链接卡片-link"><a class="markdownIt-Anchor" href="#210-链接卡片-link"></a> 2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="211-按钮-btns"><a class="markdownIt-Anchor" href="#211-按钮-btns"></a> 2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br />默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="212-github卡片-ghcard"><a class="markdownIt-Anchor" href="#212-github卡片-ghcard"></a> 2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br />以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="213-github徽标-ghbdage"><a class="markdownIt-Anchor" href="#213-github徽标-ghbdage"></a> 2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br /><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br />//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br /><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br />//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br /><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="214-网站卡片-sites"><a class="markdownIt-Anchor" href="#214-网站卡片-sites"></a> 2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="215-行内图片-inlineimage"><a class="markdownIt-Anchor" href="#215-行内图片-inlineimage"></a> 2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="216-单张图片-image"><a class="markdownIt-Anchor" href="#216-单张图片-image"></a> 2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="217-音频-audio"><a class="markdownIt-Anchor" href="#217-音频-audio"></a> 2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="218-视频-video"><a class="markdownIt-Anchor" href="#218-视频-video"></a> 2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="219-相册-gallery"><a class="markdownIt-Anchor" href="#219-相册-gallery"></a> 2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt="" /><br /><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt="" /></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="220-折叠框-folding"><a class="markdownIt-Anchor" href="#220-折叠框-folding"></a> 2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt="" /></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="221-分栏-tab"><a class="markdownIt-Anchor" href="#221-分栏-tab"></a> 2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="222-诗词标签-poem"><a class="markdownIt-Anchor" href="#222-诗词标签-poem"></a> 2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br />明月几时有？把酒问青天。<br />不知天上宫阙，今夕是何年？<br />我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br />起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br />不应有恨，何事长向别时圆？<br />人有悲欢离合，月有阴晴圆缺，此事古难全。<br />但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="223-阿里图标-icon"><a class="markdownIt-Anchor" href="#223-阿里图标-icon"></a> 2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="224-特效标签wow"><a class="markdownIt-Anchor" href="#224-特效标签wow"></a> 2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="225-进度条-progress"><a class="markdownIt-Anchor" href="#225-进度条-progress"></a> 2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br />源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="226-注释-notation"><a class="markdownIt-Anchor" href="#226-注释-notation"></a> 2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="227-气泡注释-bubble"><a class="markdownIt-Anchor" href="#227-气泡注释-bubble"></a> 2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="228-引用文献-reference"><a class="markdownIt-Anchor" href="#228-引用文献-reference"></a> 2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br />主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br />Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="229-pdf展示"><a class="markdownIt-Anchor" href="#229-pdf展示"></a> 2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="230-hexo-tag-map-插件"><a class="markdownIt-Anchor" href="#230-hexo-tag-map-插件"></a> 2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="231-隐藏块"><a class="markdownIt-Anchor" href="#231-隐藏块"></a> 2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br /><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</summary>
    
    
    
    <category term="SnowMoonの计算机基础知识" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Markdown" scheme="https://www.snowmoon.top/tags/Markdown/"/>
    
    <category term="外挂标签" scheme="https://www.snowmoon.top/tags/%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>211007——碎碎念</title>
    <link href="https://www.snowmoon.top/2021/10/07/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-1007-%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>https://www.snowmoon.top/2021/10/07/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-1007-%E7%A2%8E%E7%A2%8E%E5%BF%B5/</id>
    <published>2021-10-07T03:36:51.000Z</published>
    <updated>2023-11-30T16:43:42.639Z</updated>
    
    <content type="html"><![CDATA[<p>愉快的国庆结束了，坐在回学校的高铁上码下这篇文章，大概的记录下近几天的一些想法，就想到啥写啥了，琐碎的记录</p><h1 id="失齿之痛"><a class="markdownIt-Anchor" href="#失齿之痛"></a> 失齿之痛</h1><p>这个国庆拔了个智齿，在拔这个牙之前，我只是感觉它和另一颗牙之间有比较大的缝隙，然后它被腐蚀的有点龋了，然后就跑到医院看了看，第一家小医院就建议我拔了。。。有点接受不了，去了另外一家大口腔医院看了看，发现我的四个智齿有两个是阻生，，，所以人家也建议拔了，，，还建议直接拔四颗。</p><p>考虑了半天，还是先拔一颗比较坏的，左下颌的智齿。</p><p>在知道要把这玩意拔掉之后，我还没有意识到问题的严重性。。。</p><p>拔牙这天我心慌慌的坐在候诊室等着处刑，越接近拔牙时刻心跳速度愈发的快，打完麻药之后医生直接把我脸给盖上了，之路出嘴周围的一圈。我只感觉她在我嘴里一顿操作，还听见医生在聊哪个主任开着路虎，人长得又帅，想多看几遍。我TM。。。</p><span id="more"></span><p>十分钟左右，我的牙就没了。十分钟，￥-1490</p><blockquote><p>后来了解了一下这个拔牙的过程，感觉赶得上一个小手术了</p><p>因为是下颌，得先把牙齿附近的骨头给锯掉一部分，然后把牙冠给整个锯断取出来，接下来就是取牙根，md得把牙根从中间锯成两段，再分别取出来，最后把留下的大坑给缝上，我的牙直接缝了5针！</p></blockquote><p>麻药劲儿还没过去那阵，我活蹦乱跳的，心想：拔个智齿就这？也不疼嘛，但是在几个小时后，麻药开始失效了，这时候我开始渐渐的意识到了这玩意不简单，是真TNND疼啊！睡了半小时，被疼醒四次，吃了些止疼药，暂时还没药效的时候属实难受，坐立不安，在家里到处走来走去，后来药劲儿上来了才逐渐舒服了</p><h1 id="与老友小聚"><a class="markdownIt-Anchor" href="#与老友小聚"></a> 与老友小聚</h1><p>回家见了一波近两年都没见的老朋友聊了好多各自行业和专业内的动态，认识有七八年了，但是这么长时间不见又见面时还是有说不完的话和话题。各自都在变得更强，都很有追求，那就希望我们都能成为各自行业里的翘楚吧！</p><h1 id="to-be-continued"><a class="markdownIt-Anchor" href="#to-be-continued"></a> To be continued</h1><p>现在的我走得越来越远了，离父母也越来越远了，每次回家的间隔也在逐渐的变长，可以比较明显的感受到他们在渐渐的离我远去，回家了和他们的共同话题也越来越少，逐渐的聚焦到了未来的安排和结婚生子上。不回来不知道，原来我父亲的工作这么辛苦，整个国庆留给他的休息时间加起来不超过两天。拿着微薄的工资，做着最重的体力活。要是自己能早点开始赚钱就好了，他们对我那么好，只有对他们更好，才能对得起他们对我的好</p><p>在车上看到了妈妈发的朋友圈——“愿你前程似锦，不负余生”。差点没有崩住，我是前程似锦了，我是不负余生了，他们把最好的都给了我，我能给他们什么呢？</p><p>这个问题，需要用我的余生来回答。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;愉快的国庆结束了，坐在回学校的高铁上码下这篇文章，大概的记录下近几天的一些想法，就想到啥写啥了，琐碎的记录&lt;/p&gt;
&lt;h1 id=&quot;失齿之痛&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#失齿之痛&quot;&gt;&lt;/a&gt; 失齿之痛&lt;/h1&gt;
&lt;p&gt;这个国庆拔了个智齿，在拔这个牙之前，我只是感觉它和另一颗牙之间有比较大的缝隙，然后它被腐蚀的有点龋了，然后就跑到医院看了看，第一家小医院就建议我拔了。。。有点接受不了，去了另外一家大口腔医院看了看，发现我的四个智齿有两个是阻生，，，所以人家也建议拔了，，，还建议直接拔四颗。&lt;/p&gt;
&lt;p&gt;考虑了半天，还是先拔一颗比较坏的，左下颌的智齿。&lt;/p&gt;
&lt;p&gt;在知道要把这玩意拔掉之后，我还没有意识到问题的严重性。。。&lt;/p&gt;
&lt;p&gt;拔牙这天我心慌慌的坐在候诊室等着处刑，越接近拔牙时刻心跳速度愈发的快，打完麻药之后医生直接把我脸给盖上了，之路出嘴周围的一圈。我只感觉她在我嘴里一顿操作，还听见医生在聊哪个主任开着路虎，人长得又帅，想多看几遍。我TM。。。&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの生活随笔" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://www.snowmoon.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>琐碎的记录——生活真美好</title>
    <link href="https://www.snowmoon.top/2021/09/25/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E7%90%90%E7%A2%8E%E7%9A%84%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E7%94%9F%E6%B4%BB%E7%9C%9F%E7%BE%8E%E5%A5%BD/"/>
    <id>https://www.snowmoon.top/2021/09/25/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E7%90%90%E7%A2%8E%E7%9A%84%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E7%94%9F%E6%B4%BB%E7%9C%9F%E7%BE%8E%E5%A5%BD/</id>
    <published>2021-09-25T15:27:31.000Z</published>
    <updated>2024-06-01T04:45:13.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先写不开心的事抠出一万套海景房的尬聊"><a class="markdownIt-Anchor" href="#先写不开心的事抠出一万套海景房的尬聊"></a> 先写不开心的事——抠出一万套海景房的尬聊</h1><p>今天在地铁上可真是把我尬的受不了了，我本来开开心心的坐在座位上打游戏，打的正开心的时候，一个老哥过来问我借充电宝，借过去稍微讲了两句话，到目前为止一切正常。然后过了一会之后，这个老哥开始和我疯狂地吹牛：“兄弟，我跟你说，充电宝这玩意还得是以前质量高！我爸有一个，牌子货！呵，一个用了十多年！” 嚯，好家伙，难道这就是传说中的葫芦娃合体的牛逼闪闪的充电宝嘛，我不禁向这么🐮🍺的充电宝低下了头，继续玩我的游戏，然后这位大哥似乎没有停下来的意思，继续给我讲充电宝的故事，顺带补充了一下他那🐮🍺的充一次电可以玩十天的手机，然后他讲这个讲了二十多分钟。。。我打了两三局炉石后停下来听他继续吹牛，，，然后我开始左顾右盼，他开始越来越离谱，给我扯他的充电宝多多少钱。。。属实听不下去，，，尬的抠出一万套海景房</p><span id="more"></span><h1 id="其次是今天的出游"><a class="markdownIt-Anchor" href="#其次是今天的出游"></a> 其次是今天的出游</h1><p>在图书馆写了一天代码的我决定放空下自我，约舍友出门游玩，阔惜莫得一个人理我，那行，爷自己去🙃晚上六点多坐着地铁奔向了江汉路。</p><p>虽然来过了几遍了，但是这次过来还是有很多耳目一新的收获</p><p>又会想起了当初一个人游荡在杭州的街头，感受着这个世界的美好与喧嚣，感受着生活的存在，感受着社会的存在，感受着学校的三点一线以外的生活，我这才意识到——原来这才是生活啊，原来世界有这么大，原来世界有这么精彩，原来生活可以活的这么有趣</p><p>在象牙塔里待一段时间一定要出来走走，要出来见识见识这个美妙的世界，见识见识生活本来的样子，这样我才会更热爱生活！</p><p>吹着江风，看着江上的轮渡，和江边钓鱼的大叔唠上几句，再欣赏欣赏长江大桥的壮阔，生活遍由此而变得多姿多彩了，变得更能使我快乐了</p><h1 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h1><p>另外，今天还是学院的国家奖学金答辩的日子，啊，不知不觉已经大三了，不知不觉减已经到了第二次奖学金的评审了，在第一次评审时自己还为总成绩差了一名没法参与评审而懊恼，现在已经完全放下了这些狗屁奖学金，不就是几千块钱嘛，将来工作了一两个月就能挣回来了。</p><p>想想各个卷王为了争抢那么点荣誉拼的你死我活，课堂知识在课上学一遍就算了，回了寝室还要再在慕课上刷一遍，恨不得把所有时间都拿来学，这有什么值得的呢？为了拿点分数，都不管学的这些知识有没有什么作用，卷就完了，保了研我就🐮🍺了。</p><p>这些知识体系是几十年前工业时代下建立起来的学科体系遗留下来的传统知识。我个人非常反对学院设置的这些非常非常传统的传统机械的相关的知识体系的灌输，我认为即使是本科生，也应该接收最新的，最前沿的技术与知识，而不是抱着九几年，八几年甚至六几年出的课本传授一堆很可能已经过时的知识！</p><p>现在再想想大一大二为了点加权，为了点加分，各种蹭比赛，各种蹭科研项目，即使是打杂也要一头钻进去，为了这些个项目急红了眼，真是不值得。一切的项目，都是基于某些学长做了95%的项目进行修改，做一个机器人70%的时间装配，20%的时间调参数，剩下10%的时间看学长的代码里哪些参数有什么用，能怎么调，时间是花了，技术呢？一无所获。除了所获奖项上又能增加那么一行意外一无是处，真是后悔了自己当初的所作所为。</p><p>不过还好，现在已经悟到了自己不喜欢这些东西，既然不喜欢，那就拒绝呗，开始认真做能使我感到快乐的事情！</p><h2 id="后后记"><a class="markdownIt-Anchor" href="#后后记"></a> 后后记</h2><p>今天还是前女友的生日，一直感觉挺对不起她的，所以今年还给她了生日祝福，并且把我翻墙用的SSR传授给了她🙈，不过总感觉她挺冷淡的，没事，冷淡就冷淡叭，也该冷淡点，我本来早该删了她了的，不过似乎还是有些放不下呀，害</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;先写不开心的事抠出一万套海景房的尬聊&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#先写不开心的事抠出一万套海景房的尬聊&quot;&gt;&lt;/a&gt; 先写不开心的事——抠出一万套海景房的尬聊&lt;/h1&gt;
&lt;p&gt;今天在地铁上可真是把我尬的受不了了，我本来开开心心的坐在座位上打游戏，打的正开心的时候，一个老哥过来问我借充电宝，借过去稍微讲了两句话，到目前为止一切正常。然后过了一会之后，这个老哥开始和我疯狂地吹牛：“兄弟，我跟你说，充电宝这玩意还得是以前质量高！我爸有一个，牌子货！呵，一个用了十多年！” 嚯，好家伙，难道这就是传说中的葫芦娃合体的牛逼闪闪的充电宝嘛，我不禁向这么🐮🍺的充电宝低下了头，继续玩我的游戏，然后这位大哥似乎没有停下来的意思，继续给我讲充电宝的故事，顺带补充了一下他那🐮🍺的充一次电可以玩十天的手机，然后他讲这个讲了二十多分钟。。。我打了两三局炉石后停下来听他继续吹牛，，，然后我开始左顾右盼，他开始越来越离谱，给我扯他的充电宝多多少钱。。。属实听不下去，，，尬的抠出一万套海景房&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの生活随笔" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://www.snowmoon.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>jyy与yzh的折磨——从0到1撸PA的日子</title>
    <link href="https://www.snowmoon.top/2021/09/23/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-jyy%E4%B8%8Eyzh%E7%9A%84%E6%8A%98%E7%A3%A8%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%92%B8PA%E4%B9%8B%E8%B7%AF/"/>
    <id>https://www.snowmoon.top/2021/09/23/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-jyy%E4%B8%8Eyzh%E7%9A%84%E6%8A%98%E7%A3%A8%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%92%B8PA%E4%B9%8B%E8%B7%AF/</id>
    <published>2021-09-23T09:16:35.000Z</published>
    <updated>2023-12-01T10:53:57.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><p>本文为自己做南京大学计算机科学与技术系<code>计算机系统基础</code>课程的小(mo)型(gui)项目 (Programming Assignment, PA)的一些心路历程与实验记录，会一直更新到把整个PA给写完了</p><p>博主目前为国内某中流985天坑专业在读大三老🐶一枚，在学CSAPP的时候了解到了这个小(mo)型(gui)项目，于是下定决心来做它，为了变强，加油！</p><p>至于标题为啥这么取，，，只是为了补偿一下我最近被他摧残的差不多了的小心脏😭，yzh老师真是太太太太太好了，把这么好的资料都公开了出来，唯一的小瑕疵就是不提供OJ给我们测试，，，不过我也很理解，能有这么好的学习资料我这种天坑专业的已经很满足了！🤑</p><p>南大真是太好了，南大就是中国的CMU啊——某中流985学子投来羡慕的目光</p><h1 id="pa0我已出仓感觉良好"><a class="markdownIt-Anchor" href="#pa0我已出仓感觉良好"></a> PA0😏——我已出仓，感觉良好</h1><p>PA0还算蛮简单的，也就是配配环境，玩玩Git和vim。虽然之前都了解过这两个家伙，但是都没怎么用过，所以熟悉它们还是花了些时间的。就是唯一想吐槽的是老师这里的讲义居然是全英文的😭，英语不好的我流下了不争气的泪水😭 但是作为一名”工程师“应有的素质，我觉得老师这里做的肥肠棒，成功的让我燃起了好好学英语的兴趣！而且强制使用英语看这些报告虽然刚开始慢了点，还得时刻借助翻译的插件，但是时间长了之后对自己肯定只有好处，没有坏处。正如讲义里提到的：坚持一年, 你就会发现有不同; 坚持两年, 你就会发现大有不同。</p><p>整个讲义看下来，能明显的感觉到老师的良苦用心，又是让我阅读<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a>和<a href="https://github.com/tangx/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md">别像弱智一样提问</a>然后写800字的感想，又是随时都在让我</p><ul><li><p>STFW——Search The Friendly Web</p></li><li><p>RTFM——Read The Friendly Menu</p></li><li><p>RTFSC——Read The Friendly Source Code</p><span id="more"></span></li></ul><h1 id="pa1开始有些难度"><a class="markdownIt-Anchor" href="#pa1开始有些难度"></a> PA1——开始有些难度</h1><p>这个PA我读完手册还是一脸懵逼，不知道从哪开始，然后找了<a href="https://www.bilibili.com/video/BV1qa4y1j7xk?p=1">老师相关的习题课</a>以及相关的博客文章看了一些之后才有了一丝修改的意识与方法</p><h2 id="单步执行"><a class="markdownIt-Anchor" href="#单步执行"></a> 单步执行</h2><p>这里看了看了好久才知道是要自己实现让CPU单步执行程序的功能（原谅我菜的真实555）</p><p>然后需要使用老师提示使用的<code>strtok</code>和<code>sscanf</code>函数，具体应该是解析指令然后解析出数字，传送到CPU处使用CPU提供的指令单步执行</p><p>一次si多行倒是实现的快，但是无参数默认单步执行一直实现不出来，X了狗了，就先跳过，去做下一个命令</p><h2 id="打印寄存器信息"><a class="markdownIt-Anchor" href="#打印寄存器信息"></a> 打印寄存器信息</h2><p>这个看起来比较简单，找到CPU的寄存器结构体的定义和数据用printf打印出来就行，就是看工程文件看的有点头秃，第一波打印完之后数据有点对不齐，因为数字超过了8位，<code>\t</code>直接控制到下一个光标去了，就很丑，在这里卡了一会终于搞完了，很舒服</p><h1 id="扫描内存"><a class="markdownIt-Anchor" href="#扫描内存"></a> 扫描内存</h1><p>感觉每个任务最难的是理解题目需求和意思，看懂了要干什么之后找起文件来也就容易多了</p><h1 id="表达式"><a class="markdownIt-Anchor" href="#表达式"></a> 表达式</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面&quot;&gt;&lt;/a&gt; 写在前面&lt;/h1&gt;
&lt;p&gt;本文为自己做南京大学计算机科学与技术系&lt;code&gt;计算机系统基础&lt;/code&gt;课程的小(mo)型(gui)项目 (Programming Assignment, PA)的一些心路历程与实验记录，会一直更新到把整个PA给写完了&lt;/p&gt;
&lt;p&gt;博主目前为国内某中流985天坑专业在读大三老🐶一枚，在学CSAPP的时候了解到了这个小(mo)型(gui)项目，于是下定决心来做它，为了变强，加油！&lt;/p&gt;
&lt;p&gt;至于标题为啥这么取，，，只是为了补偿一下我最近被他摧残的差不多了的小心脏😭，yzh老师真是太太太太太好了，把这么好的资料都公开了出来，唯一的小瑕疵就是不提供OJ给我们测试，，，不过我也很理解，能有这么好的学习资料我这种天坑专业的已经很满足了！🤑&lt;/p&gt;
&lt;p&gt;南大真是太好了，南大就是中国的CMU啊——某中流985学子投来羡慕的目光&lt;/p&gt;
&lt;h1 id=&quot;pa0我已出仓感觉良好&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pa0我已出仓感觉良好&quot;&gt;&lt;/a&gt; PA0😏——我已出仓，感觉良好&lt;/h1&gt;
&lt;p&gt;PA0还算蛮简单的，也就是配配环境，玩玩Git和vim。虽然之前都了解过这两个家伙，但是都没怎么用过，所以熟悉它们还是花了些时间的。就是唯一想吐槽的是老师这里的讲义居然是全英文的😭，英语不好的我流下了不争气的泪水😭 但是作为一名”工程师“应有的素质，我觉得老师这里做的肥肠棒，成功的让我燃起了好好学英语的兴趣！而且强制使用英语看这些报告虽然刚开始慢了点，还得时刻借助翻译的插件，但是时间长了之后对自己肯定只有好处，没有坏处。正如讲义里提到的：坚持一年, 你就会发现有不同; 坚持两年, 你就会发现大有不同。&lt;/p&gt;
&lt;p&gt;整个讲义看下来，能明显的感觉到老师的良苦用心，又是让我阅读&lt;a href=&quot;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md&quot;&gt;提问的智慧&lt;/a&gt;和&lt;a href=&quot;https://github.com/tangx/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md&quot;&gt;别像弱智一样提问&lt;/a&gt;然后写800字的感想，又是随时都在让我&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;STFW——Search The Friendly Web&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RTFM——Read The Friendly Menu&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RTFSC——Read The Friendly Source Code&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの项目记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="PA" scheme="https://www.snowmoon.top/tags/PA/"/>
    
    <category term="计算机组成原理" scheme="https://www.snowmoon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP——bomblab</title>
    <link href="https://www.snowmoon.top/2021/09/21/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E2%80%94%E2%80%94bomblab/"/>
    <id>https://www.snowmoon.top/2021/09/21/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95-CSAPP%E2%80%94%E2%80%94bomblab/</id>
    <published>2021-09-21T00:30:00.000Z</published>
    <updated>2023-12-01T10:55:25.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：看了好久的书，写了好几个晚上，参考了一些大佬的笔记，终于把这个bomblab写完了</p></blockquote><h1 id="实验简介"><a class="markdownIt-Anchor" href="#实验简介"></a> 实验简介</h1><p>这个著名的bomblab为我们提供了一个二进制文件，然后我们需要将这个二进制文件进行反汇编得到一堆的汇编文件，通过阅读汇编文件中的代码以及GDB的调试来得到需要输入的字符密码来进入下一关。</p><p>整个实验一共有六个正式关卡，一个隐藏关卡，密码和进入隐藏关卡的方法也藏在文件中，需要我们一点点的探寻其中的蛛丝马迹，拆开炸弹。如果拆弹失败的话，实验文件会给我们打印出一个BOMB！！！如果你是CMU的学生，每次不小心的BOMB还会扣你这个实验的分数，不过我们不是CMU的学生，就随便他炸了23333</p><h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1><p>没有实验文件的需要先到<a href="http://csapp.cs.cmu.edu/3e/bomb.tar">这个网站</a>下载一个</p><p>首先我们需要进入到这个lab的文件所在的文件夹下，可以看到有README、bomb、和bomb.c三个文件，我们先打开bomb.c看看有些什么东西</p><p>可以看到有6个phase，每个phase基本都是要我们输入一段字符，然后它调用了判断我们字符对不对的函数。大概浏览一下，知道要干什么之后先把bomb文件反汇编一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump bomb -d &gt; disassemble.txt</span><br></pre></td></tr></table></figure><p>得到了bomb的反汇编代码打开</p><p>看到一堆莫名其妙的东西，不知道怎么下手，想起来之前有6个phase，于是就搜索了下phase，找到了phase所在地，就用GDB来进行调试了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb bomb</span><br></pre></td></tr></table></figure><p>然后给爆炸和phase_1先打上断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b explode_bomb</span><br><span class="line">b phase_1</span><br></pre></td></tr></table></figure><p>run了之后，随便输入一点字符进入phase_1，先把当前的函数用disas指令反汇编一下</p><blockquote><p>不熟悉GDB调试的可以参考CMU的<a href="http://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf">课程提供的手册</a></p></blockquote><span id="more"></span><h1 id="phase1"><a class="markdownIt-Anchor" href="#phase1"></a> phase1</h1><p>phase1的反汇编代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">=&gt; 0x0000000000400ee0 &lt;+0&gt;:        sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:        mov    $0x402400,%esi</span><br><span class="line">   0x0000000000400ee9 &lt;+9&gt;:        callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:    retq   </span><br></pre></td></tr></table></figure><p>在第二行我们看到了个很奇怪的地址<code>0x402400</code>先把它移动到了<code>esi</code>里，有使用了一个判断字符是否相等的函数，所以我们可以大胆推测密码应该就在<code>0x402400</code>里,直接展示这个地址里的数据：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109211752381.png" alt="image-20210921175234221" /></p><p>猜的差不多，我们再run一次，这次直接把上面的字符粘贴进去：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109211755754.png" alt="image-20210921175556714" /></p><p>发现已经通过了第一关</p><p>注意：在每个lab里，每个使用到了固定地址的都很重要，一般都要打印出来看看是个啥</p><p>hhh在这里还发现了点彩蛋</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109242321631.png" alt="image-20210921183658215" /></p><h1 id="phase2"><a class="markdownIt-Anchor" href="#phase2"></a> phase2</h1><p>现在我们已经有了第一关的密码，所以我们先把它存到一个文档里，然后进入gdb，设置好断点后设置一下命令参数，然后run一波，可以看到我们已经过了第一个phase</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109242340808.png" alt="image-20210924234044751" /></p><p>接下来我们开始解决phase2，随便输入一点参数后进入phase2，phase2的反汇编代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:    55                   push   %rbp</span><br><span class="line">  400efd:    53                   push   %rbx</span><br><span class="line">  400efe:    48 83 ec 28          sub    $0x28,%rsp# 堆栈操作</span><br><span class="line">  400f02:    48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  400f05:    e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;# 读入6个数字</span><br><span class="line">  400f0a:    83 3c 24 01          cmpl   $0x1,(%rsp)</span><br><span class="line">  400f0e:    74 20                je     400f30 &lt;phase_2+0x34&gt;# 堆栈顶部数字 != 1 爆炸</span><br><span class="line">  400f10:    e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:    eb 19                jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  循环体：</span><br><span class="line">  &#123;</span><br><span class="line">  400f17:    8b 43 fc             mov    -0x4(%rbx),%eax# %eax = %rsp </span><br><span class="line">  400f1a:    01 c0                add    %eax,%eax# (%eax) += (%eax)</span><br><span class="line">  400f1c:    39 03                cmp    %eax,(%rbx)# %eax == valueat(%rsp+4)</span><br><span class="line">  400f1e:    74 05                je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:    e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:    48 83 c3 04          add    $0x4,%rbx# %rbx += 4 #地址+4，相当于移向下一个数</span><br><span class="line">  400f29:    48 39 eb             cmp    %rbp,%rbx# %rbx == %rsp+24#rbx是否为第六个数后的地址</span><br><span class="line">  400f2c:    75 e9                jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  400f2e:    eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:    48 8d 5c 24 04       lea    0x4(%rsp),%rbx# %rbx = %rsp+4 #rbx存储的应该是地址</span><br><span class="line">  400f35:    48 8d 6c 24 18       lea    0x18(%rsp),%rbp# %rbp = %rsp+24</span><br><span class="line">  400f3a:    eb db                jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:    48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  400f40:    5b                   pop    %rbx</span><br><span class="line">  400f41:    5d                   pop    %rbp</span><br><span class="line">  400f42:    c3                   retq   </span><br></pre></td></tr></table></figure><p>这段代码比较长，仔细看可以看出来第一次判断的数字一定是1，需要六个数字，然后每次判断的数字都是前一个数字的两倍，于是我们就可以推导出来答案是<code>1 2 4 8 16 32</code></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109250022389.png" alt="image-20210925002200317" /></p><h1 id="phase3"><a class="markdownIt-Anchor" href="#phase3"></a> phase3</h1><p>phase3的代码稍微有点长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:    48 83 ec 18          sub    $0x18,%rsp</span><br><span class="line">  400f47:    48 8d 4c 24 0c       lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:    48 8d 54 24 08       lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:    be cf 25 40 00       mov    $0x4025cf,%esi</span><br><span class="line">  400f56:    b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400f5b:    e8 90 fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:    83 f8 01             cmp    $0x1,%eax</span><br><span class="line">  400f63:    7f 05                jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:    e8 d0 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:    83 7c 24 08 07       cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:    77 3c                ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">  400f71:    8b 44 24 08          mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:    ff 24 c5 70 24 40 00 jmpq   *0x402470(,%rax,8)</span><br><span class="line">  400f7c:    b8 cf 00 00 00       mov    $0xcf,%eax</span><br><span class="line">  400f81:    eb 3b                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:    b8 c3 02 00 00       mov    $0x2c3,%eax</span><br><span class="line">  400f88:    eb 34                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:    b8 00 01 00 00       mov    $0x100,%eax</span><br><span class="line">  400f8f:    eb 2d                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:    b8 85 01 00 00       mov    $0x185,%eax</span><br><span class="line">  400f96:    eb 26                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:    b8 ce 00 00 00       mov    $0xce,%eax</span><br><span class="line">  400f9d:    eb 1f                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:    b8 aa 02 00 00       mov    $0x2aa,%eax</span><br><span class="line">  400fa4:    eb 18                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:    b8 47 01 00 00       mov    $0x147,%eax</span><br><span class="line">  400fab:    eb 11                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:    e8 88 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:    b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400fb7:    eb 05                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:    b8 37 01 00 00       mov    $0x137,%eax</span><br><span class="line">  400fbe:    3b 44 24 0c          cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:    74 05                je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:    e8 71 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:    48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  400fcd:    c3                   retq   </span><br></pre></td></tr></table></figure><p>阅读下来看到第四行有个奇怪的地址<code>0x4025cf</code>，不管三七二十一先把它打印出来看看：</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109250025504.png" alt="image-20210925002556461" /></p><p>可以看出来题目需要我们输入两个整数</p><p>继续往下读，看到它使用了一个好像是库函数的函数<code>&lt;__isoc99_sscanf@plt&gt;</code>搜了一下得知它的返回数字为读入的数字数目</p><p>接下来就是比较了一下我们输入的第一个数字是否大于7，然后跳转到<code>0x402470+8*%rax</code>的位置，此时我们rax有0~7一共八种选择，所以我们打印一下<code>0x402470</code>附近的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/8a 0x402470</span><br><span class="line">0x402470:    0x400f7c &lt;phase_3+57&gt;0x400fb9 &lt;phase_3+118&gt;</span><br><span class="line">0x402480:    0x400f83 &lt;phase_3+64&gt;0x400f8a &lt;phase_3+71&gt;</span><br><span class="line">0x402490:    0x400f91 &lt;phase_3+78&gt;0x400f98 &lt;phase_3+85&gt;</span><br><span class="line">0x4024a0:    0x400f9f &lt;phase_3+92&gt;0x400fa6 &lt;phase_3+99&gt;</span><br></pre></td></tr></table></figure><p>再对照代码中的逻辑可以知道按照以下任意一对数字输入都可以通过</p><table><thead><tr><th style="text-align:center">数字1</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">数字2</td><td style="text-align:center">207</td><td style="text-align:center">311</td><td style="text-align:center">707</td><td style="text-align:center">256</td><td style="text-align:center">389</td><td style="text-align:center">206</td><td style="text-align:center">682</td><td style="text-align:center">327</td></tr></tbody></table><h1 id="phase4"><a class="markdownIt-Anchor" href="#phase4"></a> phase4</h1><p>接下来我们就进入到了phase_4，它的反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">=&gt; 0x000000000040100c &lt;+0&gt;:        sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401010 &lt;+4&gt;:        lea    0xc(%rsp),%rcx# %rcx = %rsp + 12</span><br><span class="line">   0x0000000000401015 &lt;+9&gt;:        lea    0x8(%rsp),%rdx# %rdx = %rsp + 8</span><br><span class="line">   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi# 0x4025cf:&quot;%d %d&quot;</span><br><span class="line">   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax</span><br><span class="line">   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)# (%rsp+8) &lt;= 14</span><br><span class="line">   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx# %edx = 14</span><br><span class="line">   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi# %esi = 0</span><br><span class="line">   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi# %edi = %rsp + 8 </span><br><span class="line">   0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax</span><br><span class="line">   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;# 返回值%rax一定为0</span><br><span class="line">   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)</span><br><span class="line">   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;# (%rsp + 12) == 0</span><br><span class="line">   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp</span><br><span class="line">   0x0000000000401061 &lt;+85&gt;:    retq   </span><br></pre></td></tr></table></figure><p>第四行出现了一个地址，打印之后得到的是<code># 0x4025cf:&quot;%d %d&quot;</code>说明需要我们输入两个整数，然后继续往下读，在倒数第四行可以看出来我们要输入的一个数字一定为0。func4具体的内容还不清楚，把func4的代码输出一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function func4:</span><br><span class="line">=&gt; 0x0000000000400fce &lt;+0&gt;:        sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:        mov    %edx,%eax# %eax = 14</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:        sub    %esi,%eax# %eax -= %esi = 14-0 = 14</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:        mov    %eax,%ecx# %ecx = %eax = 14</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx# %ecx&gt;&gt;31 = 0//%ecx = sign of %eax</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax# %eax += %ecx = 14</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:    sar    %eax# %eax&gt;&gt;1 // %eax = 7</span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx# %ecx = %rax+%rsi = 7+0=7</span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx</span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;# %edi = %ecx</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx# %edx = %rcx-1</span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax# %eax = 2*%eax</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax# %eax = 0</span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx# %ecx &gt;= %edi?</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi# %esi = %rcx+1</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax# %rax = 2%rax</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x000000000040100b &lt;+61&gt;:    retq  </span><br></pre></td></tr></table></figure><p>在func4里推了一推，发现7满足要求，所以答案可以为<code>7 0</code></p><p>看了下知乎大佬<a href="https://www.zhihu.com/people/yansongtw">@Yannick</a>逆向出来的C代码，发现答案不止一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a:%rdi b:%rsi  c:%rdx</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">  <span class="type">int</span> return_v = c - b; <span class="comment">// %rax</span></span><br><span class="line">  <span class="type">int</span> t = ((<span class="type">unsigned</span>)return_v) &gt;&gt; <span class="number">31</span>; <span class="comment">// %rcx</span></span><br><span class="line">  return_v = (t + return_v) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  t = return_v + b;</span><br><span class="line">  <span class="keyword">if</span> (t - a &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    return_v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (t - a &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> return_v;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      b = t + <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> r = func4(a,b,c);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span> * r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = t - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r = func4(a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后的代码</span></span><br><span class="line"><span class="comment">// x为输入的数</span></span><br><span class="line"><span class="comment">// y为0 z为14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k = z - y;</span><br><span class="line">    k = ((<span class="type">int</span>)(((<span class="type">unsigned</span>)k&gt;&gt;<span class="number">31</span>) + k) &gt;&gt; <span class="number">1</span>) + y;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*func4(x, k+<span class="number">1</span>, z)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*func4(x, y, k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现其实第一个数的取值范围是[0,0xe]，我们可以对它进行一个穷举：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(!func4(i, <span class="number">0</span>, <span class="number">14</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ./func4 </span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>所以最终答案是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 | 1 0 | 3 0 | 7 0</span><br></pre></td></tr></table></figure><h1 id="phase_5"><a class="markdownIt-Anchor" href="#phase_5"></a> phase_5</h1><p>进入phase_5，首先查看phase5的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">=&gt; 0x0000000000401062 &lt;+0&gt;:        push   %rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:        sub    $0x20,%rsp#堆栈相关</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:        mov    %rdi,%rbx# rbx = rdi</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:        mov    %fs:0x28,%rax# 将内存中一段数据移到rax</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)# rax = (rsp + 24)</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax# 输入的字符串长度为6</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   </span><br><span class="line">   # 循环,作用为将读入的字符串取二进制后四位作为偏移量，从0x4024b0处偏移取出字符，然后压入堆栈</span><br><span class="line">   &#123;</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx# ecx = rax+rbx = rax</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)# (rsp) = ecx</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx# rdx = rsp</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx# 取edx二进制的后四位</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx# edx = rdx+0x4024b0</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)# rsp+rax+10 = rdx</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax# rax += 1</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;# rax!=6时循环</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:    nopl   0x0(%rax,%rax,1)</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:    jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:    mov    $0x0,%eax# eax = 0</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:    jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:    mov    0x18(%rsp),%rax</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:    xor    %fs:0x28,%rax</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:    je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:    callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:    add    $0x20,%rsp</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:    pop    %rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:    retq   </span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>可以看到这段代码的逻辑是取出输入的字符的二进制后四位作为偏移量，从0x4024b0处偏移此偏移量取出字符，然后压入堆栈，再到后面的循环中从第一个压入的堆栈与地址<code>$0x40245e</code>中所含的字符进行比较，先打印<code>0x4024b0</code>处的字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4024b0</span><br><span class="line">0x4024b0 &lt;array.3449&gt;:    <span class="string">&quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span></span><br></pre></td></tr></table></figure><p>再打印<code>$0x40245e</code>中的字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br><span class="line">0x40245e:    <span class="string">&quot;flyers&quot;</span></span><br></pre></td></tr></table></figure><p>由此可知<strong>我们只要让输入的6个字符的ascii码的后四位作为偏移量，在<code>maduiersnfotvbyl</code>这十六个字符中偏移正确的值，最后取出flyers</strong>就可以了，flyers 对应的偏移量为 9fe567</p><p>所以我们的答案就很显然了，在Terminal中使用<code>man ascii</code>语句查看所有字符对应的ascii码，找出正确偏移的字符，得到一组可行的答案：<code>9?&gt;567</code></p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109251104999.jpeg" alt="img" /></p><h1 id="phase_6"><a class="markdownIt-Anchor" href="#phase_6"></a> phase_6</h1><p>phase_6的代码就有点长了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:    41 56                push   %r14</span><br><span class="line">  4010f6:    41 55                push   %r13</span><br><span class="line">  4010f8:    41 54                push   %r12</span><br><span class="line">  4010fa:    55                   push   %rbp</span><br><span class="line">  4010fb:    53                   push   %rbx</span><br><span class="line">  4010fc:    48 83 ec 50          sub    $0x50,%rsp</span><br><span class="line">  401100:    49 89 e5             mov    %rsp,%r13</span><br><span class="line">  401103:    48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  401106:    e8 51 03 00 00       callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  </span><br><span class="line">  40110b:    49 89 e6             mov    %rsp,%r14# r14 = rsp[0]</span><br><span class="line">  40110e:    41 bc 00 00 00 00    mov    $0x0,%r12d# r12d = 0</span><br><span class="line">  # 循环体2 r13每次+4，r12每次+1直到r12 = 6</span><br><span class="line">  &#123;</span><br><span class="line">  401114:    4c 89 ed             mov    %r13,%rbp# rbp = r13</span><br><span class="line">  401117:    41 8b 45 00          mov    0x0(%r13),%eax# eax = r13+0x0</span><br><span class="line">  40111b:    83 e8 01             sub    $0x1,%eax# eax--</span><br><span class="line">  40111e:    83 f8 05             cmp    $0x5,%eax# 小于等于5时不爆炸</span><br><span class="line">  401121:    76 05                jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:    e8 12 03 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401128:    41 83 c4 01          add    $0x1,%r12d# r12d += 1</span><br><span class="line">  40112c:    41 83 fc 06          cmp    $0x6,%r12d</span><br><span class="line">  401130:    74 21                je     401153 &lt;phase_6+0x5f&gt;# r12d是否等于6</span><br><span class="line">  401132:    44 89 e3             mov    %r12d,%ebx# ebx = r12d</span><br><span class="line">  </span><br><span class="line">  # 循环体1，作用为读入堆栈上的第2-6个数字，和第1个数字相比，如果相同就爆炸</span><br><span class="line">      &#123;</span><br><span class="line">  401135:    48 63 c3             movslq %ebx,%rax# rax = ebx</span><br><span class="line">  401138:    8b 04 84             mov    (%rsp,%rax,4),%eax# 读入堆栈上第rax个数放到eax上</span><br><span class="line">  40113b:    39 45 00             cmp    %eax,0x0(%rbp)</span><br><span class="line">  40113e:    75 05                jne    401145 &lt;phase_6+0x51&gt;# eax 为rbp的第0个数时 爆炸</span><br><span class="line">  401140:    e8 f5 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:    83 c3 01             add    $0x1,%ebx# ebx += 1 </span><br><span class="line">  401148:    83 fb 05             cmp    $0x5,%ebx</span><br><span class="line">  40114b:    7e e8                jle    401135 &lt;phase_6+0x41&gt;# 小于等于5跳转</span><br><span class="line">      &#125;</span><br><span class="line">  40114d:    49 83 c5 04          add    $0x4,%r13# r13 += 4</span><br><span class="line">  401151:    eb c1                jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  401153:    48 8d 74 24 18       lea    0x18(%rsp),%rsi# rsi = rsp[6]</span><br><span class="line">  401158:    4c 89 f0             mov    %r14,%rax# rax = r14 = *rsp[0]</span><br><span class="line">  40115b:    b9 07 00 00 00       mov    $0x7,%ecx# ecx = 7</span><br><span class="line">  </span><br><span class="line">  # 循环体3, 对输入的每个数进行 a[i] = 7 - a[i]操作</span><br><span class="line">  &#123;</span><br><span class="line">  401160:    89 ca                mov    %ecx,%edx# edx = 7</span><br><span class="line">  401162:    2b 10                sub    (%rax),%edx# edx -= rax</span><br><span class="line">  401164:    89 10                mov    %edx,(%rax)# (rax) = 7-rsp[0]</span><br><span class="line">  401166:    48 83 c0 04          add    $0x4,%rax# rax += 4</span><br><span class="line">  40116a:    48 39 f0             cmp    %rsi,%rax</span><br><span class="line">  40116d:    75 f1                jne    401160 &lt;phase_6+0x6c&gt;# 循环直到 rax == rsp[0]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  40116f:    be 00 00 00 00       mov    $0x0,%esi# esi = 0</span><br><span class="line">  401174:    eb 21                jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">  </span><br><span class="line">  # 循环体4，rsi == 24时跳出</span><br><span class="line">  &#123;</span><br><span class="line">  # 循环5，ecx == eax 跳出//即eax == 7 跳出</span><br><span class="line">      &#123;</span><br><span class="line">  401176:    48 8b 52 08          mov    0x8(%rdx),%rdx# rdx = (rdx所存地址+8)</span><br><span class="line">  40117a:    83 c0 01             add    $0x1,%eax# eax += 1</span><br><span class="line">  40117d:    39 c8                cmp    %ecx,%eax</span><br><span class="line">  40117f:    75 f5                jne    401176 &lt;phase_6+0x82&gt;# ecx = eax</span><br><span class="line">      &#125;</span><br><span class="line">  401181:    eb 05                jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  </span><br><span class="line">  # 循环体6，ecx &gt; 1 跳出</span><br><span class="line">      &#123;</span><br><span class="line">  401183:    ba d0 32 60 00       mov    $0x6032d0,%edx# edx = 0x6032d0</span><br><span class="line">  401188:    48 89 54 74 20       mov    %rdx,0x20(%rsp,%rsi,2)# rsp + 0x20 + 2rsi = rdx</span><br><span class="line">  40118d:    48 83 c6 04          add    $0x4,%rsi# rsi += 4</span><br><span class="line">  401191:    48 83 fe 18          cmp    $0x18,%rsi</span><br><span class="line">  401195:    74 14                je     4011ab &lt;phase_6+0xb7&gt;# rsi == 24</span><br><span class="line">  401197:    8b 0c 34             mov    (%rsp,%rsi,1),%ecx# ecx = rsp[rsi]</span><br><span class="line">  40119a:    83 f9 01             cmp    $0x1,%ecx</span><br><span class="line">  40119d:    7e e4                jle    401183 &lt;phase_6+0x8f&gt;# ecx &lt;= 1</span><br><span class="line">      &#125;</span><br><span class="line">  40119f:    b8 01 00 00 00       mov    $0x1,%eax# eax = 1</span><br><span class="line">  4011a4:    ba d0 32 60 00       mov    $0x6032d0,%edx# edx = 0x6032d0</span><br><span class="line">  4011a9:    eb cb                jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  4011ab:    48 8b 5c 24 20       mov    0x20(%rsp),%rbx# rbx = rsp[8]</span><br><span class="line">  4011b0:    48 8d 44 24 28       lea    0x28(%rsp),%rax# rax = rsp[9]</span><br><span class="line">  4011b5:    48 8d 74 24 50       lea    0x50(%rsp),%rsi# rax = rsp[20]</span><br><span class="line">  4011ba:    48 89 d9             mov    %rbx,%rcx# rcx = rbx</span><br><span class="line">  </span><br><span class="line">  # 循环7,循环直到rsi == rax</span><br><span class="line">  &#123;</span><br><span class="line">  4011bd:    48 8b 10             mov    (%rax),%rdx# rdx = rax</span><br><span class="line">  4011c0:    48 89 51 08          mov    %rdx,0x8(%rcx)# (rcx+8) = rax</span><br><span class="line">  4011c4:    48 83 c0 08          add    $0x8,%rax# rax += 8</span><br><span class="line">  4011c8:    48 39 f0             cmp    %rsi,%rax</span><br><span class="line">  4011cb:    74 05                je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:    48 89 d1             mov    %rdx,%rcx</span><br><span class="line">  4011d0:    eb eb                jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  4011d2:    48 c7 42 08 00 00 00 movq   $0x0,0x8(%rdx)# (rdx + 8) = 0</span><br><span class="line">  4011d9:    00 </span><br><span class="line">  4011da:    bd 05 00 00 00       mov    $0x5,%ebp# ebp = 5</span><br><span class="line">  </span><br><span class="line">  # 循环8 循环直到ebp &lt; 0</span><br><span class="line">  &#123;</span><br><span class="line">  4011df:    48 8b 43 08          mov    0x8(%rbx),%rax# rax = (rbx + 8)</span><br><span class="line">  4011e3:    8b 00                mov    (%rax),%eax# eax = (rax)</span><br><span class="line">  4011e5:    39 03                cmp    %eax,(%rbx)</span><br><span class="line">  4011e7:    7d 05                jge    4011ee &lt;phase_6+0xfa&gt;# 如果 rbx &lt; eax,爆炸</span><br><span class="line">  4011e9:    e8 4c 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:    48 8b 5b 08          mov    0x8(%rbx),%rbx# rbx = (rbx + 8)</span><br><span class="line">  4011f2:    83 ed 01             sub    $0x1,%ebp# ebp--</span><br><span class="line">  4011f5:    75 e8                jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  4011f7:    48 83 c4 50          add    $0x50,%rsp</span><br><span class="line">  4011fb:    5b                   pop    %rbx</span><br><span class="line">  4011fc:    5d                   pop    %rbp</span><br><span class="line">  4011fd:    41 5c                pop    %r12</span><br><span class="line">  4011ff:    41 5d                pop    %r13</span><br><span class="line">  401201:    41 5e                pop    %r14</span><br><span class="line">  401203:    c3                   retq   </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/24w 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:    332163044800</span><br><span class="line">0x6032e0 &lt;node2&gt;:    168263044960</span><br><span class="line">0x6032f0 &lt;node3&gt;:    924363045120</span><br><span class="line">0x603300 &lt;node4&gt;:    691463045280</span><br><span class="line">0x603310 &lt;node5&gt;:    477563045440</span><br><span class="line">0x603320 &lt;node6&gt;:    443600</span><br></pre></td></tr></table></figure><p>可以看出来前面的代码要求我们输入的数字都不一样且小于等于6，然后它里面有有个链表需要我们进行比较，我们输入的数字的顺序就是比较链表节点的顺序，而其中有个判断又需要我们将比较的这些链表中的数据降序输出，带入数字推断后得到期望的顺序<code>3 4 5 6 1 2</code>，每位都与7取余后得到答案: <code>4 3 2 1 6 5</code></p><p>写的很简陋，详细的分析建议看大佬的<a href="https://zhuanlan.zhihu.com/p/104130161">Introduction to CSAPP（十九）：这可能是你能找到的分析最全的Bomblab了</a></p><h1 id="secret-phase"><a class="markdownIt-Anchor" href="#secret-phase"></a> secret phase</h1><p>在看bomb文件的反汇编代码的时候，看到了个<code>secret_phase</code>全局搜索后在<code>phase_defuse</code>中发现了调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">4015c4:  sub    $0x78,%rsp</span><br><span class="line">4015c8:  mov    %fs:0x28,%rax</span><br><span class="line">4015cf:  </span><br><span class="line">4015d1:  mov    %rax,0x68(%rsp)</span><br><span class="line">4015d6:  xor    %eax,%eax</span><br><span class="line">4015d8:  cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;</span><br><span class="line">4015df:  jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line">4015e1:  lea    0x10(%rsp),%r8</span><br><span class="line">4015e6:  lea    0xc(%rsp),%rcx</span><br><span class="line">4015eb:  lea    0x8(%rsp),%rdx</span><br><span class="line">4015f0:  mov    $0x402619,%esi # 这里包括下面发现了奇怪的地址，打印看看，发现是 &quot;%d %d %s&quot;</span><br><span class="line">4015f5:  mov    $0x603870,%edi # 这里是 &quot;&quot;</span><br><span class="line">4015fa:  callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">4015ff:  cmp    $0x3,%eax # sscanf的返回值表示输入的参数个数，如果是3个，就到401604行，那么究竟什么时候会执行这段逻辑呢？</span><br><span class="line">401602:  jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401604:  mov    $0x402622,%esi # &quot;DrEvil&quot;</span><br><span class="line">401609:  lea    0x10(%rsp),%rdi # 比较 &quot;DrEvil&quot; 和某个值</span><br><span class="line">40160e:  callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">401613:  test   %eax,%eax</span><br><span class="line">401615:  jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401617:  mov    $0x4024f8,%edi # &quot;Curses, you&#x27;ve found the secret phase!&quot;</span><br><span class="line">40161c:  callq  400b10 &lt;puts@plt&gt; # 打印之</span><br><span class="line">401621:  mov    $0x402520,%edi # &quot;But finding it and solving it are quite different...&quot;</span><br><span class="line">401626:  callq  400b10 &lt;puts@plt&gt; # 打印之</span><br><span class="line">40162b:  mov    $0x0,%eax</span><br><span class="line">401630:  callq  401242 &lt;secret_phase&gt; # 调用了彩蛋关</span><br><span class="line">401635:  mov    $0x402558,%edi # &quot;Congratulations! You&#x27;ve defused the bomb!&quot;</span><br><span class="line">40163a:  callq  400b10 &lt;puts@plt&gt; # 打印之</span><br><span class="line">40163f:  mov    0x68(%rsp),%rax</span><br><span class="line">401644:  xor    %fs:0x28,%rax</span><br><span class="line">40164b:  </span><br><span class="line">40164d:  je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line">40164f:  callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">401654:  add    $0x78,%rsp</span><br><span class="line">401658:  retq   </span><br><span class="line">401659:  nop</span><br><span class="line">40165a:  nop</span><br><span class="line">40165b:  nop</span><br><span class="line">40165c:  nop</span><br><span class="line">40165d:  nop</span><br><span class="line">40165e:  nop</span><br><span class="line">40165f:  nop</span><br></pre></td></tr></table></figure><p>阅读后发现在前面某个关卡处输入的秘文为整数 整数 字符串时进入secret，推测字符串为前文发现的<code>DrEvil</code>，又发现只有phase4和phase3能满足这个要求，然后都尝试后发现在phase4输入的秘文后接一个<code>DrEvil</code>可以进入隐藏的secret_phase，以下为secret_phase的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">401242:  push   %rbx</span><br><span class="line">401243:  callq  40149e &lt;read_line&gt;</span><br><span class="line">401248:  mov    $0xa,%edx</span><br><span class="line">40124d:  mov    $0x0,%esi</span><br><span class="line">401252:  mov    %rax,%rdi</span><br><span class="line">401255:  callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">40125a:  mov    %rax,%rbx # 断点可以设置在这里，打印后发现，rax中存的是我们输入的值</span><br><span class="line">40125d:  lea    -0x1(%rax),%eax # eax = eax - 1</span><br><span class="line">401260:  cmp    $0x3e8,%eax # eax - 0x3e8 &lt;= 0 即 in - 1 &lt;= 1000</span><br><span class="line">401265:  jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">401267:  callq  40143a &lt;explode_bomb&gt; # 不满足时 爆炸</span><br><span class="line">40126c:  mov    %ebx,%esi # 这个是我们输入的值</span><br><span class="line">40126e:  mov    $0x6030f0,%edi # 观察输入的参数：</span><br><span class="line"># (gdb) x 0x6030f0</span><br><span class="line"># 0x6030f0 &lt;n1&gt;:  0x00000024</span><br><span class="line">401273:  callq  401204 &lt;fun7&gt;</span><br><span class="line">401278:  cmp    $0x2,%eax</span><br><span class="line">40127b:  je     401282 &lt;secret_phase+0x40&gt; # fun7返回值和2比，如果等于零，则成功</span><br><span class="line">40127d:  callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401282:  mov    $0x402438,%edi</span><br><span class="line">401287:  callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">40128c:  callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">401291:  pop    %rbx</span><br></pre></td></tr></table></figure><p>关键点就在于func7这个函数了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line"># %esi 存我们输入的值</span><br><span class="line"># %edi 存某一地址</span><br><span class="line">401204: sub    $0x8,%rsp</span><br><span class="line">401208: test   %rdi,%rdi # 查看是否为null</span><br><span class="line">40120b: je     401238 &lt;fun7+0x34&gt; # 满足跳转</span><br><span class="line">40120d: mov    (%rdi),%edx </span><br><span class="line">40120f: cmp    %esi,%edx</span><br><span class="line">401211: jle    401220 &lt;fun7+0x1c&gt;</span><br><span class="line">401213: mov    0x8(%rdi),%rdi</span><br><span class="line">401217: callq  401204 &lt;fun7&gt;</span><br><span class="line">40121c: add    %eax,%eax</span><br><span class="line">40121e: jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">401220: mov    $0x0,%eax</span><br><span class="line">401225: cmp    %esi,%edx</span><br><span class="line">401227: je     40123d &lt;fun7+0x39&gt;</span><br><span class="line">401229: mov    0x10(%rdi),%rdi</span><br><span class="line">40122d: callq  401204 &lt;fun7&gt;</span><br><span class="line">401232: lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">401236: jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">401238: mov    $0xffffffff,%eax # 返回全1序列</span><br><span class="line">40123d: add    $0x8,%rsp</span><br><span class="line">401241: retq</span><br></pre></td></tr></table></figure><p>大佬<a href="https://www.zhihu.com/people/yansongtw">@Yannick</a>逆向的等价C语言:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun7</span><span class="params">(<span class="type">int</span> cmp, Node* addr)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(addr == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> v = addr-&gt;value;</span><br><span class="line">  <span class="keyword">if</span> (v == cmp)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( v &lt; cmp)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span>*fun7(cmp, addr-&gt;right);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*func7(cmp, addr-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看这个二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/120 0x6030f0</span><br><span class="line">0x6030f0 &lt;n1&gt;:    36063040160</span><br><span class="line">0x603100 &lt;n1+16&gt;:    6304048000</span><br><span class="line">0x603110 &lt;n21&gt;:    8063041440</span><br><span class="line">0x603120 &lt;n21+16&gt;:    6304080000</span><br><span class="line">0x603130 &lt;n22&gt;:    50063041120</span><br><span class="line">0x603140 &lt;n22+16&gt;:    6304176000</span><br><span class="line">0x603150 &lt;n32&gt;:    22063043680</span><br><span class="line">0x603160 &lt;n32+16&gt;:    6304304000</span><br><span class="line">0x603170 &lt;n33&gt;:    45063042080</span><br><span class="line">0x603180 &lt;n33+16&gt;:    6304400000</span><br><span class="line">0x603190 &lt;n31&gt;:    6063042400</span><br><span class="line">0x6031a0 &lt;n31+16&gt;:    6304336000</span><br><span class="line">0x6031b0 &lt;n34&gt;:    107063042720</span><br><span class="line">0x6031c0 &lt;n34+16&gt;:    6304432000</span><br><span class="line">0x6031d0 &lt;n45&gt;:    40000</span><br><span class="line">0x6031e0 &lt;n45+16&gt;:    0000</span><br><span class="line">0x6031f0 &lt;n41&gt;:    1000</span><br><span class="line">0x603200 &lt;n41+16&gt;:    0000</span><br><span class="line">0x603210 &lt;n47&gt;:    99000</span><br><span class="line">0x603220 &lt;n47+16&gt;:    0000</span><br><span class="line">0x603230 &lt;n44&gt;:    35000</span><br><span class="line">0x603240 &lt;n44+16&gt;:    0000</span><br><span class="line">0x603250 &lt;n42&gt;:    7000</span><br><span class="line">0x603260 &lt;n42+16&gt;:    0000</span><br><span class="line">0x603270 &lt;n43&gt;:    20000</span><br><span class="line">0x603280 &lt;n43+16&gt;:    0000</span><br><span class="line">0x603290 &lt;n46&gt;:    47000</span><br><span class="line">0x6032a0 &lt;n46+16&gt;:    0000</span><br><span class="line">0x6032b0 &lt;n48&gt;:    1001000</span><br><span class="line">0x6032c0 &lt;n48+16&gt;:    0000</span><br></pre></td></tr></table></figure><p>画出其结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">└─ 36</span><br><span class="line">   ├─ 8</span><br><span class="line">   │  ├─ 6</span><br><span class="line">   │  │  ├─ left: 1</span><br><span class="line">   │  │  └─ right: 7</span><br><span class="line">   │  └─ 22</span><br><span class="line">   │     ├─ left: 20</span><br><span class="line">   │     └─ right: 35</span><br><span class="line">   └─ 50</span><br><span class="line">      ├─ 45</span><br><span class="line">      │  ├─ left: 40</span><br><span class="line">      │  └─ right: 47</span><br><span class="line">      └─ 107</span><br><span class="line">         ├─ left: 99</span><br><span class="line">         └─ right: 1001</span><br></pre></td></tr></table></figure><p>然后我就穷举了。。。</p><p>得到的答案是<code>22</code>或者<code>20</code>，终于拆外所有炸弹</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109251141149.png" alt="image-20210925114142077" /></p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://wdxtub.com/csapp/thick-csapp-lab-2/2016/04/16/">【读厚 CSAPP】II Bomb Lab</a></p><p><a href="https://zhuanlan.zhihu.com/p/104130161">Introduction to CSAPP（十九）：这可能是你能找到的分析最全的Bomblab了</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前言：看了好久的书，写了好几个晚上，参考了一些大佬的笔记，终于把这个bomblab写完了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;实验简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实验简介&quot;&gt;&lt;/a&gt; 实验简介&lt;/h1&gt;
&lt;p&gt;这个著名的bomblab为我们提供了一个二进制文件，然后我们需要将这个二进制文件进行反汇编得到一堆的汇编文件，通过阅读汇编文件中的代码以及GDB的调试来得到需要输入的字符密码来进入下一关。&lt;/p&gt;
&lt;p&gt;整个实验一共有六个正式关卡，一个隐藏关卡，密码和进入隐藏关卡的方法也藏在文件中，需要我们一点点的探寻其中的蛛丝马迹，拆开炸弹。如果拆弹失败的话，实验文件会给我们打印出一个BOMB！！！如果你是CMU的学生，每次不小心的BOMB还会扣你这个实验的分数，不过我们不是CMU的学生，就随便他炸了23333&lt;/p&gt;
&lt;h1 id=&quot;准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#准备工作&quot;&gt;&lt;/a&gt; 准备工作&lt;/h1&gt;
&lt;p&gt;没有实验文件的需要先到&lt;a href=&quot;http://csapp.cs.cmu.edu/3e/bomb.tar&quot;&gt;这个网站&lt;/a&gt;下载一个&lt;/p&gt;
&lt;p&gt;首先我们需要进入到这个lab的文件所在的文件夹下，可以看到有README、bomb、和bomb.c三个文件，我们先打开bomb.c看看有些什么东西&lt;/p&gt;
&lt;p&gt;可以看到有6个phase，每个phase基本都是要我们输入一段字符，然后它调用了判断我们字符对不对的函数。大概浏览一下，知道要干什么之后先把bomb文件反汇编一下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objdump bomb -d &amp;gt; disassemble.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;得到了bomb的反汇编代码打开&lt;/p&gt;
&lt;p&gt;看到一堆莫名其妙的东西，不知道怎么下手，想起来之前有6个phase，于是就搜索了下phase，找到了phase所在地，就用GDB来进行调试了&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gdb bomb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后给爆炸和phase_1先打上断点&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;b explode_bomb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b phase_1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;run了之后，随便输入一点字符进入phase_1，先把当前的函数用disas指令反汇编一下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不熟悉GDB调试的可以参考CMU的&lt;a href=&quot;http://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf&quot;&gt;课程提供的手册&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="SnowMoonの项目记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="CSAPP" scheme="https://www.snowmoon.top/tags/CSAPP/"/>
    
    <category term="bomblab" scheme="https://www.snowmoon.top/tags/bomblab/"/>
    
  </entry>
  
  <entry>
    <title>动态规划2——线性动态规划问题</title>
    <link href="https://www.snowmoon.top/2021/09/07/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A02/"/>
    <id>https://www.snowmoon.top/2021/09/07/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A02/</id>
    <published>2021-09-07T00:30:00.000Z</published>
    <updated>2023-11-30T16:44:48.205Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：本文为学习力扣文章<a href="https://leetcode-cn.com/leetbook/detail/dynamic-programming-1-plus/">《动态规划精讲（一）》</a>时的学习笔记，本文对其进行线性动态规划相关的文章和问题进行了一定的转载和修改并在其中加入了一些个人的理解。</p></blockquote><h1 id="线性动态规划简介"><a class="markdownIt-Anchor" href="#线性动态规划简介"></a> 线性动态规划简介</h1><p>线性动态规划主要是从0开始从小到大依次递推过去的，特点为问题规模依次从0到i依次递增，较大规模的问题依赖较小规模问题的解</p><p>这里问题规模为 i 的含义是考虑前 i 个元素 [0…i] 时问题的解。</p><p>状态定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[n] := [0..n] 上问题的解</span><br></pre></td></tr></table></figure><p>状态转移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[n] = f(dp[n-1], ..., dp[0])</span><br></pre></td></tr></table></figure><h1 id="单串"><a class="markdownIt-Anchor" href="#单串"></a> 单串</h1><p>单串是线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 dp[i] := 考虑[0…i]上，原问题的解，其中 i 位置的处理，根据不同的问题，主要有两种方式：</p><ul><li>第一种是 i 位置必须取，此时状态可以进一步描述为 dp[i] := 考虑[0…i]上，且取 i，原问题的解；</li><li>第二种是 i 位置可以取可以不取</li></ul><span id="more"></span><h2 id="1-依赖比-i-小的-o1-个子问题"><a class="markdownIt-Anchor" href="#1-依赖比-i-小的-o1-个子问题"></a> 1. 依赖比 i 小的 O(1) 个子问题</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></p><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><p>一个数组有很多个子数组，求哪个子数组的和最大。可以按照子数组的最后一个元素来分子问题，确定子问题后设计状态</p><p>状态的推导是按照 i 从 0 到 n - 1 按顺序推的，推到 dp[i]，时，dp[i - 1], …, dp[0] 已经计算完。因为子数组是连续的，所以子问题 dp[i] 其实只与子问题 dp[i - 1] 有关。如果 [0…i-1] 上以 nums[i-1] 结尾的最大子数组和(缓存在 dp[i-1] )为非负数，则以 nums[i] 结尾的最大子数组和就在 dp[i-1] 的基础上加上 nums[i] 就是 dp[i] 的结果否则以 i 结尾的子数组就不要 i-1 及之前的数，因为选了的话子数组的和只会更小。</p><p>按照以上的分析，状态的转移可以写出来，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = nums[i] + max(dp[i - 1], 0)</span><br></pre></td></tr></table></figure><h2 id="2-依赖比-i-小的-on-个子问题"><a class="markdownIt-Anchor" href="#2-依赖比-i-小的-on-个子问题"></a> 2. 依赖比 i 小的 O(n) 个子问题</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a></p><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p></blockquote><p>输入是一个单串，首先思考单串问题中设计状态 dp[i] 时拆分子问题的方式：枚举子串或子序列的结尾元素来拆分子问题，设计状态 dp[i] := 在子数组 [0…i] 上，且选了 nums[i] 时，的最长上升子序列。</p><p>因为子序列需要上升，因此以 i 结尾的子序列中，nums[i] 之前的数字一定要比 nums[i] 小才行，因此目标就是先找到以此前比 nums[i] 小的各个元素，然后每个所选元素对应一个以它们结尾的最长子序列，从这些子序列中选择最长的，其长度加 1 就是当前的问题的结果。如果此前没有比 nums[i] 小的数字，则当前问题的结果就是 1 。</p><p>按照以上的分析，状态的转移方程可以写出来，如下</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[i] = max_{j}(dp[j]) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">0 \leq j &lt; i, nums[j] &lt; nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>。</p><h2 id="单串问题最经典单串lis系列"><a class="markdownIt-Anchor" href="#单串问题最经典单串lis系列"></a> 单串问题：最经典单串LIS系列</h2><h3 id="1最长上升子序列"><a class="markdownIt-Anchor" href="#1最长上升子序列"></a> 1.最长上升子序列</h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>1 &lt;= nums.length &lt;= 2500</code><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">-10^4 \leq nums[i] \leq 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></p><p>进阶：</p><p>你可以设计时间复杂度为 O(n2) 的解决方案吗？</p><p>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前言：本文为学习力扣文章&lt;a href=&quot;https://leetcode-cn.com/leetbook/detail/dynamic-programming-1-plus/&quot;&gt;《动态规划精讲（一）》&lt;/a&gt;时的学习笔记，本文对其进行线性动态规划相关的文章和问题进行了一定的转载和修改并在其中加入了一些个人的理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;线性动态规划简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线性动态规划简介&quot;&gt;&lt;/a&gt; 线性动态规划简介&lt;/h1&gt;
&lt;p&gt;线性动态规划主要是从0开始从小到大依次递推过去的，特点为问题规模依次从0到i依次递增，较大规模的问题依赖较小规模问题的解&lt;/p&gt;
&lt;p&gt;这里问题规模为 i 的含义是考虑前 i 个元素 [0…i] 时问题的解。&lt;/p&gt;
&lt;p&gt;状态定义：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dp[n] := [0..n] 上问题的解&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;状态转移：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dp[n] = f(dp[n-1], ..., dp[0])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;单串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单串&quot;&gt;&lt;/a&gt; 单串&lt;/h1&gt;
&lt;p&gt;单串是线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 dp[i] := 考虑[0…i]上，原问题的解，其中 i 位置的处理，根据不同的问题，主要有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种是 i 位置必须取，此时状态可以进一步描述为 dp[i] := 考虑[0…i]上，且取 i，原问题的解；&lt;/li&gt;
&lt;li&gt;第二种是 i 位置可以取可以不取&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://www.snowmoon.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer15——双指针（简单）</title>
    <link href="https://www.snowmoon.top/2021/09/04/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer15/"/>
    <id>https://www.snowmoon.top/2021/09/04/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer15/</id>
    <published>2021-09-04T00:30:00.000Z</published>
    <updated>2023-11-30T16:46:03.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-25-合并两个排序的链表"><a class="markdownIt-Anchor" href="#剑指-offer-25-合并两个排序的链表"></a> <a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h1><p>难度 简单</p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 链表长度 &lt;= 1000</span><br></pre></td></tr></table></figure><p>注意：本题与主站 21 题相同：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><span id="more"></span><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>开辟一个空节点用来返回，也可以在进入循环前进行一下判断，不开辟节点直接进循环</p><p>循环：将l1和l2中值较大的节点作为当前节点的下一节点</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode *head,*cur;</span><br><span class="line">        head = (ListNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ListNode));</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>( l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-52-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#剑指-offer-52-两个链表的第一个公共节点"></a> <a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h1><p>难度 简单</p><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表**：**</p><p><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109050042866.png" alt="img" /></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109050042483.png" alt="img" /></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109050042893.png" alt="img" /></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Reference of the node with value = 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://haoyu-album.oss-cn-shanghai.aliyuncs.com/img202109050043045.png" alt="img" /></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li><li>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li></ul><h2 id="思路与题解"><a class="markdownIt-Anchor" href="#思路与题解"></a> 思路与题解</h2><p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p><p>这样，当它们相遇时，所指向的结点就是第一个公共结点。</p><p>两个链表长度分别为L1+C、L2+C， C为公共部分的长度， 第一个人走了L1+C步后，回到第二个人起点走L2步；第2个人走了L2+C步后，回到第一个人起点走L1步。 当两个人走的步数都为L1+L2+C时就两个家伙就相爱了</p><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *node1 = headA, *node2 = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (node1 != node2) &#123;</span><br><span class="line">            node1 = node1 != <span class="literal">NULL</span> ? node1-&gt;next : headB;</span><br><span class="line">            node2 = node2 != <span class="literal">NULL</span> ? node2-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-25-合并两个排序的链表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-25-合并两个排序的链表&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/&quot;&gt;剑指 Offer 25. 合并两个排序的链表&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;难度 简单&lt;/p&gt;
&lt;p&gt;输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;限制：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;= 链表长度 &amp;lt;= 1000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意：本题与主站 21 题相同：&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists/&quot;&gt;https://leetcode-cn.com/problems/merge-two-sorted-lists/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="https://www.snowmoon.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="https://www.snowmoon.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer14——双指针（简单）</title>
    <link href="https://www.snowmoon.top/2021/09/03/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer14/"/>
    <id>https://www.snowmoon.top/2021/09/03/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer14/</id>
    <published>2021-09-03T00:30:00.000Z</published>
    <updated>2023-11-30T16:45:58.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-22-链表中倒数第k个节点"><a class="markdownIt-Anchor" href="#剑指-offer-22-链表中倒数第k个节点"></a> <a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h1><p>难度 简单</p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="思路与题解"><a class="markdownIt-Anchor" href="#思路与题解"></a> 思路与题解</h2><p>循环两次：</p><pre><code>1. 统计链表节点数n2. 遍历到第n-k个节点（即倒数第k个节点）并返回</code></pre><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* getKthFromEnd(ListNode* head, int k) &#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        int n = 0,i;</span><br><span class="line">        while(cur != NULL) </span><br><span class="line">        &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        for(i = 0;i &lt; n-k;i++)</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-18-删除链表的节点"><a class="markdownIt-Anchor" href="#剑指-offer-18-删除链表的节点"></a> <a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h1><p>难度 简单</p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>**注意：**此题对比原题有改动</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>题目保证链表中节点的值互不相同</li><li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li></ul><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>遍历链表，遇到这个节点就修改并删除</p><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *cur;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val == val) head = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-22-链表中倒数第k个节点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-22-链表中倒数第k个节点&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/&quot;&gt;剑指 Offer 22. 链表中倒数第k个节点&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;难度 简单&lt;/p&gt;
&lt;p&gt;输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。&lt;/p&gt;
&lt;p&gt;例如，一个链表有 &lt;code&gt;6&lt;/code&gt; 个节点，从头节点开始，它们的值依次是 &lt;code&gt;1、2、3、4、5、6&lt;/code&gt;。这个链表的倒数第 &lt;code&gt;3&lt;/code&gt; 个节点是值为 &lt;code&gt;4&lt;/code&gt; 的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 k = 2.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回链表 4-&amp;gt;5.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="双指针" scheme="https://www.snowmoon.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer刷题13——动态规划（中等）</title>
    <link href="https://www.snowmoon.top/2021/09/02/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer13/"/>
    <id>https://www.snowmoon.top/2021/09/02/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer13/</id>
    <published>2021-09-02T00:30:00.000Z</published>
    <updated>2023-11-30T16:45:54.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-48-最长不含重复字符的子字符串"><a class="markdownIt-Anchor" href="#剑指-offer-48-最长不含重复字符的子字符串"></a> <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h1><p>难度 中等</p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="思路与题解"><a class="markdownIt-Anchor" href="#思路与题解"></a> 思路与题解</h2><p>这是一道典型的动态规划题目。对于一个数 num[i]，我们有两种选择：</p><ol><li>只翻译自己；</li><li>和前面的数字组合翻译，前提是组合的数在 10−25 之间。</li></ol><p>用F[i]表示前 i 个数字的翻译方法数。根据以上两种选择，我们进行如下分析：</p><ul><li>如果只翻译自己，比如 12345，如果 5 单独翻译，那么方法数与 1234 是一样的， dp(i)=dp(i-1)。</li><li>如果和前面的数字组合，比如 1235，如果 35 组合翻译，从两方面考虑：<br />35 看成一个整体，虽然加了 5 但是和没加是一样的，状态 dp(i)=dp(i-1)；<br />35 组合就意味着不能再组合了，相当于条件 11 中的单独翻译自己，方法数与 12 是一样的。这时 dp(i)=dp(i-2)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">translateNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">           <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, x, y = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            x = num % <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">10</span> * x + y;</span><br><span class="line">            <span class="type">int</span> c = (tmp &gt;= <span class="number">10</span> &amp;&amp; tmp &lt;= <span class="number">25</span>) ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">            y = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-48-最长不含重复字符的子字符串-2"><a class="markdownIt-Anchor" href="#剑指-offer-48-最长不含重复字符的子字符串-2"></a> <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h1><p>难度 中等</p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h2 id="思路与题解-2"><a class="markdownIt-Anchor" href="#思路与题解-2"></a> 思路与题解</h2><p>PS:这题剑指里归类为了动态规划，不过感觉好像滑动窗口更适合这个题点，解出来的时间也更快，不过可能主要是因为测试样例的原因把。。。</p><ol><li>用一个字符串str来存储从s[0]到s[i]中最长的字符串，初始化为空</li><li>遍历s，如果str中含有此时的s[i]，删除从第一位到重复位的字符串</li><li>每个遍历过程中更新最大值max</li><li>返回最大值</li></ol><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Max = <span class="number">0</span>,i,j,index;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            index = str.<span class="built_in">find</span>(s[i],<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(index != <span class="number">-1</span>) str.<span class="built_in">erase</span>(<span class="number">0</span>,index+<span class="number">1</span>);</span><br><span class="line">            str+=s[i];</span><br><span class="line">            Max = <span class="built_in">max</span>((<span class="type">int</span>)str.<span class="built_in">length</span>(), Max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-48-最长不含重复字符的子字符串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-48-最长不含重复字符的子字符串&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/&quot;&gt;剑指 Offer 48. 最长不含重复字符的子字符串&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;难度 中等&lt;/p&gt;
&lt;p&gt;请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;abcabcbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;bbbbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;pwwkew&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="https://www.snowmoon.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="https://www.snowmoon.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer12——动态规划（中等）</title>
    <link href="https://www.snowmoon.top/2021/09/01/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer12/"/>
    <id>https://www.snowmoon.top/2021/09/01/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer12/</id>
    <published>2021-09-01T00:30:00.000Z</published>
    <updated>2023-11-30T16:45:49.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-42-连续子数组的最大和"><a class="markdownIt-Anchor" href="#剑指-offer-42-连续子数组的最大和"></a> <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h1><p>难度 简单</p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-100 &lt;= arr[i] &lt;= 100</code></li></ul><p>注意：本题与主站 53 题相同：<a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设数组为[-2,1,-3,4,-1,2,1,-5,4]，分解每一步问题：</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1,2,1,-5,4] -&gt; 6</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1,2,1,-5] -&gt; 6</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1,2,1] -&gt; 6</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1,2] -&gt; 5</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4,-1] -&gt; 4</span></span><br><span class="line"><span class="comment">    [-2,1,-3,4] -&gt; 4</span></span><br><span class="line"><span class="comment">    [-2,1,-3] -&gt; 1</span></span><br><span class="line"><span class="comment">    [-2,1] -&gt; 1</span></span><br><span class="line"><span class="comment">    [-2] -&gt; -2</span></span><br><span class="line"><span class="comment">    转移方程：F[i] = nums[i] + F[i-1]; //F[i-1] &gt; 0</span></span><br><span class="line"><span class="comment">            F[i] = nums[i];           //F[i-1] &lt;= 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.<span class="built_in">empty</span>() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max,n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        max = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i<span class="number">-1</span>] &gt; <span class="number">0</span> ) nums[i] += nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &gt; max ) max = nums[i];</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-47-礼物的最大价值"><a class="markdownIt-Anchor" href="#剑指-offer-47-礼物的最大价值"></a> <a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h1><p>难度 中等</p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt; grid.length &lt;= 200</code></li><li><code>0 &lt; grid[0].length &lt;= 200</code></li></ul><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>转移方程：</p><p class='katex-block katex-error' title='ParseError: KaTeX parse error: Unknown column alignment: * at position 33: …\begin{array}{*̲*lr**}grid(i,j…'>dp(i,j)= \left\{\begin{array}{**lr**}grid(i,j) &amp; i=0;j=0;\\grid(i,j)+dp(i,j−1) &amp; ,i=0,j\neq0\\grid(i,j)+dp(i−1,j) &amp; ,i\neq0,j=0\\grid(i,j)+max[dp(i−1,j),dp(i,j−1)] &amp; ,i\neq0,j\neq0\\\end{array}\right.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    转移方程：F[i][j] = max(F[i-1][j], F[i][j-1]) + grid[i][j];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m,n,sum;</span><br><span class="line"></span><br><span class="line">        sum = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        m = grid.<span class="built_in">size</span>();</span><br><span class="line">        n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>( j = <span class="number">1</span>; j &lt; n ;j++ )</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; m ;i++ )</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i<span class="number">-1</span>][<span class="number">0</span>] ;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; m ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( j = <span class="number">1</span>; j &lt; n; j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                grid[i][j] += <span class="built_in">max</span>(grid[i][j<span class="number">-1</span>], grid[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-42-连续子数组的最大和&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-42-连续子数组的最大和&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/&quot;&gt;剑指 Offer 42. 连续子数组的最大和&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;难度 简单&lt;/p&gt;
&lt;p&gt;输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。&lt;/p&gt;
&lt;p&gt;要求时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums = [-2,1,-3,4,-1,2,1,-5,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= arr.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-100 &amp;lt;= arr[i] &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：本题与主站 53 题相同：&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/&quot;&gt;https://leetcode-cn.com/problems/maximum-subarray/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://www.snowmoon.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer11——动态规划（简单）</title>
    <link href="https://www.snowmoon.top/2021/08/31/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer11/"/>
    <id>https://www.snowmoon.top/2021/08/31/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer11/</id>
    <published>2021-08-31T00:30:00.000Z</published>
    <updated>2023-11-30T16:45:45.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-10-i-斐波那契数列"><a class="markdownIt-Anchor" href="#剑指-offer-10-i-斐波那契数列"></a> <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h1><p>难度 简单</p><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><span id="more"></span><h2 id="思路与题解"><a class="markdownIt-Anchor" href="#思路与题解"></a> 思路与题解</h2><ol><li><p>**状态定义：**F[i]为第i个斐波那契数列的数字</p></li><li><p><strong>转移方程：</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i] = F[i-1]+F[i-2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></p></li><li><p><strong>初始状态：</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn><mo separator="true">;</mo><mi>F</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F[0]=0;F[1]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p></li><li><p>**计算顺序：**从0开始向目标迭代</p></li></ol><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *F = <span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        F[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n ; i++)</span><br><span class="line">            F[i] = ( F[i<span class="number">-1</span>] + F[i<span class="number">-2</span>] ) % <span class="number">1000000007</span>;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> F[n] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-10-ii-青蛙跳台阶问题"><a class="markdownIt-Anchor" href="#剑指-offer-10-ii-青蛙跳台阶问题"></a> <a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h1><p>难度 简单</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><p>注意：本题与主站 70 题相同：<a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><h2 id="思路与题解-2"><a class="markdownIt-Anchor" href="#思路与题解-2"></a> 思路与题解</h2><p>由于最后一级台阶只能从倒数第二级和倒数第三级跳上来，所以<br />跳上第n个台阶的方法数量 = 跳上第n-1个台阶的方法数量 + 跳上第n-2个台阶的方法数量<br />所以本题和斐波那契数列的题是一致的，只不过初始条件由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(0) = 0,F (1) = 1,F(2) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>变成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">F(0) = 1,F (1) = 1,F(2) = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    转移方程：F[n] = F[n-1]+F[n-2]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> a,b,tmp,i,sum;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            tmp = b;</span><br><span class="line">            b = sum;</span><br><span class="line">            a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-63-股票的最大利润"><a class="markdownIt-Anchor" href="#剑指-offer-63-股票的最大利润"></a> <a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h1><p>难度 中等</p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 数组长度 &lt;= 10^5</span><br></pre></td></tr></table></figure><h2 id="思路与题解-3"><a class="markdownIt-Anchor" href="#思路与题解-3"></a> 思路与题解</h2><p>假设输入为[7,1,5,3,6,4]</p><p>分解问题并缩小为六个子问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[7,1,5,3,6,4] -&gt; max = 5</span><br><span class="line"></span><br><span class="line">[7,1,5,3,6] -&gt; max = 5</span><br><span class="line"></span><br><span class="line">[7,1,5,3] -&gt; max = 4</span><br><span class="line"></span><br><span class="line">[7,1,5] -&gt; max = 4</span><br><span class="line"></span><br><span class="line">[7,1] -&gt; max = 0</span><br><span class="line"></span><br><span class="line">[7] -&gt; max = 0</span><br></pre></td></tr></table></figure><p>则</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F[n] = max( F[n-1], max(prices[n] - prices[i]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>即 F[n] 为过去的最高利润 与 在第n日卖出时利润更高者</p><p>但是这里我用了两个循环来解，把时间复杂度整高了。。。导致了超时。。。</p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设输入为[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">    分解问题并缩小为六个子问题：</span></span><br><span class="line"><span class="comment">    [7,1,5,3,6,4] -&gt; max = 5</span></span><br><span class="line"><span class="comment">    [7,1,5,3,6] -&gt; max = 5</span></span><br><span class="line"><span class="comment">    [7,1,5,3] -&gt; max = 4</span></span><br><span class="line"><span class="comment">    [7,1,5] -&gt; max = 4</span></span><br><span class="line"><span class="comment">    [7,1] -&gt; max = 0</span></span><br><span class="line"><span class="comment">    [7] -&gt; max = 0</span></span><br><span class="line"><span class="comment">    F[n] = max( F[n-1], max(nums[n] - nums[i]))</span></span><br><span class="line"><span class="comment">    即 F[n] 为过去的最高利润 与 在第n日卖出时利润更高者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( prices.<span class="built_in">empty</span>() ) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> *F = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"></span><br><span class="line">        F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; n; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            F[i] = F[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i] - prices[j] &gt; F[i] )</span><br><span class="line">                    F[i] = <span class="built_in">max</span>(F[i<span class="number">-1</span>], prices[i] - prices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> F[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路2"><a class="markdownIt-Anchor" href="#思路2"></a> 思路2</h2><p>大佬的思路：</p><p>大佬的转移方程写的比我的清楚：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>前</mtext><mi>i</mi><mtext>日最大利润</mtext><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>前</mtext><mo stretchy="false">(</mo><mi>i</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">)</mo><mtext>日最大利润</mtext><mo separator="true">,</mo><mtext>第</mtext><mi>i</mi><mtext>日价格−前</mtext><mi>i</mi><mtext>日最低价格</mtext><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mtext>−</mtext><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo>:</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">前i日最大利润=\max(前(i−1)日最大利润,第i日价格−前i日最低价格)\\dp[i]=\max(dp[i−1],prices[i]−\min(prices[0:i]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">前</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">日</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">利</span><span class="mord cjk_fallback">润</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord cjk_fallback">前</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">日</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">利</span><span class="mord cjk_fallback">润</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">第</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">日</span><span class="mord cjk_fallback">价</span><span class="mord cjk_fallback">格</span><span class="mord">−</span><span class="mord cjk_fallback">前</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">日</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">低</span><span class="mord cjk_fallback">价</span><span class="mord cjk_fallback">格</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><strong>时间复杂度降低：</strong> 前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 日的最低价格 $min(prices[0:i]) $时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> 。而在遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">prices</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span></span>时，可以借助一个变量（记为成本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cost</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span> ）每日更新最低价格。优化后的转移方程为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mtext>−</mtext><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i]=\max(dp[i−1],prices[i]−\min(cost,prices[i]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><strong>空间复杂度降低：</strong> 由于$ dp[i]$ 只与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">dp[i - 1] , prices[i] , cost</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span> 相关，因此可使用一个变量（记为利润 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">profit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span> ）代替 $dp $列表。优化后的转移方程为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>t</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>t</mi><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">profit = \max(profit, prices[i] - \min(cost, prices[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设输入为[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">    分解问题并缩小为六个子问题：</span></span><br><span class="line"><span class="comment">    [7,1,5,3,6,4] -&gt; max = 5</span></span><br><span class="line"><span class="comment">    [7,1,5,3,6] -&gt; max = 5</span></span><br><span class="line"><span class="comment">    [7,1,5,3] -&gt; max = 4</span></span><br><span class="line"><span class="comment">    [7,1,5] -&gt; max = 4</span></span><br><span class="line"><span class="comment">    [7,1] -&gt; max = 0</span></span><br><span class="line"><span class="comment">    [7] -&gt; max = 0</span></span><br><span class="line"><span class="comment">    F[n] = max( F[n-1], max(nums[n] - nums[i]))</span></span><br><span class="line"><span class="comment">    即 F[n] 为过去的最高利润 与 在第n日卖出时利润更高者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Special case</span></span><br><span class="line">        <span class="keyword">if</span>( prices.<span class="built_in">empty</span>() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Variable declaration</span></span><br><span class="line">        <span class="type">int</span> n,cost,profit;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Initialize</span></span><br><span class="line">        n = prices.<span class="built_in">size</span>();</span><br><span class="line">        profit = <span class="number">0</span>;</span><br><span class="line">        cost = prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Main loop</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cost = <span class="built_in">min</span>(cost,prices[i]);</span><br><span class="line">            profit = <span class="built_in">max</span>(profit, prices[i] - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-10-i-斐波那契数列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-10-i-斐波那契数列&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/&quot;&gt;剑指 Offer 10- I. 斐波那契数列&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;难度 简单&lt;/p&gt;
&lt;p&gt;写一个函数，输入 &lt;code&gt;n&lt;/code&gt; ，求斐波那契（Fibonacci）数列的第 &lt;code&gt;n&lt;/code&gt; 项（即 &lt;code&gt;F(N)&lt;/code&gt;）。斐波那契数列的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;F(0) = 0,   F(1) = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。&lt;/p&gt;
&lt;p&gt;答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= n &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="https://www.snowmoon.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="https://www.snowmoon.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划问题的常规解法</title>
    <link href="https://www.snowmoon.top/2021/08/30/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.snowmoon.top/2021/08/30/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-08-30T00:30:00.000Z</published>
    <updated>2023-11-30T16:44:43.712Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：最近刷剑指offer刷到了动态规划相关的问题，之前没怎么学过，所以特地抽一天时间来学一下，以下为学习的笔记</p></blockquote><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><h2 id="题目类型"><a class="markdownIt-Anchor" href="#题目类型"></a> 题目类型</h2><p><strong>1. 计数：</strong><br />有多少种方式走到右下角<br />有多少种方法选出k个数使得和为Sum<br /><strong>2. 求最大最小值：</strong><br />从左上角走到右下角路径的最大数字和<br />最长上升子序列长度<br /><strong>3. 求存在性：</strong><br />取石子游戏，先手是否必胜<br />能不能选出k个数使得和是Sum</p><h2 id="解题步骤"><a class="markdownIt-Anchor" href="#解题步骤"></a> 解题步骤</h2><ol><li><strong>确定状态</strong><br />简单的说，就是解动态规划时需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么，类似解数学题中，xyz代表什么一样，具体分为下面两个步骤：<ul><li>研究最优策略的最后一步</li><li>化为子问题</li></ul></li><li><strong>转移方程</strong><br />根据子问题定义直接得到</li><li><strong>初始条件和边界情况</strong><br />初始条件一般都是a[0]、a[1]这种，多看看<br />边界条件主要是看数组的边界，数组越不越界</li><li><strong>计算顺序</strong><br />大部分从小到大迭代，精髓在于使用之前计算得到的结果</li></ol><span id="more"></span><h1 id="322-零钱兑换"><a class="markdownIt-Anchor" href="#322-零钱兑换"></a> <a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h1><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><p>输入：coins = [1, 2, 5], amount = 11<br />输出：3<br />解释：11 = 5 + 5 + 1<br />示例 2：</p><p>输入：coins = [2], amount = 3<br />输出：-1<br />示例 3：</p><p>输入：coins = [1], amount = 0<br />输出：0<br />示例 4：</p><p>输入：coins = [1], amount = 1<br />输出：1<br />示例 5：</p><p>输入：coins = [1], amount = 2<br />输出：2</p><p>提示：</p><p>1 &lt;= coins.length &lt;= 12<br />1 &lt;= coins[i] &lt;= 231 - 1<br />0 &lt;= amount &lt;= 104</p><h2 id="思路与题解"><a class="markdownIt-Anchor" href="#思路与题解"></a> 思路与题解</h2><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    最后一步：添加一个硬币组成当前的金额，前面几步已经得到最优解</span></span><br><span class="line"><span class="comment">    转移方程：F[amount] = min&#123;F[amount-coins]&#125;</span></span><br><span class="line"><span class="comment">    边界条件：1. F[0] = 0; 2.负数硬币为正无穷</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>* F = <span class="keyword">new</span> <span class="type">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> N = coins.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= amount;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            F[i] = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; N; j++)</span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span>( i-coins[j] &gt;= <span class="number">0</span> &amp;&amp; F[i-coins[j]]!= INT_MAX)</span><br><span class="line">                &#123;</span><br><span class="line">                     F[i] = <span class="built_in">min</span>(F[i-coins[j]] + <span class="number">1</span> ,F[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(F[amount] == INT_MAX) F[amount] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> F[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="62-不同路径"><a class="markdownIt-Anchor" href="#62-不同路径"></a> <a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h1><p>难度 中等</p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><h2 id="思路与题解-2"><a class="markdownIt-Anchor" href="#思路与题解-2"></a> 思路与题解</h2><p><strong>转移方程</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">F[i][j] = F[i-1][j] + F[i][j-1];</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">;</span></span></span></span></p><p><strong>初始状态</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mo separator="true">;</mo><mi>F</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F[i][0]=1;F[0][j] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><h4 id="c二维数组开辟方法"><a class="markdownIt-Anchor" href="#c二维数组开辟方法"></a> C++二维数组开辟方法</h4><p>这里还学到了点C++的二维数组的开辟方法，以开辟m行，n列的二维数组 <code>array2D[m][n]</code></p><p>方法总结如下：</p><ol><li><p>n为已知常量；二维数组开辟时第二位不能为变量，因此需要n已知且为常量才能使用<br />假设 n = 5;则可开辟<code>array2D[m][5]</code></p></li><li><p>使用指针间接引用；即先开辟 m 个指向指针的指针``array2D`再在每一行开辟新的行数组</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **array2D = <span class="keyword">new</span> <span class="type">int</span> *[m];  </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)  </span><br><span class="line">&#123;  </span><br><span class="line">array2D[i] = <span class="keyword">new</span> <span class="type">int</span>[n];  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ol start="3"><li>使用STL中的vector容器</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt;  IntVector;  </span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;IntVector&gt;    IntVector2D;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i, j;  </span><br><span class="line"></span><br><span class="line">IntVector2D *pArray2D = <span class="keyword">new</span> IntVector2D;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态设置大小.  </span></span><br><span class="line">pArray2D-&gt;<span class="built_in">resize</span>(height);  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;height; ++i)  </span><br><span class="line">&#123;  </span><br><span class="line">    (*pArray2D)[i].<span class="built_in">resize</span>(width);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="解题代码"><a class="markdownIt-Anchor" href="#解题代码"></a> 解题代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    转移方程：F[i][j] = F[i-1][j] + F[i][j-1];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="type">int</span> **F = <span class="keyword">new</span> <span class="type">int</span>*[m];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; m; i++ )</span><br><span class="line">            F[i] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; m;i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) F[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> F[i][j] = F[i<span class="number">-1</span>][j] + F[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> F[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="55-跳跃游戏"><a class="markdownIt-Anchor" href="#55-跳跃游戏"></a> <a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h1><p>难度 中等</p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>其实这题并不适合拿动态规划来解，因为写出来的时间复杂度有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>数量级（所以我的题解在LeetCode里因为超时挂了。。。不过还是作为一个DP的典型题目写下思路</p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j,Size;</span><br><span class="line">        Size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> *F = <span class="keyword">new</span> <span class="type">bool</span>[Size];</span><br><span class="line"></span><br><span class="line">        F[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; Size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            F[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(F[j] &amp;&amp; nums[j] + j &gt;= i)</span><br><span class="line">                &#123;</span><br><span class="line">                    F[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> F[Size<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前言：最近刷剑指offer刷到了动态规划相关的问题，之前没怎么学过，所以特地抽一天时间来学一下，以下为学习的笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;动态规划&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动态规划&quot;&gt;&lt;/a&gt; 动态规划&lt;/h1&gt;
&lt;h2 id=&quot;题目类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目类型&quot;&gt;&lt;/a&gt; 题目类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 计数：&lt;/strong&gt;&lt;br /&gt;
有多少种方式走到右下角&lt;br /&gt;
有多少种方法选出k个数使得和为Sum&lt;br /&gt;
&lt;strong&gt;2. 求最大最小值：&lt;/strong&gt;&lt;br /&gt;
从左上角走到右下角路径的最大数字和&lt;br /&gt;
最长上升子序列长度&lt;br /&gt;
&lt;strong&gt;3. 求存在性：&lt;/strong&gt;&lt;br /&gt;
取石子游戏，先手是否必胜&lt;br /&gt;
能不能选出k个数使得和是Sum&lt;/p&gt;
&lt;h2 id=&quot;解题步骤&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#解题步骤&quot;&gt;&lt;/a&gt; 解题步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;确定状态&lt;/strong&gt;&lt;br /&gt;
简单的说，就是解动态规划时需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么，类似解数学题中，xyz代表什么一样，具体分为下面两个步骤：
&lt;ul&gt;
&lt;li&gt;研究最优策略的最后一步&lt;/li&gt;
&lt;li&gt;化为子问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转移方程&lt;/strong&gt;&lt;br /&gt;
根据子问题定义直接得到&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始条件和边界情况&lt;/strong&gt;&lt;br /&gt;
初始条件一般都是a[0]、a[1]这种，多看看&lt;br /&gt;
边界条件主要是看数组的边界，数组越不越界&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计算顺序&lt;/strong&gt;&lt;br /&gt;
大部分从小到大迭代，精髓在于使用之前计算得到的结果&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://www.snowmoon.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer刷题10——搜索与回溯算法（简单）</title>
    <link href="https://www.snowmoon.top/2021/08/29/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer10/"/>
    <id>https://www.snowmoon.top/2021/08/29/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer10/</id>
    <published>2021-08-29T00:30:00.000Z</published>
    <updated>2023-11-30T16:45:40.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-26-树的子结构"><a class="markdownIt-Anchor" href="#剑指-offer-26-树的子结构"></a> <a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h1><p>难度 中等</p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br />给定的树 A:</p><p><code>   3  / \  4  5 / \ 1  2</code><br />给定的树 B：</p><p><code>  4  / 1</code><br />返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,3], B = [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [3,4,5,1,2], B = [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 10000</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>采用递归判断的方法比较好撸，先序遍历树A的所有节点，判断每个节点的子树是否包含树B</p><p><strong><code>recur(A, B)</code> 函数：</strong></p><ol><li><p>终止条件：</p><ol><li>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；</li><li>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；</li><li>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li></ol></li><li><p>返回值：</p><ol><li>继续判断 A 和 B 的左子节点是否相等，即 recur(A.left, B.left) ；</li><li>判断 A 和 B 的右子节点是否相等，即 recur(A.right, B.right) ；<br /><strong><code>isSubStructure(A, B)</code> 函数：</strong></li></ol></li><li><p>特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false ；</p></li><li><p>返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；</p><ol><li>以 节点 A 为根节点的子树 包含树 BB ，对应 recur(A, B)；</li><li>树 B 是 树 A 左子树 的子结构，对应 isSubStructure(A.left, B)；</li><li>树 B 是 树 A 右子树 的子结构，对应 isSubStructure(A.right, B)；<br />以上 2. 3. 实质上是在对树 AA 做 先序遍历 。</li></ol></li></ol><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ( A != <span class="literal">NULL</span> &amp;&amp; B != <span class="literal">NULL</span>) &amp;&amp; (<span class="built_in">helper</span>(A, B)</span><br><span class="line">        || <span class="built_in">isSubStructure</span>(A-&gt;left,B) || <span class="built_in">isSubStructure</span>(A-&gt;right,B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(TreeNode* A, TreeNode* B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( B == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( A == <span class="literal">NULL</span> || A-&gt;val != B-&gt;val ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">helper</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>刚开始想一个函数直接解决，于是有了以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( A == <span class="literal">NULL</span> &amp;&amp; B == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>( B == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( A == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>( A-&gt;val == B-&gt;val ) <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(A-&gt;left, B-&gt;left) </span><br><span class="line">                            &amp;&amp; <span class="built_in">isSubStructure</span>(A-&gt;right,B-&gt;right);</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//即if(A-&gt;val != B-&gt;val)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后来发现一个函数不方便判断当两个节点值不相同时候的情况，我这里写的两个节点值不相同只能继续往下遍历，没有办法知道是在判断A的子树里的值是否和B的子树的值相同这个逻辑里还是在判断A的子树节点值是否与B的根节点的值相同的逻辑里导致了结果与遍历到底层的结果相同，所以这个题必须分成两个函数来写。</p><h1 id="剑指-offer-27-二叉树的镜像"><a class="markdownIt-Anchor" href="#剑指-offer-27-二叉树的镜像"></a> <a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h1><p>难度 简单</p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><p><code>   4  /  \ 2   7 / \  / \1  3 6  9</code><br />镜像输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4  /  \ 7   2 / \  / \9  6 3  1</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 1000</span><br></pre></td></tr></table></figure><p>注意：本题与主站 226 题相同：<a href="https://leetcode-cn.com/problems/invert-binary-tree/">https://leetcode-cn.com/problems/invert-binary-tree/</a></p><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><p>先序遍历，回溯反向</p><ol><li>终止条件：空树直接返回</li><li>递推工作：<ol><li>新建节点暂存root的左子节点,防止修改后左子节点丢失</li><li>进入root的右子树返回为root的左子节点</li><li>进入root的左子树返回为root的右子节点</li></ol></li></ol><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    先序遍历，回溯反向</span></span><br><span class="line"><span class="comment">    1.终止条件：空树直接返回</span></span><br><span class="line"><span class="comment">    2.递推工作：</span></span><br><span class="line"><span class="comment">        1.新建节点暂存root的左子节点,防止修改后左子节点丢失</span></span><br><span class="line"><span class="comment">        2.进入root的右子树返回为root的左子节点</span></span><br><span class="line"><span class="comment">        3.进入root的左子树返回为root的右子节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* Node = root-&gt;left;</span><br><span class="line">        root-&gt;left = <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;right = <span class="built_in">mirrorTree</span>(Node);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-28-对称的二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-28-对称的二叉树"></a> <a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h1><p>难度简单226收藏分享切换为英文接收动态反馈</p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p><code>  1  / \ 2  2 / \ / \3  4 4  3</code><br />但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1  / \ 2  2  \  \  3   3</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 1000</span><br></pre></td></tr></table></figure><p>注意：本题与主站 101 题相同：<a href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a></p><h2 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h2><ol><li>终止条件：<ol><li>左右节点均为空，返回true</li><li>左右节点的值不同，返回false</li><li>左右节点只有一节点为空，返回false</li></ol></li><li>递推内容：<ol><li>左右节点值相同，进入左节点的左子树与右节点的右子树继续比较，同时，进入左节点的右子树与右节点的左子树继续比较</li></ol></li></ol><p>大佬的思路：<br /><code>isSymmetric(root) ：</code></p><p>特例处理： 若根节点 root 为空，则直接返回 true 。<br />返回值： 即 <code>recur(root.left, root.right) </code>;<br /><code>recur(L, R) ：</code></p><ol><li>终止条件：<ul><li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li><li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；</li><li>当节点 LL 值 ≠节点 R 值： 此树不对称，因此返回 false；</li></ul></li><li>递推工作：<ul><li>判断两节点 L.left 和 R.right是否对称，即 recur(L.left, R.right) ；</li><li>判断两节点 L.right 和 R.left 是否对称，即 recur(L.right, R.left) ；</li><li>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp;&amp; 连接。</li></ul></li></ol><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><pre class="highlight"><code class="C++"><span class="hljs-comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */</span> <span class="hljs-comment">/*    1. 终止条件：        1. 左右节点均为空，返回true        2. 左右节点的值不同，返回false        3. 左右节点只有一节点为空，返回false    2. 递推内容：        1. 左右节点值相同，进入左节点的左子树与右节点的右子树继续比较，同时，进入左节点的右子树与右节点的左子树继续比较 */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(root-&gt;left, root-&gt;right);    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode* Left, TreeNode* Right)</span>    </span>&#123;        <span class="hljs-keyword">if</span>( Left == <span class="hljs-literal">NULL</span> &amp;&amp; Right == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span>( Left == <span class="hljs-literal">NULL</span> || Right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span>( Left-&gt;val != Right-&gt;val ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>( Left-&gt;left, Right-&gt;right) &amp;&amp; <span class="hljs-built_in">helper</span>(Left-&gt;right, Right-&gt;left);    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-26-树的子结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-26-树的子结构&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/&quot;&gt;剑指 Offer 26. 树的子结构&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;难度 中等&lt;/p&gt;
&lt;p&gt;输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&lt;/p&gt;
&lt;p&gt;B是A的子结构， 即 A中有出现和B相同的结构和节点值。&lt;/p&gt;
&lt;p&gt;例如:&lt;br /&gt;
给定的树 A:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;   3  / &#92;  4  5 / &#92; 1  2&lt;/code&gt;&lt;br /&gt;
给定的树 B：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;  4  / 1&lt;/code&gt;&lt;br /&gt;
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：A = [1,2,3], B = [3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：A = [3,4,5,1,2], B = [4,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;限制：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;= 节点个数 &amp;lt;= 10000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="https://www.snowmoon.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="先序遍历" scheme="https://www.snowmoon.top/tags/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer刷题9——搜索与回溯算法（简单）</title>
    <link href="https://www.snowmoon.top/2021/08/28/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer9/"/>
    <id>https://www.snowmoon.top/2021/08/28/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%89%91%E6%8C%87offer9/</id>
    <published>2021-08-28T00:30:00.000Z</published>
    <updated>2023-11-30T16:45:28.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-32-ii-从上到下打印二叉树-ii"><a class="markdownIt-Anchor" href="#剑指-offer-32-ii-从上到下打印二叉树-ii"></a> <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h1><p>难度 简单</p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br />给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><p>注意：本题与主站 102 题相同：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><span id="more"></span><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路：</h2><blockquote><p>建议先做 <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">面试题32 - I. 从上到下打印二叉树</a> 再做此题，两题仅有微小区别，即本题需将 每一层打印到一行 。</p></blockquote><p>I. 按层打印： 题目要求的二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。BFS 通常借助 队列 的先入先出特性来实现。</p><p>II. 每层打印到一行： 将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> i,N;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        TreeNode* Node;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            N = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; rol;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Node = que.<span class="built_in">front</span>();</span><br><span class="line">                rol.<span class="built_in">push_back</span>(Node-&gt;val);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(Node-&gt;left != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(Node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(Node-&gt;right != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(Node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(rol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-offer-32-iii-从上到下打印二叉树-iii"><a class="markdownIt-Anchor" href="#剑指-offer-32-iii-从上到下打印二叉树-iii"></a> <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h1><p>难度 中等</p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:<br />给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>解题思路：<br />面试题32 - I. <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">从上到下打印二叉树 主要考察 树的按层打印</a> ；<br />面试题32 - II. <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树 II 额外要求 每一层打印到一行</a> ；<br />本题额外要求 打印顺序交替变化（建议按顺序做此三道题）。</p><p>BFS层序遍历，每遍历完两层就将要添加的行内数据反转一次</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> i,N;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        TreeNode* Node;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            N = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; rol;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Node = que.<span class="built_in">front</span>();</span><br><span class="line">                rol.<span class="built_in">push_back</span>(Node-&gt;val);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(Node-&gt;left != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(Node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(Node-&gt;right != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(Node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( res.<span class="built_in">size</span>()%<span class="number">2</span> == <span class="number">1</span>) <span class="built_in">reverse</span>(rol.<span class="built_in">begin</span>(), rol.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(rol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-32-ii-从上到下打印二叉树-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-32-ii-从上到下打印二叉树-ii&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/&quot;&gt;剑指 Offer 32 - II. 从上到下打印二叉树 II&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;难度 简单&lt;/p&gt;
&lt;p&gt;从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。&lt;/p&gt;
&lt;p&gt;例如:&lt;br /&gt;
给定二叉树: &lt;code&gt;[3,9,20,null,null,15,7]&lt;/code&gt;,&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9  20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /  &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 15   7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回其层次遍历结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [9,20],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [15,7]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;节点总数 &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：本题与主站 102 题相同：&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-level-order-traversal/&quot;&gt;https://leetcode-cn.com/problems/binary-tree-level-order-traversal/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="SnowMoonの刷题记录" scheme="https://www.snowmoon.top/categories/SnowMoon%E3%81%AE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.snowmoon.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="https://www.snowmoon.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="层序遍历" scheme="https://www.snowmoon.top/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
</feed>
